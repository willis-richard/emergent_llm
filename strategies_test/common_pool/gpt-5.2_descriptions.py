"""
Strategy descriptions for CommonPoolDescription.

Generated with:
- Provider: OpenAI
- Model: gpt-5.2
"""


description_COLLECTIVE_1 = '''
## Strategy: **Stock-Guarded Reciprocity (SGR)**  
Collective goal: keep the stock near capacity to maximize *total* long-run harvest, while remaining hard to exploit by persistent defectors. The strategy uses (i) **stock safety thresholds** and (ii) **reciprocal discipline** based on observed over-consumption.

### Key intuition
- If everyone plays **C**, stock tends to recover strongly (often back to capacity), so cooperation is socially efficient.
- **D** is individually tempting, but if too many do it (or stock is low), the pool can collapse and everyone loses future payoffs.
- Therefore: cooperate by default **when the pool is safe**, punish **when others threaten sustainability**, and “emergency protect” **when stock is low**.

---

## 1) Decision rules (C vs D)

### Definitions computed each round \(t\)
Let:
- \(S_t\) = current stock at start of round \(t\)
- For each player \(j\), infer last action from observed payoff and stock:
  - If \( \pi_{j,t-1} \approx S_{t-1}/(2n)\) then \(a_{j,t-1}=C\)
  - If \( \pi_{j,t-1} \approx S_{t-1}/n\) then \(a_{j,t-1}=D\)
- \(k_{t-1}\) = number of defectors last round
- **Defection rate** last round: \(p_{t-1} = k_{t-1}/n\)

Also define a *stock safety band* (depends only on parameters):
- **Safe stock threshold:**  
  \[
  S^{safe} = 0.8 \cdot capacity
  \]
- **Critical stock threshold:**  
  \[
  S^{crit} = 0.4 \cdot capacity
  \]
(These are deliberately simple and robust; see “edge cases/robustness” below.)

### Core rule set
You choose action \(a_{i,t}\) as follows:

#### A. **Emergency protection (stock is low): defect to avoid being the sucker**
If \(S_t \le S^{crit}\): **Play D**.  
Rationale: when stock is low, a cooperator’s share is very small and you risk being exploited while the pool is already in danger. Also, with low \(S\), immediate individual payoff matters more because the future may be compromised by others.

#### B. **Collective rebuilding (stock is moderate but not safe): cooperate unless defection is rampant**
If \(S^{crit} < S_t < S^{safe}\):
- If \(p_{t-1} \le 0.25\) (at most 25% defected last round): **Play C**
- Else: **Play D**  
Rationale: when stock is recovering, cooperation helps it bounce back. But if too many defect, unilateral cooperation becomes exploitable and ineffective.

#### C. **High-stock cooperation with reciprocity (stock is safe): cooperate, but punish coordinated overuse**
If \(S_t \ge S^{safe}\):
- If \(p_{t-1} = 0\): **Play C**
- If \(0 < p_{t-1} \le 0.25\): **Play C** (tolerate small noise/experimentation)
- If \(0.25 < p_{t-1} \le 0.5\): **Play D for one round**, then reassess next round
- If \(p_{t-1} > 0.5\): **Play D** (until defection drops below 0.25 for 2 consecutive rounds, then return to C)  
Rationale: at high stock, “forgiving cooperation” is good, but repeated/majority defection is a direct threat to sustainability and must be met with credible discipline.

---

## 2) Edge cases

### First round (no history)
**Play C** in round 1.  
Reason: stock starts at capacity and cooperation tests whether others are willing to sustain the pool. Starting with D would often trigger collapse spirals.

### Last round
**Play D in round r**.  
Reason: in a known finite horizon, future stock has no value after the last round. A collective strategy still needs robustness; unconditional last-round cooperation is exploitable.

### Round r−1 (second-to-last)
Use the normal rules **except**:
- If \(S_{r-1} \ge S^{safe}\) and defection has been low (\(p_{r-2} \le 0.25\)), still **play C**.  
Reason: you still get one more future round of benefits (and keeping stock high matters for round r even if you will defect then). This is the minimum concession to “endgame logic” without being naïve.

### Recovery-from-collapse behavior
If stock ever hits **very low** (e.g., \(S_t \le 0.1 \cdot capacity\)):
- **Play D** until \(S_t\) rises above \(S^{crit}\).  
Reason: if others caused collapse, you must protect yourself; also, with low S, the system may not recover reliably unless others change behavior—this avoids being repeatedly exploited.

---

## 3) Collective mindset features (why this is “collective” yet tournament-robust)

### What it promotes
- **Sustained cooperation** whenever the stock is healthy or recovering *and* opponents show restraint.
- **Stock stewardship**: cooperation is explicitly tied to keeping \(S_t\) in a region where logistic growth can replenish losses.
- **Forgiveness**: tolerates a small fraction of defectors (≤ 25%) to avoid needless retaliation against noise or occasional exploration.

### What it prevents
- **Being farmed by defectors**: once defection becomes common, it switches to D quickly.
- **Stock collapse**: when \(S_t\) is moderate/low, it becomes stricter about punishing high defection rates.
- **Retaliation traps**: punishments are *short* (often one round) when conditions improve, so it can return to C quickly.

---

## Pseudocode (implementable)

```python
def SGR_action(t, r, n, capacity, S_t, history):
    # thresholds
    S_safe = 0.8 * capacity
    S_crit = 0.4 * capacity

    # last-round defection rate
    if t == 1:
        return "C"

    # infer last actions from observed payoffs (or directly from action history if available)
    k = count_defectors_last_round(history, t-1)   # integer 0..n
    p = k / n

    # last round rule
    if t == r:
        return "D"

    # emergency low-stock rule
    if S_t <= S_crit:
        return "D"

    # moderate stock: rebuild if opponents mostly cooperate
    if S_t < S_safe:
        if p <= 0.25:
            return "C"
        else:
            return "D"

    # safe stock: cooperate with graduated reciprocity
    if p == 0:
        return "C"
    if p <= 0.25:
        return "C"
    if p <= 0.5:
        return "D"  # one-round discipline; reassess next round naturally
    else:
        # sustained discipline until cooperation is clearly returning
        if defection_rate_low_for_two_rounds(history, t-1, threshold=0.25):
            return "C"
        return "D"
```

---

### Notes on robustness
- The strategy depends only on **(n, r, capacity), current stock, and observed past actions/payoffs**, as required.
- It does not assume coordination, schedules, or communication.
- It handles: always-defect opponents (quickly protects itself), mostly-cooperative groups (stays cooperative), mixed populations (disciplines major overuse while allowing recovery), and endgame exploitation (defects last round).

If you want, I can tune the numeric thresholds (0.8/0.4, 25%/50%) analytically for specific \(n\) and capacity ranges, but the above is designed to be broadly stable across tournaments.
'''

description_COLLECTIVE_2 = '''
## Strategy: **Stock-Guarded, Forgiving Trigger (SGFT)**  
Collective goal: keep the resource near **capacity** (where growth is strongest and sustainable) while **not being exploitable** by persistent defectors. The strategy cooperates by default, but escalates to defection when the stock trajectory implies over-extraction, and de-escalates once the group returns to sustainable behavior.

---

## Key idea (what we respond to)
In each round, from observed history we can infer how many defectors there were, because total consumption is fully determined by the count of D.

Let:
- \(S_t\) = stock at start of round \(t\)
- \(k_t\) = number of defectors in round \(t\) (observable from actions)
- Total consumption fraction of stock:
  \[
  f(k_t)=\frac{k_t}{n}+\frac{n-k_t}{2n}=\frac{1}{2}+\frac{k_t}{2n}
  \]
- Remaining stock after consumption:
  \[
  R_t = S_t\left(1 - f(k_t)\right)=S_t\left(\frac{1}{2}-\frac{k_t}{2n}\right)=S_t\cdot\frac{n-k_t}{2n}
  \]
This shows the sustainability “cliff”: if \(k_t=n\), then \(R_t=0\) and the resource collapses.

So we base decisions on two signals:
1. **Stock health**: is the system near the safe high-stock region?
2. **Recent defection rate**: are others over-consuming?

---

## Parameters computed from game parameters
We use only \(n, r, capacity\) plus state/history.

Define thresholds:
- **Safe stock threshold**:  
  \[
  S_{\text{safe}} = 0.9 \cdot capacity
  \]
- **Danger stock threshold**:  
  \[
  S_{\text{danger}} = 0.6 \cdot capacity
  \]
- **Critical stock threshold**:  
  \[
  S_{\text{crit}} = 0.35 \cdot capacity
  \]
(These are deliberately coarse: robust across many opponent types.)

Define defection tolerances (in terms of *number of defectors*):
- “Small noise” tolerance:  
  \[
  k \le \max(1,\lfloor 0.1n\rfloor)
  \]
- “Too many” defectors:  
  \[
  k \ge \lceil 0.25n\rceil
  \]

Define memory window:
- \(W = \min(5, t-1)\): look back up to last 5 rounds.

---

## 1) Decision rules (C vs D)

### Rule A — Default: Cooperate when the system is healthy and defection is low
Play **C** if **all** are true:
1. \(S_t \ge S_{\text{safe}}\)  
2. In the last \(W\) rounds, average number of defectors is low:
   \[
   \bar{k} = \frac{1}{W}\sum_{j=t-W}^{t-1} k_j \le \max(1,\lfloor 0.1n\rfloor)
   \]
3. Last round wasn’t a “bad shock”: \(k_{t-1} < \lceil 0.25n\rceil\)

**Intuition:** When the group is behaving and stock is high, keep it at capacity; all-C often regenerates to capacity.

---

### Rule B — Cautious mode: mix in defection when stock is slipping or defectors are nontrivial
Play **D** if **either** condition holds:
1. **Stock is in danger:** \(S_t < S_{\text{danger}}\)  
2. **Defection pressure:** \(k_{t-1} \ge \lceil 0.25n\rceil\) or \(\bar{k} \ge \lceil 0.2n\rceil\)

Otherwise play **C**.

**Intuition:** If others are extracting too much, unconditional C gets exploited and accelerates collapse. Defection here is used as *deterrence* and *self-protection*.

---

### Rule C — Critical protection: if collapse is near, defect until recovery is visible
If \(S_t < S_{\text{crit}}\), play **D** unconditionally **until** both:
- \(S_t \ge S_{\text{danger}}\) **and**
- \(k_{t-1} \le \max(1,\lfloor 0.1n\rfloor)\)

**Intuition:** When stock is very low, the game is already in a bad basin; you must stop being the “sucker” and wait for evidence of restraint before returning to cooperation.

---

### Rule D — Forgiveness / De-escalation: return to C quickly when cooperation reappears
If you played D last round due to Rule B, then **switch back to C** as soon as:
- \(S_t \ge S_{\text{safe}}\) **and**
- \(k_{t-1} \le \max(1,\lfloor 0.1n\rfloor)\)

**Intuition:** This prevents endless retaliation cycles and helps re-establish the high-stock cooperative regime.

---

## 2) Edge cases

### First round (t = 1)
Play **C**.

Reason: With full stock at capacity, the highest collective payoff path is to try to stabilize at high stock immediately. Also, starting with D invites mutual D and instant collapse.

---

### Last round (t = r)
Play **D** unless **both**:
- \(S_r \ge S_{\text{safe}}\) and
- \(k_{r-1} = 0\)

Reason: There is no future to protect. However, if everyone has been perfectly cooperative and stock is high, staying at C avoids being the sole last-round defector if others are “cooperation-locked.” This condition is narrow on purpose.

---

### If history is noisy / partial early on
For \(t \le 2\), use only \(k_{t-1}\) (no window average).

---

### If stock hits 0 (or extremely low)
If \(S_t \approx 0\), actions barely matter for payoff. Still play **D** until you observe at least one round with \(k_{t-1}\) small and \(S_t\) rising above \(S_{\text{danger}}\). This avoids being the only cooperator in a hopeless state.

---

## 3) Why this is “collective” yet robust
- **Collective orientation:** It tries to hold stock near capacity (high-growth, high long-run payoffs) by cooperating whenever the group is not over-consuming.
- **Robustness:** It does not assume shared norms. It punishes sustained over-extraction (by switching to D) but is **forgiving** once behavior improves, preventing deadlock.
- **State-aware:** It responds to the *resource level* directly, not just actions—so it adapts if the stock is already damaged (maybe from earlier rounds or chaotic opponents).

---

## Pseudocode (implementable)
```pseudo
inputs each round t:
  n, r, capacity
  S = current_stock_at_start_of_round
  history of past actions -> compute k_prev and k_bar over last W rounds

constants:
  S_safe   = 0.9 * capacity
  S_danger = 0.6 * capacity
  S_crit   = 0.35 * capacity

  k_small  = max(1, floor(0.1 * n))
  k_many   = ceil(0.25 * n)
  k_mid    = ceil(0.2 * n)

if t == 1:
  return C

W = min(5, t-1)
k_prev = defectors_in_round(t-1)
k_bar  = average_defectors_over_last_W_rounds

# last round rule
if t == r:
  if S >= S_safe and k_prev == 0:
    return C
  else:
    return D

# critical protection
if S < S_crit:
  return D

# deterrence / cautious mode
if S < S_danger:
  return D
if k_prev >= k_many:
  return D
if k_bar >= k_mid:
  return D

# default cooperation in healthy regime
if S >= S_safe and k_bar <= k_small and k_prev < k_many:
  return C

# otherwise, mild caution: cooperate (keeps forgiveness high)
return C
```

This yields a cooperative baseline, quick deterrence against significant defection, and a clear pathway back to mutual cooperation once the environment stabilizes.
'''

description_COLLECTIVE_3 = '''
## Collective Strategy: **Stock-Sustaining Reciprocator (SSR)**  
Goal: keep the common pool near the regenerative sweet spot (high stock and strong growth) while making defection unprofitable *over time* by (i) reacting quickly to depletion and (ii) forgiving when the system stabilizes. The strategy uses only parameters \((n,r,capacity)\), current stock \(S_t\), and full history of actions/stock.

### Key ideas (collective mindset)
1. **Resource-first**: prioritize maintaining a stock level that can recover each round; without that, everyone’s future payoff collapses.
2. **Reciprocity with protection**: cooperate when others cooperate and the stock is healthy; punish (defect) when others defect or when the stock is endangered.
3. **Adaptive severity**: punishment scales with *how much* others over-consume and how close the resource is to collapse; forgiveness is automatic after a short period of good behavior.

---

## 1) Decision Rules: when to Cooperate vs Defect

### Quantities computed from history (round \(t-1\))
Let:
- \(k_{t-1}\) = number of defectors in round \(t-1\)
- \(d_{t-1} = k_{t-1}/n\) = defection rate last round
- \(S_t\) = current stock at start of round \(t\)

### Define stock zones (based on capacity)
Use three regions:
- **Safe zone**: \(S_t \ge 0.8 \cdot capacity\)  
  Stock is high; cooperation is sustainable if others aren’t heavily defecting.
- **Caution zone**: \(0.5 \cdot capacity \le S_t < 0.8 \cdot capacity\)  
  Stock is declining; tighten discipline.
- **Danger zone**: \(S_t < 0.5 \cdot capacity\)  
  Risk of collapse; prioritize immediate containment.

These thresholds are parameter-only (scale with capacity), and work across many \(n\).

### Core rule (single-step, state + last round behavior)
In round \(t\ge 2\):

**A. If stock is in Danger zone:**  
- **Play D** (defect).  
Rationale: when stock is low, a cooperator is easily exploited and has little leverage; defecting raises immediate payoff and also acts as a strong signal/punishment to reset behavior. (In many opponent populations, “always C” at low stock is dominated and leads to collapse anyway.)

**B. If stock is in Caution zone:**  
- **Cooperate only if defection rate last round was small:**  
  - Play **C** if \(d_{t-1} \le 1/n\) (i.e., at most 1 defector).  
  - Else play **D**.  
Rationale: in Caution, even moderate defection accelerates depletion; require near-unanimous cooperation.

**C. If stock is in Safe zone:**  
- **Cooperate unless defection is persistent or widespread:**  
  - Play **C** if \(d_{t-1} \le 0.25\) (≤25% defectors)  
  - Else play **D**  
Rationale: Safe stock can tolerate some noise/mistakes; don’t over-punish a single rogue when the system is healthy.

### “Punishment memory” (robustness to exploiters)
Track a **trust counter** \(T\) (integer), updated each round after observing actions:

- If \(k_{t} = 0\): \(T \leftarrow \min(T+1, 3)\)
- Else: \(T \leftarrow \max(T-1, -3)\)

Then add a “lock-in” rule:

- If \(T \le -2\): play **D** (hard punishment mode) unless \(S_t \ge 0.8\cdot capacity\) **and** \(k_{t-1}=0\) (full cooperation observed last round), in which case play **C**.

Interpretation:
- Repeated defection triggers a short “grim-ish” phase (D) to stop being farmed.
- One clean cooperative round can begin forgiveness when stock is high (so forgiveness is less risky).
- This prevents oscillation against strategies that defect intermittently to exploit naive forgiveness.

---

## 2) Edge Cases

### Round 1 (no history)
- **Play C** if \(capacity\) is at least the stated sustainable range (given) and initial stock is \(S_1=capacity\).  
This is the cooperative opening that allows the best collective trajectory *if* others are also pro-social. With simultaneous moves, you need to give cooperation a chance once.

### Last round (round \(r\))
Finite-horizon logic tempts universal defection. But in a tournament, many opponents use reciprocity; unconditional endgame defection often backfires earlier because it’s anticipated by other AIs via backward induction heuristics. So:

- If \(S_r \ge 0.8\cdot capacity\) **and** \(k_{r-1}=0\): **Play C**  
- Otherwise: **Play D**

This keeps you cooperative with genuinely cooperative groups (maximizing total welfare) but avoids being the “sucker” if there was any sign of exploitation or if stock is already stressed.

### Stock at/near zero
If \(S_t\) is extremely small (e.g., \(S_t < 0.05\cdot capacity\)), always **D**.  
Rationale: cooperation yields tiny payoffs and provides no leverage; you need harsh incentives to shift group behavior, and you must protect yourself.

### Noise/mistakes by others
The Safe-zone tolerance (\(\le 25\%\) defectors) plus the trust counter prevents overreacting to one-off defections and prevents being permanently exploited by periodic defectors.

---

## 3) Clear Collective Alignment

This strategy is “collective” in three concrete ways:

1. **It aims to keep stock in the high-growth region** (near capacity) by cooperating when conditions support sustainability.
2. **It conditions cooperation on observed restraint**, so it rewards groups that preserve the commons.
3. **It uses calibrated punishment** to deter free-riding without causing irreversible collapse via permanent retaliation.

---

## Pseudocode (implementation-ready)

```pseudo
initialize:
  T = 0  // trust counter

for t in 1..r:
  observe S_t

  if t == 1:
    action = C
  else:
    // compute last round defection stats
    k = number_of_defectors_in_round(t-1)
    d = k / n

    // stock zones
    if S_t < 0.5 * capacity:
      action = D
    else if S_t < 0.8 * capacity:
      // caution zone: require near-unanimity
      if d <= 1/n and T > -2:
        action = C
      else:
        action = D
    else:
      // safe zone
      if (d <= 0.25) and (T > -2):
        action = C
      else:
        action = D

    // last round override for endgame
    if t == r:
      if (S_t >= 0.8 * capacity) and (k == 0):
        action = C
      else:
        action = D

  play(action)

  // after round resolves, update trust based on observed actions in round t
  k_now = number_of_defectors_in_round(t)
  if k_now == 0:
    T = min(T + 1, 3)
  else:
    T = max(T - 1, -3)
```

---

### Why this should perform well in a tournament
- **Against cooperators**: quickly converges to all-C, maintaining high stock and high long-run payoffs.
- **Against occasional defectors**: tolerates small noise in Safe zone but tightens in Caution; avoids spirals.
- **Against exploiters / always-defect**: shifts to D and stops being harvested; doesn’t waste rounds cooperating into collapse.
- **Against “trigger” strategies**: its forgiveness mechanism is limited and state-aware, reducing endless retaliation while still deterring exploitation.

If you want, I can also provide a variant tuned to be more forgiving (higher cooperation rates) or more defensive (earlier punishment), depending on what you expect the tournament population to look like.
'''

description_COLLECTIVE_4 = '''
## Strategy: **Stock-Guard with Forgiving Retaliation (SGFR)**  
Goal: keep the stock near the regenerative “sweet spot” (high and stable), while making defection unprofitable by quickly switching to defection when others over-extract—then returning to cooperation as soon as the group does.

This is a **collective** strategy: it treats *resource sustainability* as the primary objective, and uses punishment only as a tool to restore cooperation.

---

# Key idea (what we try to enforce)
Let current stock be `S`. If `k` players defect in a round, total consumption is:
- `C_total = (n-k) * S/(2n) + k * S/n = S/2 + k * S/(2n)`

So remaining stock after consumption is:
- `S_rem = S - C_total = S * (1/2 - k/(2n)) = S * (n-k)/(2n)`

**If everyone cooperates (k=0):** `S_rem = S/2`, which exactly matches the peak-growth point of the logistic rule. That keeps stock at capacity (or pulls it back toward capacity).  
**If too many defect:** `S_rem` gets too small, growth collapses, and the resource can spiral downward.

So the strategy tries to keep the system close to “all C”, but **does not naively keep cooperating against defectors**.

---

# What we observe each round
From history we can infer (because actions are observable):
- `k_last`: number of defectors last round
- `S`: current stock
- optionally, a short moving average of defection frequency

---

# 1) Decision rules: when to cooperate vs defect

### A. Default mode: **Cooperate**
Cooperate when the group is behaving sustainably.

You cooperate if **both** are true:
1) **Stock is healthy enough**: `S >= S_safe`
2) **Recent defection is low**: `k_last <= k_tol` (tolerance level)

Where:
- `S_safe = capacity * 0.60` (health threshold; adjustable but fixed by parameters)
- `k_tol = 0` for small groups, otherwise a small fraction:  
  `k_tol = floor(0.1 * n)`  
  (So in many cases, any defection triggers response; in large n, you allow a tiny amount of noise.)

Rationale: collective cooperation is efficient, and at high stock it is self-sustaining **only if most players cooperate**.

---

### B. Retaliation mode: **Defect to match exploitation**
If the group over-extracts, you defect to stop being the “sucker” and to reduce the advantage of defectors.

You defect if **either** is true:
1) **Any significant defection occurred**: `k_last > k_tol`
2) **Stock is in danger**: `S < S_safe`

This is the “guardrail”: once the stock is threatened, the priority is to prevent cooperators being systematically exploited while also signaling that overuse is met with consequences.

---

### C. Forgiveness / return to cooperation
Punishment is costly; you return to cooperation as soon as it’s safe.

After defecting, you switch back to cooperation when:
- `k_last == 0` **and**
- `S >= S_recover`

Where:
- `S_recover = capacity * 0.75` (hysteresis to avoid oscillation)

Interpretation: “We’ll come back to collective restraint once everyone else does and the stock has recovered enough.”

---

# 2) Edge cases (first round, last round, unusual stock)

### First round
**Play C.**  
Reason: with no history, the cooperative action is the only one that supports collective sustainability; also it tests whether others will reciprocate.

### Last round
**Play D** (unless stock is extremely low; see below).  
Reason: standard repeated-game end effect: there is no future to incentivize restraint. In tournaments, many opponents will defect in the final round; matching prevents being exploited.

**Exception:** if `S` is critically low, defecting can yield little anyway and may worsen collapse signals for earlier rounds (though last round is last). Still, to keep the strategy simple and robust:
- If `S < capacity * 0.10`, play **C** (it barely matters for payoff, but preserves “collective-first” identity and avoids weird corner incentives).

### Critically low stock at any time
If `S <= capacity * 0.15`, play **C** *only if* `k_last == 0`, else play **D**.  
Reason: when the resource is near collapse, unilateral cooperation is mostly wasted if others defect, but mutual cooperation is the only path to recovery.

### If stock is capped at capacity
No special case needed; cooperation maintains it.

---

# 3) Collective framing (what this strategy “stands for”)
- **Primary objective:** maintain the shared stock at a high level, because that maximizes long-run total welfare.
- **Secondary objective:** prevent persistent exploitation by defectors using swift retaliation.
- **Behavioral principle:** “Cooperate by default, punish quickly, forgive as soon as the group returns to restraint.”

This is explicitly collective: it does not try to “win the round”; it tries to keep the commons productive and only uses defection as enforcement.

---

# Pseudocode (implementable)

```python
def SGFR_action(t, r, n, capacity, S, history):
    # history provides last round actions for all players if t>1
    S_safe = 0.60 * capacity
    S_recover = 0.75 * capacity
    k_tol = int(0.1 * n)  # small tolerance for large n

    # First round
    if t == 1:
        return "C"

    # Count last-round defectors
    last_actions = history[t-1]  # list length n of "C"/"D"
    k_last = sum(1 for a in last_actions if a == "D")

    # Last round logic
    if t == r:
        if S < 0.10 * capacity:
            return "C"
        else:
            return "D"

    # Critical stock regime (near-collapse)
    if S <= 0.15 * capacity:
        if k_last == 0:
            return "C"
        else:
            return "D"

    # Main rule: retaliate if defection significant or stock endangered
    if (k_last > k_tol) or (S < S_safe):
        # Forgive when fully cooperative AND stock recovered
        if (k_last == 0) and (S >= S_recover):
            return "C"
        return "D"

    # Otherwise cooperate
    return "C"
```

---

## Why this is robust in tournaments
- **Against always-cooperate:** stays cooperative, keeps stock high, strong long-run payoffs.
- **Against always-defect:** quickly defects too, avoiding being exploited; outcome is poor but unavoidable without coordination.
- **Against conditional cooperators (Tit-for-Tat-like):** converges to stable mutual cooperation after brief adjustment.
- **Against noisy or mixed strategies:** tolerance + forgiveness reduces permanent feuds, while still reacting to sustained overuse.
- **Against opportunists who occasionally defect:** immediate retaliation removes the one-shot gain from occasional defection, pushing them toward cooperation if they are adaptive.

If you want, I can also provide a “version 2” that uses an explicit **estimated sustainable-defection ceiling** derived from stock-change equations (more math-driven), but the above is intentionally simple, parameter-based, and implementable.
'''

description_COLLECTIVE_5 = '''
## Strategy: **Sustain-and-Sanction (SaS)**  
Goal: keep the stock near **capacity** (high long-run yield) while being **hard to exploit** by defectors. The strategy cooperates by default, but switches to short, state-dependent punishment when others over-consume, then returns to cooperation when behavior and stock recover.

Key idea: In this game, full cooperation can be *self-sustaining* because logistic growth can restore the stock to capacity if total consumption leaves enough remaining stock. Defection is individually profitable short-run but can crash the stock. So we (i) **target a safe stock level after consumption**, (ii) **detect over-consumption from history**, and (iii) **punish just enough** to make defection unattractive and to protect the stock when it’s already low.

---

# 1) Decision rules: when to cooperate vs defect

### Notation
- `n, r, capacity` as given.
- At round `t`, current stock is `S_t`.
- Let `k_{t-1}` be the number of defectors observed in the previous round (from history).
- Let `S_{t}` already includes growth from previous round (i.e., it’s the current round’s starting stock).

### Step A — Compute a **sustainability threshold** for the current stock
To avoid collapse, we want stock after consumption to stay above a “recovery floor”. A simple robust floor is:
- `S_floor = capacity / 4`

Reason: logistic growth `2x(1-x/capacity)` is strong when `x` is not too close to 0. Keeping remaining stock above ~capacity/4 avoids the low-stock trap and typically allows rebound.

Also define a “comfort zone”:
- `S_good = 0.8 * capacity` (stock is healthy)
- `S_critical = capacity / 4` (below this, prioritize recovery)

### Step B — Predict whether **cooperating is safe** given recent behavior
If we cooperate, our consumption is `S_t/(2n)`. If we defect, it’s `S_t/n`.

We can estimate expected total consumption using last round’s defection count as a proxy:
- Expected defectors next round: `k̂ = k_{t-1}` (clipped to `[0, n]`)
- Expected total consumption fraction of stock:
  - each cooperator consumes `1/(2n)` of stock
  - each defector consumes `1/n` of stock
  - Total fraction = `(n - k̂)*(1/(2n)) + k̂*(1/n) = 1/2 + k̂/(2n)`
- So expected remaining stock if we cooperate:
  - `S_rem_if_C ≈ S_t * (1 - (1/2 + k̂/(2n))) = S_t * (1/2 - k̂/(2n))`

**Safety check:** cooperating is considered “stock-safe” if  
`S_rem_if_C >= S_floor`.

If cooperating is unsafe (too many defectors recently or stock too low), we switch to a defensive mode.

### Step C — Main action rule (core of SaS)

**Rule 1: Default cooperate when stock is healthy and behavior isn’t exploitative**  
Play **C** if:
- `S_t >= S_good`, **and**
- `k_{t-1} == 0` (no one defected last round)

This locks into the efficient outcome when it exists.

**Rule 2: Gentle containment for occasional defection (probation)**  
If `S_t >= S_good` but `k_{t-1} > 0`, enter **probation**:
- Cooperate for now (**C**) **only if** cooperation is stock-safe (`S_rem_if_C >= S_floor`).
- Otherwise defect (**D**) to avoid being the only “sucker” while the stock is being drained.

Interpretation: we don’t instantly spiral into mutual defection if a single defection occurs while stock is very high and recovery is easy, but we also don’t keep cooperating into a crash.

**Rule 3: Punish sustained or severe over-consumption (sanction)**  
Play **D** if any of these hold:
- `S_t <= S_critical` (stock is low: protect yourself / reduce exploitation), or
- `k_{t-1} >= ceil(n/2)` (many defectors), or
- Cooperation is not stock-safe (`S_rem_if_C < S_floor`).

This makes exploitation less profitable and prevents unilateral “martyr cooperation” from accelerating depletion.

**Rule 4: Return-to-cooperation when conditions recover**  
After you punish (play D), return to **C** when both are true:
- `k_{t-1} == 0` (others stopped defecting), and
- `S_t >= S_good` (stock recovered)

This avoids permanent grudges and allows re-coordination.

---

# 2) Edge cases

### First round (t = 1)
Play **C**.

Rationale: You need a cooperative “on-ramp” to ever reach the high-yield steady state; starting with D often triggers others’ retaliation and can crash stock quickly.

### Last round (t = r)
Play **D** *unless* stock is critically low.

- If `S_t > S_critical`: play **D** (standard end-game temptation; no future to protect).
- If `S_t <= S_critical`: play **C** (because defecting when stock is tiny yields little anyway and can be dominated by keeping remaining stock from hitting zero before the payoff is realized across players—this is mainly a robustness clause; either action yields low payoff, but C avoids worst-case collapse if others also panic).

### Penultimate rounds (t = r-1)
Use normal rules, but slightly increase strictness:
- Treat `S_good` as `0.9*capacity` (require healthier stock to forgive) to reduce end-game exploitation.

### If stock hits 0 (or extremely low)
If `S_t` is near 0, both actions yield ~0 payoff. Choose **C** to try to allow growth from any remaining stock (if not exactly zero). If exactly zero, action is irrelevant; default **C**.

---

# 3) “Collective mindset” clarity (why this is collective and robust)

### Collective objective encoded in the rules
- The strategy’s *default* aims to keep the system in the region where the resource regenerates to capacity, maximizing total long-run payoffs.
- It only defects to (i) prevent being exploited, and (ii) prevent stock from entering the low-recovery trap.

### Robustness to opponent types
- **Always-Cooperators:** We get high payoffs while keeping stock high; we only defect late-game.
- **Always-Defectors:** We switch to D quickly (based on `k_{t-1}` and stock-safe test), limiting exploitation; stock may still collapse, but we don’t “donate” extra.
- **Conditional cooperators / grim trigger types:** We avoid unnecessary early punishment; we also return to cooperation after a clean round with high stock, enabling re-coordination.
- **Noisy / occasional defectors:** Probation mode tolerates limited noise when stock is abundant, but clamps down if noise becomes frequent or dangerous for stock.

---

# Pseudocode (implementable)

```python
def SaS_action(t, r, n, capacity, S_t, history):
    # history gives last round defector count
    if t == 1:
        return "C"

    k_last = history.defectors_in_round(t-1)  # integer 0..n

    S_floor = capacity / 4.0
    S_good = 0.8 * capacity
    S_critical = capacity / 4.0

    # End-game tightening
    if t == r-1:
        S_good = 0.9 * capacity

    # Last round rule
    if t == r:
        if S_t > S_critical:
            return "D"
        else:
            return "C"

    # Predict whether cooperating is stock-safe
    k_hat = k_last
    S_rem_if_C = S_t * (0.5 - k_hat/(2.0*n))  # expected remaining stock if we cooperate

    coop_safe = (S_rem_if_C >= S_floor)

    # Defensive triggers
    if S_t <= S_critical:
        return "D"
    if k_last >= (n + 1)//2:
        return "D"
    if not coop_safe:
        return "D"

    # Cooperative region
    if S_t >= S_good and k_last == 0:
        return "C"

    # Probation: mild response to limited defection
    if S_t >= S_good and k_last > 0:
        return "C"  # safe and forgiving when stock is strong

    # Otherwise, cautious
    return "C" if coop_safe and k_last == 0 else "D"
```

---

## Summary in one sentence
**Cooperate by default to keep the stock regenerating at high levels; defect only when recent behavior or current stock makes cooperation unsafe or exploitable; punish briefly and return to cooperation once a clean cooperative round occurs and the stock is healthy again.**
'''

description_COLLECTIVE_6 = '''
## Strategy: **Stock-Guarded Reciprocity (SGR)**  
Goal: keep the resource near its sustainable region (high stock) while being hard to exploit. The strategy (i) defaults to cooperation when the stock can sustain it, (ii) punishes over-consumption quickly and proportionally, and (iii) forgives when opponents return to restraint.

### Key idea
Because payoffs scale with current stock \(S\), the collective optimum is to maintain \(S\) high. Full defection collapses the stock to (near) zero and destroys future value. So we:
- **Cooperate** when the group is behaving sustainably and stock is healthy.
- **Defect** as a **temporary sanction** when others over-consume, especially when stock is threatened.
- **Return to cooperation** after a short, clear punishment if the group improves.

This is a collective strategy: it treats cooperation as the default, and uses defection only to protect the commons and deter exploitation.

---

## 1) Decision rules: when to Cooperate vs Defect

We use only parameters \((n,r,\text{capacity})\), current stock \(S_t\), and full history of actions.

### Definitions computed each round \(t\)
Let \(k_t\) = number of players (including you) who defected in round \(t\).

Let \(S_t\) be stock at the **start** of round \(t\).

Define a **safe-stock threshold**:
- **\(S_{\text{safe}} = 0.8 \cdot \text{capacity}\)**  
Above this, the stock can absorb occasional shocks; below this, we prioritize protection.

Define a **critical-stock threshold**:
- **\(S_{\text{crit}} = 0.5 \cdot \text{capacity}\)**  
Below this, over-consumption risks a collapse / slow recovery.

Define a **tolerance band** for occasional mistakes:
- **Tolerate up to 1 defector** when stock is safe.
- Tolerate **0 defectors** when stock is below safe.

We also maintain an internal integer **punishment counter** \(P\ge 0\) (how many future rounds we will defect).

---

### Core rule set

#### A. Default mode (no active punishment, \(P=0\))
1) **If \(t = r\) (last round): Defect (D)**  
Reason: end-game incentive; also everyone else will likely do this.

2) **If \(S_t < S_{\text{crit}}\): Cooperate (C)**  
Reason: when stock is critically low, additional extraction accelerates collapse; cooperating maximizes the chance of regrowth and future payoffs (even if others are not perfect). This is the “resource rescue” mode.

3) **If \(S_{\text{crit}} \le S_t < S_{\text{safe}}\):**
- If **anyone defected last round** (\(k_{t-1}\ge 1\)): set \(P = 1\), play **D** now.  
- Else play **C**.

4) **If \(S_t \ge S_{\text{safe}}\):**
- If **many defected last round** (\(k_{t-1} \ge 2\)): set \(P = 2\), play **D** now.  
- If **exactly one** defector last round: play **C** (forgive a single deviation when stock is healthy).
- If **none** defected: play **C**.

#### B. Punishment mode (active punishment, \(P>0\))
- Play **D**.
- Decrease \(P := P-1\) after the action.
- **Early exit / forgiveness:** if in the immediately previous round, defections were low:
  - If \(k_{t-1}=0\) and \(S_t \ge S_{\text{safe}}\), then set \(P=0\) (return to cooperation next round).
  - If \(k_{t-1}\le 1\) and \(S_t \ge 0.9\cdot\text{capacity}\), set \(P=0\).

This makes punishment **short and conditional**: it deters exploitation but avoids spiraling into mutual defection.

---

## 2) Edge cases and special handling

### First round (\(t=1\))
- Play **C**.  
Rationale: (i) stock starts at capacity, (ii) you establish cooperative intent, (iii) you gather information about the population’s baseline behavior.

Initialize \(P=0\).

### Last round (\(t=r\))
- Play **D** always.  
This is tournament-robust: many strategies defect at the end; cooperating is usually dominated.

### Near-last rounds (\(t=r-1\))
- If \(S_{r-1} \ge S_{\text{safe}}\) and history shows stable cooperation (e.g., \(k_{r-2}=0\)), play **C**.
- Otherwise play **D**.  
This reduces getting exploited by “late grab” strategies while still rewarding cooperative populations.

### Stock at/near zero
If \(S_t\) is extremely small, both C and D pay little. The strategy still uses **C when \(S_t < S_{\text{crit}}\)** to maximize recovery chances; defecting doesn’t help recovery and can prolong low-stock periods.

### Populations of consistent defectors
If opponents systematically defect, SGR will:
- punish briefly,
- then switch into resource-rescue cooperation when the stock becomes critically low,
- and still defect in late game.
This avoids self-destructive continuous defection when the resource is already collapsing, while not being an unconditional cooperator at high stock.

---

## 3) Why this is “collective” and robust
- **Collective first:** Cooperation is the default whenever the commons is safe and behavior isn’t clearly exploitative.
- **Commons protection:** When stock is threatened (below safe), the strategy becomes strict: any defection triggers punishment.
- **Proportional sanctions:** One defector when stock is high is forgiven; widespread defection triggers longer punishment.
- **Forgiveness:** Punishment is time-limited and ends early when the group returns to cooperation, enabling recovery of high-stock equilibria.
- **Tournament robustness:** Handles endgame defection, noisy opponents, conditional cooperators, and exploiters without requiring any pre-coordination.

---

## Pseudocode (implementable)

```python
# Inputs each round t:
# n, r, capacity
# S_t: stock at start of round t
# history of actions for all players from past rounds
# internal state: P (punishment counter), initially 0

S_safe = 0.8 * capacity
S_crit = 0.5 * capacity

def count_defectors(last_round_actions):
    return sum(1 for a in last_round_actions if a == 'D')

def act(t, S_t, history, P):
    if t == 1:
        return 'C', 0

    if t == r:
        return 'D', 0

    k_prev = count_defectors(history[t-1])  # actions in round t-1

    # Resource rescue mode
    if S_t < S_crit:
        return 'C', 0  # override punishment; prioritize regrowth

    # Punishment mode
    if P > 0:
        # forgiveness checks
        if (k_prev == 0 and S_t >= S_safe) or (k_prev <= 1 and S_t >= 0.9 * capacity):
            P = 0
        else:
            P -= 1
            return 'D', P

    # Default mode
    if S_t < S_safe:
        if k_prev >= 1:
            return 'D', 0  # set P=1 could be used; here immediate one-shot
        else:
            return 'C', 0

    # S_t >= S_safe
    if k_prev >= 2:
        return 'D', 1  # set punishment counter for next round too
    elif k_prev == 1:
        return 'C', 0
    else:
        return 'C', 0
```

If you want, I can tune the thresholds (\(0.8, 0.5\)) and punishment lengths as explicit functions of \(n\) (e.g., stricter when \(n\) is large because one defector has smaller direct impact but can trigger cascades), but the above is already parameter/state/history dependent and tournament-robust.
'''

description_COLLECTIVE_7 = '''
## Strategy: **Stock-Guarded, Reciprocity-Triggered (SGRT)**  
Goal: keep the resource near the sustainable “high” region (≈ capacity) by default, but respond quickly to over-extraction so you don’t get exploited, and recover cooperation when conditions improve.

Key design ideas:
- **Stock is the main public signal**: if stock stays high, the group is effectively cooperating; if it falls, someone is over-consuming.
- **Defect only as a corrective tool**: used to avoid being the “sucker” when others defect, and to create pressure for others to return to C.
- **Forgive when stock recovers**: because logistic growth can replenish if extraction is moderated.

---

# 1) Decision rules (C vs D)

### Definitions computed each round \(t\)
Let:
- \(S_t\) = current stock at start of round \(t\)
- \(cap\) = capacity
- \(n\) players
- \(H\) = number of players who defected last round (from observed history). If \(t=1\), set \(H=0\).
- \(S_{t-1}^{after}\) = stock after last round’s growth (i.e., the current \(S_t\)). (So we only need the current stock plus last actions.)

### Intuition for thresholds
- If **all cooperate**, stock tends to return to capacity (as in your example).
- If **many defect**, stock can crash.
- So we create **stock “zones”**:
  - **Green zone** (healthy): cooperate.
  - **Yellow zone** (at risk): cooperate unless recent defection is significant.
  - **Red zone** (critical): defect to avoid being exploited and to “match” others.

### Parameters (constants of the strategy)
These are fixed functions of the game parameters (no tuning to opponents):

- **Green threshold**: \(G = 0.80 \cdot cap\)
- **Yellow threshold**: \(Y = 0.50 \cdot cap\)
- **Critical threshold**: \(R = 0.25 \cdot cap\)

- **Defection tolerance** (how many defectors we “accept” before retaliating):
  - \(T = \max(1, \lceil 0.20 n \rceil)\)  (about 20% of the group)

- **Retaliation length** \(L\): how many rounds we keep defecting once triggered:
  - \(L = 1 + \lceil \log_2(n) \rceil\)
  - This scales mildly with group size (bigger groups need slightly longer “pressure”).

We also maintain an internal state variable:
- `punish_remaining` (integer, initially 0)

---

## Core rule
At round \(t\), play:

### A) If in punishment mode
If `punish_remaining > 0`:
- Play **D**
- Decrease `punish_remaining -= 1`
- **Exception (early forgiveness):** if \(S_t \ge G\) *and* \(H = 0\) (nobody defected last round), set `punish_remaining = 0` and play **C** instead.  
Rationale: if the group is clearly back to full cooperation and stock is healthy, return immediately.

---

### B) If not in punishment mode (`punish_remaining == 0`)
Use stock zones + last-round defection signal:

1) **Green zone: \(S_t \ge G\)**
- Play **C**
- If \(H > T\) (meaning noticeable defection happened despite healthy stock), set `punish_remaining = L` starting next round (i.e., retaliate after observing the defection).  
Rationale: don’t “preemptively” defect in a simultaneous move, but do retaliate reliably.

2) **Yellow zone: \(Y \le S_t < G\)**
- If \(H > 0\): play **D** and set `punish_remaining = L`  
- Else (no defection observed): play **C**  
Rationale: when stock is slipping, even small defection is dangerous; otherwise keep cooperating to recover.

3) **Red zone: \(R \le S_t < Y\)**
- Play **D**  
- If \(H = 0\) for **two consecutive rounds** and stock is rising (see below), then switch back to **C**.  
Rationale: in this zone, the priority is not being the last cooperator while stock is low; but you still allow recovery if behavior stabilizes.

4) **Critical zone: \(S_t < R\)**
- Play **D** unconditionally until stock returns to at least \(Y\).  
Rationale: when the pool is near collapse, any cooperation is easily exploited and doesn’t generate enough collective restraint signal.

---

### Stock trend check (“stock is rising”)
To decide if recovery is underway, compute:
- `rising = (S_t > S_{t-1})` (using observed stock history)

In Red zone, allow a return to C only if:
- last two rounds had \(H=0\) (no defectors)
- and `rising` is true at least once over the last two transitions

This prevents “false forgiveness” when stock is still deteriorating.

---

# 2) Edge cases

### First round (t = 1)
- Play **C**.
Reason: With full stock (initially capacity), cooperation is optimal for sustaining capacity; also you gain information about the population.

### Last round (t = r)
Tournament settings matter here: if opponents are fully rational and backward-induct, end-game defection can unravel cooperation. But many tournament agents are not strict backward-induction types, and maintaining a cooperative reputation can matter if strategies use history strongly.

So the rule is:
- If \(S_r \ge Y\) and **no defection in round r-1** (\(H=0\)), play **C**.
- Otherwise play **D**.

This is a “soft” last-round defection: you only defect at the end if the environment already looks non-cooperative or stock is low.

### If stock hits 0
- Always **D** (doesn’t matter for immediate payoff since \(S=0\), but keeps consistent incentives and avoids being the only cooperator when recovery starts).

### If everyone defected last round
- Trigger punishment immediately (or remain in it), and play **D** until stock is at least \(Y\) and defection ceases.

---

# 3) Why this is collective and robust

### Collective alignment
- Default is **C** whenever stock is healthy (Green) or can plausibly recover (Yellow without observed defection).
- The strategy’s “objective function” is implicitly **maintain stock near capacity**, which maximizes long-run total group payoffs because the growth term replenishes strongly around mid-to-high stock and saturates at capacity.

### Robustness to opponents
- **Against unconditional defectors:** you quickly enter D-mode and stop being exploited; you don’t waste many rounds cooperating into a collapse.
- **Against mostly cooperative populations:** you stay cooperative almost always, keeping stock high and payoffs stable.
- **Against noisy / occasional defectors:** retaliation is finite and forgiveness is explicit; you don’t spiral into permanent mutual defection.
- **Against strategies that try to “farm” cooperators:** stock-zone rules + retaliation ensure that repeated opportunism moves you into D frequently enough that exploitation isn’t profitable.

---

# Pseudocode (implementable)
```pseudo
constants:
  G = 0.80 * capacity
  Y = 0.50 * capacity
  R = 0.25 * capacity
  T = max(1, ceil(0.20 * n))
  L = 1 + ceil(log2(n))

state:
  punish_remaining = 0

function action(t, S_t, history):
  if t == 1:
    return C

  H = number_of_defectors_in_round(t-1, history)
  S_prev = stock_at_start_of_round(t-1, history)  // or store last S
  rising = (S_t > S_prev)

  if punish_remaining > 0:
    if S_t >= G and H == 0:
      punish_remaining = 0
      return C
    punish_remaining -= 1
    return D

  // not in punishment mode
  if S_t >= G:
    // cooperate, but prepare to punish next round if many defected
    if H > T:
      punish_remaining = L
    return C

  if S_t >= Y:  // Yellow
    if H > 0:
      punish_remaining = L
      return D
    return C

  if S_t >= R:  // Red
    // defect unless clear stabilization
    if last_two_rounds_have_H_eq_0(history) and stock_rising_recently(history):
      return C
    return D

  // Critical
  return D
```

If you want, I can also provide a compact “decision table” version or suggest slight parameter tweaks (e.g., more/less forgiving) depending on whether tournament opponents tend to be more exploitative or more cooperative.
'''

description_COLLECTIVE_8 = '''
## Collective Strategy: **Stock-Steward with Graduated Sanctions (SSGS)**  
Goal: keep the stock near the regenerative sweet spot (high growth), reward restraint, and punish over-extraction enough to make exploitation unprofitable—while recovering quickly when others return to restraint.

Key idea: treat each round as a choice between (a) sustaining the resource (C) and (b) sanctioning / self-protecting (D). Use only observable history (past actions) + current stock.

---

# 1) Decision rules (C vs D)

### Definitions (computed each round before acting)
- Let `S` = current stock at start of the round.
- Let `cap` = capacity.
- Let `n` = number of players.
- Let `D_last` = number of players who defected last round (including you).
- Let `d_rate_last = D_last / n`.
- Let `my_last` be your own last action.
- Maintain a state variable `strike` (integer ≥ 0) measuring how “non-collective” the environment has been recently.

### Intuition behind thresholds
- **If stock is healthy**, cooperation is best for the group *if others also restrain*, because logistic growth can restore stock (often back to capacity).
- **If many defect**, cooperating becomes “sucker” behavior: you take half the payoff and also help keep stock high for defectors to exploit. So punish.
- **If stock is low**, defecting can collapse it to 0. When stock is fragile, cooperate to avoid irreversible collapse—even if others are mixed—unless you are in an explicit punishment phase.

---

## Core rule set

### Rule A — **Default to stewardship (cooperate) when conditions are viable**
Play **C** if all of the following hold:
1. **Stock not critically low:** `S >= S_low`, where `S_low = 0.35 * cap`  
2. **Defection not widespread:** `d_rate_last <= 0.25` (at most 25% defected last round)  
3. **Not currently sanctioning:** `strike == 0`

Rationale: with low defection and decent stock, cooperation keeps the pool productive and stabilizes payoffs.

---

### Rule B — **Graduated sanctions if others over-extract**
Increase `strike` based on last round defection:

- If `d_rate_last > 0.50`: set `strike = max(strike, 3)`  
- Else if `0.25 < d_rate_last <= 0.50`: set `strike = max(strike, 2)`  
- Else if `0 < d_rate_last <= 0.25`: set `strike = max(strike, 1)`  
- Else (no one defected): `strike = max(strike - 1, 0)` (cool down)

Then:
- If `strike > 0`, play **D** *unless* the stock is critically low (Rule C).

Rationale: punish more when defection is widespread; cool down gradually to allow recovery and re-cooperation.

---

### Rule C — **Resource collapse prevention override**
If stock is in a danger zone, avoid actions that accelerate collapse.

- Define **critical stock**: `S_crit = 0.15 * cap`
- If `S <= S_crit`, play **C** regardless of `strike`, **except** in the last round (see edge cases).

Rationale: when stock is very low, additional extraction is disproportionately harmful; cooperating is the least damaging action and helps the pool regrow if any growth is possible.

---

### Rule D — **Exploit-resistant reciprocity (anti-sucker clause)**
Even if stock is healthy, do **not** cooperate if you were exploited repeatedly.

Maintain `exploit_count`:
- If you played C last round and `D_last > 0`, increment `exploit_count`.
- Else decrement `exploit_count` by 1 to a minimum of 0.

If `exploit_count >= 2`, set `strike = max(strike, 2)` (enter sanction mode).

Rationale: prevents being farmed by alternating or opportunistic defectors.

---

### Rule E — **Return-to-cooperation test**
When `strike` reaches 0, do not instantly jump into unconditional cooperation if stock is high and others might be testing you. Use a one-round “probe”:
- If `strike == 0` and `d_rate_last == 0`: play **C** (good environment).
- If `strike == 0` and `0 < d_rate_last <= 0.25`: play **C** (forgiving).
- If `strike == 0` and `d_rate_last > 0.25`: play **D** (don’t restart cooperation into a defection-heavy environment).

Rationale: quick restoration when possible, but avoid naive resets.

---

# 2) Edge cases

### First round (no history)
Play **C**.
- Also initialize: `strike = 0`, `exploit_count = 0`.

Rationale: collective intent, and you learn opponents’ tendencies at minimal strategic cost when stock starts at capacity.

---

### Last round
Play **D** *unless* stock is critical:
- If `S <= S_crit`, play **C**
- Else play **D**

Rationale: classic endgame temptation is strong in finite horizons. This rule is robust in tournaments: it avoids being the only cooperator at the end, but still prevents catastrophic collapse in ultra-low stock states (where even last-round defection yields tiny immediate benefit and may be dominated by keeping a small stock for any scoring conventions that might reward sustainability—though your model says only per-round payoff matters, so this is mainly “do no harm” at negligible cost).

---

### Near-capacity with history of cooperation
If `S >= 0.9*cap` and `d_rate_last == 0`, always **C** (even if you previously sanctioned and strike just hit 0).

Rationale: lock in the high-growth/high-payoff cooperative regime.

---

### Persistent defection environment
If in the last `k=3` rounds, `d_rate_last > 0.5` each round, then play **D** until you observe `d_rate_last <= 0.25` for two consecutive rounds (a “ceasefire” signal), *unless* `S <= S_crit` (then cooperate to prevent collapse).

Rationale: prevents repeated sucker losses in hostile populations while still leaving a path back.

---

# 3) “Collective mindset” alignment
This strategy is collective in three ways:
1. **Stewardship-first:** starts with cooperation and aims to keep stock in a regenerative zone.
2. **Punishment is conditional and temporary:** sanctions are used only to deter extraction and are explicitly designed to end once others restrain.
3. **Collapse prevention:** even when angry (strike > 0), it will switch to cooperation if stock is critically low to preserve the shared future value of the resource.

---

# Pseudocode (implementable)

```python
# Parameters: n, cap, r
# State variables:
strike = 0
exploit_count = 0

def decide(t, S, history_actions):  
    # history_actions: list of length t-1, each entry is list of actions of all n players
    S_low  = 0.35 * cap
    S_crit = 0.15 * cap

    if t == 1:
        return "C"

    last = history_actions[-1]
    D_last = sum(1 for a in last if a == "D")
    d_rate_last = D_last / n

    my_last = last[my_index]

    # Update exploit_count
    if my_last == "C" and D_last > 0:
        exploit_count += 1
    else:
        exploit_count = max(exploit_count - 1, 0)

    # Update strike from defection rate
    if d_rate_last > 0.50:
        strike = max(strike, 3)
    elif d_rate_last > 0.25:
        strike = max(strike, 2)
    elif d_rate_last > 0.0:
        strike = max(strike, 1)
    else:
        strike = max(strike - 1, 0)

    # Anti-sucker escalation
    if exploit_count >= 2:
        strike = max(strike, 2)

    # Last round rule
    if t == r:
        if S <= S_crit:
            return "C"
        else:
            return "D"

    # Collapse prevention override
    if S <= S_crit:
        return "C"

    # Persistent hostile environment check (optional robustness)
    if t >= 4:
        recent = history_actions[-3:]
        if all(sum(1 for a in round_a if a == "D") / n > 0.5 for round_a in recent):
            # wait for two consecutive low-defection rounds to resume C (unless critical stock handled above)
            # here: keep defecting
            return "D"

    # Main action choice
    if strike > 0:
        return "D"

    # strike == 0: stewardship conditions
    if (S >= S_low) and (d_rate_last <= 0.25):
        return "C"
    else:
        return "D"
```

---

If you tell me typical tournament settings (common values of `n`, `r`, and `capacity`), I can tune the numerical thresholds (`0.35 cap`, `0.15 cap`, 25%/50% defection cutoffs, strike lengths) to better match the growth/consumption magnitudes for those regimes.
'''

description_COLLECTIVE_9 = '''
## Collective Strategy: **Stock-Guard with Forgiving Reciprocity (SGFR)**

Goal: keep the stock near its sustainable high level (≈ capacity), while deterring exploitation by switching to defection when others over-consume, and returning to cooperation once behavior improves.

Key idea: **use the stock and observed total consumption to infer whether the group is behaving cooperatively**, then:
- **Cooperate** when the group is near the cooperative path or when stock is fragile (to preserve the resource).
- **Defect** when others are exploiting enough that unilateral cooperation just subsidizes them, but **only as long as needed** to restore incentives.

This is “collective” because it treats **stock stability** as the primary objective and uses punishment only instrumentally to re-align incentives.

---

# 1) Decision rules (C vs D)

### Observables each round \(t\)
- \(S_t\): current stock at start of round \(t\)
- From last round’s history (if \(t>1\)):
  - \(S_{t-1}\), actions of all players
  - \(k_{t-1}\): number of defectors last round

### Compute a key diagnostic: **implied total consumption last round**
If \(t>1\), you can infer total consumption without ambiguity from the action profile:
- Each C consumes \(S_{t-1}/(2n)\)
- Each D consumes \(S_{t-1}/n\)
So total consumption fraction is:
\[
\text{cons\_frac} = \frac{(n-k)\cdot \frac{1}{2n} + k \cdot \frac{1}{n}}{1}
= \frac{n-k}{2n} + \frac{k}{n}
= \frac{1}{2} + \frac{k}{2n}
\]
Thus, under all-C: cons_frac = 1/2. Under all-D: cons_frac = 1.

This lets you classify “how exploitative” last round was, independent of capacity/growth.

---

## SGFR Policy (high level)

### A. Stock safety rule (resource-first)
If stock is low, prioritize recovery by cooperating (punishment via defection is counterproductive when the pool is fragile).

- Define **low-stock threshold**:  
  \[
  S_t \le S_{\text{low}} := 0.5\cdot \text{capacity}
  \]
- If \(S_t \le S_{\text{low}}\): **play C** (unless it is the very last round; see edge cases).

Rationale: when stock is already below half of capacity, additional extraction (defection) tends to slow rebuilding and risks collapse. Collective strategy protects the state.

---

### B. Reciprocity rule (anti-exploitation)
When stock is healthy, respond to exploitation with proportional punishment, but forgive quickly.

Let:
- \(k_{t-1}\) = number of defectors last round.

Use three regimes when \(S_t > S_{\text{low}}\):

1) **Cooperative environment**: if \(k_{t-1}=0\)  
   → **Play C**

2) **Mild exploitation**: if \(1 \le k_{t-1} \le \lceil n/3 \rceil\)  
   → **Play C** (forgiving stance)

3) **Serious exploitation**: if \(k_{t-1} > \lceil n/3 \rceil\)  
   → **Play D** (deterrence mode)

Why the \(\lceil n/3 \rceil\) cutoff?  
- With a small minority defecting, staying cooperative keeps the stock high and avoids spirals.
- When defection becomes common, unconditional cooperation becomes a “donation” to defectors; switching to D raises immediate payoff and pressures a return to C.

---

### C. Punishment is temporary (forgiveness / exit rule)
If you entered deterrence mode (playing D because many defected), you should **return to cooperation as soon as behavior improves**.

- After you played D, if in the next observed round \(k_{t-1} \le \lceil n/3 \rceil\), switch back to **C**.
- If \(k_{t-1}\) stays high, continue **D**, but cap punishment length to avoid permanent collapse dynamics:
  - After **2 consecutive D rounds by you**, if stock is still healthy and others are not improving, you may alternate **C** once to “offer a path back”:
    - If your last two actions were D and D, then play C **once** (a “reset offer”).
    - If defection persists immediately after that offer, revert to D again.

This makes the strategy robust against:
- Grim-trigger types (you don’t lock into endless war immediately)
- Noise-like instability (you don’t overreact to one defector)
- Pure defectors (you don’t keep donating indefinitely)

---

# 2) Edge cases

### First round (no history)
- If \(r\) is finite and known, last-round logic matters; still, start collectively:
  - **Round 1: Play C**  
Reason: it establishes the best long-run state (high stock) and tests opponents.

### Last round
There is no future to protect, so reciprocity incentives disappear. However, the strategy remains “collective” unless exploitation is rampant.

- If \(t = r\):
  - If \(S_t \le S_{\text{low}}\): **C** (even at the end, this avoids accelerating collapse for no future benefit—purely collective choice)
  - Else if in the previous round \(k_{t-1} > \lceil n/3 \rceil\): **D**
  - Else: **C**

This is a balanced endgame: don’t defect “just because it’s last”; defect only if the environment is already exploitative.

### Stock at (or near) 0
- If \(S_t\) is extremely low (e.g., \(S_t < 10^{-9}\)), both C and D yield ~0 payoff; choose **C** to support recovery (and signal willingness).

### Capacity constraint and parameter extremes
- The policy scales with \(n\) via the \(\lceil n/3 \rceil\) threshold.
- It uses only ratios of stock to capacity, so it adapts across capacities.

---

# 3) Why this is “collective” and robust

**Collective alignment**
- Defaults to C to maintain stock near capacity where everyone can earn sustainably.
- Treats stock preservation as a first-class objective (safety rule).

**Robustness**
- Against always-cooperate: mutual C maintained; stock stays high.
- Against occasional defectors: forgiving; avoids destructive retaliation spirals.
- Against majority defectors: switches to D to avoid being exploited and to apply pressure.
- Against alternating / tricky opponents: uses a simple, interpretable statistic (# defectors), plus a limited punishment and reset offer to prevent being trapped.

---

# Pseudocode (implementable)

```pseudo
inputs each round t:
  S_t, capacity, n, r
  history actions from t-1 (if t>1)

constants:
  S_low = 0.5 * capacity
  k_cutoff = ceil(n/3)

state variable:
  my_last_actions (track last 2 of mine), optional

function choose_action(t, S_t, history):
  if t == 1:
    return C

  k_prev = count_defectors(history[t-1])  // number of D last round

  // Last round handling
  if t == r:
    if S_t <= S_low:
      return C
    else if k_prev > k_cutoff:
      return D
    else:
      return C

  // Stock safety rule
  if S_t <= S_low:
    return C

  // Forgiving reciprocity
  if k_prev == 0:
    return C

  if k_prev <= k_cutoff:
    return C

  // Serious exploitation: deterrence mode
  // Limited punishment with a reset offer
  if my_last_actions[-2:] == [D, D]:
    return C   // one-round reset offer
  else:
    return D
```

If you want a slightly harsher or softer variant for tournament tuning:
- Harsher: set cutoff to `ceil(n/4)` and remove the reset offer.
- Softer: set cutoff to `ceil(n/2)` and keep reset offer.

SGFR is designed to be broadly competitive while still genuinely optimizing the collective outcome when others permit it.
'''

description_COLLECTIVE_10 = '''
## Strategy: **StockGuard (forgiving trigger with stock-based control)**

**Collective objective:** keep the resource near its sustainable “high stock” region so everyone can earn high payoffs every round, while **swiftly punishing** behaviour that risks collapse and **forgiving** once behaviour returns to safe levels. The strategy uses only *(n, r, capacity)*, current *stock S*, and full history of actions.

---

# Key idea (what we’re trying to stabilize)

Let:
- \(k_t\) = number of defectors in round \(t\)
- Per-round **total consumption** given stock \(S\):
  \[
  \text{consumption} = (n-k)\frac{S}{2n} + k\frac{S}{n} = \frac{S}{2}\left(1 + \frac{k}{n}\right)
  \]
- Remaining stock after consumption:
  \[
  S_{\text{rem}} = S\left(\frac{1}{2} - \frac{k}{2n}\right)
  \]

If **everyone cooperates** (\(k=0\)), then \(S_{\text{rem}} = S/2\), and with the given growth rule the stock tends to bounce back strongly (often to capacity). If many defect, \(S_{\text{rem}}\) shrinks and growth can’t rescue it, risking collapse.

So we want:
1) default cooperation when the system is safe,
2) immediate punishment when the group’s extraction is unsafe or exploitative,
3) rapid return to cooperation when the group returns to safe behavior.

---

# Decision rules (cooperate vs defect)

We maintain a single internal variable:

- **punish_timer**: nonnegative integer (starts at 0)

### Definitions computed each round \(t\) before choosing action
From last round’s history (if \(t>1\)):
- \(k_{t-1}\): number of players who played D last round
- \(S_t\): current observed stock at start of round \(t\)

Thresholds:
- **Safe stock threshold:**  
  \[
  S_{\text{safe}} = 0.8 \times \text{capacity}
  \]
- **Critical stock threshold:**  
  \[
  S_{\text{crit}} = 0.4 \times \text{capacity}
  \]

Punishment lengths:
- **Base punishment:** \(L_0 = 2\)
- **Escalation:** add +1 punishment round for each defector beyond the first, capped.
  \[
  L(k) = \min\left(6,\; L_0 + \max(0, k-1)\right)
  \]

### Rule set
1) **Last round (t = r): defect.**  
   Rationale: endgame incentives otherwise invite being exploited; we protect ourselves and avoid being the “sucker” in the final move. (This is the only explicitly non-collective-looking edge, but it prevents last-round predation that can unravel earlier cooperation.)

2) **If punish_timer > 0: defect** and decrement punish_timer by 1.  
   This is the credible deterrent.

3) **Otherwise (not currently punishing):**
   - **If stock is critical (S ≤ S_crit): cooperate.**  
     When the system is near collapse, defecting accelerates depletion; the best collective move is to reduce extraction. (Also, defecting at low S yields little immediate gain anyway.)
   - **Else if we observed any defectors last round (k_{t-1} > 0):**
     - If stock is still high (S ≥ S_safe): **start punishment**: set punish_timer = L(k_{t-1}), and **defect now**.
     - If stock is not high (S < S_safe): **cooperate** (focus on recovery), but set a *conditional punishment*: if defection repeats next round, punish then.  
       (In pseudocode: record “warning flag”; simplest implementation: treat repeated defection as k>0 again next round; see below.)
   - **Else (no defectors last round): cooperate.**

---

# Edge cases & special handling

### Round 1
**Cooperate in round 1.**  
Reason: the resource starts at capacity; cooperation is Pareto-efficient, and we want to invite mutual cooperation rather than start with aggression.

### Last 2 rounds nuance (optional but recommended)
To reduce unraveling while still defending against endgame defection:
- In **round r-1**:
  - If *no defection ever occurred* (perfect cooperation so far) **cooperate**.
  - Otherwise follow normal rules.
Then in **round r** defect regardless.

This keeps long cooperative runs stable against “backward induction paranoia,” but still closes the endgame.

### Handling noisy / “accidental” defection patterns
We’re **forgiving** by design:
- A **single defection** triggers only **short punishment** (2 rounds) *and only if stock is high*.  
- When stock is middling/low, we prioritize **stock recovery** over retaliation.

### Handling chronic defectors
Escalation via \(L(k)\) makes punishment harsher when many defect simultaneously, which is when collapse risk is highest and deterrence needs to be strongest.

---

# Pseudocode (implementable)

```python
# parameters: n, r, capacity
# observed each round t: S_t (current stock), history of actions

punish_timer = 0

S_safe = 0.8 * capacity
S_crit = 0.4 * capacity

def L(k):
    return min(6, 2 + max(0, k-1))

for t in 1..r:

    if t == r:
        action = "D"
        break

    if punish_timer > 0:
        action = "D"
        punish_timer -= 1
        continue

    if t == 1:
        action = "C"
        continue

    k_prev = count_defectors_in_round(t-1)

    if S_t <= S_crit:
        action = "C"
        continue

    if k_prev > 0:
        if S_t >= S_safe:
            punish_timer = L(k_prev)
            action = "D"
        else:
            # focus on recovery; forgive once
            action = "C"
        continue

    # no defection last round
    action = "C"
```

Optional tweak for r-1 cooperation after perfect history:
```python
if t == r-1 and no_defection_in_history_so_far:
    action = "C"
```

---

# Why this is “collective” and tournament-robust

- **Collective first:** defaults to C whenever the group is cooperating or the stock is threatened.
- **Deters exploitation:** swift punishment when defection appears while stock is high (the typical “temptation” region).
- **Avoids mutual destruction:** does *not* mindlessly punish when stock is already low—retaliation then is costly and risks collapse.
- **Adaptive:** punishment length scales with how many defected (a proxy for how coordinated/serious the deviation is).
- **Compatible with many opponent types:**
  - Cooperative strategies: converges to stable C most of the game.
  - Grim/trigger types: still works because it punishes defect and then settles.
  - Always-defect: will mostly defect after detection, limiting losses.
  - Random/noisy: forgiving stance at low stock prevents runaway collapse.

If you want, I can also provide a variant that *never* defects in the last round (purely collective), or a variant that uses a computed “target remaining stock” instead of fixed 0.8/0.4 thresholds.
'''

description_COLLECTIVE_11 = '''
## Strategy: **Stock-Guardian (collective, adaptive, retaliation-with-forgiveness)**

Goal: keep the resource near a self-sustaining level (high future value) while deterring repeated overconsumption. The strategy is **state-based** (uses current stock) and **history-based** (responds to how much others over-consumed last round), with **graduated retaliation** and **fast forgiveness** once behavior improves.

Key idea: there is a *safe stock band* where mutual cooperation is best for the group because the logistic growth refills stock quickly. When others defect too much, you must sometimes defect to (a) avoid being exploited and (b) impose a cost that makes defection less attractive, but only as long as needed.

---

# 1) Decision rules (C vs D)

### Definitions computed each round \(t\)
- \(S_t\): current stock at start of round \(t\).
- Let \(D_{t-1}\) be the **number of defectors last round** (observable from actions).
- Define **overuse index** last round:
  \[
  \delta_{t-1} = \frac{D_{t-1}}{n} \in [0,1]
  \]
- Maintain an internal **severity score** \(p_t\) (“punishment pressure”), integer \(\ge 0\).

### Stock zones
Use two stock thresholds based on capacity:
- **Critical**: \(S_t \le 0.25 \cdot capacity\)
- **Healthy**: \(S_t \ge 0.6 \cdot capacity\)

(These values are chosen to be robust: below ~25% the pool is fragile; above ~60% it can absorb some misbehavior while still regrowing well.)

### Core action rule
You choose **C** by default in healthy conditions, but switch to **D** when either (i) stock is dangerously low, or (ii) opponents are defecting enough to justify retaliation.

**Rule (high-level):**
- If stock is **Critical** → play **C** (protect regeneration; avoid collapse spiral).
- Else if you are in a **punishment phase** (tracked by \(p_t>0\)) → play **D**.
- Else (normal phase):
  - If last-round defection rate \(\delta_{t-1}\) is **low** → play **C**.
  - If last-round defection rate \(\delta_{t-1}\) is **high** → play **D** (one-shot deterrence).

### Concrete thresholds
- “Low defection”: \(\delta_{t-1} \le 1/n\) (at most one defector)
- “High defection”: \(\delta_{t-1} \ge 2/n\) (two or more defectors)

Rationale: one defector can be noise/experimentation; two or more suggests a trend that can destabilize the pool if unchallenged.

---

# 2) Edge cases (first round, last round, recovery)

### First round (no history)
- Play **C**, unless stock is already Critical (shouldn’t happen with initial \(S=capacity\), but handle it).
  - Collective stance: start cooperative to allow the group to lock into the high-stock steady path.

### Last round
- Play **D** unless stock is Critical.
  - Reason: there is no future to protect, so collective/resource stewardship has no continuation value; also others may “end-game defect.”  
  - Exception: if \(S_t\) is Critical, still play **C** (because defecting at near-zero stock barely helps you anyway and can be strictly dominated by keeping the remaining stock from hitting zero for marginal payoff differences).

### Recovery / forgiveness behavior
Forgiveness is important: once others return to cooperation, the pool can snap back to capacity quickly.

- If last round had **no defectors** (\(D_{t-1}=0\)) and stock is at least **Healthy**, then **reset punishment pressure** quickly (reduce \(p\) to 0).
- If defectors drop but not to zero, reduce \(p\) gradually.

---

# 3) Collective mechanism: graduated retaliation with a state “circuit breaker”

The strategy uses **two coupled controls**:

## A) A “circuit breaker” for low stock (always conserve)
When the pool is fragile, everyone’s long-run payoff depends on recovery. So regardless of others’ actions:
- If \(S_t \le 0.25 \cdot capacity\): play **C**.

This prevents a destructive feedback loop where retaliation drives the stock to zero.

## B) A “punishment pressure” score \(p\) (retaliate, but not forever)
Update \(p\) after observing round \(t\) (for use in round \(t+1\)):

- If \(D_t = 0\):  
  \(p \leftarrow \max(0, p - 2)\)  (fast forgiveness)
- If \(D_t = 1\):  
  \(p \leftarrow \max(0, p - 1)\)  (mild forgiveness / treat as noise)
- If \(D_t \ge 2\):  
  \(p \leftarrow \min(p + 2, 6)\)  (escalate, capped)

Then the action rule uses:
- If \(p>0\) and stock not Critical → play **D** and decrement \(p\) by 1 after playing D (so punishment is **finite** unless renewed by further defections).

This creates **predictable, proportionate** consequences: persistent defection triggers multiple rounds of D from you; cooperative behavior quickly restores C.

---

# Pseudocode (implementation-ready)

```python
# persistent state for our agent:
p = 0  # punishment pressure, integer

def decide_action(t, r, S, capacity, n, history_actions):
    # history_actions[t-1] is list of actions by all players last round, if t>1

    critical = (S <= 0.25 * capacity)
    healthy  = (S >= 0.60 * capacity)

    # last round info
    if t == 1:
        D_prev = 0
    else:
        D_prev = count_defectors(history_actions[t-1])

    # last round defection rate
    # (avoid float issues: compare using counts)
    high_defection = (D_prev >= 2)
    low_defection  = (D_prev <= 1)

    # last round is handled via p update AFTER round ends.
    # action decision now:
    if t == r:
        return "C" if critical else "D"

    if critical:
        return "C"

    if p > 0:
        return "D"

    # normal phase
    if high_defection:
        return "D"
    else:
        return "C"


def update_after_round(t, S_next, actions_all, capacity, n):
    global p
    D_t = count_defectors(actions_all)

    if D_t == 0:
        p = max(0, p - 2)
    elif D_t == 1:
        p = max(0, p - 1)
    else:
        p = min(p + 2, 6)

    # if we punished this round (played D due to p>0), we can also decay p by 1
    # but only if stock wasn't critical (i.e., punishment was "active")
    # This is optional if you implement punishment as "p implies D then p--".
```

(If you implement “when p>0 play D” then you typically do `p -= 1` when you actually choose D due to p. Keep the update rule consistent.)

---

# Why this should do well in a tournament

- **Cooperates when the group can sustain it** (keeps stock near capacity where growth is strongest).
- **Punishes coordinated or repeated defectors** enough to avoid being a “sucker,” without triggering total collapse.
- **Forgives quickly** when cooperation resumes, capturing the high long-run returns of a regenerated pool.
- **Robust to mixed populations**:  
  - Against always-cooperators: mostly C (high collective payoff).  
  - Against occasional defectors: brief D responses, then back to C.  
  - Against persistent defectors: sustained D, but with the circuit breaker to avoid zero-stock traps.  
- **Handles end-game** with pragmatic last-round D (standard in finite repeated dilemmas), while still protecting against meaningless “defect into collapse” when stock is already too low.

If you want, I can tune the numeric thresholds (0.25, 0.60, escalation cap 6) to specific \((n, capacity, r)\) ranges, but the above is designed to be parameter-robust without needing coordination assumptions.
'''

description_COLLECTIVE_12 = '''
## Strategy: **Stock-Guard Reciprocal (SGR)**  
Goal: keep the stock near the sustainable “high-yield” region (close to capacity) while being hard to exploit. We do this by (i) cooperating by default when the stock is healthy, (ii) switching to defect when the stock is threatened, and (iii) punishing recent over-consumption by others in a proportional, forgiving way.

This is a **collective** strategy: it treats cooperation as the default public good, uses defection mainly as a **resource-protection and deterrence tool**, and returns to cooperation quickly when the group does.

---

# Key ideas (why these rules)
- **C is socially optimal** when stock is high: if everyone plays C at high stock, consumption is moderate and the logistic growth often restores the stock to capacity.
- **D is individually tempting**, but widespread D collapses the stock to 0 and kills future payoffs.
- Because actions are observable, we can enforce cooperation with **reciprocity**: cooperate when others cooperate; defect when they over-consume.
- Also, stock dynamics matter: even if others are “nice,” if stock gets low, we must defect to avoid ending with tiny per-round payoffs forever.

---

# Definitions computed each round
Let:
- `S_t` = stock at start of round t
- `k_{t-1}` = number of players who defected in previous round (from observed history). For t=1, undefined.
- `defect_rate_{t-1} = k_{t-1} / n`
- Two stock thresholds (depend only on parameters):
  - `S_low = capacity/2`  (below this, growth is weaker and the system is fragile)
  - `S_high = 0.9*capacity` (above this, the system is healthy)

(These are simple, parameter-based and robust; the exact constants can be tuned but work well across many settings.)

---

# 1) Decision rules (C vs D)

### Rule A — **Resource protection first (state-based)**
1. **If `S_t <= S_low`: play D.**  
   Rationale: when stock is low, individual payoffs are low anyway; D increases your payoff and discourages others from draining further without consequence. It also avoids being the “sucker” when others panic-defect.

2. **Else if `S_t >= S_high`: default to C**, *unless punishment is triggered* (Rule B).

3. **Else (mid-stock region)**: apply punishment sensitivity (Rule B) more strongly (because stock is not fully safe).

### Rule B — **Reciprocal deterrence (history-based)**
We punish based on how many defected last round, but we’re forgiving when defection is rare.

Define a *punish probability* `p_punish`:

- If `S_t >= S_high`:
  - `p_punish = clamp( 2*defect_rate_{t-1} , 0, 1 )`
- If `S_low < S_t < S_high`:
  - `p_punish = clamp( 3*defect_rate_{t-1} , 0, 1 )`

Then:
- If `t > 1` and (random draw) `< p_punish`, play D; else play C.

Interpretation:
- If a few players defect (say 1 out of n), we mostly keep cooperating, but we introduce some risk of punishment so defection isn’t free.
- If many defect, we quickly shift toward D, preventing exploitation and signaling that the group must return to cooperation to recover.

### Rule C — **“Return-to-C” forgiveness**
If **no one defected last round** (`k_{t-1}=0`) and `S_t > S_low`, then **play C deterministically** (ignore punishment).  
This ensures rapid convergence to full cooperation whenever the group cooperates.

---

# 2) Edge cases

### First round (t = 1)
- If `S_1 >= S_high`, **play C**.  
- Else if `S_1 <= S_low`, **play D**.  
- Else (mid): **play C**.  
Rationale: start cooperatively unless the resource is already in danger.

### Last round (t = r)
Standard repeated-game logic tempts end-game defection, but tournaments often reward strategies that remain cooperative because:
- you can’t assume others will “unravel,”
- mutual cooperation in the last round can still be valuable if stock is high,
- and reputation-like reciprocity matters because opponents are strategies, not fully rational backward-induction solvers.

So:
- If `S_r <= S_low`: play D (resource protection).
- Else: follow the same Rule B reciprocity (do **not** auto-defect).

### After a collapse (S_t very small)
If `S_t` is extremely low (e.g., `S_t < 0.1*capacity`), defecting or cooperating both yield tiny payoffs, but cooperation may help regrow only if others also cooperate. Still, a lone cooperator is easily exploited. So:
- **Play D until either**:
  - you observe `k_{t-1}=0` (everyone cooperated), then switch to C, or
  - stock rises above `S_low`, then revert to normal rules.

---

# 3) Collective alignment (how it behaves socially)
- **Pro-cooperation default** when the resource is healthy.
- **Proportional punishment** discourages free riding without permanently locking into mutual defection.
- **Fast forgiveness** enables the group to re-coordinate after shocks or after meeting harsher opponents.
- **State awareness** means the strategy protects the common pool when it’s endangered, rather than blindly “being nice.”

---

# Pseudocode (implementation-ready)

```python
def action(t, S_t, history, n, r, capacity):
    S_low  = 0.5 * capacity
    S_high = 0.9 * capacity

    if t == 1:
        if S_t <= S_low: 
            return "D"
        else:
            return "C"

    # Observe last round defections
    k = history.num_defectors(t-1)     # integer 0..n
    defect_rate = k / n

    # Collapse handling
    if S_t < 0.1 * capacity:
        if k == 0:        # group just cooperated
            return "C"
        else:
            return "D"

    # Resource protection
    if S_t <= S_low:
        return "D"

    # Full forgiveness when everyone cooperated
    if k == 0:
        return "C"

    # Reciprocal punishment intensity depends on stock safety
    if S_t >= S_high:
        p_punish = min(1.0, 2.0 * defect_rate)
    else:
        p_punish = min(1.0, 3.0 * defect_rate)

    # Probabilistic punishment to avoid deadlocks, while deterring exploitation
    return "D" if random() < p_punish else "C"
```

---

## What this is robust against
- **Always-defectors:** quickly escalates to mostly D, limiting exploitation.
- **Mostly-cooperators with occasional mistakes/noise:** forgiveness + low punishment keeps cooperation stable.
- **Conditional cooperators:** converges to mutual cooperation.
- **Chaotic strategies:** state-based protection prevents catastrophic long-term loss.

If you want, I can also provide a deterministic variant (no randomness) that uses a moving window of defections and a strict trigger threshold, but the probabilistic punishment tends to perform better across diverse opponents by reducing permanent retaliation cycles.
'''

description_COLLECTIVE_13 = '''
## Collective strategy: **Stock-Guarded, Forgiving Threshold (SGFT)**

Goal: maximize *total group extraction over time* by keeping the stock near the regenerative sweet spot, while still being robust to exploitation by defectors.

Key idea:  
- The stock regenerates well when it is not driven too low; collapse is catastrophic.  
- We therefore **default to cooperation when stock is healthy**, but **defect defensively** when (a) stock is at risk, or (b) others are repeatedly defecting and draining the pool.

This is a *collective* strategy because its “preferred” mode is to maintain the resource; retaliation is used only to stop persistent free-riding and prevent collapse.

---

# 1) Decision rules (C vs D)

### Observables each round
At round \(t\), you know:
- current stock \(S_t\)
- history of actions of all players in rounds \(1..t-1\)
- parameters \(n, r, capacity\)

Let:
- \(D_{t-1}\) = number of players who defected in round \(t-1\)
- \(p_{t-1} = D_{t-1} / n\) = defection rate last round
- `streakD_j` = how many consecutive rounds player \(j\) has defected up to \(t-1\)

### Stock-based “safe operating band”
Define two stock thresholds:
- **Danger threshold:** \(S_{\text{low}} = 0.35 \cdot capacity\)
- **Target threshold:** \(S_{\text{high}} = 0.70 \cdot capacity\)

Interpretation:
- Below \(S_{\text{low}}\): resource is fragile; we prioritize preventing collapse.
- Above \(S_{\text{high}}\): resource is abundant; we can afford to cooperate and invite others back to cooperation.

(These constants are intentionally simple and parameter-only; they work across many \(n\), \(r\), capacities.)

### Retaliation trigger (against exploitation)
We also compute:
- **Persistent-defection signal:**  
  \(P_t = \frac{\#\{j: streakD_j \ge 2\}}{n}\)  
  (fraction of players who have defected at least two rounds in a row)

This separates “noise” from “systematic free-riding”.

---

## Core action rule

At round \(t\):

1) **If the stock is in danger, cooperate to rebuild (unless endgame):**  
- If \(S_t \le S_{\text{low}}\) then play **C**, *except* in the final-round edge case described below.

Reason: Defection when stock is low accelerates collapse; cooperation is the most collective move.

2) **If the stock is healthy and defection is not rampant, cooperate:**  
- If \(S_t \ge S_{\text{high}}\) and \(p_{t-1} \le 0.25\) and \(P_t \le 0.20\), play **C**.

Reason: When others mostly cooperate, staying cooperative keeps the resource at/near capacity and yields high long-run group payoff.

3) **Otherwise, use measured defensive defection:**  
If neither (1) nor (2) holds, decide based on whether exploitation seems persistent:

- If \(P_t \ge 0.25\) **or** \(p_{t-1} \ge 0.50\): play **D** (one-round “pressure”).
- Else: play **C** (forgiveness / benefit of doubt).

Reason:  
- If many are repeatedly defecting, unconditional cooperation becomes a subsidy to them; a coordinated “pressure” response is needed even without communication.  
- If defection isn’t clearly persistent, forgiveness maintains collective stability and avoids unnecessary collapse spirals.

4) **De-escalation rule (forgiveness):**  
After you play D due to retaliation, return to C as soon as **either**:
- stock recovers to \(S_t \ge S_{\text{high}}\), **or**
- last-round defection rate drops to \(p_{t-1} \le 0.25\).

Reason: The objective is to restore cooperation quickly, not punish indefinitely.

---

# 2) Edge cases

### Round 1 (no history)
- If \(t=1\): play **C**.

Reason: Starts in the collective mode; with stock at capacity this is efficient and sets a cooperative baseline. Also avoids immediately pushing the system toward collapse.

### Last round (endgame pressure)
Finite horizon creates a strong temptation to defect at the end. We handle this without fully giving up collective principles:

- If \(t=r\) (final round):
  - If \(S_t \le S_{\text{low}}\): play **C** (prevent total collapse; collective even in endgame).
  - Else: play **D**.

Reason: If the resource is not in danger, the future has no value, so taking the larger share is individually rational; but if the stock is already fragile, defecting is socially destructive and often yields little additional benefit if others also defect.

### Second-to-last round
- If \(t=r-1\):
  - If \(S_t \ge S_{\text{high}}\) and \(p_{t-1} \le 0.25\): play **C** (try to keep cooperation through the end)
  - Else follow core rule.

Reason: Gives one last chance to sustain cooperation if it’s already stable, while still protecting against clear endgame defections.

### Stock extremely low (near collapse)
- If \(S_t < 0.10 \cdot capacity\): always play **C** (even in last round).

Reason: At very low stock, everyone’s payoff is tiny; mutual restraint can sometimes allow some regrowth, while defection almost guarantees zeroing out.

---

# 3) “Collective mindset” explanation

This strategy treats the stock as a shared productive asset. It:
- **prioritizes regeneration** when the stock is low (always cooperative in danger zones),
- **maintains a high-stock cooperative regime** when others are mostly cooperating,
- **applies limited, conditional pressure** (temporary D) only when evidence suggests persistent exploitation,
- **forgives quickly** to re-establish cooperation.

It is robust because it does not require shared norms, signaling, or pre-agreed schedules: it reacts only to observable stock and defection patterns.

---

# Pseudocode (implementation-ready logic)

```python
def SGFT_action(t, r, n, capacity, S_t, history_actions):
    # thresholds
    S_low  = 0.35 * capacity
    S_high = 0.70 * capacity
    S_very_low = 0.10 * capacity

    if t == 1:
        return "C"

    # compute last-round defection rate
    last_actions = history_actions[t-1]  # list of length n with "C"/"D"
    D_last = sum(1 for a in last_actions if a == "D")
    p_last = D_last / n

    # compute persistent defection signal
    streaks = []
    for j in range(n):
        streak = 0
        k = t-1
        while k >= 1 and history_actions[k][j] == "D":
            streak += 1
            k -= 1
        streaks.append(streak)
    P_t = sum(1 for s in streaks if s >= 2) / n

    # extreme collapse prevention
    if S_t < S_very_low:
        return "C"

    # last round logic
    if t == r:
        if S_t <= S_low:
            return "C"
        else:
            return "D"

    # second-to-last round (soft extension of cooperation if stable)
    if t == r-1:
        if S_t >= S_high and p_last <= 0.25:
            return "C"
        # else fall through to core rule

    # core rule
    if S_t <= S_low:
        return "C"

    if S_t >= S_high and p_last <= 0.25 and P_t <= 0.20:
        return "C"

    # measured retaliation
    if P_t >= 0.25 or p_last >= 0.50:
        return "D"

    return "C"
```

---

If you want, I can also provide (a) a more “resource-optimal” version that explicitly estimates next-round stock from expected consumption, or (b) a harsher “anti-exploitation” variant for tournaments dominated by defect-heavy strategies.
'''

description_COLLECTIVE_14 = '''
## Strategy: **Sustain–Test–Reciprocate (STR)**  
Goal: keep the stock near the regenerative “sweet spot” while being hard to exploit. The logistic growth term is maximized when post-consumption stock is about **capacity/2**; if stock hits **0**, the game collapses. STR therefore (i) tries to hold the resource in a high-growth band, (ii) tests whether others are willing to sustain it, and (iii) punishes over-consumption quickly but forgives once behavior improves.

### Core ideas
- **Sustainability target:** after consumption, aim for remaining stock ≈ `capacity/2`. That maximizes growth and makes long-run payoffs high.
- **Collective-first but not naïve:** start cooperative, but switch to defection when evidence suggests others are draining the pool.
- **State-dependent “emergency mode”:** when stock is low, cooperation is mandatory regardless of others—because defection accelerates collapse and harms everyone, including you.
- **Reciprocity measured from history:** infer how many players defected last round (since actions are observed). Use that to decide punishment/forgiveness.

---

## 1) Decision rules (when to cooperate vs defect)

### Notation
At round `t` (1-indexed), before acting:
- `S_t`: current stock (observed).
- `D_{t-1}`: number of opponents who defected last round (observed; for `t=1`, undefined).
- `f_{t-1} = D_{t-1} / (n-1)`: defection rate among opponents last round.
- Define thresholds (depend only on parameters):
  - **Critical stock:** `S_crit = 0.25 * capacity`
  - **Low stock:** `S_low  = 0.40 * capacity`
  - **High stock:** `S_high = 0.70 * capacity`
  - **Tolerance:** `tau = 1/(n-1)` (≈ “at most one defector among opponents”)

These constants are deliberately simple and robust; they don’t require predicting others’ exact future actions.

### Rule A — Stock safety first (state-based)
1. **If `S_t <= S_crit`: play `C` (always).**  
   Rationale: when stock is very low, defection is collectively disastrous and often self-defeating over remaining rounds.

2. **Else if `S_crit < S_t <= S_low`: play `C` unless opponents were overwhelmingly cooperative.**  
   Concretely: if `f_{t-1} == 0` (no one defected last round), play `C`; otherwise still play `C`.  
   (In this zone, STR simply commits to rebuilding the stock; punishment is deferred because conserving the pool dominates.)

### Rule B — Reciprocity in the sustainable zone
When `S_t` is healthy (`S_t > S_low`), use reciprocal discipline:

3. **If `S_low < S_t < S_high` (sweet-spot zone):**
   - **Play `C` if `f_{t-1} <= tau`**, i.e., at most ~one opponent defected.
   - **Play `D` if `f_{t-1} > tau`**, i.e., multiple opponents defected.

4. **If `S_t >= S_high` (plentiful stock):**
   - **Play `C` if `f_{t-1} <= 2*tau`** (be slightly more tolerant when stock is abundant),
   - otherwise **play `D`**.

Interpretation:  
- In good conditions, you cooperate when most others do, and you defect when defection becomes common.  
- Tolerance scales with group size via `tau`.

### Rule C — Forgiveness and re-entry
To avoid permanent collapse into mutual defection:
5. **After any round you played `D`, immediately return to `C` next round if opponents’ defection rate falls to `<= tau` and `S_t > S_low`.**  
This makes punishment sharp but short: “one round of punishment, then test for recovery.”

---

## 2) Handle edge cases

### First round (`t = 1`)
- **Play `C`.**  
Reason: the stock starts at `capacity`, where the collective optimum is to keep the pool productive. Starting with `D` unnecessarily signals aggression and can trigger collapse in many matchups.

### Second round (`t = 2`) and early rounds
- Use the normal rules with `D_{t-1}` observed from round 1.
- Early detection matters: if multiple players defect in round 1, STR switches to `D` (unless stock already dipped into low/critical zones, where it stays `C` to prevent collapse).

### Last round (`t = r`)
There is a classic endgame temptation to defect. STR handles this with a **conditional last-round discipline**:
- If stock is **not** abundant (`S_t < S_high`): **play `C`** (protect remaining value; also many opponents will be doing the same if they’re state-aware).
- If stock is abundant (`S_t >= S_high`):
  - **play `C` if opponents were cooperative** (`f_{t-1} <= tau`),
  - **otherwise play `D`**.
This avoids being the only cooperator in an endgame grab, but still supports cooperative endings when feasible.

### What if everyone defects and stock hits 0?
- Stock stays 0 forever (growth is 0). In that absorbing state, actions don’t matter for payoffs (all get 0). STR can default to `C` (collective stance) but it’s inconsequential.

### What if observation shows “noise” or one inconsistent player?
- The `tau` tolerance (≈ one defector) prevents overreacting to a single rogue in large groups, while still reacting when defection becomes systemic.

---

## 3) Collective mindset (why this is “collective”)
- **Primary objective is resource sustainability:** the strategy explicitly prioritizes rebuilding when stock is low, even if short-run incentives favor defection.
- **Punishment is instrumental, not spiteful:** it is used only when the pool is healthy enough to absorb it, and it is designed to be brief and reversible.
- **Maximizes long-run total yield:** by keeping stock near a high-growth region and avoiding the catastrophic 0-stock trap, STR aims to raise total group payoffs across rounds—while protecting itself from persistent free-riders.

---

## Pseudocode (implementable)

```python
def STR_action(t, r, n, capacity, S_t, history_actions):
    # history_actions[t-1] gives list of actions in previous round for all players (incl. self)
    S_crit = 0.25 * capacity
    S_low  = 0.40 * capacity
    S_high = 0.70 * capacity
    tau = 1.0 / (n - 1)  # tolerance ~ one defector among opponents

    if t == 1:
        return "C"

    # compute opponent defection rate last round
    last = history_actions[t-1]
    opp_actions = [a for j,a in enumerate(last) if j != self_index]
    D_opp = sum(1 for a in opp_actions if a == "D")
    f = D_opp / (n - 1)

    # safety-first zones
    if S_t <= S_crit:
        return "C"
    if S_t <= S_low:
        return "C"

    # last-round conditional discipline
    if t == r:
        if S_t < S_high:
            return "C"
        else:
            return "C" if f <= tau else "D"

    # normal play
    if S_t < S_high:
        return "C" if f <= tau else "D"
    else:
        return "C" if f <= 2*tau else "D"
```

This STR policy is adaptive (responds to both stock and opponents), robust (doesn’t require coordination), and explicitly collective (protects the regenerative capacity of the pool while using limited reciprocity to deter exploitation).
'''

description_COLLECTIVE_15 = '''
## Strategy: **Stock-Guarded, Forgiving Trigger (SGFT)**  
Collective goal: keep the resource near **capacity** (where growth replenishes), take **C** by default, and only switch to **D** when necessary to (i) deter persistent overuse, and/or (ii) avoid being the “sucker” against defect-heavy opponents. The strategy is *state-aware* (stock), *history-aware* (how others behaved), and *recovery-aware* (returns to cooperation once the pool is safe again).

---

# 1) Decision rules (when to cooperate vs defect)

### Key intuition
- When the stock is healthy, mutual **C** is sustainable and keeps stock near capacity (often exactly at capacity in your example).
- **D** gives higher immediate payoff but risks collapse; if others overuse, we must sometimes **D** to avoid being exploited and to apply pressure.
- Because actions are simultaneous, we need rules that react to *observed* past behavior and the *current* stock.

### Quantities computed each round (from history and current state)
Let at round `t` the current stock be `S_t`.

From last round’s observed actions:
- `d_{t-1}` = number of opponents who played **D** in round `t-1` (0 to n-1)
- `D_rate_k` = fraction of **D** actions among opponents over last `k` rounds (use `k = min(5, t-1)`)

Define stock regions (depend only on parameters):
- `S_high = 0.85 * capacity`  (safe/abundant)
- `S_mid  = 0.50 * capacity`  (watch zone)
- `S_low  = 0.25 * capacity`  (danger zone)
These thresholds are intentionally coarse and robust.

Define **overuse severity** from last round:
- `sev = d_{t-1} / (n-1)` in `[0,1]`

---

## Core action rule
You choose **C** by default, but switch to **D** under two kinds of triggers:

### A) **Resource-protection trigger (stock-based)**
- If `S_t <= S_low`: play **C** (yes, cooperate)  
  Rationale: when stock is near collapse, defecting accelerates ruin. Even if others defect, the only path to any future payoff is recovery. This is the “collective emergency brake.”

- If `S_low < S_t <= S_mid`: play **C** unless opponents are heavily defecting (rule B below triggers).  
  Rationale: we still prioritize sustainability but must avoid being permanently exploited.

- If `S_t > S_mid`: normal deterrence logic (rule B).

### B) **Deterrence / anti-exploitation trigger (history-based)**
When stock is not in collapse (`S_t > S_low`), punish sustained defection:

Play **D** if any of the following are true:
1) **Majority-defection last round:** `d_{t-1} >= ceil((n-1)/2)`  
   (Opponents mostly defected → you defect to avoid being the lone cooperator and to signal intolerance.)

2) **Sustained defection recently:** `D_rate_k >= 0.40` and `t > 2`  
   (If ~40%+ of observed opponent actions are D in recent window, that’s a defect-heavy environment.)

3) **“Exploit me twice” rule:** if in the last 2 rounds you played **C** and at least one opponent played **D** in both rounds, then play **D** this round (unless `S_t <= S_low`).  
   (Prevents repeated unilateral exploitation while still allowing one-off mistakes/noise.)

Otherwise play **C**.

---

## C) **Return-to-cooperation (forgiveness)**
If you are currently in a punishment phase (you played D recently), you return to **C** once **both** conditions hold:
- `S_t >= S_mid` (resource not fragile), **and**
- in the last round `d_{t-1} <= 1` (almost everyone cooperated)

This forgiveness rule makes the strategy robust to:
- accidental defections,
- strategies that test once,
- populations that can be nudged back to cooperation.

---

# 2) Edge cases (first round, last round, and other special situations)

### First round (t = 1)
Play **C**.
- Stock starts at `capacity`, where cooperation is maximally sustainable.
- Starting cooperative encourages reciprocal types and preserves long-run value.

### Second round (t = 2)
Use only `d_1` (since no longer history). Apply the same rules with `k = 1`.

### Last round (t = r)
Normally finite-horizon logic pushes toward defection, but tournaments often reward long-run performance across many opponents; additionally, last-round defection can be dominated by the fact that it may have already reduced stock and payoffs in earlier rounds due to earlier triggers.

So:
- If `S_r <= S_mid`: play **C** (don’t crash the pool when it’s already low).
- Else if opponents were mostly cooperative in round `r-1` (`d_{r-1} <= 1`): play **C** (maintain collective norm).
- Else: play **D** (no reason to be exploited at the end).

This keeps the strategy “collective-first” while not being naive in obviously defect-heavy endgames.

### If stock ever hits 0
Always play **C** thereafter (there is nothing to gain by defecting, and cooperation is the only remotely recovery-compatible stance; though recovery from 0 is impossible under your growth rule, this at least avoids pointless punishment logic).

---

# 3) Why this is collectively aligned (and tournament-robust)

### Collective alignment
- Default behavior is **C**, which preserves the pool and maximizes sustainable total payoff.
- When the stock is low, the strategy *doubles down on cooperation* rather than racing to the bottom.
- Punishment is conditional and temporary—meant to restore cooperation, not to win a vendetta.

### Robustness to varied opponents
- Against always-cooperate: stays at **C**, keeps stock near capacity → high payoffs each round.
- Against always-defect: quickly shifts to **D** when stock isn’t in collapse, avoiding being the sucker; when stock becomes critically low, switches to **C** to avoid accelerating collapse (though collapse may be unavoidable).
- Against “mostly cooperate but occasionally defect”: forgiveness restores cooperation quickly.
- Against strategic testers: “exploit me twice” prevents repeated one-sided losses while allowing single tests without permanent breakdown.

---

# Pseudocode (implementation-ready)

```pseudo
parameters:
  S_high = 0.85 * capacity
  S_mid  = 0.50 * capacity
  S_low  = 0.25 * capacity

state each round t:
  S = current stock S_t
  if t == 1: return C

  d_last = number_of_opponents_who_played_D_in_round(t-1)
  k = min(5, t-1)
  D_rate = (total opponent D actions in rounds t-k..t-1) / ((n-1)*k)

  exploit_twice =
      (t >= 3) AND
      (my_action[t-1] == C AND my_action[t-2] == C) AND
      (exists opponent j s.t. opp_j[t-1]==D AND opp_j[t-2]==D)

  majority_defect_last = (d_last >= ceil((n-1)/2))
  sustained_defection  = (t > 2) AND (D_rate >= 0.40)

  # emergency stock protection
  if S <= S_low:
      return C

  # last round handling
  if t == r:
      if S <= S_mid: return C
      if d_last <= 1: return C
      return D

  # deterrence trigger
  if majority_defect_last OR sustained_defection OR exploit_twice:
      return D

  # forgiveness / default
  return C
```

If you want it even more “collective,” you can tighten forgiveness (return to C sooner) or raise the punishment thresholds; if you want it tougher in hostile fields, lower `0.40` to `0.30` and require fewer defections to trigger punishment.
'''

description_COLLECTIVE_16 = '''
## Collective Strategy: **Stock-Sustaining Reciprocal Control (SSRC)**  
Goal: maximize *group* total payoff by keeping the stock near the regenerative sweet spot (high stock, high growth) while remaining robust to exploitation by defectors.

The key facts your rules exploit:

- If everyone cooperates when stock is high, the stock can fully regenerate (often back to `capacity`), enabling large long-run payoffs.
- Defection gives a short-run advantage but can collapse the stock, reducing everyone’s future payoffs (including the defector’s).
- Because actions are only `{C,D}`, the main lever is *how often* we switch to D in response to observed overconsumption, and *when* we return to C once opponents do.

This strategy:
1) defaults to cooperation to sustain the resource,  
2) punishes overconsumption quickly and proportionally,  
3) forgives quickly when opponents return to restraint,  
4) adds an endgame rule to avoid being naïvely exploited in the final rounds.

---

# 1) Decision rules (C vs D)

### Definitions (computed each round from history/state)
Let:
- `t` be the round number (1..r)
- `S` be current stock at start of round `t`
- `k_{t-1}` = number of opponents who defected in round `t-1` (for `t=1`, define `k_0 = 0`)
- `f_{t-1} = k_{t-1} / (n-1)` = opponent defection rate last round
- `S_safe = capacity/2` (the stock level where logistic growth is maximized)
- `S_crit = capacity/4` (below this, recovery is slower and collapse risk is high)
- `S_full = 0.9 * capacity` (near full; easiest to sustain)
- `end_window = 2` (last 2 rounds treated as endgame)

### Core intuition
- If stock is healthy and opponents are mostly cooperating → **C**.
- If opponents defect significantly → **D** as a deterrent (but not forever).
- If stock is low → prioritize **C** to rebuild (unless punishment is necessary to stop collapse).
- Near the end → become more defensive to prevent last-round exploitation.

---

## SSRC Rules

### Rule A — First round (seed cooperation)
- **Round 1: play C** always.  
Rationale: establishes the cooperative baseline; with no comms, the only credible “collective” opening is to cooperate.

---

### Rule B — Stock-based “sustainability mode”
When stock is at risk, your action should be guided more by the stock than by punishment.

1) **If `S <= S_crit` (very low stock):**
- **Play C**, *unless* opponents are heavily defecting **and** you are in the endgame (see Rule D).  
Rationale: D here accelerates collapse; collective recovery requires restraint.

2) **If `S_crit < S < S_safe` (recovering zone):**
- **Play C** if opponents are not mostly defecting (`f_{t-1} < 0.5`).
- **Play D** if opponents are mostly defecting (`f_{t-1} >= 0.5`).  
Rationale: you cooperate to rebuild unless you must deter a majority-defect regime.

3) **If `S >= S_safe` (healthy zone):**
- Use reciprocity rules (Rule C) primarily; stock can tolerate brief punishment.

---

### Rule C — Reciprocity with proportional punishment + quick forgiveness
This is the robustness core. It is “collective” because it tries to stabilize cooperation but refuses to be a sucker.

Compute `f_{t-1}`. Then:

- If **no opponent defected last round** (`k_{t-1}=0`): **Play C**.
- If **some defected**:
  - If `f_{t-1} < 1/3`: **Play C** (tolerate small noise / one-off defection).
  - If `1/3 <= f_{t-1} < 2/3`: **Play D** for **1 round**, then re-evaluate next round.
  - If `f_{t-1} >= 2/3`: **Play D** until `f_{t-1}` drops below `1/3` for **two consecutive rounds**, then return to C.

**Why these thresholds?**  
- Below 1/3: could be experimentation or error; keep the cooperative path open.
- Between 1/3 and 2/3: meaningful exploitation; one-round punishment signals intolerance but allows quick return.
- Above 2/3: the table is mostly defecting; cooperating would be consistently exploited and may not change others’ incentives—sustain punishment until behavior shifts.

**Forgiveness rule (important):**  
As soon as defections subside (`f_{t-1} < 1/3`) and stock is not critically low, you revert to cooperation quickly (after at most a short confirmation).

---

### Rule D — Endgame protection (last rounds)
Repeated games with a known end (`r` finite) invite late defection. You can’t fully solve that, but you can avoid being the only cooperator at the end.

Let `remaining = r - t + 1`.

- If `remaining <= end_window` (last 2 rounds):
  - If **any opponent defected in the previous round** (`k_{t-1} > 0`): **Play D**.
  - Else (no one defected last round): **Play C**.

This is a “conditional endgame”: it keeps collective cooperation alive if it’s still intact, but it stops you from being exploited by a last-minute defector.

---

# 2) Edge cases

### First round
- Always **C** (Rule A).

### Last round (`t=r`)
- If last round `t=r-1` had any defections: **D**.
- Otherwise **C**.
This avoids being the naive cooperator against last-move defectors, without forcing universal endgame collapse when cooperation persists.

### Stock near zero
- If `S` is extremely small (close to 0), C and D both yield tiny immediate payoff, but D accelerates collapse; therefore default **C** (Rule B). The only exception is endgame retaliation when exploitation is ongoing and there’s no future to protect.

### Capacity constraint / parameter extremes
- Uses `capacity` only to set relative thresholds (`capacity/2`, `capacity/4`, `0.9*capacity`), so it scales.
- Works for any `n≥2` because it relies on *fractions* of defectors, not absolute counts.

### “Always defect” opponents
- SSRC shifts into punishment mode (frequent D) once defections exceed thresholds, limiting the sucker outcome.
- If stock becomes low, SSRC still tends to C to preserve any chance of recovery; but with pervasive defection and near-end rounds, it switches to D.

### “Noisy” or intermittent opponents
- The `<1/3` tolerance prevents unnecessary punishment spirals.
- The “one-round punishment” in the medium band creates a clear signal but doesn’t lock into long grudges.

---

# 3) Collective mindset (what makes it “collective”)
- **Default stance is to sustain the resource** (cooperation-first, stock-protection rules).
- **Punishment is not for revenge**; it’s a tool to move the group back to sustainable extraction by making exploitation less profitable.
- **Forgiveness is fast** so the group can re-coordinate on cooperation whenever possible.
- **Stock thresholds prioritize long-run group yield** (keeping the system around high-regeneration regions rather than chasing short-term private gain).

---

## Pseudocode (implementable sketch)

```python
def SSRC_action(t, r, n, capacity, S, prev_actions):  
    # prev_actions: list of length n with actions from round t-1, or None if t==1
    S_safe = 0.5 * capacity
    S_crit = 0.25 * capacity
    end_window = 2

    if t == 1:
        return "C"

    # count opponent defections last round
    k = count_opponent_defects(prev_actions)  # excludes self
    f = k / (n - 1)

    remaining = r - t + 1
    if remaining <= end_window:
        return "D" if k > 0 else "C"

    # Stock protection mode
    if S <= S_crit:
        return "C"

    if S < S_safe:
        return "D" if f >= 0.5 else "C"

    # Healthy stock: reciprocity bands
    if k == 0:
        return "C"
    if f < (1/3):
        return "C"
    if f < (2/3):
        return "D"   # one-round punishment; next round will re-evaluate naturally
    else:
        # in practice: keep returning "D" while f remains high;
        # forgiveness handled by re-evaluation each round plus a 2-round confirmation rule
        return "D"
```

(If you want the strict “2 consecutive low-defection rounds” confirmation for exiting heavy-punishment mode, store a small state variable like `low_defect_streak` based on history.)

---

If you tell me whether the tournament includes implementation limits (e.g., memoryless strategies only, or limited history length), I can compress SSRC into a strictly finite-state version with the same behavior.
'''

description_COLLECTIVE_17 = '''
## Collective strategy: **Sustain–Recover–Discipline (SRD)**  
Goal: keep the stock near the sustainable high-payoff region (close to `capacity`) by default, but respond quickly to over-extraction in a way that (i) protects the resource, (ii) makes defection less attractive going forward, and (iii) reopens cooperation once behavior improves.

### Key idea
- If everyone plays **C**, stock stays at/returns to `capacity` (by your growth rule) and the group can earn high payoffs forever.
- If too many play **D**, stock drops and future payoffs collapse.
- So we:
  1) **Cooperate when the resource is healthy and others are not over-consuming.**  
  2) **Switch to defection as a deterrent** when we detect over-consumption (discipline phase).  
  3) **If the stock becomes low, cooperate to rebuild** (recovery phase), even if others misbehave—because punishment by defection when stock is low can destroy the resource completely.  
  4) **Forgive** after a short, clear, history-based penalty.

This is a “collective-first” strategy: it prioritizes sustaining the common stock, not maximizing one-round advantage.

---

## Quantities computed from history (public information)
Let:
- `S_t` = stock at start of round `t`.
- `d_{t-1}` = number of defectors observed in round `t-1` (from actions).
- `Dshare_{t-1} = d_{t-1} / n`.

Also define stock health thresholds (depend only on parameters):
- `S_high = 0.90 * capacity`  (healthy)
- `S_mid  = 0.60 * capacity`  (watch zone)
- `S_low  = 0.35 * capacity`  (danger / recovery priority)

(These are deliberately simple and robust; they don’t assume anything about others’ “types”.)

---

## 1) Decision rules: when to cooperate vs defect

### Mode-based behavior
Maintain an internal mode `mode ∈ {COOP, DISCIPLINE(k), RECOVER}`.

#### A. Cooperation mode (default)
Play **C** if:
- Stock is healthy or moderate: `S_t ≥ S_mid`, **and**
- Recent defection is not too high: `Dshare_{t-1} ≤ 0.25` (i.e., at most ~1 in 4 defected last round), **and**
- We are not currently in a penalty phase.

Intuition: tolerate a small amount of noise/exploration but don’t let defection become contagious.

#### B. Discipline (punishment) trigger
Enter `DISCIPLINE(k)` if stock is not low (`S_t > S_low`) and any of the following are true:
- **Majority defection:** `Dshare_{t-1} ≥ 0.50`, or
- **Persistent defection:** `Dshare_{t-1} > 0.25` for 2 consecutive rounds, or
- **Sudden resource drop while healthy:** `S_{t} < 0.85 * S_{t-1}` and `S_{t-1} ≥ S_mid` (a strong sign of over-consumption)

When in `DISCIPLINE(k)`, play **D** for `k` rounds (fixed), unless stock becomes low (then switch to RECOVER).

Set penalty length as:
- `k = 2 + ceil(r / 10)` (short but noticeable; scales mildly with horizon)

Intuition: a credible, finite punishment that makes sustained defection less profitable, without guaranteeing total collapse.

#### C. Recovery mode (resource-first)
If stock is low: `S_t ≤ S_low`, enter `RECOVER` and play **C**.

Stay in RECOVER until stock is safely back:
- Exit when `S_t ≥ S_mid` **and** `Dshare_{t-1} ≤ 0.25`.  
Then go to `COOP`.

Intuition: when the pool is near collapse, defection punishment is counterproductive. Rebuilding stock is the collective priority.

---

## 2) Edge cases (first round, last rounds, ties)

### First round
- Play **C**.
Reason: the initial stock is `capacity`, and mutual cooperation is the socially optimal steady state; also gives others a chance to coordinate on sustainability without prior info.

### Last round (and endgame handling)
There is an endgame temptation to defect, but fully yielding to it destroys the “collective” objective and also invites mutual defection earlier in many adaptive opponents. Use a tempered rule:

- In the **final round** (`t = r`):
  - Play **C** if `S_t ≤ S_mid` (protect stock; also defection yields less when stock is already reduced).
  - Otherwise (stock high), play **D** **only if** the previous round had significant defection: `Dshare_{r-1} > 0.25`.  
  - Else play **C**.

This keeps the strategy collectively oriented while not being trivially exploitable by last-round defectors.

### If history is unavailable / corrupted
- Default to `COOP` when `S_t ≥ S_mid`, else `RECOVER` (play C) when `S_t < S_mid`.

### If stock is exactly at boundaries
- Treat `S_t = S_low` as RECOVER.
- Treat `S_t = S_mid` as eligible for COOP if defection is low.

---

## 3) “Collective mindset” alignment (what this strategy optimizes)
- **Primary objective:** maintain the common stock in the high-growth/high-payoff region so that the group’s *total* payoff across `r` rounds is high.
- **Secondary objective:** discourage exploitation enough that cooperative outcomes are stable in heterogeneous tournaments.
- **Tertiary objective:** avoid irreversible collapse. That’s why RECOVER overrides punishment.

This is not “always cooperate”; it is “cooperate when sustainable, punish to stop a defection cascade, rebuild when endangered, then forgive.”

---

## Pseudocode (implementable)
```python
# Parameters
S_high = 0.90 * capacity
S_mid  = 0.60 * capacity
S_low  = 0.35 * capacity
k_pen  = 2 + ceil(r / 10)

mode = "COOP"
pen_remaining = 0
defect_streak = 0  # counts consecutive rounds with Dshare > 0.25

for t in 1..r:
    observe S_t
    if t == 1:
        play C
        continue

    # compute last round stats from observed history
    Dshare = d_{t-1} / n

    # update defect streak
    if Dshare > 0.25: defect_streak += 1
    else: defect_streak = 0

    # endgame rule (final round)
    if t == r:
        if S_t <= S_mid:
            play C
        else:
            if Dshare > 0.25: play D
            else: play C
        continue

    # Recovery overrides everything if stock low
    if S_t <= S_low:
        mode = "RECOVER"
        play C
        continue

    # If currently punishing
    if mode == "DISCIPLINE" and pen_remaining > 0:
        pen_remaining -= 1
        play D
        if pen_remaining == 0:
            mode = "COOP"
        continue

    # Decide whether to trigger discipline
    major_defection = (Dshare >= 0.50)
    persistent_defection = (defect_streak >= 2)

    sudden_drop = (S_{t-1} >= S_mid) and (S_t < 0.85 * S_{t-1})

    if (major_defection or persistent_defection or sudden_drop):
        mode = "DISCIPLINE"
        pen_remaining = k_pen
        play D
        pen_remaining -= 1
        if pen_remaining == 0: mode = "COOP"
        continue

    # Otherwise cooperate if not in danger
    if S_t >= S_mid and Dshare <= 0.25:
        mode = "COOP"
        play C
    else:
        # cautious: if stock is only moderate or defection somewhat elevated, prefer C to avoid collapse
        play C
```

---

### Why this is robust in tournaments
- Against cooperators: quickly converges to stable **C** with high stock and high cumulative payoff.
- Against unconditional defectors: triggers discipline (reducing their gains relative to naive cooperators) but switches to recovery when the resource is endangered, preventing total meltdown where possible.
- Against “grim trigger” / tit-for-tat-like strategies: punishment is finite and forgiving, which helps reestablish cooperation after disruptions.
- Against noisy or exploratory agents: tolerates limited defection (`≤ 25%`) without spiraling into mutual punishment.

If you want, I can tune the numeric thresholds (`S_low, S_mid`, tolerance 0.25, penalty length) for specific expected `n`, `r`, and `capacity` ranges, or derive them from the stock update equation more tightly.
'''

description_COLLECTIVE_18 = '''
## Collective Adaptive Stock-Guard (CASG)

Goal: **maximize long-run total group harvest** by keeping the stock near the sustainable “high-growth” region, while being **robust to exploitation** (players who defect too often) and **able to recover** cooperation quickly when others do.

This is a *collective* strategy: it cooperates by default, protects the stock when it’s endangered, and punishes over-consumption in a way that is proportional and reversible.

---

## Key idea

- Let **S** be current stock at start of a round.
- Let **k** be the number of defectors in the previous round (observed).
- If too many players defect, stock collapses quickly (especially when S is high).
- If most cooperate, the stock tends to return toward capacity (often fully).

So we:
1) **Cooperate when the group is behaving and stock is healthy**, to keep the system productive.
2) **Defect defensively** when others are defecting (to avoid being the “sucker”) or when the stock is low enough that strict conservation is needed to rebuild credibility and deter further exploitation.
3) Use **forgiveness**: return to cooperation after a short “probation” if others do.

---

## Strategy state variables (internal)

Maintain:
- `k_prev`: # defectors last round (initialize 0)
- `streak_bad`: consecutive rounds where defection was “high” (initialize 0)

Define thresholds (depend only on parameters):
- **Majority threshold**: `K_major = ceil(n/2)`
- **High defection threshold**: `K_high = ceil(2n/3)`
- **Stock safety threshold**: `S_safe = 0.6 * capacity`
- **Stock danger threshold**: `S_danger = 0.3 * capacity`
- **Probation length**: `P = 2` rounds (can be `max(2, floor(r/10))` but cap at e.g. 3)

These are chosen to be simple, tournament-robust defaults:
- Above ~60% capacity, the system is resilient; below ~30%, it’s fragile.

---

## 1) Decision rules (C vs D)

### Rule A — First round (seed cooperation)
- **Round 1: play C.**
Rationale: creates a baseline; many strategies reciprocate.

---

### Rule B — Stock emergency (protect against collapse / exploiters)
At any round `t` (including early rounds), if:
- `S <= S_danger`  
then **play D**.

Rationale: when stock is low, each unit matters and other agents often switch to defection; you avoid being exploited and signal seriousness. (Note: D consumes more in absolute terms, but when S is small the absolute difference is small; strategically it prevents you from being the only cooperator paying an opportunity cost while others defect.)

---

### Rule C — Reciprocity to observed behavior (main driver)
Let `k_prev` be number of defectors in round `t-1`.

1) If `k_prev == 0` and `S >= S_safe`: **play C**.  
   (Full cooperation and healthy stock → stay cooperative.)

2) If `1 <= k_prev < K_major`: **play C**.  
   (A small minority defected → be forgiving; don’t trigger collapse.)

3) If `K_major <= k_prev < K_high`: **play D for 1 round**, then enter probation (below).  
   (Group is drifting toward over-consumption → short, sharp deterrence.)

4) If `k_prev >= K_high`: **play D** and increment `streak_bad`.  
   (Strong evidence of exploitative environment → defend yourself.)

---

### Rule D — Probation / forgiveness mechanism
If you defected last round due to Rule C(3) or C(4), you test whether the group comes back.

- If in the last round, `k_prev` decreased to `< K_major` **and** `S >= S_danger`: **switch back to C** immediately.
- Else: continue **D** up to `P` rounds total, but **return to C** as soon as `k_prev < K_major` for one round.

This makes punishment:
- **Proportional** (only long if others keep defecting),
- **Forgiving** (restores cooperation quickly),
- **Robust** (doesn’t get stuck in permanent D against noisy opponents).

---

### Rule E — Endgame (last round)
In the **final round t = r**:
- If `k_prev == 0`: **play C**
- Else: **play D**

Rationale: no future retaliation exists, but if the group has been fully cooperative, maintaining C avoids unnecessary last-round collapse and also matches “nice” equilibria some strategies encode; if anyone defected recently, take the safe best response.

---

## 2) Edge cases & clarifications

### If stock is at/near capacity
- You still follow the reciprocity rules. Capacity isn’t a license to defect; it’s where defection is most damaging because consumption is largest.

### If stock is extremely low (near 0)
- The emergency rule triggers D, but note that when S≈0 both actions pay ~0 anyway. The point is behavioral: you don’t donate value to defectors once recovery begins.

### If opponents alternate or use stochastic defection
- The majority-based trigger prevents overreacting to 1 “noisy” defector.
- The probation rule prevents endless vendettas and adapts to changing environments.

### If facing always-defect strategies
- After round 1, you rapidly switch to D and stay mostly D, minimizing exploitation.
- You still occasionally return to C if the environment genuinely shifts.

### If facing cooperative-but-trigger-happy strategies
- Your forgiveness helps restore cooperation after accidental defection cascades.
- Majority threshold avoids triggering their punishments if only one player defects.

---

## 3) Collective mindset: why this aligns with group welfare

- The strategy is **cooperative by default** and only escalates when there’s evidence that collective action is failing.
- It uses **minimal necessary punishment** (mostly 1–2 rounds) to steer the group back to the cooperative basin.
- It prioritizes maintaining stock in the **high-growth region** by preventing widespread defection when stock is healthy and valuable.
- It is **adaptive**: it conditions on both *state* (S) and *history* (k_prev trends), making it robust across many opponent types.

---

## Pseudocode (implementable)

```python
# parameters: n, r, capacity
K_major = ceil(n/2)
K_high  = ceil(2*n/3)
S_safe  = 0.6 * capacity
S_danger = 0.3 * capacity
P = 2  # probation cap

# internal state
streak_bad = 0
punish_left = 0  # remaining punishment rounds (0 means none)

def action(t, S, history):  
    # history provides k_prev = number of Ds in round t-1 (0 if t==1)
    if t == 1:
        return "C"

    k_prev = history.num_defectors_last_round()

    # Final round rule
    if t == r:
        return "C" if k_prev == 0 else "D"

    # Stock emergency
    if S <= S_danger:
        return "D"

    # If currently in punishment/probation mode
    if punish_left > 0:
        if k_prev < K_major:
            punish_left = 0
            return "C"
        else:
            punish_left -= 1
            return "D"

    # Main reciprocity rules
    if k_prev == 0 and S >= S_safe:
        streak_bad = 0
        return "C"

    if 1 <= k_prev < K_major:
        streak_bad = 0
        return "C"

    if K_major <= k_prev < K_high:
        punish_left = P - 1  # defect now + up to remaining
        return "D"

    # k_prev >= K_high
    streak_bad += 1
    punish_left = P - 1
    return "D"
```

This “CASG” policy is easy to compute, uses only allowed information, and tends to (a) achieve high payoffs in cooperative fields, (b) avoid being farmed by defectors, and (c) recover cooperation quickly after turbulence.
'''

description_COLLECTIVE_19 = '''
## Collective strategy: **Stock-Sustaining, Retaliatory, Forgiving (SSRF)**

Goal: maximize long-run total extraction by keeping the resource near a “high-growth” region and discouraging free-riding. The strategy is (i) **stock-aware** (protects the pool when it’s fragile), (ii) **history-aware** (retaliates against exploitation), and (iii) **forgiving** (returns to cooperation once behavior improves).

Key idea: with logistic growth, the stock replenishes fastest around **capacity/2**. Your actions should (a) avoid crashing the stock, (b) punish defection enough to remove its advantage, but (c) not spiral into permanent depletion.

---

# 1) Decision rules: when to cooperate vs defect

### Quantities you track each round \(t\)
- Current stock: \(S_t\)
- Last round defections count:  
  \(d_{t-1} = \#\{j \neq i : a_{j,t-1} = D\}\)
- A short “defection rate” over a window \(W\) (e.g., 3 rounds):  
  \(\bar d = \text{average of } d\text{ over last }W\text{ rounds}\)
- A “punishment counter” \(P \ge 0\) (how many punishment rounds remain)
- A “cooldown / forgiveness counter” \(F\) (optional; described below)

### Stock zones
Define two stock thresholds from parameters only:
- **Danger threshold**: \(S_{\text{low}} = \max(2n,\; 0.30 \cdot capacity)\)  
  (when below this, the pool is fragile; prioritize survival)
- **Target band** (productive zone): around \(capacity/2\). We don’t need precise control; we just avoid extremes.

### Core action logic (high level)
1) **If stock is low, cooperate** (stabilize the pool).
2) **If you are in punishment mode, defect** (credible deterrence).
3) **Otherwise cooperate by default**, but **trigger punishment** when defection is observed.

This keeps cooperation as the norm while still defending against exploiters.

---

## Triggering and applying punishment
**Trigger condition (start punishment):**
- If in the previous round at least one opponent defected, start punishment unless stock is dangerously low:
  - If \(d_{t-1} \ge 1\) and \(S_t > S_{\text{low}}\), then set:
    \[
    P \leftarrow \min\left(P_{\max},\; 1 + \left\lfloor \frac{d_{t-1}}{n-1} \cdot K \right\rfloor\right)
    \]
  where typical constants:
  - \(K = 3\) (scale punishment by how widespread defection was)
  - \(P_{\max} = 3\) (cap to avoid resource collapse)
  Intuition: isolated defection → short punishment; mass defection → longer.

**Punishment action:**
- If \(P > 0\) and \(S_t > S_{\text{low}}\): **play D**, then decrement \(P \leftarrow P-1\).

**Forgiveness / exit punishment early (avoid mutual ruin):**
- If during punishment the *last round* had **no defections by opponents** (i.e., \(d_{t-1}=0\)), then immediately end punishment: \(P \leftarrow 0\) and return to cooperation next round (unless endgame logic says otherwise).

---

## Cooperation default (when not punishing)
When not punishing and stock not low:
- **Play C**.

Rationale: In this game, mutual cooperation can sustain stock and enable large total payoffs across rounds. Any defection is handled by the punishment trigger.

---

# 2) Edge cases and special rounds

## First round
- **Play C**.
Reason: it’s the only move that can initiate a cooperative trajectory with unknown opponents, and early stock is valuable.

## Low-stock emergency rule (dominates everything)
If \(S_t \le S_{\text{low}}\):
- **Play C** regardless of history (even if others defected).
Reason: If the pool collapses, future payoffs go to ~0. You sacrifice short-run advantage to preserve any chance of recovery. Also, punishing by defecting when stock is low accelerates collapse and is collectively irrational.

(If others keep defecting in low stock, you can’t stop collapse alone; but cooperating is still the most “collective” and least self-damaging response.)

## Last round (and last 2 rounds) rule
Finite horizon makes endgame defection tempting. But if everyone defects, the resource collapses and the last-round payoff may be lower than a high-stock cooperative outcome.

Use a **stock-based endgame switch**:
- Let \(t\) be current round and \(r\) total rounds.
- If \(t = r\) (last round):
  - If \(S_t \ge 0.6 \cdot capacity\): **play D** (harvest while stock is high).
  - Else: **play C** (avoid worsening low endgame payoffs).
- If \(t = r-1\) (second-to-last):
  - If recent defection rate is high (\(\bar d \ge 1\)) and \(S_t \ge 0.6\cdot capacity\): **play D** (anticipate unraveling).
  - Otherwise **play C**.

This preserves cooperation when it matters (keeping stock high into the end) but avoids being exploited right at the finish.

---

# 3) Clearly collective mindset (why this is collective and robust)

### Collective objectives embedded in the rules
- **Stock preservation is prioritized** via the low-stock emergency cooperation rule.
- **Deterrence is calibrated**: punishment is limited in duration and automatically forgiven when others stop defecting, preventing endless retaliation that destroys the common pool.
- **Adaptivity**: the strategy escalates punishment when more opponents defect (responds to “crowd defection” more strongly), and de-escalates quickly if cooperation returns.
- **No coordination assumptions**: it doesn’t require shared schedules, messages, or precise alternation; it only uses observed actions and the stock.

---

# Pseudocode (implementable)

```python
# Parameters (fixed)
W = 3
K = 3
P_max = 3

def S_low(capacity, n):
    return max(2*n, 0.30*capacity)

state:
  P = 0
  history_defections = []  # store d_t each round

for t in 1..r:
  observe current stock S

  # compute recent defection stats
  if t == 1:
    d_prev = 0
  else:
    d_prev = count_opponents_defected(t-1)
  history_defections.append(d_prev)
  d_bar = average(last W values of history_defections)

  # Endgame rules
  if t == r:
    if S >= 0.6*capacity: action = D
    else: action = C
    play(action); continue

  if t == r-1:
    if d_bar >= 1 and S >= 0.6*capacity: action = D
    else: action = C
    play(action); continue

  # Emergency low-stock rule
  if S <= S_low(capacity, n):
    P = 0
    action = C
    play(action); continue

  # Forgive early if opponents cooperated last round
  if P > 0 and d_prev == 0:
    P = 0

  # Trigger punishment
  if P == 0 and d_prev >= 1:
    P = min(P_max, 1 + floor((d_prev/(n-1)) * K))

  # Apply punishment if active
  if P > 0:
    action = D
    P -= 1
  else:
    action = C

  play(action)
```

---

## What this does well in a tournament
- Against cooperators: stays cooperative almost all game, sustaining stock and high payoffs.
- Against occasional defectors: punishes briefly, deters repetition, then returns to cooperation.
- Against persistent defectors: spends some time defecting to avoid being a sucker, but avoids self-destructive endless mutual defection by switching to cooperation when stock is threatened.
- In mixed groups: scales response to how widespread defection is, which is crucial when a minority defects.

If you want it more aggressive (higher deterrence) or more conservationist (higher stock threshold), you can tune \(S_{\text{low}}, K, P_{\max}\), but the structure above is already robust across many opponent types.
'''

description_COLLECTIVE_20 = '''
## Strategy: **Stateful Conditional Stewardship (SCS)**  
Goal: keep the stock near the regenerative sweet-spot *and* protect the group from persistent over-consumption. The strategy is “collective-first” but uses credible, history-based sanctions to avoid being exploited.

### Key idea
- **Cooperate by default** to sustain stock.
- **Defect only as a corrective action** when the group is clearly overdrawing (or to avoid being the lone cooperator among defectors).
- Use **stock level + observed aggregate consumption** to infer whether the group is on a sustainable path.
- Apply **graduated punishment** (short, state-dependent) and quickly **forgive** once behavior improves.

---

## Useful derived quantities (from parameters and observed history)

Let:
- `S_t` = stock at start of round *t*.
- `n` = players, `capacity` given.
- Consumption per cooperator: `cC = S_t/(2n)`
- Consumption per defector: `cD = S_t/n`

From observed actions in round *t-1*:
- `k_{t-1}` = number of defectors last round (observable).
- Total fraction of stock consumed last round:
  \[
  f_{t-1} = \frac{k_{t-1}}{n} + \frac{n-k_{t-1}}{2n} = \frac{1}{2} + \frac{k_{t-1}}{2n}
  \]
So `f` ranges from `0.5` (all C) to `1.0` (all D).

**Stock stewardship thresholds**
- `S_high = 0.85 * capacity` (abundant; safe to be generous)
- `S_mid  = 0.60 * capacity` (watchful)
- `S_low  = 0.35 * capacity` (danger; prioritize deterrence)
- `S_crit = 0.20 * capacity` (emergency)

**Defection tolerance (how many defectors we “absorb” before sanctioning)**
- `k_tol = floor(n/4)`  
Interpretation: tolerate up to ~25% defectors without escalating, because sometimes noise/opportunism happens; beyond that, the group is trending toward collapse.

**Forgiveness condition**
- “Improving” means `k_{t-1} <= k_tol` for one round, and stock is not falling fast (see below).

---

## Internal state variables (maintained by the strategy)
- `punish_timer` (integer ≥ 0): remaining rounds to play D as sanction.
- `trend_bad` (integer): counts consecutive rounds of clearly excessive group consumption.
- `trend_good` (integer): counts consecutive rounds of acceptable group consumption.

Initialize: `punish_timer = 0`, `trend_bad = 0`, `trend_good = 0`.

---

## 1) Decision rules (when to C vs D)

### Rule A — Emergency protection (stock-based)
If `S_t <= S_crit`: **play D**.  
Rationale: at very low stock, cooperation is easily exploited and collapse is imminent; defection here is a “last-ditch” attempt to avoid being the only restraint while others take more.

If `S_crit < S_t <= S_low`:
- If last round had `k_{t-1} > 0` (someone defected): **play D** (deterrence in fragile state).
- Else (everyone cooperated last round): **play C** (try to rebuild).

### Rule B — Punishment mode (history-based sanction)
If `punish_timer > 0`: **play D**, then decrement `punish_timer -= 1`.

### Rule C — Normal stewardship (default cooperative with conditional sanctions)
Compute `k_{t-1}` (defectors last round). Define:
- **Clearly excessive** if `k_{t-1} > k_tol` (too many defectors).
- **Acceptable** if `k_{t-1} <= k_tol`.

Update trends:
- If clearly excessive: `trend_bad += 1`, `trend_good = 0`
- Else: `trend_good += 1`, `trend_bad = 0`

Now choose:

**C1 (Cooperate in healthy conditions):**  
Play **C** if all of the following hold:
- `S_t >= S_mid` (stock not fragile), and
- last round was acceptable (`k_{t-1} <= k_tol`), and
- we are not in punishment mode.

**C2 (Trigger punishment when exploitation persists or stock is declining):**  
Play **D** and set `punish_timer` when either condition holds:

1) **Persistent overdrawing:** `trend_bad >= 2`  
(two consecutive rounds with too many defectors)

2) **Overdrawing while stock is slipping:**  
If `S_t < S_mid` and `k_{t-1} > 0` (any defection in watchful/low stock)

**Punishment length (graduated, state-aware):**
Set
\[
punish\_timer = 1 + \mathbf{1}[S_t < S\_mid] + \mathbf{1}[k_{t-1} > n/2]
\]
So punishment is typically 1 round, becomes 2 if stock is middling/low, becomes 3 if a majority defected.

### Rule D — “Don’t be the sucker” guardrail (anti-lone-cooperator)
Even if the above would say cooperate, override to **D** if:
- last round had `k_{t-1} >= n/2` (a majority defected).  
Rationale: when a majority defects, your unilateral cooperation barely helps sustainability but strongly invites exploitation; defecting is the credible collective pressure.

---

## 2) Edge cases

### First round (t = 1)
Play **C**.  
Rationale: establishes the cooperative baseline; with capacity initially full, mutual cooperation is self-sustaining and reveals who is predisposed to defect.

### Last round (t = r)
Play **C** *unless* one of the following holds:
- `punish_timer > 0`, or
- `S_r <= S_low`, or
- last round had `k_{r-1} >= n/2`.

Rationale: In many repeated games, last-round defection temptation exists, but here *state carries no future*, so deterrence doesn’t matter in the final round. Still, staying cooperative in the last round is consistent with collective mindset—unless you’re clearly being exploited or the stock is already fragile.

### Near-last rounds (t = r-1, r-2)
No special endgame “defect by default.” Continue normal rules.  
Rationale: endgame unraveling is common; refusing to automatically unravel helps preserve cooperation against strategies that try to induce late collapse.

### Stock hits (or is extremely close to) zero
If `S_t` is ~0, payoffs are ~0 regardless. Follow Rule A (D in emergency), but it won’t matter much; the key is earlier prevention.

---

## 3) Why this is a *collective* strategy (not just self-protective)

- **Default is cooperation** whenever the stock is in a safe range and the group is not clearly exploiting.
- **Sanctions are conditional and temporary**: you punish only after *observed* excessive defection, and you forgive quickly once the group returns to acceptable extraction.
- **State-aware stewardship**: when the stock is low, even small defections can cause irreversible decline, so the strategy becomes more intolerant—protecting the commons for everyone.
- **Robustness**: against always-defecters, it will not keep sacrificing indefinitely; against mixed/noisy opponents, it does not overreact to one-off defections; against cooperative groups, it sustains the high-stock cycle.

---

## Pseudocode (implementation-ready sketch)

```python
# constants
S_high = 0.85 * capacity
S_mid  = 0.60 * capacity
S_low  = 0.35 * capacity
S_crit = 0.20 * capacity
k_tol  = n // 4

# state
punish_timer = 0
trend_bad = 0
trend_good = 0

def act(t, S_t, history):
    global punish_timer, trend_bad, trend_good

    if t == 1:
        return "C"

    k_prev = count_defectors(history[t-1])  # observable

    # Emergency protection
    if S_t <= S_crit:
        return "D"
    if S_t <= S_low:
        if k_prev > 0:
            return "D"
        else:
            return "C"

    # Punishment mode
    if punish_timer > 0:
        punish_timer -= 1
        return "D"

    # Update trends
    if k_prev > k_tol:
        trend_bad += 1
        trend_good = 0
    else:
        trend_good += 1
        trend_bad = 0

    # Anti-sucker guardrail
    if k_prev >= n/2:
        # optional: set a short punishment to coordinate deterrence
        punish_timer = 1 + (1 if S_t < S_mid else 0)
        return "D"

    # Trigger punishment if persistent/excessive in sensitive stock
    if trend_bad >= 2 or (S_t < S_mid and k_prev > 0):
        punish_timer = 1 + (1 if S_t < S_mid else 0) + (1 if k_prev > n/2 else 0)
        return "D"

    # Last round: cooperate unless clearly exploited / fragile / punishing
    if t == r:
        if S_t <= S_low or k_prev >= n/2:
            return "D"
        return "C"

    # Normal stewardship
    if S_t >= S_mid and k_prev <= k_tol:
        return "C"
    else:
        # mildly cautious when stock not high
        return "C" if k_prev == 0 else "D"
```

---

If you want, I can tune the thresholds (`S_mid`, `S_low`, `k_tol`) analytically for specific `n, capacity, r` (e.g., to maximize long-run total group payoff under plausible opponent mixtures), but the above is designed to be broadly robust across tournament diversity.
'''

description_COLLECTIVE_21 = '''
## Collective Strategy: **Stock-Guided Forgiving Trigger (SGFT)**

**Goal:** Keep the stock near a “safe” level where the resource regenerates strongly, while deterring exploitation. The strategy is *collective-first*: cooperate whenever the stock and opponents’ behavior suggest the group can sustain it; punish defection just enough to stop cascades; and return to cooperation quickly when others do.

This is a **state-and-history dependent** rule that uses only: parameters `(n, r, capacity)`, current stock `S_t`, round `t`, and the full public history of actions.

---

# Intuition (why this works)
- With logistic growth `G = 2 S_rem (1 - S_rem/capacity)`, regeneration is strongest around **half capacity**.  
- If everyone cooperates, total consumption is `S/2`, leaving `S/2`, which then regrows strongly (often back to capacity when starting high).  
- If many defect, total consumption rises toward `S` and the stock can crash to (near) zero, killing future payoffs.
- So:
  1) **Cooperate** when stock is healthy and others are not exploiting.  
  2) **Punish** after observed defection to make exploitation unprofitable.  
  3) **Conserve** (cooperate) when stock is low, even if others are nasty—because defecting on a depleted stock destroys the future and yields little anyway.

---

# Key Quantities (computed each round from history)

Let:
- `d_{t-1}` = number of defectors in previous round (observed).
- `defect_rate_{t-1} = d_{t-1} / n`.
- `S_t` = current stock at start of round `t`.

Define two stock thresholds:
- **Low-stock threshold:** `S_low = 0.30 * capacity`
- **High-stock threshold:** `S_high = 0.70 * capacity`

Define a “tolerable defection rate”:
- `τ = 1/n` (i.e., tolerate at most **one** defector in a round without escalating)

Define punishment length (adaptive, but bounded):
- `L = clamp( 1 + 2*d_{t-1}, 1, 6 )`  
  (more defectors → longer punishment; cap avoids endless spirals)

We also keep an internal counter `punish_remaining` (starts at 0).

---

# 1) Decision Rules: When to Cooperate vs Defect

### Rule A — Stock safety first (resource conservation)
If the stock is low, **always cooperate**:
- If `S_t <= S_low`: play **C** regardless of history.

Reason: When stock is low, defecting yields only `S_t/n` (small) and risks pushing stock to collapse; cooperating is the least harmful and gives the best chance of recovery.

---

### Rule B — Punish clear exploitation (but forgive)
If not low stock and currently in a punishment phase:
- If `punish_remaining > 0` **and** `S_t > S_low`: play **D**, decrement `punish_remaining -= 1`.

Punishment is conditional on stock not being dangerously low. If stock falls low, we stop punishment and revert to cooperation to prevent collapse.

---

### Rule C — Start/continue cooperation when the group is behaving
If not low stock and not punishing:
- If `defect_rate_{t-1} <= τ` (i.e., at most one defector last round): play **C**.

This keeps cooperation stable even with occasional noise or one-off deviators.

---

### Rule D — Trigger punishment when defection is “too high”
If not low stock and not punishing:
- If `defect_rate_{t-1} > τ`: begin punishment:
  - set `punish_remaining = L`
  - play **D** this round.

---

### Rule E — Fast return to cooperation (forgiveness condition)
While punishing, we also watch whether others reform:

If during punishment we observe that **the previous round had** `defect_rate_{t-1} <= τ` (group largely cooperating again), then:
- **End punishment early** by setting `punish_remaining = 0`
- Next round (unless `S_t <= S_low`) return to **C**.

This prevents permanent mutual defection and restores collective gains quickly.

---

# 2) Edge Cases

### First round (t = 1)
- Play **C**.

Rationale: Starting cooperative maximizes the chance to establish a cooperative path, and it’s not exploitable too badly because defection reveals itself immediately and triggers punishment.

---

### Last round (t = r)
There is a classic end-game temptation to defect. But this environment has **state-dependent externalities**: the last round still has value, and tournament opponents may punish “end defection” in earlier rounds if they anticipate it.

So we do:
- If `S_r <= S_low`: play **C** (conservation still matters even late).
- Else:
  - If the recent defection rate is high (`defect_rate_{r-1} > τ`) or we are in punishment: play **D**.
  - Otherwise play **C**.

This remains collectively aligned while not being naïve against clearly non-cooperative populations.

---

### Stock near zero (S_t very small)
- Always **C** (falls under Rule A).  
Even if others defect, defecting yields little and risks preventing recovery. Cooperative play is the least bad option and can help if any regeneration is possible.

---

### Everyone else always defects
Behavior:
- Round 1: we play C, see `d_1 ≈ n`, trigger punishment.
- Thereafter: mostly play D when stock allows, but will revert to C when stock becomes low to avoid total collapse.
This is robust: it does not get “farmable” for long, yet it avoids pointless over-harvesting at low stock.

---

### Everyone else always cooperates
Behavior:
- We keep playing C. Stock stays high, growth strong, high long-run payoffs.

---

### Mixed / noisy opponents
- The `τ = 1/n` tolerance plus early forgiveness prevents overreacting to one-off defection.
- Escalation is proportional (`L` increases with the number of defectors), which helps deter coordinated exploitation.

---

# 3) Clearly Collective Mindset (what the strategy optimizes)
This strategy treats the common pool as the shared engine of long-run payoff:
- **Cooperate by default** to keep stock in the productive region.
- **Punish only when necessary** and **only when stock can handle it**.
- **Forgive quickly** to restore collective benefits.
- **Protect the stock** when it’s low, even if others are behaving badly.

---

# Pseudocode (implementable)

```pseudo
parameters: n, r, capacity
state variable: punish_remaining = 0

constants:
  S_low  = 0.30 * capacity
  tau    = 1.0 / n

function choose_action(t, S_t, history):
  if t == 1:
    return C

  d_prev = number_of_defectors_in_round(history, t-1)
  defect_rate_prev = d_prev / n

  # Stock safety
  if S_t <= S_low:
    punish_remaining = 0
    return C

  # Forgive early if group re-cooperated
  if punish_remaining > 0 and defect_rate_prev <= tau:
    punish_remaining = 0
    # fall through to normal logic

  # If still punishing
  if punish_remaining > 0:
    punish_remaining -= 1
    return D

  # Not punishing: decide based on last round behavior
  if defect_rate_prev <= tau:
    return C
  else:
    L = clamp(1 + 2*d_prev, 1, 6)
    punish_remaining = L - 1   # because we defect now
    return D
```

---

If you want, I can also provide a tighter variant tuned for extremely adversarial tournaments (more aggressive deterrence), or a more “pro-social” variant that sacrifices less efficiency when facing occasional defectors.
'''

description_COLLECTIVE_22 = '''
## Strategy: **Stock-Guarded Reciprocal (SGR)**  
Goal: keep the common pool near a “safe” stock band where growth can recover from moderate overuse, while using swift, state-based retaliation to deter persistent defectors. The strategy is collective: it defaults to cooperation, only defects as a *corrective tool* when the stock or opponents’ behavior threatens future group payoffs.

---

## Key idea (why this works here)
- Cooperation yields lower immediate payoff than defection, but it sustains stock and therefore future payoffs.
- In this game, **stock collapses fast when many defect**, and once low, future rounds become low-payoff for everyone.
- The only credible leverage without communication is:  
  **(a) condition your action on observable history, and (b) use the stock as a public signal**.

So SGR uses:
1) a **stock “guardrail”** (cooperate when stock is healthy; conserve/discipline when it isn’t), and  
2) a **reciprocity trigger** (respond to observed defection rates with temporary punishment),  
while avoiding needless mutual destruction when recovery is still possible.

---

## Notation (publicly observable each round)
- `n, r, capacity` given
- `t` current round (1..r)
- `S_t` current stock at start of round `t`
- `D_{t-1}` = number of players who defected in round `t-1`
- `f_{t-1} = D_{t-1}/n` defection fraction
- `S_high = 0.9 * capacity` (healthy)
- `S_mid  = 0.6 * capacity` (watch zone)
- `S_low  = 0.35 * capacity` (danger)
- `S_crit = 0.20 * capacity` (near-collapse)

(These cutoffs are parameter-only and scale with capacity; they work across many n, r.)

---

## 1) Decision rules: when to cooperate vs defect

### Default behavior: **Cooperate**
- If the stock is not endangered and opponents are not heavily defecting, cooperate to maximize long-run group payoffs.

### Retaliation behavior: **Defect as a temporary sanction**
- If many others defected recently, defect for a short, state-dependent “punishment window” to remove the unilateral advantage and discourage continued defection.
- But avoid pushing the system off a cliff: if stock is already critically low, prioritize recovery (cooperate), because mutual defection can permanently zero out the pool.

### Conservation behavior: **Defect if stock is high but being exploited**
- When stock is high, a single round of sanctioning is less dangerous. Use it to resist exploitation while the resource can absorb it.

---

## 2) Edge cases

### Round 1
- **Play C**.
Rationale: you establish the cooperative baseline and avoid needless early depletion. Also, with no history, punishing is unjustified.

### Last round (t = r)
- **Play D if stock is not critical; otherwise play C**:
  - If `S_t > S_crit`, play **D**.
  - If `S_t ≤ S_crit`, play **C**.
Rationale: no future to protect, so take the higher one-shot payoff unless the pool is so low that even defecting yields almost nothing and can’t be meaningfully improved by sanctioning.

### Near-collapse stock
- If `S_t ≤ S_crit`: **always C**, regardless of history.
Rationale: punishment is counterproductive when the resource is on life support; the collective priority is to let growth operate.

---

## 3) The collective, adaptive core (pseudocode)

We maintain an internal variable `punish` = remaining punishment rounds (starts at 0).

### Update punishment based on last round
After observing round `t-1`:

- If `f_{t-1} ≥ 0.5` (at least half defected):  
  `punish = max(punish, 2)`  
- Else if `0.25 ≤ f_{t-1} < 0.5`:  
  `punish = max(punish, 1)`  
- Else (`f_{t-1} < 0.25`):  
  `punish = max(punish - 1, 0)` (cool down)

This makes retaliation **proportional** and **forgiving**.

### Action choice each round

```
Input: t, S_t, punish, (D_{t-1} if t>1)

If t == 1:
    return C

If t == r:
    if S_t <= S_crit: return C
    else: return D

# Safety first: prevent collapse
If S_t <= S_crit:
    punish = 0
    return C

# If stock is low, prioritize recovery and only punish extreme exploitation
If S_crit < S_t <= S_low:
    if f_{t-1} >= 0.5:
        return D          # one corrective hit if group is heavily defecting
    else:
        return C

# If stock is medium, use measured reciprocity
If S_low < S_t <= S_mid:
    if punish > 0:
        punish -= 1
        return D
    else:
        return C

# If stock is high, you can afford firmer sanctions against exploitation
If S_t > S_mid:
    if f_{t-1} >= 0.25:
        return D          # deter opportunism when resource can absorb it
    else:
        return C
```

---

## Why this is robust in a tournament

### Against always-cooperators
- SGR mostly cooperates; stock stays high; high total payoffs.
- Only defects in last round (if not critical), gaining a small edge without wrecking the whole game.

### Against always-defectors
- Stock collapses quickly no matter what; SGR does not waste rounds “being nice” when exploitation is obvious.
- It retaliates when stock is not yet critical; once critical, it switches to recovery mode (cooperate) because punishment no longer changes incentives and only ensures zero forever.

### Against mixed / noisy strategies
- Proportional punishment avoids endless vendettas from occasional mistakes.
- Stock thresholds prevent “punish into collapse” dynamics.

### Against sophisticated exploiters (defect until threatened, then cooperate)
- The rule “defect when stock is high and defection fraction ≥ 0.25” makes opportunism costly early.
- The punishment window is short but repeatable, so cyclic exploitation doesn’t get a free ride.

---

## Collective mindset (explicit)
- **Primary objective:** keep `S_t` out of the low/critical zone to preserve future payoffs for everyone.  
- **Secondary objective:** deter persistent free-riding through limited, state-aware sanctions.  
- **Tertiary objective:** in the final round, take the efficient one-shot action since there is no future commons to protect.

If you want, I can tune the thresholds (`0.9/0.6/0.35/0.20`) and punishment lengths as functions of `n` and `r` (e.g., harsher for longer horizons), but the above is already parameter-only, adaptive to state/history, and tournament-robust.
'''

description_COLLECTIVE_23 = '''
## Strategy: **Stock-Guard with Graduated Retaliation (SGGR)**  
Goal: keep the resource near its sustainable high-payoff region (ideally at/near `capacity`), cooperate by default to maximize long-run total yield, and punish over-consumption quickly enough that unilateral defection is unprofitable in expectation—while forgiving once behavior stabilizes.

Key idea: in this game, full cooperation can keep stock at `capacity` (given `capacity ≥ 2n`), while too many defections can crash stock to 0. So the collective strategy is:  
- **Cooperate when stock is healthy and others are not over-consuming.**  
- **Defect to deter/punish when others over-consume**, but **return to cooperation** once the group stops.

This is designed to be robust to: always-defect, noisy strategies, grim trigger types, conditional cooperators, and opportunists.

---

# 1) Decision rules (C vs D)

### Observable signals from history
At the end of each round `t`, you can observe:
- Stock at start of round: `S_t`
- Actions of each player (C/D), hence number of defectors: `k_t`
- Stock next round: `S_{t+1}`

Define:
- `k_t` = number of defectors in round `t`
- `defect_rate_recent` = average of `k` over a recent window (e.g., last `w=3` rounds, truncated at available history)
- `S_t` = current stock (start-of-round)

### Two operating modes
Maintain an internal mode variable: `mode ∈ {COOP, PUNISH}`.

**Start in `COOP`.**

#### A. When to cooperate (play C)
Play **C** when all of the following are true:

1) **Stock is not in a danger zone**:  
   `S_t ≥ S_safe`, where  
   `S_safe = 0.6 * capacity`  (tunable threshold; chosen to keep you out of the collapse basin)

2) **Recent over-consumption is low**:  
   `defect_rate_recent ≤ k_tol`, where  
   `k_tol = 0.25 * n` (i.e., tolerate up to ~25% defectors without immediately flipping)

3) **Not currently punishing** (or punishment has completed; see below)

Intuition: cooperate whenever the stock is high and the group is mostly cooperative; don’t overreact to one-off defections.

#### B. When to defect (play D)
Play **D** if any of these triggers fire:

**Trigger 1: Immediate major defection event**
- If last round had many defectors: `k_{t-1} ≥ k_major`, where  
  `k_major = ceil(n/2)`  
Then switch to PUNISH and defect.

**Trigger 2: Stock danger (protect against collapse / deter)**
- If `S_t < S_safe`, switch to PUNISH and defect.  
Rationale: low stock means the system is already stressed; your best lever is deterrence (reduce being the “sucker” while others cash out), and create consequences for depletion.

**Trigger 3: Persistent moderate defection**
- If `defect_rate_recent > k_tol`, switch to PUNISH and defect.

---

# Punishment and forgiveness (collective but robust)

### Punishment rule (graduated, not permanent)
Once in `PUNISH`, you defect for a fixed “burst” length that depends on how bad the deviation was, then test cooperation again.

Let:
- `severity = max(k_{t-1}, round(defect_rate_recent))`
- `L = 1 + floor( 2 * severity / n )`  
So `L` is 1–3 rounds typically:
- small deviation → 1 round punishment  
- big deviation (≥ half defect) → 2–3 rounds punishment

During punishment:
- Play **D** for `L` consecutive rounds (countdown).
- After the countdown, enter a **probation/test** phase of 1 round: play **C** once and see if others also mostly cooperate.

### Return-to-cooperation condition
After punishment ends, play **C** (probation) and return to `COOP` if:
- In that probation round, `k_t ≤ k_tol` **and**
- Stock is not worsening: `S_{t+1} ≥ S_t - small_epsilon` (epsilon ~ 0.01*capacity)

If probation fails (too many defectors again or stock keeps sliding), re-enter `PUNISH` with updated severity.

This is a “forgiving trigger”: punish enough to make deviation unattractive, but don’t lock into mutual destruction.

---

# 2) Edge cases

### First round (`t = 1`)
Play **C**.  
Reason: when stock starts at `capacity`, cooperation is collectively optimal and also the best “handshake” to attract conditional cooperators. Early defection destroys long-run value and provides little strategic advantage given no communication.

### Last round (`t = r`)
Play **D** unless stock is in danger of collapse *and* you’re trying to preserve it for nothing (no future). Since there is no future, the collective objective is irrelevant in a strict finite-horizon sense, and exploitation risk is maximal.

So:
- If `t == r`: **play D**.

(If you want a more “collective-minded” version: play C only if `S_t` is already very low and your D doesn’t add much—but in this game D always doubles your take relative to C at given S, so last-round defection is dominant individually.)

### Second-to-last round (`t = r-1`)
This is where endgame unraveling can start. To stay robust:
- If recent cooperation has been strong (`defect_rate_recent == 0`) and `S_t ≥ S_safe`, play **C**.
- Otherwise play **D**.

This “soft endgame” keeps good groups cooperative one more round, but avoids being a late sucker against endgame defectors.

### Stock extremely low (`S_t` near 0)
If `S_t ≤ S_low` where `S_low = 0.1 * capacity`, then:
- Play **D** (unless you are in probation test and want one last attempt; but generally D).
Reason: with very low stock, growth is small and the group is in a depletion trap likely caused by defection; you must avoid unilateral restraint that others exploit.

### Handling noise / occasional defections
The use of `defect_rate_recent` with tolerance `k_tol` prevents flipping to punishment due to a single defection among many players. The punishment is short and followed by a cooperation test, which allows recovery.

---

# 3) Collective mindset (what this is optimizing)
- **Default is cooperation** because full cooperation can keep stock at `capacity`, maximizing total long-run harvest for everyone.
- **Punishment is calibrated**: enough to deter and to avoid being exploited, but designed to re-enable cooperation quickly.
- **State-aware**: when stock is healthy, prioritize rebuilding/maintaining trust; when stock is threatened, prioritize stopping further depletion and discouraging free-riding.

---

# Pseudocode (implementable)

```python
# Parameters
S_safe = 0.6 * capacity
S_low  = 0.1 * capacity
w = 3
k_tol = 0.25 * n
k_major = math.ceil(n/2)
epsilon = 0.01 * capacity

# State variables
mode = "COOP"
punish_countdown = 0
in_probation = False

def decide(t, S_t, history):
    global mode, punish_countdown, in_probation

    # Count defectors last rounds
    def k(round_actions): return sum(1 for a in round_actions if a == "D")

    if t == 1:
        return "C"

    # Endgame rules
    if t == r:
        return "D"

    # compute recent stats
    recent = history[-w:]  # each item contains (actions, S_start, S_next)
    k_recent = [k(h.actions) for h in recent]
    defect_rate_recent = sum(k_recent)/len(k_recent)
    k_last = k(history[-1].actions)

    # If currently punishing
    if punish_countdown > 0:
        punish_countdown -= 1
        if punish_countdown == 0:
            in_probation = True
        return "D"

    # Probation: test cooperation once
    if in_probation:
        in_probation = False
        # decide C to test
        return "C"

    # Soft endgame (r-1)
    if t == r-1:
        if defect_rate_recent == 0 and S_t >= S_safe:
            return "C"
        else:
            return "D"

    # Danger zone or defection triggers -> enter punishment
    if S_t < S_safe or k_last >= k_major or defect_rate_recent > k_tol:
        severity = max(k_last, round(defect_rate_recent))
        L = 1 + math.floor(2 * severity / n)  # 1..3 typically
        punish_countdown = L
        return "D"

    # Extremely low stock: avoid sucker outcomes
    if S_t <= S_low:
        return "D"

    # Otherwise cooperate
    return "C"

def observe_after_round(t, S_t, S_next, actions):
    global mode
    # After probation round we evaluate: if many defectors or stock keeps falling,
    # the next call to decide() will trigger punishment via defect_rate_recent / S_t
    pass
```

---

## Why this should do well in a tournament
- Against cooperative clusters: stays at `C`, keeping stock near `capacity`, maximizing long-run payoff.
- Against always-defect / heavy defectors: quickly shifts to `D`, limiting exploitation; avoids repeatedly “feeding” defectors.
- Against conditional cooperators: provides a clear cooperative signal and a credible deterrent, with forgiveness to restore cooperation after deviations.
- Against chaotic/noisy: tolerance + short punishments prevents permanent breakdown.

If you want, I can tune the thresholds (`S_safe`, `k_tol`, punishment length formula) for specific `n`, `r`, `capacity` regimes (e.g., small n vs large n, short vs long horizon).
'''

description_COLLECTIVE_24 = '''
## Collective, adaptive strategy: **StockGuard (forgiveness + stock targeting)**

Goal: keep the common stock near a “safe” level where growth replenishes what a fully cooperative group takes, while deterring persistent over-consumption. The strategy is intentionally *collective-first* (cooperate whenever it seems sustainable) but *robust* (switches to defect when others are depleting the resource or when the stock is too low to sustain cooperation).

Key idea: infer how many opponents defected last round from the observed stock transition, then respond with a calibrated “defection pressure” that increases when others defect and relaxes (forgives) when they return to cooperation.

---

# 1) Decision rules (C vs D)

### Notation (at round t)
- `S_t` = stock at start of round t (observed)
- After round t-1 you observe `S_t` (new stock after dynamics).
- Actions are `C` (consume S/(2n)) or `D` (consume S/n).
- Let `k` = number of defectors in a round (0..n).

### Step A — Estimate how many defectors there were last round
Given you know:
- the prior stock `S_{t-1}`
- and the resulting next stock `S_t`

You can infer total consumption last round (up to numerical tolerance):

1. For any candidate `k ∈ {0..n}`, compute predicted next stock if there were `k` defectors:

- Individual consumption rates:
  - Cooperators: `S_{t-1}/(2n)`
  - Defectors: `S_{t-1}/n`
- Total consumption if `k` defectors:
  - `Cons(k) = (n-k)*S_{t-1}/(2n) + k*S_{t-1}/n = S_{t-1} * (n+k)/(2n)`
- Remaining stock:
  - `R(k) = S_{t-1} - Cons(k) = S_{t-1} * (n-k)/(2n)`
- Growth:
  - `G(k) = 2*R(k) * (1 - R(k)/capacity)`
- Predicted next stock:
  - `S_pred(k) = min(R(k) + G(k), capacity)`

2. Choose `k_hat` that minimizes `|S_pred(k) - S_t|` (within a tolerance, e.g. 1e-6 to 1e-3 depending on float noise).

This lets you react to *actual realized exploitation*, not guesses.

---

### Step B — Maintain a “retaliation meter” based on observed defection
Maintain an internal state variable `pressure ∈ [0,1]` representing how strongly we should punish/defend against exploitation.

Update after each round (starting round 2), using `k_hat` from the previous round:

- Let defection rate be `d = k_hat / n`.
- Update:
  - `pressure ← clamp( (1-λ)*pressure + λ*d , 0, 1 )`
- Use `λ` around `0.5` (fast adaptation).  
  - High λ: quickly punishes.  
  - Low λ: more forgiving.

Intuition:
- If everyone cooperates, `d=0`, pressure decays toward 0.
- If many defect, pressure rises toward 1.

---

### Step C — Stock safety check (collective sustainability guardrail)
Even if others cooperate, when stock is low, continued cooperation may not rebuild.

Define a *low-stock threshold*:
- `S_low = capacity / 2` (the logistic growth is strongest around capacity/2 and it’s a natural “rebuild zone”).

Rule:
- If `S_t < S_low`, we enter **rebuild mode**: cooperate unless exploitation is extreme (details below).

Rationale:
- When stock is below capacity/2, the system can rebound if consumption is controlled; mutual D can crash it.

---

### Step D — Action choice each round
At start of round t:

1. **If t = 1 (no history): Cooperate (C).**

2. Else (t ≥ 2), compute:
- `k_hat` from last round,
- update `pressure`,
- compute `S_t` relative to `S_low`.

Then choose:

#### Primary action rule (deterrence with forgiveness)
- Compute probability to defect:
  - `pD = pressure`
- But apply stock-aware caps:

**If `S_t >= S_low` (healthy stock):**
- Play **D** with probability `pD`, else **C**.

**If `S_t < S_low` (rebuild mode):**
- Be more cooperative to restore the resource unless others are clearly predatory:
  - If `k_hat ≥ ceil(n/2)` (a majority defected last round): play **D** (defend yourself; otherwise you’re exploited while stock collapses).
  - Else: play **C**.

This creates a clear conditional:
- When stock is low, prioritize recovery *unless* the group is actively looting.

---

### Step E — Escape from collapse / endgame protection
If stock gets extremely low, individual actions matter less in absolute payoffs, but you still want to avoid being the only cooperator among defectors.

Define:
- `S_crit = capacity / (4)` (or, more generally, any “danger” level well below capacity/2).

Rule:
- If `S_t ≤ S_crit`:
  - If last round had any defectors (`k_hat ≥ 1`): **D** (don’t be the sucker).
  - If last round had 0 defectors: **C** (try to rebuild).

---

# 2) Edge cases (first round, last round, numerical issues)

### First round
- **Always C.**
Reason: It is collective-first, and in many tournaments early cooperation is necessary to ever reach stable high-payoff paths. One round of C also gives a clean signal to classify opponents.

### Last round (t = r)
Classic backward induction would say “defect”, but tournament success typically rewards strategies that sustain cooperation across many rounds and punish only when needed. Still, you should not allow unpunished last-round exploitation.

Rule:
- In the last round:
  - If `pressure` is low *and* last round looked cooperative (`k_hat = 0`): **C**.
  - Otherwise: **D**.

This prevents being exploited by strategies that “cash out” at the end while still allowing full cooperation if the group has been consistently cooperative.

### Numerical / inference robustness
Because `S_pred(k)` may be very close for adjacent k when stock is small or capped at `capacity`, implement:
- tolerance `eps`
- if multiple k tie within `eps`, choose the **smallest** k (more forgiving) *unless* stock decreased sharply, in which case choose the larger (more cautious). A simple tie-break:
  - if `S_t == capacity` and several k match: pick smallest k (it’s consistent with stock being refilled).
  - else pick the k with smallest absolute error; if tie, pick larger k.

---

# 3) Why this is “collective” and robust

### Collective alignment
- Defaults to **C** whenever the system is healthy or rebuilding cooperatively.
- Actively tries to keep the stock in the high-growth region (around capacity/2 to capacity), which is best for long-run total payoffs.
- Forgives quickly when others return to cooperation (pressure decays when d→0).

### Robustness to opponent types
- **Always-defectors:** pressure rapidly → 1; you defect most rounds, avoiding being a permanent sucker. (The resource may still collapse, but you don’t donate extra payoff.)
- **Conditional cooperators (Tit-for-Tat-like):** your initial C and forgiveness stabilizes mutual cooperation; occasional noise doesn’t trigger permanent war because pressure is smoothed.
- **Opportunists / alternating defectors:** their defection rate keeps pressure elevated; they get punished proportionally.
- **Endgame defectors:** last-round rule reduces your vulnerability.

---

# Pseudocode (implementable)

```pseudo
state:
  pressure = 0.0
  prev_stock = None
  prev_prev_stock = None   # to infer from transitions, optional
  prev_k_hat = 0

constants:
  λ = 0.5
  S_low = capacity / 2
  S_crit = capacity / 4
  eps = 1e-6

function predict_next_stock(S, k):
  Cons = S * (n + k) / (2*n)
  R = max(S - Cons, 0)
  G = 2 * R * (1 - R/capacity)
  return min(R + G, capacity)

function infer_k(S_prev, S_now):
  best_k = 0
  best_err = +inf
  for k in 0..n:
    S_pred = predict_next_stock(S_prev, k)
    err = abs(S_pred - S_now)
    if err + eps < best_err:
      best_err = err
      best_k = k
    else if abs(err - best_err) <= eps:
      # tie-break: cautious if not at cap
      if S_now < capacity:
        best_k = max(best_k, k)
      else:
        best_k = min(best_k, k)
  return best_k

function act(t, S_t, observed_next_stock_from_last_round):
  if t == 1:
    prev_stock = S_t
    return C

  # infer last round defection count from transition prev_stock -> S_t
  k_hat = infer_k(prev_stock, S_t)
  prev_k_hat = k_hat

  d = k_hat / n
  pressure = clamp((1-λ)*pressure + λ*d, 0, 1)

  if t == r:
    if k_hat == 0 and pressure < 0.2:
      action = C
    else:
      action = D
  else:
    if S_t <= S_crit:
      action = (k_hat >= 1) ? D : C
    else if S_t < S_low:
      action = (k_hat >= ceil(n/2)) ? D : C
    else:
      action = (rand() < pressure) ? D : C

  prev_stock = S_t
  return action
```

---

If you want a deterministic variant (no randomness), replace “`rand() < pressure`” with a threshold rule like: defect iff `pressure ≥ 0.5` or iff `k_hat ≥ 1` (harsher), but the probabilistic version is typically harder to exploit while still converging to cooperation in cooperative groups.
'''

description_COLLECTIVE_25 = '''
## Strategy: **Stock-Guarded Proportional Reciprocity (SGPR)**  
Collective objective: keep the common pool near the sustainable “sweet spot” where regrowth is high, while discouraging free-riding through predictable, proportional retaliation. The strategy cooperates whenever the stock can sustain it and opponents aren’t exploiting; it defects only to (a) prevent collapse when stock is low or (b) discipline persistent over-consumption.

Key idea: treat each round as choosing a *group consumption rate* that keeps the stock in a safe band, and use history to estimate whether others are doing their share.

---

# 1) Decision rules: when to Cooperate vs Defect

### Definitions (computed each round \(t\))
- Inputs known: \(n, r, capacity\), current stock \(S_t\), and full history of actions.
- Let \(D_{t-1}\) = number of players who defected last round (observed).
- Let \(d_{t-1} = D_{t-1}/n\) be last-round defection rate.
- Let \(k_t\) be your **retaliation level** (an internal state variable), initialized to 0.

### Stock safety thresholds
We use conservative thresholds because one all-D round can collapse stock.

- **Critical stock**:  
  \[
  S_{\text{crit}} = 2n
  \]
  Rationale: your spec bounds stock by \(0 \le S \le 2n\); this is the lowest “nontrivial” region where any over-consumption risks collapse.

- **Safe stock**:  
  \[
  S_{\text{safe}} = 0.5 \cdot capacity
  \]
  Rationale: logistic growth is strong around mid-capacity; the example shows full recovery when stock after consumption lands near \(capacity/2\).

### Core cooperation rule (default)
- If stock is not endangered **and** opponents are mostly cooperating, **play C**.
- Otherwise, **play D** as either a defensive move (low stock) or a disciplinary move (high defection rate).

Concretely:

#### Rule A — Protect the resource (stock-first)
- If \(S_t \le S_{\text{crit}}\): **play C**.  
  (When stock is near the floor, defecting accelerates collapse; the collective best response is to reduce extraction.)

- Else if \(S_t < S_{\text{safe}}\): be cautious; only cooperate if the group is cooperating:
  - If \(d_{t-1} \le 0.25\): **play C**
  - Else: **play D**

#### Rule B — Reciprocity / discipline (when stock is safe)
If \(S_t \ge S_{\text{safe}}\), set/adjust retaliation and choose action:

- Update retaliation level:
  \[
  k_t = \text{clamp}\Big(k_{t-1} + \mathbf{1}[d_{t-1} > 0.25] - \mathbf{1}[d_{t-1}=0],\ 0,\ 3\Big)
  \]
  Interpretation:
  - If notable defection happened (>25%), increase retaliation by 1.
  - If everyone cooperated, cool down by 1.
  - Retaliation bounded to avoid permanent war.

- Action choice from retaliation:
  - If \(k_t = 0\): **C**
  - If \(k_t \ge 1\): **D** with probability \(p = \min(1, 0.35 \cdot k_t)\), else **C**  
    (So \(k=1 \Rightarrow p=0.35\), \(k=2 \Rightarrow 0.70\), \(k=3 \Rightarrow 1\).)

Why probabilistic? It avoids being exploited by deterministic “bait-and-switch” opponents while still allowing re-coordination to cooperation when others improve.

---

# 2) Edge cases (first round, last round, etc.)

### Round 1 (no history)
- **Play C** if \(capacity \ge 2n\) (given) and \(S_1 = capacity\): the pool is maximally healthy and cooperation is the collective-optimal opening.
- Initialize \(k_1 = 0\).

### Last round (\(t = r\))
Classic backward induction would suggest defection, but tournaments often reward long-run totals and punish collapse before the end. Still, the last round has no future discipline value.

Use a **last-round hybrid**:
- If \(S_r \ge S_{\text{safe}}\) and last round’s defection rate \(d_{r-1} \le 0.25\): **C** (finish cooperatively; no need to grab).
- Otherwise: **D** (no future to protect, and others are not reliably cooperative).

### Near-end rounds (\(t \ge r-1\))
- Keep the same rules, but **reduce cooldown** (forgive more slowly) because there’s less time to recover from exploitation:
  - In retaliation update, replace “cool down by 1 on all-C” with “cool down by 1 only if all-C occurred twice in a row”.

### If stock hits zero
- If \(S_t = 0\): your payoff is 0 regardless; choose **C** (weakly dominates for collective recovery in following rounds).

---

# 3) “Collective” mindset: what it optimizes and why it’s robust

### What the strategy is collectively doing
1. **Stabilizing stock near high-growth region**: cooperation is favored whenever the stock is below \(capacity/2\), preventing irreversible collapse and allowing regrowth.
2. **Enforcing fairness**: defection is used as a *controlled sanction* when defection becomes common, discouraging persistent free-riders.
3. **Allowing re-coordination**: the retaliation “cooldown” ensures the group can return to all-C if opponents shift.

### Robustness against common opponent types
- **Always Defect**: retaliation ramps up quickly to frequent D when stock is safe; when stock becomes low, the strategy shifts to C to avoid complete ruin (minimizing catastrophic spirals).
- **Always Cooperate**: stays at C almost always (high total welfare).
- **Tit-for-tat-like**: converges to mutual cooperation because any all-C round reduces retaliation.
- **Opportunistic / periodic defectors**: probabilistic retaliation makes timing exploitation harder and raises their expected cost.
- **Noisy strategies**: bounded retaliation avoids endless punishment cycles due to occasional errors.

---

## Pseudocode (implementable)

```python
# parameters: n, r, capacity
# state each round: S_t, history of actions (to compute d_{t-1})
# internal memory: k (retaliation level), initialized 0

S_crit = 2*n
S_safe = 0.5*capacity

def choose_action(t, S_t, d_prev, allC_prev, allC_prevprev, k):
    # Edge: first round
    if t == 1:
        return "C", 0

    # Stock-first protection
    if S_t <= S_crit:
        # protect recovery
        k = max(k-1, 0)  # mild forgiveness when resource is critical
        return "C", k

    if S_t < S_safe:
        if d_prev <= 0.25:
            return "C", k
        else:
            # moderate discipline when stock is recovering
            return "D", min(k+1, 3)

    # Stock is safe: update retaliation
    k_new = k
    if d_prev > 0.25:
        k_new = min(k + 1, 3)
    else:
        # cooldown
        if t >= r-1:
            # near end: require two consecutive all-C to cool down
            if allC_prev and allC_prevprev:
                k_new = max(k - 1, 0)
        else:
            if allC_prev:
                k_new = max(k - 1, 0)

    # Last round adjustment
    if t == r:
        if S_t >= S_safe and d_prev <= 0.25:
            return "C", k_new
        else:
            return "D", k_new

    # Choose action based on retaliation
    if k_new == 0:
        return "C", k_new
    else:
        p = min(1.0, 0.35 * k_new)
        return ("D" if random() < p else "C"), k_new
```

---

### Summary in one sentence
**Cooperate by default to keep stock in the high-regrowth zone, but apply bounded, proportional, partially-random retaliation when defection becomes common—while prioritizing resource protection when stock is low and using a pragmatic last-round rule.**
'''

description_COLLECTIVE_26 = '''
## Strategy: **Stock-Guarded Reciprocal Cooperation (SGRC)**  
Collective goal: keep the stock near **capacity** (high sustainable yield) while **deterring one-shot and persistent overconsumption**. The strategy is cooperative by default when the group is behaving sustainably, but it uses fast, state-based retaliation when the stock is being driven down.

Key idea: because payoffs scale with current stock, the group does best by keeping stock high; because D is individually tempting, we need **credible punishment** that is triggered by **observed stock damage**, not by assumed coordination.

---

## 1) Decision rules (C vs D)

### Quantities you can compute each round
At the start of round *t*, you observe stock \(S_t\) and history (previous actions and stocks).

Define:
- \(c_t\) = number of players who cooperated in round \(t\)
- \(d_t = n - c_t\)
- **Defection rate:** \(\delta_t = d_t / n\)
- **Relative stock:** \(x_t = S_t / \text{capacity}\)

Also define two thresholds that depend only on parameters:
- **Safe stock threshold:**  
  \[
  x_{\text{safe}} = 0.70
  \]
  (Above this, stock is comfortably high.)
- **Critical stock threshold:**  
  \[
  x_{\text{crit}} = 0.45
  \]
  (Below this, prioritize deterring further depletion even at short-run cost.)

And a retaliation “memory” window:
- \(W = \min(5, r-1)\) (use last up to 5 observed rounds)

Compute recent defection pressure:
\[
\bar{\delta} = \text{average of } \delta \text{ over last } W \text{ rounds (or fewer if early)}
\]

---

### Core policy
You choose **C** unless one of the following triggers fires; triggers are ordered from strongest to weakest:

#### Trigger A — **Emergency stock protection**
If \(x_t \le x_{\text{crit}}\): play **D**.

Rationale: when stock is low, any unilateral C is highly exploitable and may not restore stock fast enough if others keep defecting. Defecting here is a defensive move to force others to feel the depletion consequences immediately, which tends to shorten the time they can profitably exploit.

#### Trigger B — **Retaliate against heavy recent defection**
If \(x_t < x_{\text{safe}}\) **and** \(\bar{\delta} \ge 0.35\): play **D**.

Rationale: if a substantial minority is defecting while stock is not comfortably high, cooperation becomes a subsidy to defectors. This trigger is intentionally earlier than “majority defect” because CPR dynamics are nonlinear: moderate overuse can push stock into a bad region.

#### Trigger C — **Targeted deterrence when exploitation is clear**
If last round had **any defectors** (\(\delta_{t-1} > 0\)) and stock is not improving, play **D** for one round:
- Condition: \(\delta_{t-1} > 0\) **and** \(S_t \le S_{t-1}\)
- Action: **D** (one-round “shock”)

Rationale: if defection occurred and the resource failed to rebound, a short retaliatory pulse makes defection less profitable without committing to permanent mutual destruction.

#### Otherwise: **Cooperate**
If none of the above triggers fire: play **C**.

---

### De-escalation (how you return to cooperation)
After playing D due to any trigger, you return to C when:
- \(x_t \ge x_{\text{safe}}\) **and**
- \(\bar{\delta} \le 0.20\)

This prevents endless punishment cycles and supports recovery when others reform.

---

## 2) Edge cases

### Round 1 (no history)
- Play **C**.

Reason: starting cooperative maximizes the chance of locking into the high-stock “virtuous cycle.” With capacity initial stock, full cooperation can keep stock at capacity indefinitely (as in the example).

### Early rounds with little history (t ≤ W)
- Use the average \(\bar{\delta}\) over the available past rounds only.

### Last round (t = r)
- Play **D** **unless** stock is already very low:
  - If \(x_r > x_{\text{crit}}\): play **D**
  - If \(x_r \le x_{\text{crit}}\): play **C** (to avoid fully zeroing out a collapsing stock; this is a collective “do no further harm” clause)

Explanation: in a finitely repeated game, end-game cooperation is hard to sustain; taking D at the end avoids being the sucker. The exception prevents the last move from unnecessarily annihilating the common pool when it’s already critical—useful in tournaments that might include cross-game scoring or resource-preservation criteria, and it’s still consistent with “collective” values.

### If stock hits zero
- If \(S_t = 0\): play **C**.
Reason: both actions yield zero payoff at zero stock, so choose the action aligned with recovery norms; also avoids additional “defection signals” that could prolong mutual distrust once stock regrows.

---

## 3) Why this is collectively aligned and robust

### Collective alignment
- Defaults to **C** whenever the system is healthy and opponents aren’t overconsuming.
- Protects the stock by responding to *resource state* (not just moralizing about D).  
- De-escalates quickly when the group returns to sustainable behavior.

### Robustness to opponent types
- **Always-cooperators:** You cooperate most of the time; only defect if stock becomes threatened (rare if everyone else cooperates).
- **Always-defectors:** You switch to D once stock falls or defection pressure is clear; you avoid being persistently exploited.
- **Occasional defectors / noisy strategies:** One-round retaliation (Trigger C) plus de-escalation prevents permanent spirals.
- **Grim-trigger types:** You mostly won’t trigger them unless the group starts defecting; if they do punish, your de-escalation gives a path back once stock is safe.

---

## Pseudocode (implementation-friendly)

```pseudo
parameters:
  x_safe = 0.70
  x_crit = 0.45
  W = min(5, r-1)

function action(t, S_t, history):
  if t == 1:
    return C

  if t == r:
    if S_t / capacity > x_crit:
      return D
    else:
      return C

  x = S_t / capacity

  # compute recent defection rates
  delta_list = []
  for k in last min(W, t-1) rounds:
    delta_list.append( (#defectors in round k) / n )
  bar_delta = average(delta_list)

  # previous stock
  S_prev = stock at start of round (t-1)
  delta_prev = (#defectors in round t-1) / n

  # Trigger A: emergency
  if x <= x_crit:
    return D

  # Trigger B: sustained/meaningful defection while not super safe
  if x < x_safe and bar_delta >= 0.35:
    return D

  # Trigger C: one-round shock if defection occurred and stock didn't improve
  if delta_prev > 0 and S_t <= S_prev:
    return D

  return C
```

If you want, I can also provide a “parameter-free” variant (no explicit numeric thresholds) that derives thresholds directly from the logistic growth term and n, but the above is intentionally simple and tournament-robust.
'''

description_COLLECTIVE_27 = '''
## Strategy: **Stock-Guarded Reciprocal Cooperation (SGRC)**  
Collective goal: keep the stock in the “safe regenerative zone” (high enough that logistic growth can refill to capacity) while deterring systematic over-consumption. The strategy cooperates by default, escalates to defection only when the *observed* behavior and/or *state* implies the group is on a depletion trajectory, and then de-escalates once the stock is safe again.

Key idea: because consumption is proportional to current stock, preserving stock early pays compounding dividends. But if others defect, unconditional cooperation becomes exploitable and can still collapse the resource. So we use **(i) a stock safeguard**, **(ii) a forgiveness-but-punish reciprocity rule**, and **(iii) endgame realism**.

---

# 1) Decision rules (C vs D)

### Definitions observed each round
At start of round \(t\), stock is \(S_t\). From last round’s action profile, compute:
- \(d_{t-1}\): number of defectors last round (players who played D)
- Defection rate \(p_{t-1} = d_{t-1}/n\)

We also define two stock thresholds (depend only on parameters):
- **Danger threshold:** \(S_{\text{low}} = 0.5 \times \text{capacity}\)  
  (Below this, the resource is vulnerable; one “bad” round can push it into a low-growth trap.)
- **Recovery threshold:** \(S_{\text{high}} = 0.8 \times \text{capacity}\)  
  (Above this, we can afford to cooperate more readily.)

These constants can be tuned, but 0.5/0.8 are robust across capacities and n.

---

## Core rule (per round t)

### A. Stock safeguard (state-based)
1. **If stock is critically low**, prioritize deterrence and immediate payoff:
- If \(S_t \le S_{\text{low}}\): **Play D**  
  Rationale: when the pool is already in danger, cooperating while others defect accelerates collapse and yields very low long-run returns anyway.

2. **If stock is very healthy**, prioritize rebuilding/maintenance:
- If \(S_t \ge S_{\text{high}}\): proceed to reciprocity rule (below) with a bias toward C.

### B. Reciprocity with proportional retaliation (history-based)
Maintain a “retaliation meter” \(R_t \in \{0,1,2\}\) that represents how many upcoming rounds we will defect to punish detected overuse. Update it from observed defection rate.

**Update rule after observing round \(t-1\):**
- If \(p_{t-1} = 0\): set \(R_t = \max(R_{t-1}-1, 0)\) (forgive gradually)
- If \(0 < p_{t-1} \le 1/3\): set \(R_t = \max(R_{t-1}, 1)\) (light punishment)
- If \(1/3 < p_{t-1} \le 2/3\): set \(R_t = 2\) (stronger punishment)
- If \(p_{t-1} > 2/3\): set \(R_t = 2\) and treat as “near-collapse behavior”

**Action selection when \(S_t > S_{\text{low}}\):**
- If \(R_t > 0\): **Play D** and decrement \(R_t := R_t - 1\)
- Else: **Play C**

Intuition:  
- If most people cooperate, we cooperate and keep stock high.  
- If some defect, we retaliate enough to make defection less attractive, but we don’t spiral into permanent mutual defection.  
- If many defect, we defect too (resource and self-protection), but we remain willing to return to cooperation when the group does.

### C. “Collapse prevention” override (trajectory-based)
Even if the retaliation meter would cooperate, defect if last round’s behavior implies the next stock likely drops below the danger zone.

Compute last round’s total consumption fraction of stock:
- Cooperators consume \(S/(2n)\), defectors consume \(S/n\)
- If \(d\) defectors, total consumed fraction of \(S\) is:
  \[
  \frac{(n-d)}{2n} + \frac{d}{n} = \frac{1}{2} + \frac{d}{2n}
  \]
So remaining stock fraction after consumption is:
\[
1 - \left(\frac{1}{2} + \frac{d}{2n}\right) = \frac{1}{2} - \frac{d}{2n}
\]
If \(d \ge n/2\), remaining stock is \(\le S/4\), often hazardous.

**Override:**
- If last round \(d_{t-1} \ge \lceil n/2 \rceil\) and \(S_t < S_{\text{high}}\): **Play D**  
(You are in a high-defection environment and stock isn’t fully safe.)

---

# 2) Edge cases (first round, last round, etc.)

### First round (t = 1)
- **Play C** unless stock is already low (it starts at capacity by spec, so normally **C**).  
Reason: cooperation from the start is the only way to reach the high-payoff steady state; it also probes whether others are willing.

Initialize:
- \(R_1 = 0\)

### Last round (t = r)
Endgame incentives push toward defection. But a purely “always defect last round” rule can trigger earlier unraveling if others anticipate it (some strategies do). We use a conditional last-round policy:

- If \(S_r \ge S_{\text{high}}\) **and** \(p_{r-1}=0\): **Play C** (reward full cooperation)
- Otherwise: **Play D**

Rationale: if the group proved cooperative and stock is safe, keep the collective norm; otherwise, take the safe payoff.

### Final 2 rounds (t = r-1)
Slightly stricter, because there’s little future to punish:
- If \(S_{r-1} < S_{\text{high}}\) or \(p_{r-2} > 0\): bias to **D** (set \(R_{r-1}= \max(R_{r-1},1)\))

### Extremely low stock
If \(S_t\) is near 0, both actions yield near-0 payoff; however, D weakly dominates in one-shot terms. The strategy already defects when \(S_t \le S_{\text{low}}\), which covers this.

---

# 3) Collective mindset (what it optimizes and why it’s robust)

### Collective target behavior
- **If everyone follows SGRC**, play C almost always, keeping stock near capacity (a self-replenishing “golden path”), achieving high cumulative payoffs.
- The strategy is designed so that in cooperative populations it is *forgiving* (returns to C quickly), minimizing accidental punishment cycles.

### Robustness to opponents
- **Against always-defect / high-defection strategies:** SGRC quickly switches to D (via stock safeguard + retaliation), avoiding being a “sucker” while still allowing recovery if the environment changes.
- **Against noise / occasional defection:** limited retaliation (1–2 rounds) plus forgiveness prevents lock-in to mutual defection.
- **Against conditional cooperators / reciprocators:** the initial C and predictable retaliation/f forgiveness pattern tends to synchronize toward cooperation.
- **Against “endgame defectors”:** the last-round conditionality avoids being consistently exploited without pre-committing to unraveling.

---

# Pseudocode (implementable)

```pseudo
parameters: n, r, capacity
constants:
  S_low  = 0.5 * capacity
  S_high = 0.8 * capacity

state:
  R = 0  // retaliation meter in {0,1,2}

for t in 1..r:
  observe current stock S

  if t == 1:
     action = C
     play(action)
     continue

  // compute last round defection rate
  d = count_defectors_last_round()
  p = d / n

  // update retaliation meter
  if p == 0:
     R = max(R - 1, 0)
  else if p <= 1/3:
     R = max(R, 1)
  else:
     R = 2

  // last rounds tightening
  if t == r-1:
     if S < S_high or p > 0:
        R = max(R, 1)

  // last round special rule
  if t == r:
     if S >= S_high and p == 0:
        action = C
     else:
        action = D
     play(action)
     continue

  // stock safeguard
  if S <= S_low:
     action = D
     play(action)
     continue

  // collapse prevention override
  if d >= ceil(n/2) and S < S_high:
     action = D
     play(action)
     continue

  // retaliation execution
  if R > 0:
     action = D
     R = R - 1
  else:
     action = C

  play(action)
```

---

## Summary in one line
**Cooperate when stock is safe and the group is mostly cooperating; retaliate proportionally and briefly when defection appears; defect when stock is in danger or defection is widespread; forgive quickly to re-enter the high-stock cooperative regime.**
'''

description_COLLECTIVE_28 = '''
## Strategy: **Stock-Guardian with Forgiving Reciprocity (SGFR)**  
Goal: keep the stock near a “safe high” region where the resource regenerates strongly, while deterring persistent over-consumption. The strategy is collective (defaults to C), adaptive (responds to observed behavior and stock), and robust (doesn’t require coordination signals or fixed schedules).

---

# 1) Decision rules (when to C vs D)

### Key intuition
- **C is the default** because mutual C maximizes long-run total extraction by keeping stock high.
- **D is used only as a control action** in two situations:
  1) **Punishment/containment:** when others are over-consuming (many D’s), to avoid being the “sucker” and to reduce the incentive to defect.
  2) **Emergency salvage:** when stock is already low, immediate payoff matters and the game may be collapsing; also, a single cooperator cannot restore the stock alone.

### What you observe each round
From the previous round \(t-1\):
- \(S_t\): current stock entering round \(t\)
- \(d_{t-1}\): number of defectors last round (count of players who played D)

### Thresholds derived from parameters
Let:
- **Safe stock level**:  
  \[
  S_{\text{safe}} = 0.8 \times \text{capacity}
  \]
  (high enough that recovery is easy; not too strict)
- **Danger stock level**:  
  \[
  S_{\text{danger}} = 0.35 \times \text{capacity}
  \]
  (below this, the system is in a fragile region; salvage behavior kicks in)
- **Defection tolerance** (how many defectors you tolerate while still cooperating):  
  \[
  d_{\text{tol}} = \left\lfloor \frac{n}{4} \right\rfloor
  \]
  (allows a few “noisy” or exploratory defectors without collapsing cooperation)

### Core decision rule
In round \(t\):

**Rule A — Cooperative default (collective mode): play C if all are true**
1) \(S_t \ge S_{\text{danger}}\) (stock not in emergency), and  
2) \(d_{t-1} \le d_{\text{tol}}\) (defection is rare/recoverable), and  
3) you are not currently in a punishment phase (defined below).

**Otherwise: play D** (protect yourself + apply pressure).

---

## Punishment and forgiveness (robust reciprocity)
When defection becomes significant, SGFR enters a **temporary punishment phase** designed to:
- remove the immediate advantage of defecting, and
- clearly condition cooperation on returning to cooperative behavior.

### Trigger
If \(d_{t-1} > d_{\text{tol}}\), start (or extend) punishment.

### Punishment length (adaptive)
Let:
\[
L = 1 + \left\lceil \frac{d_{t-1} - d_{\text{tol}}}{\max(1, n - d_{\text{tol}})} \times 3 \right\rceil
\]
So punishment is at least 2 rounds when defection is meaningfully above tolerance, and gets longer when defection is widespread.

### Behavior in punishment phase
- **Play D** for the remaining punishment rounds.
- **Forgiveness condition (early exit):** if in any round you observe \(d_{t} = 0\) (everyone cooperated), then **end punishment immediately** and return to cooperative default next round.

This makes it forgiving (can quickly re-stabilize cooperation), yet credible (defection causes multi-round consequences).

---

# 2) Edge cases

### First round (t = 1)
- **Play C.**  
Rationale: you lose nothing by attempting to establish cooperation; and early stock is typically high (capacity), so cooperative norms have maximum value.

### Last round (t = r)
- **Play D.**  
Rationale: there is no future to protect; endgame unraveling is expected in tournaments. Defecting avoids being exploited by strategies that “cash out” at the end.

### Second-to-last round (t = r-1)
- If \(S_{r-1} \ge S_{\text{safe}}\) and defection has been low recently (\(d_{r-2} \le d_{\text{tol}}\)), **play C**.
- Otherwise **play D**.
Rationale: one last attempt at collective payoff if the system is healthy; otherwise protect yourself.

### Emergency low-stock regime
If \(S_t < S_{\text{danger}}\):  
- **Play D** (unless it is very early and defection-free—still, default is D here).  
Rationale: with low stock, cooperation yields tiny payoffs, and you need strong disincentives against continued defection. Also, the logistic growth term is small when stock is near zero; recovery is hard without broad cooperation, so unilateral C is usually wasted.

---

# 3) “Collective mindset” alignment

SGFR is collective because it:
- **Starts with cooperation** and maintains it under modest noise.
- **Defends the commons** by conditioning cooperation on the group’s behavior (not on individual grudges), which is appropriate since the harm is collective.
- **Punishes proportionally and forgives quickly**, aiming to restore high-stock cooperation rather than spiral into permanent retaliation.
- **Uses stock-based safeguards** to avoid “cooperating into collapse” when the resource is already endangered.

---

# Pseudocode (implementable)

```python
# Parameters: n, r, capacity
S_safe   = 0.8 * capacity
S_danger = 0.35 * capacity
d_tol    = n // 4

punish_remaining = 0

for t in 1..r:
    observe current stock S_t
    if t == 1:
        action = "C"
    elif t == r:
        action = "D"
    else:
        # observe last-round defections d_prev (from history)
        d_prev = num_defectors[t-1]

        # forgiveness: if everyone cooperated last round, clear punishment
        if d_prev == 0:
            punish_remaining = 0

        # emergency stock rule
        if S_t < S_danger:
            action = "D"

        else:
            # trigger/extend punishment
            if d_prev > d_tol:
                L = 1 + ceil(((d_prev - d_tol) / max(1, n - d_tol)) * 3)
                punish_remaining = max(punish_remaining, L)

            if punish_remaining > 0:
                action = "D"
                punish_remaining -= 1
            else:
                action = "C"

    play(action)
```

---

## Why this should perform well in a tournament
- Against cooperators: quickly converges to near-all C, maintaining high stock and high long-run payoffs.
- Against intermittent defectors/noisy strategies: tolerates small defection without collapsing cooperation; proportional punishment discourages repeated exploitation.
- Against always-defect or endgame-cashout types: doesn’t remain a sucker; shifts to D when defection is common and in the final round.
- Against strategies that try to “farm” cooperators: the defection threshold + punishment makes farming unprofitable.

If you want, I can tune the constants (0.8, 0.35, the punishment scaling “3”) for specific ranges of \(n, r,\) and capacity, or propose an alternative variant that is harsher/softer depending on tournament meta.
'''

description_COLLECTIVE_29 = '''
## Collective Strategy: **Stock-Guard Conditional Cooperation (SGCC)**

Goal: keep the common stock near capacity (high sustainable yield) while discouraging exploitation. The strategy is **collectively oriented by default**, but **switches to defection** when cooperation is not reciprocated or when the stock is in danger of collapse.

This strategy uses only: parameters `(n, r, capacity)`, current `stock S_t`, and full history of actions/payoffs.

---

# 1) Decision rules (when to cooperate vs defect)

### Key idea
- When stock is healthy, **cooperate unless opponents are persistently over-consuming**.
- When stock is fragile, **defect to protect yourself** (because others’ defection can wipe the stock and your future payoffs).
- Use a **simple reciprocity test** based on observed fraction of defectors, with forgiveness when stock is high.

### Quantities computed each round `t`
Let:
- `S = current stock at start of round t`
- `d_{t-1} = (# of opponents who played D in round t-1) / (n-1)` (for t>1)
- `d̄ = average defection rate among opponents over last W rounds` (rolling window)
- Choose a small window `W = 3` (works across many r; if r<4, use W = t-1)

Define stock “zones”:
- **Safe**: `S >= 0.80 * capacity`
- **Caution**: `0.40 * capacity <= S < 0.80 * capacity`
- **Critical**: `S < 0.40 * capacity`

Define reciprocity thresholds:
- `T_safe = 0.35` (tolerate some noise/experimentation when stock is abundant)
- `T_caution = 0.20` (be stricter when stock is lower)

### Core rule
**Round t decision:**

1) **If stock is Critical (`S < 0.40*capacity`)**  
   → **Play D**  
   Rationale: in low stock, one-sided cooperation is punished heavily and collapse risk is high; you need immediate payoff and to avoid being the “sucker”.

2) **Else if stock is Caution (`0.40*capacity <= S < 0.80*capacity`)**  
   - If `d̄ > T_caution` → **Play D**  
   - Else → **Play C**  
   Rationale: conditional cooperation to rebuild/maintain stock; punish consistent defection quickly.

3) **Else stock is Safe (`S >= 0.80*capacity`)**  
   - If `d̄ > T_safe` → **Play D**  
   - Else → **Play C**  
   Rationale: be generous when the resource is robust; still deter chronic exploiters.

### Forgiveness / recovery rule
If you have been defecting due to punishment, you don’t want to lock into mutual defection forever.

So after any round where you played D:
- If `S >= 0.80*capacity` **and** `d_{t-1} == 0` (everyone else cooperated last round)  
  → **Return to C** immediately next round.

This allows rapid restoration of collective cooperation when others demonstrate it.

---

# 2) Edge cases (first round, last round, and special situations)

### First round (t = 1)
- **Play C**, unless stock is already low (nonstandard initial state):
  - If `S_1 < 0.40*capacity` → play D
  - Else play C

Rationale: collective stance from the start; if the stock starts damaged, protect yourself.

### Last round (t = r)
In the last round, there is no future stock value, so the collective motive weakens—many opponents will defect.

Rule:
- If `S_r` is Safe (`>= 0.80*capacity`) **and** opponents have been mostly cooperative (`d̄ <= 0.20`)  
  → **Play C** (collective “finish strong”)
- Otherwise → **Play D**

This avoids being exploited by endgame defection while still rewarding consistently cooperative groups.

### Very short games (small r)
If `r <= 3`, reciprocity learning is limited:
- Use `W = t-1` and rely more on the stock zones:
  - Critical → D
  - Otherwise start C, punish only if defection is obvious (`d_{t-1} >= 0.5`)

### If the stock hits zero
If `S == 0`, both C and D yield zero that round. But you still want to prevent being the only cooperator later if recovery is possible in other parameterizations.
- Play **D** until `S` exits Critical.

(With the given dynamics, if it truly reaches 0 it may stay 0; this rule is still safe.)

---

# 3) Collective alignment (why this is “collective”)

- **Default is cooperation** whenever the stock can sustain it and opponents aren’t exploiting.
- The strategy uses **resource-health triggers**: it cooperates to keep the system near capacity (where growth is strong and yields are high).
- Punishment is **measured, state-dependent, and forgiving**: it deters defection but returns to cooperation quickly when the group does.
- It is robust against:
  - Always-defectors (you switch to D and stop subsidizing them),
  - Grim-trigger types (you won’t defect unless necessary; forgiveness helps),
  - Noisy or exploratory strategies (tolerance in Safe zone),
  - Endgame defection (last-round rule).

---

## Pseudocode (implementable)

```pseudo
parameters: n, r, capacity
constants:
  W_base = 3
  SAFE = 0.80 * capacity
  CRIT = 0.40 * capacity
  T_safe = 0.35
  T_caution = 0.20

state tracked:
  history of opponents' actions each round

function opponent_defection_rate(last k rounds):
  count D among all opponents across those rounds / ((n-1)*k)

for round t = 1..r:
  S = current_stock()

  if t == 1:
     if S < CRIT: play D else play C
     continue

  W = min(W_base, t-1)
  dbar = opponent_defection_rate(last W rounds)
  d_last = opponent_defection_rate(last 1 round)  // fraction of opponents who defected in t-1

  // Last round adjustment
  if t == r:
     if S >= SAFE and dbar <= 0.20:
        play C
     else:
        play D
     continue

  // Immediate forgiveness: if others fully cooperated last round and stock is healthy
  if (my_action_{t-1} == D) and (S >= SAFE) and (d_last == 0):
     play C
     continue

  // Stock-zone rules
  if S < CRIT:
     play D
  else if S < SAFE:  // Caution zone
     if dbar > T_caution: play D else play C
  else:              // Safe zone
     if dbar > T_safe: play D else play C
```

---

If you want, I can also propose a **more aggressive “stock-target controller” variant** that explicitly estimates the expected next stock under C vs D and chooses the action that keeps `S` near capacity while maintaining incentive compatibility—but SGCC above is a strong, simple tournament-ready baseline.
'''

description_COLLECTIVE_30 = '''
## Strategy: **Stock-Guardian with Graduated Reciprocity (SGR)**  
Collective objective: keep the resource near the regenerative sweet spot and reward groups that sustain it; punish groups that drain it—quickly, but not irreversibly—so cooperation can re-emerge.

Key idea: in this game, **full cooperation keeps stock at capacity** (because remaining stock becomes 1/2 capacity each round, which regrows back to capacity). Defection is immediately tempting but collectively catastrophic if widespread. So we:
- **Default to C** when the group appears sustainable.
- **Switch to D** when observed behavior implies over-harvesting that risks collapse.
- **Return to C** after the group shows restraint (forgiveness), because future rounds are valuable and stock can recover.

---

# 1) Decision rules (C vs D)

### Notation observed at end of each round \(t\)
- \(S_t\): stock at start of round \(t\)
- \(S_{t+1}\): stock after consumption+growth (start of next round)
- \(D_t\): number of players who defected in round \(t\) (observable from actions)
- \(\hat{k}_t\): estimated number of defectors based on stock drop (backup if action logs are noisy)  
  \[
  \hat{k}_t = \text{round}\left(2n\left(1 - \frac{S_{\text{rem}}}{S_t}\right)\right) - n
  \]
  where \(S_{\text{rem}}\) is stock after consumption, before growth (if not directly observable, you can reconstruct from known rule; in many tournament setups you will have actions so this is just a fallback).

### Compute an “overuse signal”
Let
- \(k_t = D_t\) (use actual defector count when available; else \(\hat{k}_t\))
- **Overuse fraction**: \(x_t = k_t/n \in [0,1]\)

Interpretation: if \(x_t\) is high, the group is extracting too much and future stock is endangered.

---

## Core policy
We maintain two internal variables:
- **punish_level** \(p \in \{0,1,2,3\}\) (how hard we punish right now)
- **cooldown** \(c \ge 0\) (how long we stay in punishment mode)

### Thresholds (parameter-only)
- **Sustainable zone**: \(S_t \ge 0.8 \cdot \text{capacity}\)
- **Warning zone**: \(0.4 \cdot \text{capacity} \le S_t < 0.8 \cdot \text{capacity}\)
- **Critical zone**: \(S_t < 0.4 \cdot \text{capacity}\)

These are chosen because logistic growth is strong when stock is not too low, and collapse risk increases sharply when repeated overuse drives stock downward.

---

## Action rule (what to play this round)
### Default
- If not in punishment mode (cooldown \(c=0\)): **play C**.

### Punishment mode
- If cooldown \(c>0\): **play D** and decrement cooldown by 1.

This makes punishment simple, visible, and costly to defectors (they get less future stock), while also being self-protective when others are exploiting.

---

## Updating punishment mode (after observing round \(t\))
After each round, update based on both **behavior** and **state**.

### Step A: Escalate if exploitation is detected
Set a “trigger” if any of the following hold:
1) **Many defectors**: \(x_t \ge 1/3\)  
2) **Stock is falling out of sustainable zone** and there is any defection:  
   - if \(S_{t+1} < 0.8\cdot \text{capacity}\) and \(k_t \ge 1\)
3) **Critical stock** regardless of defection count:  
   - if \(S_{t+1} < 0.4\cdot \text{capacity}\)

If triggered, set punishment severity:
- If \(S_{t+1} < 0.4\cdot \text{capacity}\) **or** \(x_t \ge 1/2\): set \(p=3\)
- Else if \(x_t \ge 1/3\): set \(p=2\)
- Else: set \(p=1\)

Then set cooldown length:
- \(c = p\) (1–3 rounds of D)

Rationale: you punish longer when the group is clearly over-harvesting or stock is near danger.

---

### Step B: Forgive quickly when restraint returns
If **in punishment mode** and you observe both:
- \(k_t = 0\) (everyone cooperated), and
- \(S_{t+1} \ge S_t\) (stock is recovering or stable),
then **end punishment early**:
- set \(c = 0\), \(p=0\) (return to C next round)

Rationale: if the group returns to cooperation, don’t keep dragging stock down with continued D; you want to re-coordinate on the efficient path.

---

### Step C: Anti-exploitation “ratchet”
If **you cooperated** in round \(t\) and saw exploitation (e.g., \(k_t \ge 1\)) while stock is already outside sustainable zone (\(S_{t+1}<0.8\cdot \text{capacity}\)), then treat it as more serious:
- increase \(p\) by 1 (cap at 3), set \(c=p\)

Rationale: prevents being a repeated sucker against strategies that sprinkle occasional defections.

---

# 2) Edge cases

### First round (t = 1)
- **Play C**.
- Reason: starting at capacity, cooperation is collectively optimal and also the best attempt at establishing a cooperative basin. Immediate D destroys trust and can collapse the stock if others do the same.

### Last round (t = r)
There is an end-game temptation to defect. But in tournaments, opponents vary: some will exploit end-game, some won’t, and some punish end-game defection harshly earlier if they anticipate it.

Rule:
- If \(r\) is known and \(t=r\):
  - If stock is **critical** (\(S_t < 0.4\cdot \text{capacity}\)) or last round is already in punishment mode: **play D** (self-protection; no future to rebuild).
  - Otherwise: **play C** (collective signal; avoids triggering “grim” opponents in penultimate rounds that predict last-round D).

### Penultimate round (t = r-1)
- Follow normal rules with one extra caution:  
  If stock is in **warning/critical** and you observe any defection in \(t=r-1\), escalate punishment immediately (set \(c=1\) so you defect in the final round).

---

# 3) Why this is collectively aligned and robust

**Collective alignment**
- When cooperation is common, SGR keeps stock near capacity, maximizing long-run total payoff.
- It prioritizes stock recovery (quick forgiveness) so the group can return to the high-yield cooperative path.

**Robustness**
- Against always-defect or frequent-defect strategies: SGR rapidly switches to D for multiple rounds, avoiding being consistently exploited and signaling intolerance.
- Against noisy or mixed strategies: graduated, finite punishment avoids permanent collapse and allows re-coordination.
- Against conditional cooperators: visible, contingent punishment/reward resembles widely successful tournament strategies (reciprocity with forgiveness).

---

# Pseudocode (implementable)

```pseudo
init:
  c = 0          # cooldown remaining
  p = 0          # punish level
for t in 1..r:
  observe S_t

  # choose action
  if c > 0:
    action = D
  else:
    action = C

  play(action)

  # after round, observe actions of others and new stock S_{t+1}
  k = number_of_defectors_among_others_plus_me?   # use total defectors D_t
  x = k / n

  # forgiveness condition (if we were punishing)
  if c > 0 and k == 0 and S_{t+1} >= S_t:
    c = 0
    p = 0
    continue

  # determine trigger
  trigger = false
  if x >= 1/3: trigger = true
  if S_{t+1} < 0.8*capacity and k >= 1: trigger = true
  if S_{t+1} < 0.4*capacity: trigger = true

  if trigger:
    if S_{t+1} < 0.4*capacity or x >= 1/2:
      p = 3
    else if x >= 1/3:
      p = 2
    else:
      p = 1

    # anti-exploitation ratchet
    if action == C and k >= 1 and S_{t+1} < 0.8*capacity:
      p = min(3, p + 1)

    c = p

  # decrement cooldown at start of next decision (or here)
  if c > 0:
    c = c - 1

# last round override:
# if t == r and (S_t < 0.4*capacity or c>0): play D else play C
```

(You can implement the cooldown decrement either immediately after setting it or at the top of the next loop—just be consistent.)

---

If you want, I can also provide: (a) a simplified version with fewer thresholds, or (b) a more “state-theoretic” controller that targets the stable point \(S \approx \text{capacity}\) by estimating implied total extraction each round and reacting continuously.
'''

description_COLLECTIVE_31 = '''
## Collective strategy: **Stock-Guard with Graduated Retaliation (SGR)**

Goal: keep the stock in (or quickly return it to) the high-growth region while making defection unprofitable over time. The strategy is **state-based** (protect stock) and **history-based** (punish exploiters), with forgiveness to recover cooperation when others do.

Key idea: Treat the round as a choice between:
- **C** = “sustainable take” (stock/(2n))
- **D** = “extra take” (stock/n) that increases collapse risk

We cooperate by default when stock is healthy and opponents are not exploiting; we defect when (a) stock is in danger, or (b) opponents are defecting enough that cooperating is being exploited.

---

# 1) Decision rules (when to cooperate vs defect)

### Quantities computed each round \(t\)
Let:
- \(S_t\) = current stock at start of round \(t\)
- \(d_{t-1}\) = number of defectors in the previous round (from observed actions)
- \(x_{t-1} = d_{t-1}/n\) = last-round defection rate
- Maintain a “trust score” \(T_t\) based on recent defection rates (EWMA):

\[
T_t = \lambda T_{t-1} + (1-\lambda) x_{t-1}, \quad \lambda \in [0.6,0.8]
\]

Interpretation: \(T_t\) is a smoothed estimate of “how defect-prone the group is”.

---

## A. Stock-safety override (protect against collapse)
If stock is low, prioritize preventing a death spiral / avoiding being the only cooperator when stock is near zero.

- **If \(S_t \le S_{\text{low}}\)** then **play D**.
- **Else if \(S_t \ge S_{\text{high}}\)** then proceed to behavior rule (B).
- Otherwise (mid-stock) proceed to behavior rule (B) but with stricter punishment.

Recommended thresholds (parameter-only):
- \(S_{\text{low}} = 0.35 \cdot \text{capacity}\)
- \(S_{\text{high}} = 0.80 \cdot \text{capacity}\)

Rationale: With logistic growth, very low stock can be slow to recover, and any defection can keep it suppressed; at high stock, cooperation sustains capacity (as in your example).

---

## B. Graduated retaliation & forgiveness (collective enforcement)
Define two defection tolerance cutoffs:
- “mostly cooperative” cutoff: \(\theta_C = 1/n\) (≈ one defector)
- “uncooperative group” cutoff: \(\theta_D = 2/n\) (≈ two defectors)

Decision rule:
1. **If \(T_t \le \theta_C\)**: **play C**  
   (Group is behaving; reward cooperation.)
2. **If \(\theta_C < T_t \le \theta_D\)**: **play C** unless stock is mid/low; otherwise **mix in mild punishment**:
   - If \(S_t < S_{\text{high}}\): **play D** (pressure to stop drifting into overuse)
   - Else: **play C**
3. **If \(T_t > \theta_D\)**: **play D**  
   (Enough defection that unconditional cooperation is exploitable.)

This makes punishment **proportional** and **forgiving**: once defection declines, \(T_t\) falls and we return to C automatically.

---

## C. Targeted escalation for repeated exploiters (without needing identity coordination)
Even though actions are observed, strategies are independent and we can’t coordinate. Still, we can punish persistent defectors using only history.

Maintain for each player \(j\) a rolling count \(D_j\) = number of times \(j\) defected in the last \(w\) rounds (e.g., \(w=5\)).

Escalation rule:
- If there exists **any** player with \(D_j \ge 4\) (chronic defector) and \(S_t < S_{\text{high}}\), then **play D**.
- Otherwise follow rules A+B.

Reason: a chronic defector in a fragile stock region will continually harvest more and push the system downward; collective discipline is needed. This is “collective” because it protects the stock and discourages free-riding, not because it coordinates with any one agent.

---

# 2) Edge cases

## Round 1 (no history)
- **Play C** if \(S_1 \ge S_{\text{high}}\) (which it is if initialized at capacity).
- Else **play D** (if game begins in a damaged state).

This establishes a cooperative baseline and tests others.

## Last rounds (endgame pressure)
In finite repeated games, many agents defect at the end. We respond without precommitting to unconditional endgame defection (which would help collapse).

Let \(k\) = remaining rounds including current.

- If \(k \le 2\) (last two rounds):  
  - If \(T_t \le \theta_C\) **and** \(S_t \ge S_{\text{high}}\): **play C** (finish strong if group stayed cooperative).  
  - Else: **play D** (don’t be exploited in the endgame).

This is robust: it preserves cooperation when it’s clearly stable, but avoids being the “sucker” if others unravel.

## Stock at/near zero
If \(S_t\) is extremely low (e.g., \(S_t \le 0.05\cdot \text{capacity}\)), always **play D**.  
Reason: with tiny stock, payoffs are tiny anyway, and you need to avoid being the only one restraining while others take double.

## “Everyone defected last round”
If \(x_{t-1}=1\), then **play D** until \(x\) drops below \(2/n\) for two consecutive rounds (using EWMA effectively enforces this). This avoids single-round “fake cooperation” traps.

---

# 3) Collective mindset (why this is collective and robust)

- **Collective first**: default is cooperation whenever stock is healthy and group behavior is not strongly exploitative. This keeps the resource near capacity where logistic growth replenishes efficiently.
- **No naïveté**: it punishes defection quickly (via thresholds and EWMA) so exploiters don’t earn sustained advantage.
- **Forgiving**: once opponents return to cooperation, the EWMA trust score declines and we revert to C without requiring coordination or communication.
- **State-aware**: it tightens discipline when stock is mid/low to prevent tipping into collapse, and relaxes when stock is high.

---

## Pseudocode (implementation-ready)

```python
# parameters
lambda_ = 0.7
w = 5
S_low  = 0.35 * capacity
S_high = 0.80 * capacity
theta_C = 1 / n
theta_D = 2 / n

# state
T = 0.0  # start optimistic (no defection observed yet)
history_actions = []  # list of dicts: {player_id: action}

def decide(t, S, r, history_actions, T):
    k = r - t + 1  # rounds remaining incl current

    # --- compute last-round defection rate if available ---
    if t > 1:
        last = history_actions[-1]
        d_last = sum(1 for a in last.values() if a == 'D')
        x_last = d_last / n
        T = lambda_ * T + (1 - lambda_) * x_last
    else:
        x_last = 0.0

    # --- stock-safety override ---
    if S <= 0.05 * capacity:
        return 'D', T
    if S <= S_low:
        return 'D', T

    # --- chronic defector detection in last w rounds ---
    if t > 1:
        recent = history_actions[-min(w, len(history_actions)):]
        # count defections per player
        D_counts = {j: 0 for j in range(1, n+1)}
        for rnd in recent:
            for j,a in rnd.items():
                if a == 'D':
                    D_counts[j] += 1
        chronic = any(cnt >= 4 for cnt in D_counts.values())
        if chronic and S < S_high:
            return 'D', T

    # --- endgame handling ---
    if k <= 2:
        if T <= theta_C and S >= S_high:
            return 'C', T
        else:
            return 'D', T

    # --- graduated retaliation ---
    if T <= theta_C:
        return 'C', T
    elif T <= theta_D:
        if S < S_high:
            return 'D', T
        else:
            return 'C', T
    else:
        return 'D', T
```

---

If you want, I can also provide (a) recommended alternative threshold settings for very small n (e.g., n=2) and (b) a variant that explicitly optimizes for keeping the stock near the logistic growth maximizer (≈ capacity/2 after consumption) rather than near capacity.
'''

description_COLLECTIVE_32 = '''
## Strategy: **Stock-Guarded Reciprocal Cooperation (SGRC)**  
Collective objective: keep the stock near *capacity* to maximize long-run total surplus, while deterring repeated over-extraction by switching to defection when needed. The strategy adapts using only observable history (who defected) and the current stock.

### Core intuition
- If the group extracts “moderately” (many C), stock regrows to capacity and everyone can keep earning.
- If too many defect (many D), stock collapses and everyone’s future payoffs crash.
- So we:  
  1) **Cooperate by default when stock is healthy**,  
  2) **Punish over-extraction enough to change incentives**,  
  3) **Forgive and return to cooperation once the stock is safe again**,  
  4) **Shift to self-protection near the end** (finite horizon).

---

## 1) Decision rules (C vs D)

### Variables observed each round
- `S_t`: current stock at start of round `t`
- `d_{t-1}`: number of players who defected in round `t-1`
- For each opponent `j`: their action history, especially whether they defected recently

### Derived thresholds (depend only on parameters)
- **Healthy stock threshold:**  
  `S_high = 0.8 * capacity`  
  Above this, the system is resilient and cooperation is worth attempting.
- **Danger stock threshold:**  
  `S_low = 0.4 * capacity`  
  Below this, recovery is fragile; we prioritize preventing collapse.
- **Defection tolerance:**  
  `d_tol = floor((n-1)/3)`  
  We tolerate a small minority defecting without immediately flipping the whole stance, because harsh punishment for tiny noise can destroy cooperation.
- **Punishment length base:**  
  `L_base = 2`  
  (Short but noticeable.)
- **Escalation factor:**  
  additional punishment if defection persists.

### Main rule set
At the start of round `t`:

**Rule A — First round: cooperate.**  
- Play `C` in round 1 (creates a cooperative baseline and reveals opponents).

**Rule B — Stock emergency: defect to preserve what’s left.**  
- If `S_t <= S_low`, play `D`.  
Rationale: when stock is low, any unilateral cooperation is easily exploited and may not restore sustainability.

**Rule C — Cooperative mode when stock is healthy and defection is limited.**  
- If `S_t >= S_high` **and** `d_{t-1} <= d_tol`, play `C`.  
Rationale: keep the stock near capacity; mild noise doesn’t justify collapse.

**Rule D — Reciprocal punishment when over-extraction is detected.**  
Trigger: if `d_{t-1} > d_tol` **or** if the stock is trending downward sharply (see Rule E).  
- Enter *punishment mode* for `L` rounds and play `D` during punishment.

Punishment length `L` is adaptive:
- Let `d_excess = max(0, d_{t-1} - d_tol)`
- `L = L_base + d_excess`  
So if many defect, punishment lasts longer.

**Rule E — Trend-based trigger (guards against slow collapse).**  
Even if defectors are “few”, stock can still drift down depending on state. Track `S_{t-1}`:
- If `S_t < 0.9 * S_{t-1}` (≥10% drop from last round’s start stock), treat as over-extraction and trigger punishment (Rule D).  
Rationale: catches coordinated exploitation or “just enough” defection to erode stock.

**Rule F — Forgiveness / return to cooperation.**  
After punishment ends, return to cooperation *only if*:
- `S_t >= S_high` **and** `d_{t-1} <= d_tol`  
Otherwise continue defecting (either because stock is not yet safe or opponents still defect).

---

## 2) Edge cases

### First round
- **Always C** (Rule A).

### Last rounds (finite horizon protection)
Cooperation is harder to sustain in the end because punishment has less future leverage. To remain robust:
- Define `T_end = max(1, floor(r/5))` (last 20% of game, at least 1 round).
- For rounds `t > r - T_end`:
  - If `S_t >= S_high` and defection last round is very low (`d_{t-1} == 0`), **play C**.
  - Otherwise **play D**.

This keeps cooperation possible when everyone is behaving, but avoids being the “sucker” when endgame defection starts.

### Stock at/near zero
- If `S_t` is extremely low (e.g., `S_t < capacity/(10n)`), **always D**.  
Reason: payoffs are tiny anyway; the priority is not allowing opportunists to take the remaining sliver while you cooperate.

### If everyone defects and stock is stuck at 0
- You can’t regrow from zero under the given dynamics (growth is 0 at S=0). In that absorbing state, actions don’t matter; the strategy will default to D by Rules B/D.

### Noise/one-off defection
- A single defector is tolerated if within `d_tol` and stock remains healthy (Rule C), preventing overreaction that destroys cooperation.

---

## 3) “Collective” alignment (what the strategy is optimizing for)
This is a *collective-first* strategy because:
- **Default stance is cooperation** when the ecosystem is safe (high stock), which is what maximizes long-run group payoffs.
- **Punishment is conditional and state-aware**, intended to restore cooperation rather than permanently collapse into mutual defection.
- **Forgiveness exists**: once stock and behavior indicate sustainability, the strategy returns to C.
- **Endgame caution** is minimal and conditional: it still cooperates late if the group is fully cooperative and stock is healthy.

---

## Pseudocode (implementable)

```python
def SGRC(t, r, n, capacity, S_t, history_actions, history_stock):
    # history_actions[t-1] gives list of actions by all players in previous round
    # history_stock[t-1] gives previous round start stock
    
    S_high = 0.8 * capacity
    S_low  = 0.4 * capacity
    d_tol  = (n-1) // 3
    L_base = 2
    T_end  = max(1, r // 5)

    if t == 1:
        return "C"

    prev_actions = history_actions[t-1]
    d_prev = sum(1 for a in prev_actions if a == "D")
    S_prev = history_stock[t-1]

    # Endgame rule
    if t > r - T_end:
        if S_t >= S_high and d_prev == 0:
            return "C"
        else:
            return "D"

    # Emergency low-stock rule
    if S_t <= S_low or S_t < capacity/(10*n):
        return "D"

    # Trend trigger (slow-collapse detection)
    trend_bad = (S_t < 0.9 * S_prev)

    # Punishment mode tracking (store externally as state: punish_remaining)
    if punish_remaining > 0:
        punish_remaining -= 1
        return "D"

    # Decide whether to punish
    if d_prev > d_tol or trend_bad:
        d_excess = max(0, d_prev - d_tol)
        punish_remaining = L_base + d_excess
        punish_remaining -= 1
        return "D"

    # Cooperative mode
    if S_t >= S_high and d_prev <= d_tol:
        return "C"
    else:
        # If stock not yet "healthy", be cautious
        return "D"
```

---

### Why this is robust in a tournament
- **Against cooperators:** quickly stabilizes at all-C with stock near capacity (maximizes long-run payoffs).
- **Against occasional defectors:** tolerates small noise; doesn’t spiral into endless punishment.
- **Against persistent defectors:** escalates to D and stops being exploited.
- **Against clever “near-threshold” exploiters:** the **trend trigger** detects gradual erosion even if defection counts stay just under tolerance.
- **Against endgame defection:** conditional endgame caution reduces being exploited late while still allowing late cooperation when safe.

If you want, I can tune the numeric thresholds (`0.8`, `0.4`, `10%`, `L_base`, `d_tol`) for specific `(n, r, capacity)` regimes or propose an alternative variant that uses per-opponent targeting (still without communication).
'''

description_COLLECTIVE_33 = '''
## Strategy: **Stock-Guarded Generous Trigger (SGGT)**  
Goal: keep the stock near a high, self-sustaining region (so everyone can keep earning), but punish depletion quickly enough that defection isn’t profitable for long. The strategy is “collective” because it prioritizes preserving the shared stock and returns to cooperation as soon as opponents stop over-consuming.

---

# 1) Decision rules (C vs D)

### Key observables each round *t*
- `S_t`: stock at start of round t  
- From last round (t−1): observed actions of others, so we can compute  
  - `kD_{t-1}` = number of defectors among the other `n-1` players  
  - `kD_all_{t-1}` = total defectors among all `n` players  
- We also know parameters `n, r, capacity`.

### Intuition
- **Default to C** when the group isn’t actively depleting the resource.
- **Switch to D** when others’ behavior indicates active over-consumption (to avoid being the “sucker” funding others’ high takes).
- **Use stock thresholds**: when stock is already low, even “fair” punishment by defecting can finish the resource off; so in low-stock states we shift to a *recovery-first* posture (cooperate) unless exploitation is extreme.

---

## Core rule set

### A. Stock “safety bands”
Define two thresholds based on capacity:

- `S_high = 0.8 * capacity`  (resource healthy)
- `S_low  = 0.35 * capacity` (resource at risk; prioritize recovery)

(These are intentionally simple and robust across n/capacity. You can adjust slightly, but keep the separation.)

### B. Cooperation is the baseline
Play **C** if *either* of the following holds:
1) Stock is endangered: `S_t <= S_low` **and** opponents are not overwhelmingly defecting  
2) Opponents were mostly cooperative last round (low observed defection)

Concretely:
- If `S_t <= S_low`:
  - Play **C** unless `kD_{t-1} >= ceil((n-1)*0.6)` (i.e., a strong majority of others defected).  
  Rationale: when stock is low, we try to rebuild unless we are being clearly exploited.

- If `S_t > S_low`:
  - Play **C** if `kD_{t-1} <= 1` (at most one defector among the other players last round).  
  Rationale: tolerate occasional noise/mistakes; keep the collective equilibrium stable.

### C. Punishment: defect, but in a controlled way
Play **D** when:
- Stock is not in the danger zone (`S_t > S_low`) **and**
- Last round showed meaningful defection: `kD_{t-1} >= 2`

Additionally, scale punishment by how bad it was:
- If `kD_{t-1}` is a strict majority of others (`>= ceil((n-1)/2)`), then defect until you observe a drop in defection (see “return to cooperation” below).
- If it’s a minority (2 up to just below half), defect for **one round** then test cooperation again.

### D. Return-to-cooperation rule (forgiveness / adaptation)
After you defect as punishment, you don’t stay hostile forever. You return to **C** when either:
- Opponents reduce defection to `kD_{t-1} <= 1`, or
- Stock drops into danger: `S_t <= S_low` (recovery overrides punishment)

This makes the strategy robust against:
- “Always Defect” (you end up mostly defecting too, avoiding being exploited)
- “Mostly Cooperate with occasional Defect” (you keep cooperation stable)
- “Conditional cooperators” (you coordinate quickly)
- Noisy policies (you forgive small errors)

---

# 2) Edge cases (first round, last round, etc.)

### Round 1
Play **C**.
- Collective intent signal, and it’s optimal for discovering cooperative types.
- With the growth function, mutual C can maintain stock at capacity in many parameterizations; starting C is rarely harmful and often crucial.

### Last round (round r)
Play **D** **unless** stock is in danger (`S_r <= S_low`) **and** you observed mostly cooperation recently.

Reason:
- In a finite-horizon setting, end-game defection is tempting. If everyone does it, stock may crash, but after the last round there is no future to protect.  
- However, if stock is already low, defecting may yield little anyway (since payoff scales with S), and cooperating can be weakly better if it preserves some value in the same round’s dynamic? (In your model, payoffs depend on start-of-round S only, so last-round C doesn’t increase your last-round payoff; still, the exception helps avoid pointless mutual destruction if opponents stay cooperative and you value collective norms in tournaments with varied scoring/selection.)

So implement:
- If `t == r`:  
  - If `S_t > S_low`: play **D**  
  - Else: play **C** if `kD_{t-1} <= 1`, else **D**

### Early rounds with no history (t = 2)
Use round-1 observations (`kD_1`) normally.

### If stock ever hits (or nearly hits) zero
If `S_t <= 0.05 * capacity`, play **C** unless an overwhelming majority defected last round.
- This is the “resuscitation” mode: once the resource collapses, everyone’s payoffs become tiny; cooperation is the only route to potential recovery, but you avoid being a pure sucker if nearly everyone defects.

---

# 3) Collective mindset (what this optimizes and why)

This strategy’s “collective” stance is operational:
- **Primary objective:** keep `S_t` in a high band where growth can refill after consumption, enabling sustained per-round payoffs for all.
- **Secondary objective:** don’t let unilateral or small-coalition defectors profit at cooperators’ expense; punish proportionally and quickly.
- **Tertiary objective:** restore cooperation fast once others stop over-consuming, to avoid long retaliatory spirals that destroy the stock.

It is explicitly designed to:
- **Stabilize full cooperation** when possible (high-payoff, sustainable).
- **Deter opportunism** (defection triggers immediate consequences).
- **Remain adaptive** across heterogeneous opponents without needing coordination.

---

# Pseudocode (implementable)

```python
def SGGT_action(t, r, n, capacity, S_t, history_actions):
    # history_actions: list of length t-1 with action profiles from past rounds
    # each profile lets us count how many others defected
    
    S_high = 0.8 * capacity
    S_low  = 0.35 * capacity
    S_crit = 0.05 * capacity

    if t == 1:
        return "C"

    last_profile = history_actions[t-2]  # round t-1 actions
    kD_others = count_defectors_among_others(last_profile)  # 0..n-1

    # Last round special handling
    if t == r:
        if S_t > S_low:
            return "D"
        else:
            return "C" if kD_others <= 1 else "D"

    # Critical stock: recovery-first unless overwhelming exploitation
    if S_t <= S_crit:
        return "C" if kD_others < int((n-1)*0.6 + 0.9999) else "D"

    # Low stock: prioritize rebuilding
    if S_t <= S_low:
        return "C" if kD_others < int((n-1)*0.6 + 0.9999) else "D"

    # Normal stock: generosity with proportional punishment
    if kD_others <= 1:
        return "C"
    else:
        # punish
        return "D"
```

(Optionally, you can add a “one-round test” mechanism: after any D, if kD_others drops to <=1, switch back to C immediately; the above already does that.)

---

If you want, I can also provide a variant tuned to maximize tournament performance under specific scoring rules (e.g., average payoff per round vs. total payoff, or if tournaments include many always-defectors), but the above is a robust baseline collective strategy.
'''

description_COLLECTIVE_34 = '''
## Strategy: **Stock-Guarded Forgiving Trigger (SGFT)**  
Goal: keep the resource near its sustainable high-stock region (so everyone can earn high per-round payoffs), while being hard to exploit by defect-heavy opponents. The key levers are (i) **protecting the stock** when it’s low, and (ii) **conditioning on observed opponent behavior** with a forgiving but escalating response.

### Intuition
- If the group mostly cooperates, stock stays high and everyone earns steady payoffs.
- If too many defect, stock collapses and future payoffs vanish. So we must deter persistent defection.
- But we also need **forgiveness**: punish briefly to correct behavior, then return to cooperation quickly if others do.

---

## 1) Decision rules (C vs D)

We compute two signals each round from history/state:

### A. **Stock safety signal**
Use stock at start of round \(S_t\) relative to capacity:
- **Safe:** \(S_t \ge 0.8 \cdot \text{capacity}\)
- **Caution:** \(0.5 \cdot \text{capacity} \le S_t < 0.8 \cdot \text{capacity}\)
- **Danger:** \(S_t < 0.5 \cdot \text{capacity}\)

(Thresholds are parameter-only and robust; they don’t assume any opponent norms.)

### B. **Observed defection pressure**
Let \(d_{t-1}\) be the number of opponents who played **D** last round (you observe this). Define a **defection rate**:
\[
\delta_{t-1} = \frac{d_{t-1}}{n-1}
\]

Also track a short memory of defections to avoid overreacting to noise:
- \( \bar{\delta}_{t-1} \) = average defection rate over the last **L** rounds (e.g., \(L = 3\), or fewer if early).

### Core rule
At the start of round \(t\), choose:

**Rule 1 — Protect the commons when stock is low (Danger):**  
- If \(S_t < 0.5\cdot \text{capacity}\): **Play C**.  
Reason: defecting accelerates collapse; with low stock, even defect gains are small and damage is huge. This is “collective first aid.”

**Rule 2 — Cooperative default when stock is safe and others are mostly cooperative:**  
- If \(S_t \ge 0.8\cdot \text{capacity}\) **and** \( \bar{\delta}_{t-1} \le 0.25\): **Play C**.  
Reason: sustain the good regime.

**Rule 3 — Graduated deterrence when defection is significant:**  
- If \( \bar{\delta}_{t-1} > 0.25\): enter/continue a **punishment mode** that plays **D** for a limited number of rounds, then tests cooperation.

Punishment length depends on how bad defection is:
- If \(0.25 < \bar{\delta}_{t-1} \le 0.5\): punish for **1** round (play D), then test C.
- If \(0.5 < \bar{\delta}_{t-1} \le 0.75\): punish for **2** rounds.
- If \( \bar{\delta}_{t-1} > 0.75\): punish for **3** rounds.

**But** punishment is overridden by stock protection:
- If stock enters **Danger**, always revert to **C** (even during punishment), because collective survival dominates deterrence.

**Rule 4 — Recovery / cooperation testing:**  
After punishment ends, play **C** for one round as a “test.”  
- If opponents’ defection drops back to \( \bar{\delta} \le 0.25\), remain in cooperative mode (C).
- If not, re-enter punishment with updated severity.

This makes the strategy **forgiving** (returns to C quickly when others do) and **robust** (escalates against persistent defectors).

---

## 2) Edge cases

### First round
**Play C.**  
Rationale: you can’t condition on history yet; cooperative seeding maximizes chance of reaching/staying at the high-stock attractor and signals a collective intent.

### Last round
There is a temptation to defect at the end. However, in tournaments you face many strategies, some of which retaliate even for “final-round” defection (because they may not special-case the end, or because they compute rolling punishments). Also, your defection in the last round still harms the group payoff in that round by reducing stock before growth (and there is no future).  

**Rule for final round \(t=r\):**
- If \( \bar{\delta}_{r-1} \le 0.25\) and \(S_r \ge 0.5\cdot \text{capacity}\): **Play C** (finish collectively).
- Otherwise: **Play D** (don’t be the sole cooperator among defectors).

### Very small stock (near 0)
If \(S_t\) is extremely low, both C and D yield tiny immediate payoff, but D risks keeping the stock pinned at 0.  
So the strategy’s “Danger ⇒ C” rule stands: **Play C**.

### Capacity constraints / parameter extremes
- Works for any \(n\ge2\), any \(r>1\), any capacity \(\ge 2n\), because it only uses ratios of capacity and observed actions.
- If capacity is huge relative to \(n\), cooperation is even more attractive; thresholds still keep you in C most of the time.
- If opponents are random/noisy, the 3-round averaging reduces whiplash.

---

## 3) “Collective mindset” features (what makes it collective)
1. **Stock-first safeguard:** when the commons is threatened, it cooperates even if that reduces short-run individual gain.
2. **Graduated sanctions:** it punishes to protect the cooperative regime, but only as much as needed and with quick forgiveness.
3. **Re-entry testing:** it actively seeks to restore mutual cooperation rather than locking into permanent conflict.
4. **No reliance on coordination:** it does not assume others share schedules, norms, or communication; it reacts only to state/history.

---

## Pseudocode (implementable)

```pseudo
parameters:
  SAFE = 0.8
  DANGER = 0.5
  L = 3   # memory length
  LOW_DEFECT = 0.25

state variables:
  punish_remaining = 0

function choose_action(t, S_t, history):
  if t == 1:
    return C

  # compute average defection rate over last L rounds
  deltas = []
  for k in last min(L, t-1) rounds:
    d_k = number_of_opponents_who_played_D_in_round(k)
    deltas.append(d_k / (n-1))
  avg_defect = mean(deltas)

  # stock protection overrides everything
  if S_t < DANGER * capacity:
    punish_remaining = 0
    return C

  # last round rule
  if t == r:
    if avg_defect <= LOW_DEFECT and S_t >= DANGER * capacity:
      return C
    else:
      return D

  # if currently punishing
  if punish_remaining > 0:
    punish_remaining -= 1
    return D

  # cooperative regime
  if S_t >= SAFE * capacity and avg_defect <= LOW_DEFECT:
    return C

  # otherwise set punishment length by severity and start punishing
  if avg_defect <= 0.5:
    punish_remaining = 0  # punish this round only
    return D
  else if avg_defect <= 0.75:
    punish_remaining = 1  # total 2 D rounds incl. this one
    return D
  else:
    punish_remaining = 2  # total 3 D rounds incl. this one
    return D
```

**Note on “test C” after punishment:** This occurs automatically because once `punish_remaining` hits 0, the strategy will choose C again if defection has dropped; if not, it re-enters punishment.

---

If you want, I can also provide a variant tuned for (a) very short horizons (small r), or (b) tournaments where many opponents are unconditional defectors (to reduce wasted cooperation while still protecting stock).
'''

description_COLLECTIVE_35 = '''
## Collective Strategy: **Sustain-and-Sanction (SaS)**

Goal: keep the stock near **capacity** (which maximizes long-run per-round payoffs) while being **robust** to exploitation by defectors. The strategy is collective-minded: it cooperates by default, but it **withholds cooperation** when enough others are defecting that continued cooperation would just subsidize them and/or crash the resource.

Key idea: use **stock-based sustainability** plus a **history-based discipline** mechanism:
- **Stock trigger** protects the resource even if others behave unpredictably.
- **Defection trigger** protects you from being the “sucker” when others are persistently defecting.
- **Forgiveness** allows recovery to cooperation when the group returns to cooperative behavior.

---

# 1) Decision Rules (C vs D)

### Quantities observed each round \(t\)
- \(S_t\): stock at start of round \(t\)
- \(d_{t-1}\): number of defectors observed in previous round (for \(t=1\), undefined)
- Maintain internal state:
  - `punish_timer` (integer ≥ 0)
  - `trust_score` (integer, can be negative)

### Intuition for thresholds
If the group cooperates, stock tends to regenerate strongly (especially near \(S = capacity\)). If the group defects heavily, stock can collapse. Since you can’t coordinate, you condition behavior on *what you see*.

We treat “too many defectors” as a signal that cooperation is currently unsafe (you’ll be exploited and stock may fall). But we don’t punish forever: we gradually forgive after observed cooperation.

---

## Rule A — **Resource Safety Rule (stock-based)**
- If \(S_t\) is **low**, cooperate to preserve the resource.
- Use a conservative safety threshold:
  - \(S_{\text{low}} = 2n\) (the maximum stock bound in the state description suggests “critical zone” behavior; also it scales with group size)

**If** \(S_t \le S_{\text{low}}\):  
→ play **C** (always)

Rationale: when stock is scarce, defecting accelerates collapse and reduces future payoffs. Even if others defect, cooperating is the least damaging action to the commons, and may enable recovery if others also respond to scarcity.

---

## Rule B — **Baseline Cooperation Rule**
If stock is not in the danger zone and you are not actively punishing:

**If** `punish_timer == 0` and \(S_t > S_{\text{low}}\):  
→ play **C**

This is the collective default: assume cooperation unless evidence suggests it’s being exploited.

---

## Rule C — **Sanction Rule (history-based)**
Start punishment when defection is “meaningful,” not just a single accident.

Define:
- “Defection majority” threshold:  
  \[
  d_{t-1} \ge \left\lceil \frac{n}{2} \right\rceil
  \]
- “Defection minority” threshold (still concerning):  
  \[
  d_{t-1} \ge 2
  \]
  (for \(n=2\), this equals majority; for larger n it captures persistent free-riding)

We use a **two-tier trigger**:
1) **Immediate punishment** if last round had a defection majority.
2) **Escalating punishment** if repeated minority defection persists.

### Trust update
After round \(t-1\):
- If \(d_{t-1} = 0\): `trust_score += 2`
- Else if \(d_{t-1} = 1\): `trust_score -= 1`
- Else: `trust_score -= 2` (2+ defectors)

Clamp `trust_score` to e.g. \([-10, +10]\).

### Punishment trigger
- If \(d_{t-1} \ge \lceil n/2 \rceil\): set `punish_timer = 2`
- Else if `trust_score <= -3`: set `punish_timer = 1`
- Else no new punishment

### Punishment action
While `punish_timer > 0`:
- If \(S_t > S_{\text{low}}\): play **D**
- Decrement `punish_timer -= 1`

Rationale:
- Punishment is **short** to avoid self-destruction of the commons.
- Punishment is **strong** (D) so defectors lose the benefit of exploiting cooperators.
- Stock safeguard still overrides: if stock is low, we cooperate even during punishment.

---

## Rule D — **Forgiveness / Return-to-Cooperation**
After punishment ends, return to cooperation if the group shows signs of cooperating again.

Condition:
- If in the most recent round \(d_{t-1} = 0\), or `trust_score >= 0`, then do not extend punishment.

This makes the strategy adaptive to strategies that test once and then cooperate.

---

# 2) Edge Cases

### First round (t = 1)
- No history exists; start collective:
  - If \(S_1 > 2n\): play **C**
  - Else play **C** anyway (scarcity rule)

So: **always C in round 1**.

Rationale: starting with D provides short-term gain but invites retaliation and risks collapse; C gives the best chance to establish a cooperative basin.

---

### Last round (t = r)
Classic backward induction would suggest defection, but in tournaments you’re evaluated against many strategies; reputation-like dynamics matter even without cross-game memory, because opponents respond within-game.

So we do **not** auto-defect in the last round. We keep the same rules with one small tweak:

- If \(t = r\) and \(S_t > 2n\) and you are currently punishing (`punish_timer > 0`): play **D** (finish punishment)
- Otherwise follow normal rules (often C).

Rationale: avoid pointless endgame collapse when cooperation is already established, but don’t “forgive for free” mid-punishment.

---

### Very low stock / near-collapse
If \(S_t \le 2n\): always **C**, regardless of history, round number, or punishment.

This prevents the strategy from contributing to extinction spirals and makes it “collective” even under stress.

---

### Small n (e.g., n=2)
- Majority defection threshold \(\lceil n/2\rceil = 1\), so any defection triggers punishment quickly.
- That’s appropriate: with 2 players, one defector is already half the group and exploitation is acute.

---

# 3) Collective Mindset (Why this is “collective”)

- **Default cooperation** to keep the stock at/near capacity, which is where long-run payoffs are highest for everyone.
- **Stock protection**: when the common pool is endangered, it prioritizes recovery over punishment.
- **Targeted, bounded sanctions**: punishes defection enough to deter free-riding, but avoids prolonged mutual defection that destroys the commons.
- **Forgiveness**: quickly returns to cooperation when others do, enabling stable high-payoff regimes.

---

# Pseudocode (implementation-friendly)

```python
# Parameters: n, r, capacity
S_low = 2*n

punish_timer = 0
trust_score = 0  # clamp to [-10, 10]

def decide_action(t, S_t, history):
    # history contains previous round defect count d_prev if t>1
    global punish_timer, trust_score

    # Scarcity safeguard
    if S_t <= S_low:
        return "C"

    # First round: cooperate
    if t == 1:
        return "C"

    d_prev = history.defectors_last_round  # integer in [0, n]

    # Update trust_score based on last round
    if d_prev == 0:
        trust_score += 2
    elif d_prev == 1:
        trust_score -= 1
    else:
        trust_score -= 2
    trust_score = max(-10, min(10, trust_score))

    # Possibly start/refresh punishment
    if d_prev >= (n+1)//2:
        punish_timer = max(punish_timer, 2)
    elif trust_score <= -3:
        punish_timer = max(punish_timer, 1)

    # Act
    if punish_timer > 0:
        punish_timer -= 1
        return "D"

    return "C"
```

---

## What this strategy is robust against
- **Always-defect opponents**: you will punish quickly (play D often) and avoid being the consistent sucker; stock may still crash due to them, but you won’t disproportionately subsidize them.
- **Conditional cooperators (Tit-for-Tat-like)**: you align easily—cooperate most of the time, punish briefly after defection waves, forgive quickly.
- **Random/noisy strategies**: trust score prevents overreacting to a single defection; majority-trigger handles coordinated defection surges.
- **Endgame defection traps**: no automatic last-round defection, so you don’t destroy a cooperative equilibrium unnecessarily.

If you want, I can also provide a “more collective” variant (punish with C under scarcity and only mild D otherwise) or a “more exploit-resistant” variant (harsher/longer sanctions), depending on what tournament environment you expect.
'''

description_COLLECTIVE_36 = '''
## Strategy: **Stock-Guard Reciprocity (SGR)**  
Goal: keep the resource near the high-growth region (so everyone can earn repeatedly), but punish behavior that drives stock down. The strategy is collective: it cooperates by default, escalates only when the group over-consumes, and forgives once sustainability is restored.

Key idea: infer “how many defectors” the group effectively had last round from the observed stock change, then choose C/D based on (a) stock safety and (b) recent over-consumption.

---

## 1) Decision rules (C vs D)

### A. Compute what happened last round (from public history)
Let:
- `S_t` = stock at start of round t  
- `S_{t+1}` = stock at start of round t+1 (after consumption+growth in round t)
- `cap` = capacity

We can reconstruct the **post-consumption remaining stock** `R_t` (i.e., stock immediately after everyone consumed, before growth), because growth rule is known.

Growth rule:  
`S_{t+1} = min(R_t + 2*R_t*(1 - R_t/cap), cap)`

If `S_{t+1} < cap`, then `S_{t+1} = 3R_t - 2R_t^2/cap`. Solve for `R_t` in `[0, cap]`:
- `2R_t^2/cap - 3R_t + S_{t+1} = 0`
- `R_t = (cap/4) * (3 - sqrt(9 - 8*S_{t+1}/cap))`  (this is the feasible root in [0,cap])

If `S_{t+1} == cap`, then growth saturated; we only know `R_t` was high enough to refill. In that case approximate `R_t = cap/2` as a conservative estimate (any `R_t ≥ cap/2` refills to `cap` under this growth).

Then total consumption in round t:  
`T_t = S_t - R_t`

Given actions are only {C,D} with per-player consumption:
- C consumes `S_t/(2n)`
- D consumes `S_t/n`

If `k_t` players defected, total consumption equals:
`T_t = (n-k_t)*S_t/(2n) + k_t*S_t/n = S_t*(n + k_t)/(2n)`

So infer:
`k_hat = round( 2n*T_t/S_t - n )` clipped to `[0,n]`.

Interpretation:
- `k_hat` ≈ number of defectors last round.
- This works even if others use mixed behavior: it estimates “defection intensity”.

---

### B. Define “safe stock” and “danger stock”
We want to keep stock from ever entering a region where one more bad round crashes it.

Use two thresholds (depend only on parameters):
- **Danger threshold**: `S <= cap/2`  
  Below `cap/2`, even full cooperation may not immediately refill to cap; repeated over-consumption can spiral downward.
- **Critical threshold**: `S <= cap/4`  
  Below this, prioritize harsh punishment to stop free-riding and to prevent collapse.

(These thresholds align with logistic growth: growth is strongest around `cap/2`.)

---

### C. Core action rule
At start of round t, with stock `S_t` and last-round inferred defectors `k_hat_{t-1}`:

**Default (collective) stance:** cooperate unless (i) stock is in danger or (ii) the group recently over-consumed.

Let `m = floor(n/2)` (majority).

**Rule 1 — Stock emergency protection**
- If `S_t <= cap/4`: play **D**.  
  Rationale: when stock is critically low, you cannot afford being the “sucker.” Defection increases your current payoff and (importantly) signals maximum intolerance for overuse; it also prevents you from being exploited into near-zero cumulative payoff.  
  (Note: in this game, D always consumes more, which is bad for the stock; but at *very* low S, the absolute consumption is small anyway. The main objective here is deterrence and avoiding unilateral sacrifice.)

**Rule 2 — Guard band (danger zone)**
- Else if `cap/4 < S_t <= cap/2`:
  - If `k_hat_{t-1} == 0`: play **C** (reward full cooperation).
  - Else: play **D** for **one round**, then reassess next round.  
    (A short, sharp punishment discourages continued defection without locking into permanent mutual defection.)

**Rule 3 — Normal zone (healthy stock)**
- Else (`S_t > cap/2`):
  - If `k_hat_{t-1} <= 1`: play **C**.  
    (Forgiving: tolerate a single defector/noise to keep the cooperative basin stable.)
  - If `2 <= k_hat_{t-1} <= m`: play **D** for **one round** (a proportional “warning shot”).
  - If `k_hat_{t-1} > m`: play **D** for **two consecutive rounds** (escalate against widespread defection), then revert to reassessment.

This creates a *graduated reciprocity* tied to measured harm, not to any fixed opponent identity.

---

## 2) Edge cases and special rounds

### First round
- Play **C**.
Reason: the stock starts at capacity; cooperation is collectively optimal and also gives maximum information about who is willing to defect.

### Last round
- Play **D**.
Reason: finite-horizon end-game incentives. Cooperation has no future value in the terminal round, and defecting strictly dominates in that round given stock S.

### Second-to-last round (optional but robust)
- If `r` is known and `t == r-1`:
  - If `S_t > cap/2` and `k_hat_{t-1} == 0`: play **C** (one last attempt to harvest high stock twice).
  - Otherwise play **D** (avoid being exploited right before the end).

This balances “try to keep the pie big” with end-game realism.

### If stock ever hits 0
- Play **D** (indifferent, payoff is 0 anyway), and continue; the state is absorbing at 0, so no strategy can recover it.

### If the inference is ambiguous (due to saturation at cap)
When `S_{t} == cap` and `S_{t+1} == cap`, many consumption patterns could have occurred. Use a conservative assumption:
- Treat it as if `k_hat = 0` **unless** you directly observed someone’s payoff consistent with D (in implementations where individual actions are observed, you won’t need inference anyway).  
Given your spec says actions are observable, you can set `k_hat` exactly from actions; the inference logic is only a fallback.

---

## 3) Why this is collective, adaptive, and robust

### Collective
- Cooperates by default, rewards full cooperation immediately.
- Punishes only when there is measurable over-consumption (defection intensity), and punishes proportionally.
- Uses forgiveness (returns to C quickly after compliance) to prevent endless retaliation cycles.

### Adaptive
- Responds to *how many* defectors there were (not just “any defection”), and to the *stock level* (state-dependent).
- Tightens discipline automatically when stock is in the danger zone.

### Robust
- Against always-defect: quickly shifts to sustained D (you won’t be the sole cooperator).
- Against noisy or occasional defectors: tolerates small noise (≤1 defector) when stock is healthy, preserving the cooperative equilibrium.
- Against exploiters who alternate: the “warning shot” and escalation on majority defection reduces profitability of cycling.

---

## Pseudocode sketch (implementation-ready logic)

```python
def choose_action(t, r, n, cap, S_t, history):
    # history contains past observed actions or at least S_{t-1}, S_t, etc.

    if t == 1:
        return "C"
    if t == r:
        return "D"

    # Determine k_hat from last round
    # If actions observable:
    k_hat = count_defectors(history.actions[t-1])  # exact

    # If not observable, infer from S_{t-1} and S_t using the reconstruction method.

    m = n // 2  # floor

    if S_t <= cap/4:
        return "D"

    if S_t <= cap/2:
        if k_hat == 0:
            return "C"
        else:
            return "D"

    # S_t > cap/2 (healthy)
    if k_hat <= 1:
        # optional endgame tweak
        if t == r-1 and not (k_hat == 0):
            return "D"
        return "C"
    elif k_hat <= m:
        return "D"
    else:
        # escalate for widespread defection:
        # simplest: defect now; implementation can remember to defect one more round if desired
        return "D"
```

If you want the “two-round punishment when majority defects,” add a small internal state variable `punish_timer` that is set to 2 when `k_hat > m`, decremented each round, and forces D while positive.

---

This strategy is intentionally simple (low implementation risk), explicitly state-aware (stock thresholds), and history-based (defection intensity), making it competitive in heterogeneous tournaments without assuming shared norms or coordination.
'''

description_COLLECTIVE_37 = '''
## Strategy: **Stock-Guarded Conditional Cooperation (SGCC)**  
Goal: keep the stock near the regenerative sweet spot (high future value), cooperate by default, but punish over-consumption quickly and proportionally, then return to cooperation when the group does.

Key idea: In this game, **full cooperation is self-sustaining** at capacity (it returns to capacity each round), while defection can crash the stock. So we (i) **anchor on C**, (ii) **use the stock level as an objective “ecological alarm”**, and (iii) **use history to target punishment to how many defectors exist** (since we can’t target individuals directly, punishment is collective and time-limited).

---

# 1) Decision rules (C vs D)

### Notation (at start of round *t*):
- `S`: current stock level
- `k_{t-1}`: number of defectors observed last round (0..n)
- `S_{t-1}`: last round’s starting stock
- Parameters: `n, r, capacity`

### Derived quantities:
- **Safe-stock threshold:**  
  `S_safe = 0.8 * capacity`  
  (Above this, the system is healthy; below this, we prioritize deterrence/discipline.)

- **Critical-stock threshold:**  
  `S_crit = 0.4 * capacity`  
  (Below this, collapse risk is high; we respond aggressively.)

- **Expected remaining stock if everyone played C this round:**  
  If all play C, total consumption = `S/2`, so remaining = `S/2`.  
  Growth then roughly restores toward capacity, especially when `S` is not tiny.  
  So cooperation is “ecologically safe” unless the group has been defecting.

### Core rule:
We maintain a **punishment counter** `P` (integer ≥ 0). If `P>0`, we defect; if `P=0`, we cooperate—*except* when stock is critically low.

#### Rule A — Default: cooperate
Play **C** when:
- `P = 0`, **and**
- `S >= S_crit` (not in ecological emergency)

Rationale: keeps the resource at/near capacity if others also cooperate; also gives the highest long-run group payoff.

#### Rule B — Ecological emergency: defect to deter and prevent being exploited
Play **D** when:
- `S < S_crit`  
Rationale: When stock is very low, any unilateral cooperation is likely to be exploited and does little to restore. Defection here is a “hard stance” until behavior improves and stock recovers.

#### Rule C — Punishment trigger (based on observed defections)
After observing last round:
- If `k_{t-1} = 0`: set `P = 0` (immediate forgiveness)
- If `k_{t-1} > 0`: increase punishment length proportional to severity:

Punishment update:
- `P = max(P, ceil( (2 * k_{t-1}) / n ))`

Interpretation:
- A small minority defecting ⇒ short punishment (1 round).
- Many defectors ⇒ longer punishment (up to 2 rounds when everyone defects).

During punishment:
- If `P > 0`: play **D** and decrement `P ← P-1` each round *unless* we see full cooperation, in which case we forgive early (`P=0`).

This makes the strategy:
- **Retaliatory** (defection is punished),
- **Proportional** (more defectors ⇒ longer response),
- **Forgiving** (quick return to C when cooperation returns),
- **Robust** (doesn’t get stuck defecting forever).

---

# 2) Edge cases

### First round (t = 1)
Play **C**.

Reason: With no history, the collective-optimal equilibrium path begins with cooperation. Also, early cooperation is necessary to establish a cooperative basin; premature defection just accelerates collapse.

### Last round (t = r)
Still follow the same rule, with one modification:

- If `t = r` and **either** (a) `P>0` **or** (b) `k_{t-1}>0`, play **D**.
- Otherwise play **C**.

Reason: In finite horizons, many strategies end with endgame defection. This rule prevents being the “sucker” in the final step while still cooperating if the group has been clean.

### Near-last rounds (t ≥ r-1)
No special cycling schedules. Continue SGCC.  
Reason: Tournament opponents may exploit predictable endgame patterns; we only tighten the last-round protection.

### Stock at/near zero
If `S` is extremely small (e.g., `S <= 1e-9`), action choice barely matters for immediate payoff; still play:
- **D** if in punishment/emergency, else **C**.
This preserves consistent signaling.

### Capacity constraint (capacity ≥ 2n)
No special handling needed; our thresholds scale with capacity.

---

# 3) “Collective mindset” alignment

SGCC is explicitly collective in three ways:

1. **Cooperation-first policy**: The default is C whenever the group is behaving and the ecosystem isn’t in danger.
2. **Public-good enforcement**: Punishment is triggered only by observed defection (free-riding) and is proportional—strong enough to deter but not so strong that it destroys recovery prospects.
3. **Rapid reintegration**: If the group returns to full cooperation, we immediately drop punishment. This avoids needless mutual defection spirals and restores the high-payoff sustainable path.

---

## Pseudocode (implementable)

```python
# persistent state
P = 0  # punishment rounds remaining

def act(t, S, history, n, r, capacity):
    global P

    S_safe = 0.8 * capacity
    S_crit = 0.4 * capacity

    if t == 1:
        return "C"

    # read last round defections
    k = count_defectors(history[t-1])  # 0..n

    # update punishment based on last round
    if k == 0:
        P = 0
    else:
        P = max(P, math.ceil((2 * k) / n))

    # last-round protection
    if t == r:
        if P > 0 or k > 0:
            return "D"
        else:
            return "C"

    # ecological emergency overrides
    if S < S_crit:
        return "D"

    # punishment mode
    if P > 0:
        P -= 1
        return "D"

    # otherwise cooperate
    return "C"
```

---

### Why this holds up in a tournament
- Against cooperators: stays at C almost always → high sustained payoffs.
- Against occasional defectors/noise: punishes briefly, then returns to C → resilient.
- Against persistent defectors: spends more time in D → reduces exploitation losses.
- Against endgame defectors: last-round protection limits being farmed at the end.

If you want, I can tune the `S_crit`, punishment scaling, or add a “stock-recovery mode” (e.g., require 2 consecutive cooperative rounds before fully forgiving) depending on whether the tournament tends to feature more exploitative or more forgiving opponents.
'''

description_COLLECTIVE_38 = '''
## Strategy: **Stock‑Guarded Generous Trigger (SGGT)**  
Goal: keep the stock near the regenerative sweet spot (high long‑run total payoff), while remaining hard to exploit by persistent defectors and able to re‑establish cooperation after mistakes.

Key ideas:
- **Sustainability first:** if the stock is low, *everyone* must cooperate or the resource collapses.
- **Reciprocity with forgiveness:** punish defection, but allow recovery if others return to cooperation.
- **State‑aware punishment:** punish more strongly when defection is especially damaging (low stock), less when the stock is safely high.
- **Collective mindset:** default to cooperation whenever the history suggests it is viable.

---

# 1) Decision rules: when to Cooperate vs Defect

### Definitions (observable each round t)
- `S` = current stock at start of round t  
- `n` = number of players  
- From previous round (t−1) actions:  
  - `kD_prev` = number of players who defected last round  
  - `kC_prev = n - kD_prev`
- Let `my_last` be my last action (C/D).
- Let `pD_prev = kD_prev / n`.

### Stock regimes (choose constants as functions of capacity)
Let:
- `S_low = 0.35 * capacity`  (danger zone; collapse risk)
- `S_mid = 0.70 * capacity`  (recovery/maintenance zone)

(These fractions are intentionally simple and parameter-based; they work across capacities because growth is logistic and collapse is most dangerous when S is low.)

### Core rule set
We compute a **cooperation intention** based on stock + history, then choose C or D.

#### Rule A — **Emergency conservation (always cooperate)**
If `S <= S_low`:  
- **Play C** regardless of history.

Rationale: when stock is low, defection (taking S/n) accelerates collapse; collective survival dominates short-run gains.

#### Rule B — **Build/rebuild cooperation (cooperate if not facing a defection majority)**
If `S_low < S <= S_mid`:  
- **Play C** if `pD_prev <= 1/3`  
- **Play D** if `pD_prev > 1/3`

Rationale: In mid stock, we try to rebuild cooperation if defection is limited (mistakes or a small opportunistic minority). If a sizable bloc defects, we stop being exploited and apply pressure.

#### Rule C — **High stock reciprocity (mirror but slightly generous)**
If `S > S_mid`:  
- **Play C** if `pD_prev == 0` (everyone cooperated)  
- **Play C** if `0 < pD_prev <= 1/n` (at most one defector)  
- **Play D** if `pD_prev > 1/n`

Rationale: When the resource is healthy, we can afford to be forgiving to a single defector (noise, experimentation). But if more than one defects, we punish quickly to prevent unraveling.

---

# 2) Edge cases and tournament-hardening

### First round (t = 1)
- **Play C**.

Rationale: With initial stock at capacity, all-C is best for long-run and also a strong “cooperative opening” that many adaptive strategies respond to.

### Last round (t = r)
- Use the **same rules as above** (no endgame defection “just because it’s last”).

Rationale: In unknown tournaments, some opponents punish endgame defection (or condition future cooperation in their internal scoring). Since you can’t gain future benefits after the last round *but can still trigger retaliatory behavior earlier if you’re predictable*, a consistent rule performs better cross-opponent. Also, if others still cooperate, unilateral defection may collapse stock earlier in multi-round variants with uncertain effective horizon in opponents’ models.

### “I got exploited last round” override
If I played C in round t−1 and `kD_prev >= 2` (at least two defectors), then in round t:
- If `S > S_low`, **escalate one step toward defection** by applying the Rule B/C thresholds more strictly:
  - In `S_low < S <= S_mid`, defect if `pD_prev > 1/4` (instead of 1/3)
  - In `S > S_mid`, defect if `pD_prev > 0` (instead of > 1/n)

This makes SGGT robust to coordinated exploitation: if multiple players start taking advantage, you stop “feeding” them quickly.

### Recovery / re-coordination clause
If the last round had **full cooperation** (`kD_prev = 0`), then:
- **Reset to cooperative mode** (i.e., no lingering punishment).

This prevents permanent grudges and allows the group to climb back to the efficient path.

### Collapse floor
If stock is extremely low:
- If `S <= (2n)` (near the hard state bound mentioned), **always C**.

Reason: At very low S, any defection likely prevents recovery; cooperation is the only chance.

---

# 3) Collective alignment (what this strategy is “trying to do”)

SGGT behaves like a *resource steward*:
- It treats **high stock as a public good to preserve**, not a “cash-out” opportunity.
- It **punishes patterns** (multiple defectors) rather than single events (one defector), which is more collective and tolerant of noise.
- It **switches to conservation** when the ecological state demands it, even if others misbehave, because saving the resource is the only path back to good payoffs for everyone.

---

# Pseudocode (implementable)

```pseudo
Inputs each round t:
  S        // current stock at start of round
  history  // previous actions by all players (if t>1)
Constants:
  S_low = 0.35 * capacity
  S_mid = 0.70 * capacity

If t == 1:
  return C

kD_prev = count_defectors_in_round(t-1)
pD_prev = kD_prev / n
i_cooperated_prev = (my_action_in_round(t-1) == C)

if S <= min(S_low, 2*n):
  return C

// exploitation override (anti-ganging-up)
strict_mode = (t > 1) and i_cooperated_prev and (kD_prev >= 2)

if S <= S_mid:  // mid zone
  threshold = (strict_mode ? 0.25 : (1/3))
  if pD_prev <= threshold:
    return C
  else:
    return D
else:           // high zone
  if strict_mode:
    // punish any defection if I was just exploited by multiple defectors
    if pD_prev == 0: return C else return D
  else:
    // generous: forgive at most one defector
    if kD_prev <= 1: return C else return D
```

---

## What this is robust against
- **Always-defectors:** you quickly shift to D when they are numerous, preventing chronic exploitation, while still cooperating in low-stock emergencies to avoid mutual ruin.
- **Tit-for-tat / grim-trigger types:** you open cooperatively, punish defection visibly, and reset cleanly after full cooperation.
- **Noisy / exploratory agents:** single defections are forgiven in high stock; cooperation can re-emerge.
- **Coordination failure:** mid-zone rules bias toward rebuilding cooperation when feasible, which helps the whole group recover.

If you want, I can also provide (a) a version tuned for very small r (e.g., r=2–5) vs large r, or (b) a variant that explicitly estimates whether “defecting now” is resource-safe by computing expected remaining stock from last round’s mix.
'''

description_COLLECTIVE_39 = '''
## Strategy: **Stock-Guarded Generous Grim (SGGG)**  
Collective goal: keep the stock near capacity (high sustainable yield) while deterring repeated overconsumption. The strategy is **state-based first**, **history-based second**: protect the resource when it’s fragile; otherwise cooperate unless opponents show persistent exploitation.

Key idea:  
- When the stock is healthy, *cooperation* maximizes long-run group payoff because it preserves the stock near capacity (logistic regrowth refills it).  
- Defection is used **sparingly** as (i) a **shield** when the stock is low, and (ii) a **punishment** only after a clear pattern of repeated defection by others.

---

# 1) Decision rules: when to Cooperate vs Defect

### Definitions observed at the start of round *t*
- `S` = current stock.
- `H` = full public history of actions.
- Let `d_prev` = number of players (among the other `n-1`) who played **D** in round `t-1`. (For t=1, define `d_prev = 0`.)
- Let `D_rate_last_k` = fraction of all *other-player actions* that were D in the last `k` rounds (use `k = min(5, t-1)`).

### Thresholds (depend only on parameters)
- **Critical stock threshold:** `S_crit = capacity / 2`  
  Rationale: under all-C, stock after consumption is `S/2` which regrows strongly; below ~capacity/2 the system is more fragile and mistakes are costly.
- **Low stock threshold:** `S_low = capacity / 4`  
  Rationale: when stock is this low, the group can spiral toward collapse if anyone defects.

### Rule A — Resource-first safeguard (state-based)
1. If `S <= S_low`: **Play C** (always).  
   Collective “triage”: even if others defect, the priority is to avoid total collapse. Defecting here accelerates extinction; punishing is counterproductive.
2. Else if `S_low < S <= S_crit`:  
   - If `d_prev == 0`: **Play C** (reward full cooperation).  
   - If `d_prev >= 1`: **Play C** (still), *unless* opponents have shown persistent defection (see Rule C).  
   Rationale: in the fragile zone we default to conservation; we only switch to D if we’ve clearly learned the group is not conserving anyway.

### Rule B — Healthy-stock cooperation (default)
If `S > S_crit`: **Play C**, unless triggered punishment mode (Rule C).  
Rationale: when stock is high, universal C keeps it near capacity indefinitely and yields stable high payoffs.

### Rule C — Adaptive deterrence (history-based, but stock-aware)
Enter **Punishment Mode** if BOTH conditions hold:
- Stock is not fragile: `S > S_crit` (only punish when the resource can absorb it), AND
- Evidence of exploitation: either
  - `d_prev >= ceil((n-1)/2)` (a majority of others defected last round), OR
  - `D_rate_last_k >= 0.35` (sustained defection in recent history).

**While in Punishment Mode:**
- Play **D** for `L` rounds, where  
  `L = 1 + floor((n-2)/2)` (scales mildly with group size; e.g., n=4 → L=2).
- Exit early (return to C) if in any punishment round the others show reform: `d_prev == 0`.

**But:** if during Punishment Mode the stock falls to `S <= S_crit`, immediately switch back to **C** (resource-first override).

Rationale:  
- Punishment must be strong enough to make “always defect” strategies less profitable, but bounded so we don’t destroy the commons ourselves.
- Forgiveness is built in: one fully cooperative round from others resets us to C.

---

# 2) Edge cases (first round, last round, etc.)

### First round (t = 1)
- **Play C**, regardless of parameters.  
Rationale: establishes the cooperative attractor without coordination; with initial stock = capacity, all-C can maintain capacity indefinitely.

### Last round (t = r)
- **Still follow the same state/history rules** (do *not* auto-defect).  
Rationale: (i) tournament opponents may punish endgame defection across repeated matches or in learning-based strategies; (ii) collective ethos; (iii) with simultaneous move and no communication, unconditional last-round defection invites mutual defection spirals in many adaptive opponents.

### If stock is extremely high or exactly capacity
- Still cooperate unless punishment is triggered and stock is safely above `S_crit`.  
The purpose is stability: all-C at capacity is self-replenishing each round.

### If stock is near zero
- Always C (Rule A).  
At S≈0, D yields almost nothing anyway and hastens stagnation; C maximizes the chance of regrowth from any remaining stock.

---

# 3) Why this is “collective” and robust

### Collective alignment
- The strategy treats the stock as a shared asset and uses **conservation as the default**.
- Even when exploited, it avoids “scorched earth”: punishment is **limited**, **conditional**, and **resource-aware**.

### Robustness vs common opponent types
- **Always-Cooperate opponents:** we stay C → stable capacity, maximal sustainable payoffs.
- **Always-Defect opponents:** we learn quickly (via `d_prev` / `D_rate_last_k`), punish when stock is healthy, but stop punishing when stock becomes fragile (so we don’t help collapse further). This prevents being a perpetual sucker while still protecting the commons when it matters.
- **Tit-for-Tat / Grim / retaliatory strategies:** our default C and bounded punishment with forgiveness tends to synchronize back to mutual cooperation quickly.
- **Noisy / occasional defectors:** the exploitation thresholds (majority defection or sustained 35% rate) prevent overreacting to one-off mistakes.

---

# Pseudocode (implementable sketch)

```pseudo
params: n, r, capacity
constants:
  S_crit = capacity / 2
  S_low  = capacity / 4
  k_max  = 5
  L = 1 + floor((n-2)/2)

state variables:
  punish_remaining = 0

function action(t, S, history):
  if t == 1:
    punish_remaining = 0
    return C

  d_prev = count_D_among_others(history[t-1])
  k = min(k_max, t-1)
  D_rate_last_k = fraction_of_D_among_others_over_last_k_rounds(history, k)

  // Resource-first override
  if S <= S_low:
    punish_remaining = 0
    return C

  if punish_remaining > 0:
    if S <= S_crit:
      punish_remaining = 0
      return C
    if d_prev == 0:
      punish_remaining = 0
      return C
    punish_remaining -= 1
    return D

  // Not currently punishing
  if S > S_crit:
    if d_prev >= ceil((n-1)/2) or D_rate_last_k >= 0.35:
      punish_remaining = L
      punish_remaining -= 1
      return D
    else:
      return C
  else:
    // S in (S_low, S_crit]
    if (D_rate_last_k >= 0.50) and (d_prev >= 1):
      // only if clearly persistent exploitation even in fragile zone
      return D
    return C
```

If you want, I can also provide (a) a simplified version with fewer thresholds for easier implementation, or (b) a more “mechanism-design” version that targets a specific steady-state stock (e.g., keep S near capacity via explicit stock control).
'''

description_COLLECTIVE_40 = '''
## Strategy: **Sustain–Reward–Protect (SRP)**  
Goal: keep the stock near capacity (maximizes long-run total payoffs) while being robust to defectors by (i) rewarding cooperative periods, (ii) quickly protecting the stock when it is at risk, and (iii) punishing persistent over-consumption enough to deter it, but not so much that we permanently collapse the resource.

Key observation: With all **C**, the stock tends to regenerate back to capacity (given your dynamics). With enough **D**, the stock can crash to 0 and stay there. So the strategy should be “cooperate by default, defect only when needed to (a) discipline, or (b) prevent getting exploited when others are clearly defecting anyway, or (c) harvest late when the horizon is ending and stock is safe.”

---

# 1) Decision rules (C vs D)

### Variables from history/state (computed each round \(t\))
- \(S_t\): current stock at start of round \(t\).
- \(k_{t-1}\): number of defectors observed in previous round (0…n).
- **Estimated defector rate** over a recent window \(W\):  
  \[
  \bar{k} = \text{average of } k \text{ over last } W \text{ rounds (or fewer if early)}
  \]
- **Stock regime thresholds** (depend only on parameters):
  - High stock: \(S_t \ge 0.85 \cdot capacity\)
  - Medium stock: \(0.50 \cdot capacity \le S_t < 0.85 \cdot capacity\)
  - Low stock: \(S_t < 0.50 \cdot capacity\)
  (You can tune 0.85/0.50; the logic is what matters.)

### Core policy
You choose **C** unless one of the “protection / punishment / endgame” triggers fires.

#### A. **Resource protection trigger (stock-based)**
When stock is low, prioritize recovery and avoid being the “last cooperator” funding defectors.

- If \(S_t < 0.25 \cdot capacity\): **Play C** (try to regrow; D now usually accelerates collapse).  
  *Exception:* if **everyone is defecting consistently** (see section C), then D is acceptable because cooperation can’t rescue it alone; but default is C at very low stock.

- If \(0.25 \cdot capacity \le S_t < 0.50 \cdot capacity\):  
  - If \(k_{t-1} \le 1\): **C** (cooperative regime still viable).  
  - If \(k_{t-1} \ge 2\): **D** (protect yourself; others are already extracting hard).

Rationale: In low-to-mid stock, you want to cooperate only if the group is close to cooperating; otherwise you avoid being exploited.

#### B. **Cooperation reward trigger (history-based)**
If the group is behaving, keep cooperating to sustain the high-payoff steady state.

- If \(S_t \ge 0.50 \cdot capacity\) **and** \(k_{t-1} = 0\): **C**.
- If \(S_t \ge 0.85 \cdot capacity\) **and** \(k_{t-1} \le 1\): **C**.

Rationale: When the group is mostly cooperating and stock is healthy, staying at C preserves capacity and maximizes long-run sum of payoffs.

#### C. **Anti-exploitation / punishment trigger**
Use a measured but decisive response to observed defection to discourage it, without permanently tanking the pool.

Define a “defection alarm”:
- Alarm if either:
  - \(k_{t-1} \ge 2\) (multiple defectors last round), or
  - \(\bar{k} \ge 1.5\) over window \(W\) (persistent defection).

If alarm is active and stock is not critically low:
- If \(S_t \ge 0.50 \cdot capacity\): **Play D** for **P** rounds, then test cooperation.
  - Suggested: \(W = 5\), \(P = 2\).  
- After punishment \(P\) rounds: **Play C** for one “probe” round.
  - If defection drops (e.g., \(k\) becomes 0 or 1), return to cooperative mode.
  - If defection persists (\(k \ge 2\)), repeat punishment cycle.

Rationale: This is like “contrite tit-for-tat with limited retaliation”: punish enough to remove the easy advantage of unilateral D, but regularly offer a path back to cooperation.

#### D. **Opportunistic safety rule (when D can’t do much harm)**
If the stock is extremely high and you are close to the end, taking D does not meaningfully threaten sustainability.

- If \(S_t \ge 0.95 \cdot capacity\) and you observed \(k_{t-1} \ge 1\): **D** (don’t be the sucker when someone already defected and stock is full).

This prevents exploitation in very safe states.

---

# 2) Edge cases

### First round (t = 1)
- **Play C**.
Reason: establishes the cooperative attractor and is the only way to discover whether others are willing to maintain stock. Starting with D needlessly risks a cascade to depletion.

### Last round (t = r)
- If \(S_r \ge 0.50 \cdot capacity\): **Play D**.
- Else: **Play C** (if stock is already low, D yields little anyway; C is weakly “collective” and doesn’t worsen collapse much).

Why: With a known finite horizon, endgame defection is common. This rule captures endgame payoff without causing earlier unraveling because it only applies at the final step.

### Second-to-last round (t = r-1)
- If \(S_{r-1} \ge 0.85 \cdot capacity\) and \(k_{r-2} \le 1\): **C** (preserve high stock to make the final-round D lucrative for everyone).
- If alarm active (persistent defection): follow punishment rule.

### Very small capacity / constraints
You specified \(capacity \ge 2n\). Thresholds are proportional to capacity, so the policy remains well-defined.

### When stock hits 0
- **Always C** afterward (unless last round where it doesn’t matter).  
If everyone keeps defecting, the outcome is 0 regardless; but C is the only action consistent with recovery if others ever relent.

---

# 3) “Collective mindset” alignment
This strategy is collective in three concrete ways:

1. **Default cooperation** builds and maintains the high-stock equilibrium that maximizes total long-run payoff.  
2. **Measured retaliation** is not spite; it is a *discipline mechanism* to deter overconsumption and protect the pool from collapse.  
3. **Frequent forgiveness/probing** (returning to C after short punishment) actively attempts to restore cooperation rather than locking into mutual defection.

---

## Pseudocode (implementable)
```python
# parameters
W = 5               # memory window
P = 2               # punishment length
HIGH = 0.85
VERY_HIGH = 0.95
MID = 0.50
LOW = 0.25

state: punishment_left = 0

def choose_action(t, r, S, history_k):
    # history_k: list of past defector counts k_1..k_{t-1}
    if t == 1:
        return "C"

    k_last = history_k[-1]
    k_bar = sum(history_k[-W:]) / min(len(history_k), W)

    # last-round rule
    if t == r:
        return "D" if S >= MID * capacity else "C"

    # if currently punishing, continue
    if punishment_left > 0:
        punishment_left -= 1
        return "D"

    # stock critical: focus on recovery unless clearly hopelessly exploited
    if S < LOW * capacity:
        # if persistent heavy defection, protect self; else cooperate to regrow
        if k_bar >= 2.0:
            return "D"
        return "C"

    # moderate-low stock
    if S < MID * capacity:
        if k_last <= 1:
            return "C"
        else:
            return "D"

    # high/healthy stock: reward cooperation
    if S >= HIGH * capacity and k_last <= 1:
        return "C"

    # opportunistic safety if someone already defected and stock is full
    if S >= VERY_HIGH * capacity and k_last >= 1:
        return "D"

    # defection alarm triggers punishment cycle
    alarm = (k_last >= 2) or (k_bar >= 1.5)
    if alarm:
        punishment_left = P - 1
        return "D"

    # otherwise cooperate
    return "C"
```

---

### Why this should do well in a tournament
- Against cooperative strategies: it stays mostly at C, keeping stock near capacity and generating high cumulative payoffs.
- Against always-defect / high-defection strategies: it quickly switches to D in healthy stock (avoids being exploited) but tends to C in very low stock (keeps open the only recovery path).
- Against noisy/mixed opponents: short punishment + probe prevents endless vendettas and re-establishes cooperation when possible.
- Finite horizon is handled without triggering early unraveling: only the final round is a guaranteed D, with a conditional \(r-1\) behavior that preserves the resource when it matters.

If you want, I can also provide a tighter mathematical justification for the thresholds (e.g., based on expected next-stock under k defectors) and suggest parameter sweeps for W/P/thresholds.
'''

description_COLLECTIVE_41 = '''
## Strategy: **Sustain-and-Sanction (SaS)**  
Goal: keep the stock near **capacity** (high sustainable yield) while being robust to exploitation. The strategy is collective: it cooperates by default, but enforces cooperation using **state-based discipline** and **history-based retaliation** that is *proportional* and *forgiving*.

---

# Core idea (why it works)
- When many players **C**, total consumption is ≈ S/2 and logistic growth (with factor 2) replenishes back toward capacity; this yields **high long-run average payoffs**.
- A defector gets double payoff *this round*, but reduces future stock for everyone. So the strategy:
  1) **cooperates** when the system is healthy and others are mostly cooperating;  
  2) **sanctions** by defecting when others defect too much or when stock is endangered;  
  3) **forgives** after a short “probation” once behavior improves, to restore collective efficiency.

---

# Observables needed
At end of each round t, observe:
- Stock before round: \(S_t\)
- Actions of all players in round t (or at least counts of C and D)
- Stock after update: \(S_{t+1}\)

Define:
- \(D_t\) = number of defectors among the other \(n-1\) players in round t  
- \(d_t = D_t/(n-1)\) = defection rate among others
- “Stock health ratio”: \(h_t = S_t / \text{capacity}\)

---

# Parameters (only depend on n, r, capacity)
These are fixed constants derived from game parameters:

- **Safe stock threshold**:  
  \[
  h_{\text{safe}} = 0.85
  \]
- **Danger stock threshold** (resource endangered):  
  \[
  h_{\text{danger}} = 0.60
  \]
- **Defection tolerance** (how many defectors we allow before sanctioning):  
  \[
  d_{\text{tol}} = \frac{1}{n-1}
  \]
  i.e., tolerate at most **one** defector among opponents; more triggers punishment.
- **Punishment length** (short but meaningful):  
  \[
  L = \max(2,\lceil r/10 \rceil)
  \]
- **Forgiveness requirement**: need **2 consecutive rounds** of low defection to exit punishment.

You can tune the numeric thresholds slightly, but keep the structure.

---

# Decision rules (C vs D)

## Modes
The strategy has two modes:
1) **COOP mode** (default)
2) **PUNISH mode** (temporary sanction)

Maintain:
- `punish_timer` (integer ≥ 0)
- `good_streak` (0,1,2…) counts consecutive “good” rounds while in punish mode

---

## Round 1 (edge case: no history)
**Play C**.

Rationale: with initial stock at capacity, C is the socially efficient starting action and creates a cooperation signal without committing to being exploited indefinitely.

---

## Main rule: choose action at round t (1-indexed)

### Step A: Immediate stock protection (state-based)
Regardless of history:
- If \(h_t \le h_{\text{danger}}\): **play D**.  
  (When stock is low, you need to stop being the “sucker”; D both protects your payoff and discourages further depletion by not rewarding cooperators who enable defectors.)

- Else if \(h_t < h_{\text{safe}}\) and \(d_{t-1} > 0\): **play D**.  
  (If stock is slipping and someone defected recently, enforce discipline quickly.)

### Step B: If currently in PUNISH mode
- If `punish_timer > 0`: **play D**, decrement `punish_timer`.
- Track `good_streak` during punishment:
  - A “good round” is when \(d_{t-1} \le d_{\text{tol}}\) **and** \(h_t \ge h_{\text{safe}}\).
  - If good round: `good_streak += 1` else `good_streak = 0`
  - If `punish_timer == 0` and `good_streak >= 2`: exit punishment → return to COOP mode next round.
  - If `punish_timer == 0` but `good_streak < 2`: extend punishment by 1 (soft extension) and continue D.  
    (This prevents “one-round fake apology” exploitation.)

### Step C: If in COOP mode (normal operation)
Play **C** if both conditions hold:
1) Stock healthy: \(h_t \ge h_{\text{safe}}\)
2) Others mostly cooperative recently: \(d_{t-1} \le d_{\text{tol}}\) (i.e., at most one defector)

Otherwise:
- Trigger PUNISH mode: set `punish_timer = L`, `good_streak = 0`, and **play D**.

---

## Last round (edge case)
In the final round, there is no future stock benefit, so most opponents will defect. To avoid being exploited:

- If round \(t = r\): **play D**, unless *both*:
  - \(d_{r-1} = 0\) (everyone cooperated last round)
  - \(h_r \ge 0.95\) (stock extremely healthy)
  
In that rare case, play **C** as a “collective bonus” (it slightly sacrifices your last-round payoff but rewards a fully cooperative group). In tournaments, defaulting to D on the last round is usually safer and still consistent with collective intent under endgame pressure.

---

# Pseudocode (implementable)

```python
# constants from (n, r, capacity)
h_safe = 0.85
h_danger = 0.60
d_tol = 1/(n-1)
L = max(2, ceil(r/10))

punish_timer = 0
good_streak = 0
mode = "COOP"

def action(t, S_t, history):
    global punish_timer, good_streak, mode

    h_t = S_t / capacity
    d_prev = history.defection_rate_among_others(t-1) if t > 1 else 0.0

    # Last round rule
    if t == r:
        if (t > 1) and (d_prev == 0.0) and (h_t >= 0.95):
            return "C"
        return "D"

    # Immediate stock protection
    if h_t <= h_danger:
        mode = "PUNISH"
        punish_timer = max(punish_timer, 1)
        good_streak = 0
        return "D"

    if (h_t < h_safe) and (t > 1) and (d_prev > 0):
        mode = "PUNISH"
        punish_timer = max(punish_timer, 1)
        good_streak = 0
        return "D"

    # Punish mode behavior
    if punish_timer > 0:
        punish_timer -= 1

        # update good_streak based on prior round and current stock
        if (t > 1) and (d_prev <= d_tol) and (h_t >= h_safe):
            good_streak += 1
        else:
            good_streak = 0

        # if timer ended, require 2-round good behavior to exit
        if punish_timer == 0:
            if good_streak >= 2:
                mode = "COOP"
            else:
                punish_timer = 1  # soft extension

        return "D"

    # Coop mode behavior
    if (h_t >= h_safe) and ((t == 1) or (d_prev <= d_tol)):
        mode = "COOP"
        return "C"

    # Otherwise trigger punishment
    mode = "PUNISH"
    punish_timer = L
    good_streak = 0
    return "D"
```

---

# How this handles common opponent types

- **Always Cooperate opponents**: you mostly play C; stock stays near capacity; high long-run payoffs.
- **Always Defect opponents**: you quickly enter punishment (D). You don’t waste rounds cooperating while being exploited; you also avoid accelerating collapse by being the lone cooperator.
- **Occasional / noisy defection**: tolerance of up to one defector (or very small defection rate) prevents overreacting; forgiveness restores cooperation after stability.
- **Strategic exploiters (defect intermittently)**: punishment is triggered by sustained defection and reinforced by the “two-good-rounds” exit condition, making on-off exploitation unprofitable.

---

# Collective mindset summary
- **Default is cooperation** when the resource is healthy and others are mostly cooperating.
- **Sanction is automatic and temporary** when behavior threatens collective welfare (excess defection) or when stock health deteriorates.
- **Forgiveness is structured** to allow recovery to efficient cooperation, but not so fast that opportunists can game it.

If you want, I can provide a small worked example trajectory (stock and actions) for a few typical opponent mixes to show the mode switching in action.
'''

description_COLLECTIVE_42 = '''
## Strategy: **Stock-Guarded, Forgiving Threshold (SGFT)**  
Collective objective: keep the resource near *capacity* (where sustainable growth is high) while still extracting value. The strategy cooperates by default, but switches to defection when the group is endangering the stock, and returns to cooperation once the stock recovers. It is history-based, parameter-based, and does not require coordination or shared conventions.

Key idea: **Use the stock itself as the coordination device**. When stock is high, be generous (C). When stock is threatened, “enforce” (D) to protect yourself from being exploited, but only as long as needed. This makes the strategy robust against (i) always-defectors, (ii) noisy/mixed opponents, (iii) conditional cooperators, and (iv) opportunists.

---

# 1) Decision rules: when to Cooperate vs Defect

### Definitions observed at start of round *t*
- `S = stock_t` (current stock)
- `h = number of opponents who played D last round` (so `h ∈ {0,...,n-1}`)
- `S_prev = stock_{t-1}` (if t>1)
- `ΔS = S - S_prev` (stock trend)

### Derived safety thresholds (depend only on parameters)
We use two stock thresholds:
- **Safe zone**: `S ≥ S_high`
- **Danger zone**: `S ≤ S_low`

Set:
- `S_high = 0.85 * capacity`
- `S_low  = 0.55 * capacity`

Rationale:
- Above ~0.85 capacity, the pool is effectively “healthy”; cooperation sustains it well.
- Below ~0.55 capacity, the system is at risk of getting pushed into low-growth territory by continued over-consumption; defensive action is justified.

(If you want a purely parameteric alternative: you can cap these to `[2n, capacity]`, but the stated capacity constraint makes this workable.)

---

## Core policy (single-round choice)

### Rule A — Default cooperate in the safe zone
If `S ≥ S_high` **and** last round wasn’t heavily defecting, cooperate:
- If `h ≤ 1`: play **C**
- Else (more than one defector last round): go to Rule C (targeted enforcement)

### Rule B — Protect the stock in the danger zone
If `S ≤ S_low`: play **D**  
(You cannot unilaterally save the stock by cooperating when others defect; this prevents being the “sucker” while the pool is collapsing.)

### Rule C — Targeted enforcement when others defect at high stock
When stock is high but defection appears, respond proportionally to discourage sustained exploitation:

Compute a “defection pressure” score:
- `p = h / (n-1)`  (fraction of opponents who defected last round)

Then:
- If `p == 0`: play **C**
- If `0 < p ≤ 0.5`: play **C** unless stock is trending downward strongly  
  - If `t>1` and `ΔS < -0.10*capacity`: play **D**  
  - else play **C**
- If `p > 0.5`: play **D** (majority-defection response)

Interpretation:  
- Small amounts of defection are tolerated when the pool is healthy (forgiveness + stability).
- Majority defection triggers defection to avoid being exploited and to signal “this won’t be profitable”.

### Rule D — Recovery cooperation (return-to-C)
After you have defected, return to cooperation as soon as the pool is recovering:
- If `S ≥ S_high` and `h ≤ 1`: play **C**
- Or if `S` increased last round (`ΔS > 0`) and `S ≥ 0.70*capacity` and `h` is not increasing: play **C**

This prevents endless retaliation cycles and allows coordination with forgiving conditional cooperators.

---

# 2) Edge cases

### First round (t = 1)
Play **C**.
- Starting at `capacity`, mutual cooperation produces strong regrowth and keeps the game in the good region.
- Also maximizes the chance of matching cooperative types early.

### Last round (t = r)
Normally repeated games have an endgame defection problem. Here, however, stock carries no value after the last round, so purely selfish play would defect.  
But in a tournament you face strategies that punish endgame grabs; also, your own payoff in the last round depends only on *current stock*, which is highest when the pool has been maintained.

So:
- If `S ≥ S_high` and last round had `h ≤ 1`, play **C** even in the last round (collective “finish strong”).
- Otherwise play **D** (don’t be exploited on the final step).

### Very low stock (near collapse)
If `S ≤ 2n` (the minimum meaningful scale implied by action sizes), always play **D**.  
Reason: at very low S, your absolute payoff is tiny; cooperating only increases the exploitation gap with little regeneration benefit if others keep defecting.

### Persistent exploiters
If opponents defect heavily for several rounds, SGFT will settle into **D** frequently (especially when `p > 0.5` or stock is low). This prevents large relative losses and makes exploitation less attractive (you stop “funding” defectors by staying C).

### Mixed/noisy opponents
Because SGFT is forgiving in the safe zone and only escalates on (i) majority defection, (ii) sustained stock decline, or (iii) danger zone stock, it does not overreact to one-off noise.

---

# 3) Why this is “collective” (and still robust)
Collective behavior is encoded as:
- **Cooperate by default** when the stock is healthy (maximize long-run shared value).
- **Use the stock level as a shared public signal** to coordinate back to cooperation.
- **Punish only when necessary** (majority defection or dangerous depletion), and **forgive quickly** when recovery is visible.

This makes the strategy compatible with a wide range of “reasonable” cooperative strategies while remaining defensively sound against exploitation.

---

# Pseudocode (implementable)

```pseudo
inputs each round t:
  S = current_stock
  if t == 1:
    return C

  h = count_opponents_defected_last_round
  p = h / (n-1)
  S_prev = previous_stock
  ΔS = S - S_prev

  S_high = 0.85 * capacity
  S_low  = 0.55 * capacity

  if S <= 2*n:
    return D

  if t == r:  # last round
    if S >= S_high and h <= 1:
      return C
    else:
      return D

  if S <= S_low:
    return D

  # S > S_low
  if S >= S_high:
    if h <= 1:
      return C
    else:
      # enforcement in safe zone
      if p > 0.5:
        return D
      else:
        if ΔS < -0.10 * capacity:
          return D
        else:
          return C

  # middle zone: S_low < S < S_high
  # be more cautious: cooperate if defection is rare, else defect
  if p == 0:
    return C
  if p <= 0.33 and ΔS >= 0:
    return C
  return D
```

---

If you tell me typical tournament settings (ranges of `n`, `r`, and `capacity`) or whether strategies are allowed any internal randomness, I can tune the thresholds (`0.85`, `0.55`, trend cutoff) for better performance.
'''

description_COLLECTIVE_43 = '''
## Strategy: **Stock-Guard Conditional Cooperation (SGCC)**  
A collective strategy that (i) tries to keep the resource near capacity (high long-run payoffs), (ii) tolerates occasional noise/experimentation by others, and (iii) punishes sustained over-extraction quickly enough to prevent collapse, while allowing recovery and re-entry to cooperation.

The key idea: **treat cooperation as the default while the stock is healthy and others are not persistently over-consuming; otherwise defect to avoid being the “sucker” and to force opponents to internalize depletion.** Because payoffs scale with stock, preserving stock is collective—but unconditional cooperation is exploitable.

---

# 1) Decision rules (C vs D)

### Quantities to compute each round \(t\)
Let current stock at start of round be \(S_t\).

From observed actions in previous round \(t-1\), compute:
- \(d_{t-1}\) = number of defectors last round.
- \(x_{t-1} = d_{t-1}/n\) = defection rate last round.

Track a short memory of defection rates over last \(m\) rounds (suggest \(m=3\)):
- \(\bar{x}_{t-1} = \text{average of } x_{t-k} \text{ for } k=1..m\) (use fewer rounds early).

### Stock “health” regions
Define two stock thresholds (fractions of capacity):
- **Healthy:** \(S_t \ge \theta_H \cdot capacity\) with \(\theta_H = 0.85\)
- **Low:** \(S_t \le \theta_L \cdot capacity\) with \(\theta_L = 0.60\)

(These are conservative: once stock drops well below capacity, recovery is slower under ongoing extraction, so you need tighter discipline.)

### Defection tolerance
Allow some defection without immediate retaliation (robustness to mixed populations):
- **Tolerable defection:** \(\bar{x}_{t-1} \le \tau\) with \(\tau = 0.20\)

Interpretation: if at most ~20% of players defect on average recently, continue cooperating to keep the system at capacity and avoid needless punishment cycles.

---

## Core rule (per round \(t\))
**Default to Cooperate, unless either stock is threatened or defection is persistent.**

Play **C** if ALL are true:
1. \(S_t \ge \theta_L \cdot capacity\)  (stock not low), AND  
2. \(\bar{x}_{t-1} \le \tau\) (recent defection not persistent), AND  
3. You are not currently in a punishment phase (defined below).

Otherwise play **D**.

---

## Punishment / forgiveness mechanism (stateful)
To be robust, SGCC uses **triggered punishment with a finite duration**, and **forgiveness when the group returns to cooperation**.

### Trigger punishment
If either condition holds, start (or refresh) punishment:
- **Stock trigger:** \(S_t \le \theta_L \cdot capacity\)
- **Behavior trigger:** \(\bar{x}_{t-1} > \tau\)

### Punishment action
During punishment, play **D** for \(P\) rounds, where:
- \(P = \max(2,\lceil r/10 \rceil)\)  (at least 2 rounds; scales mildly with horizon)

Rationale: finite punishment avoids endless spirals; duration long enough to make defection unattractive in repeated play, short enough to allow recovery.

### Early exit (forgiveness)
If during punishment you observe **one full round with zero defectors** (i.e., \(d_{t-1}=0\)) AND stock is not low (\(S_t > \theta_L\cdot capacity\)), then **end punishment early** and return to cooperation.

This lets cooperative populations recover quickly after a shock, while still requiring a clear behavioral signal.

---

# 2) Edge cases

### Round 1
Play **C** in round 1.  
Reason: stock starts at capacity, and collective optimum is sustained high stock. Starting with D destroys trust and can collapse the resource quickly.

### Last round (round \(r\))
Play **D**.  
Reason: with a known finite horizon and no future discipline, there is no strategic reason to cooperate in the terminal round; taking the higher immediate payoff dominates.

### Round \(r-1\) (second-to-last)
Play:
- **C** only if (i) not in punishment, (ii) \(d_{r-2}=0\), and (iii) \(S_{r-1}\) is Healthy (\(\ge \theta_H\cdot capacity\)).
- Otherwise **D**.

This “soft endgame” prevents being exploited by late defectors while still allowing near-terminal cooperation in clearly cooperative groups.

### Extremely low stock
If \(S_t\) is very low (e.g., \(S_t \le 0.25\cdot capacity\)), **always D**.  
Reason: when the system is already badly depleted, unilateral cooperation yields small payoffs and is easily exploited; defecting is the only leverage to push others toward restraint, and also avoids being consistently out-earned.

---

# 3) “Collective mindset” rationale (what the strategy is trying to achieve)

SGCC is designed to:
1. **Maximize long-run total payoffs** by keeping stock near capacity whenever the group is mostly cooperative.
2. **Be resilient**: it does not collapse into permanent defection due to a single defection or a brief exploratory phase by others (thanks to averaging over a short window and finite punishment).
3. **Prevent exploitation**: if others are persistently defecting, SGCC defects too—refusing to subsidize their higher extraction.
4. **Enable recovery**: it explicitly forgives and returns to cooperation when the group demonstrates compliance (zero defection round) and stock is not low.

---

# Pseudocode (implementable outline)

```pseudo
parameters:
  theta_H = 0.85
  theta_L = 0.60
  tau = 0.20
  m = 3
  P = max(2, ceil(r/10))

state variables:
  punish_remaining = 0
  history_defection_rates = []   // store x_t each round after observing actions

function decide(t, S_t, history_actions):
  if t == 1:
     return C

  if t == r:
     return D

  // compute recent defection average
  x_bar = average_of_last_m(history_defection_rates, m)

  // early forgiveness check (based on last round behavior)
  d_last = number_of_defectors_in_round(t-1)
  if punish_remaining > 0 and d_last == 0 and S_t > theta_L*capacity:
      punish_remaining = 0

  // trigger punishment if needed
  if S_t <= theta_L*capacity or x_bar > tau:
      punish_remaining = P

  if punish_remaining > 0:
      punish_remaining -= 1
      return D

  // endgame caution at r-1
  if t == r-1:
      if d_last == 0 and S_t >= theta_H*capacity:
         return C
      else:
         return D

  // normal cooperation condition
  if S_t >= theta_L*capacity and x_bar <= tau:
      return C
  else:
      return D

function observe_end_of_round(t, actions):
  d_t = count_defectors(actions)
  x_t = d_t / n
  append(history_defection_rates, x_t)
```

---

## Notes on robustness
- **Against always-cooperate opponents:** SGCC mostly cooperates (high collective payoff), only defects at the end.
- **Against always-defect opponents:** SGCC quickly switches to defection (avoids being exploited).
- **Against mixed/learning agents:** the defection-rate averaging and finite punishment prevent overreacting to one-off defections while still disciplining persistent ones.
- **Against “late grab” strategies:** endgame rules reduce vulnerability.

If you want, I can tune \(\theta_H,\theta_L,\tau,m,P\) analytically as functions of \(n\) and growth dynamics (e.g., using expected stock transition comparisons) rather than fixed fractions.
'''

description_COLLECTIVE_44 = '''
## Strategy: **StockGuard (Collective, State‑Based, Forgiving Trigger)**

Goal: keep the resource near **capacity** (where growth is strongest), while being robust to exploitation. The strategy cooperates by default, but switches to defection when (a) the stock is being overharvested or (b) opponents are repeatedly taking the larger share. It also includes a clear “path back” to cooperation to prevent endless collapse.

Key idea: Use **observable stock transitions** to infer whether the group is collectively sustaining the pool, and use **observed actions** to identify persistent overconsumers. Punish in a way that is strong enough to deter, but not so permanent that it destroys recovery.

---

# 1) Decision rules (when to cooperate vs defect)

### Notation you can compute from history at round *t*
- Parameters: `n, r, capacity`
- Current stock at start of round: `S_t`
- Last round actions: `a_{-i, t-1}` (others’ actions), your last action `a_{i,t-1}`
- Let `D_{t-1}` = number of opponents who defected last round
- Let `d_rate_{t-1} = D_{t-1} / (n-1)`
- Let `S_{t-1}` = stock at start of last round

### Two core “health” signals
1) **Stock health (absolute):**  
   - Define **safe stock band** near capacity:  
     - `S_high = 0.9 * capacity`  
     - `S_low  = 0.6 * capacity`  
   Intuition: above ~0.9C you’re safe; below ~0.6C you’re entering a region where continued overharvest risks collapse.

2) **Stock trend (relative):**  
   - `ΔS = S_t - S_{t-1}` (change in stock from last start-of-round to this start-of-round)  
   If `ΔS < 0`, the group’s net behavior is depleting the resource despite regrowth.

### Opponent-behavior score (to target persistent defectors)
Maintain a per-opponent counter `bad_j` updated each round:
- If opponent `j` played `D` last round: `bad_j += 1`
- Else: `bad_j = max(bad_j - 1, 0)` (forgiveness / decay)

Define:
- `Bad = count_j (bad_j >= 2)`  (persistently defecting opponents)

---

## Primary action rule (each round t)

You choose **C** unless one of the following “collective risk” conditions holds; then choose **D**.

### Cooperate (C) if all are true:
1) **Stock is healthy:** `S_t >= S_low`
2) **No strong evidence of ongoing overharvest:**  
   - either `ΔS >= 0` (stock not shrinking), **or** stock is still very high (`S_t >= S_high`)
3) **Not too many persistent defectors:** `Bad <= (n-1)/3` (round down)

### Otherwise: Defect (D)

Interpretation:
- You keep cooperating as long as the pool is not in danger and defection is not entrenched.
- You defect when the pool is drifting downward or too many players repeatedly defect—because continued unilateral cooperation then just funds free-riding and accelerates collapse.

---

## Punishment / recovery (important for robustness)

When you switch to defection, you don’t necessarily defect forever. You apply a **punishment phase** triggered by collective risk, then attempt to restore cooperation when the system stabilizes.

### Punishment phase trigger
Enter “punishment mode” if any holds:
- `S_t < S_low` (stock is low), or
- `ΔS < 0` **and** `d_rate_{t-1} > 0` (someone defected and stock is falling), or
- `Bad > (n-1)/3` (defection is persistent and widespread)

### While in punishment mode
- Play **D** until you observe **both**:
  1) `d_rate_{t-1} <= 1/(n-1)` (at most one opponent defected last round), and
  2) stock is recovering: `ΔS >= 0` or `S_t >= S_high`

Then exit punishment mode and return to default cooperation.

This creates a credible deterrent: persistent defectors face reduced long-run gains because the group stops subsidizing them. But it’s forgiving: cooperation resumes quickly if opponents stop defecting and stock stabilizes.

---

# 2) Edge cases

### First round (t = 1)
- Play **C**.
Rationale: With full stock at capacity, mutual cooperation sustains capacity and reveals opponents’ types without immediately collapsing the pool.

### Last round (t = r)
- Play **D**.
Rationale: End-game incentives: future discipline is irrelevant. Defecting is individually dominant in the final stage given the per-round payoff structure.

### Second-to-last round (t = r-1)
- If `S_{r-1} >= S_high` and `Bad = 0`: play **C** (try to preserve cooperative norm through r-1).
- Else: play **D** (avoid being exploited right before the end).

This prevents being “last-minute farmed” by opportunists while still allowing near-full-stock groups to finish cooperatively.

### Extremely low stock
If `S_t <= capacity/(4)` (very low):
- Play **D** (you must secure some payoff; cooperation yields little and may be exploited).
- Continue punishment mode until `S_t` returns above `S_low` and opponents largely stop defecting.

(Yes, this may slow regrowth, but with this game’s consumption rules, unilateral restraint is often not enough if others defect; the priority is to stop subsidizing overconsumption and force behavior change.)

---

# 3) Collective mindset (what the strategy is “trying to do”)

This strategy treats the stock like a shared infrastructure that should be kept near **capacity**, because that’s where the growth term can fully replenish the round’s cooperative extraction. It therefore:

- **Cooperates by default** to sustain a high-growth equilibrium.
- **Uses stock decline as a coordination signal** when explicit communication is impossible.
- **Punishes persistent overconsumption** to remove the advantage of defecting.
- **Forgives quickly** once the group returns to sustainable behavior, preventing permanent collapse spirals.
- **Recognizes end-game reality** while still supporting cooperation as long as it’s strategically safe.

---

# Pseudocode sketch (implementable)

```python
# State kept by player i
punish = False
bad = {j: 0 for j in opponents}   # persistent defection counters
S_prev = None

def decide(t, S_t, history):
    global punish, bad, S_prev

    S_high = 0.9 * capacity
    S_low  = 0.6 * capacity

    # Edge: first round
    if t == 1:
        S_prev = S_t
        return "C"

    # Update bad counters from last round actions
    last_actions = history.actions[t-1]  # dict player->C/D
    D_count_opp = 0
    for j in opponents:
        if last_actions[j] == "D":
            bad[j] += 1
            D_count_opp += 1
        else:
            bad[j] = max(bad[j] - 1, 0)

    d_rate = D_count_opp / (n - 1)
    Bad = sum(1 for j in opponents if bad[j] >= 2)

    # Stock trend
    ΔS = S_t - S_prev
    S_prev = S_t

    # Last round / endgame
    if t == r:
        return "D"
    if t == r-1:
        if S_t >= S_high and Bad == 0:
            return "C"
        else:
            return "D"

    # Enter punishment mode?
    if (S_t < S_low) or ((ΔS < 0) and (d_rate > 0)) or (Bad > (n-1)//3):
        punish = True

    # Exit punishment mode?
    if punish:
        if (d_rate <= 1/(n-1)) and ((ΔS >= 0) or (S_t >= S_high)):
            punish = False

    # Action selection
    if punish:
        return "D"
    else:
        # Default cooperation if healthy and not too many persistent defectors
        if (S_t >= S_low) and ((ΔS >= 0) or (S_t >= S_high)) and (Bad <= (n-1)//3):
            return "C"
        else:
            return "D"
```

---

If you want, I can also provide (a) recommended parameter tuning for `S_low/S_high` as a function of `n` and `capacity`, or (b) an alternative variant that is more “nice” (higher cooperation rate) vs more “tough” (earlier punishment) depending on tournament meta.
'''

description_COLLECTIVE_45 = '''
## Strategy: **Stock-Guarded, Forgiving Reciprocity (SGFR)**  
Goal: keep the stock near the “safe” region (high regeneration) while using **reciprocity** to (i) make cooperation individually tolerable against mixed populations, and (ii) punish persistent over-consumption quickly enough to prevent collapse.

Key idea:  
- When the stock is healthy, default to **C** to sustain high future payoffs for everyone.  
- If others over-consume, respond with **targeted punishment** (play **D**) for a short, state-dependent period.  
- If the stock becomes endangered, switch to a **protect-the-resource** mode (more D or even always D) because preventing total collapse dominates “being nice.”

This is a collective strategy: it treats the stock as the common asset to defend, and uses punishment only as an instrument to restore sustainable use.

---

# 1) Decision rules (when cooperate vs defect)

### Observables from history (round \(t-1\))
Let:
- \(S_t\) = current stock at start of round \(t\) (known).
- \(k_{t-1}\) = number of opponents who defected last round (i.e., played D).
- \(\bar{k}\) = smoothed defection rate over recent history (optional but recommended):
  - \(\bar{k}_t = \alpha \bar{k}_{t-1} + (1-\alpha) k_{t-1}\), with \(\alpha \approx 0.7\).
- “Recent defections” = \(k_{t-1}\) and/or \(\bar{k}_t\).

### Stock zones (based on capacity)
Define three thresholds:
- **Healthy zone:** \(S_t \ge 0.80 \cdot \text{capacity}\)
- **Caution zone:** \(0.40 \cdot \text{capacity} \le S_t < 0.80 \cdot \text{capacity}\)
- **Danger zone:** \(S_t < 0.40 \cdot \text{capacity}\)

(These values are chosen because logistic growth is strong at moderate stock, but collapse is hard to reverse once very low, especially under continued D.)

---

## Core action rule (per round)

### A) If in **Danger zone** (\(S_t < 0.40C\)): **Defect (D)**  
Rationale: if the pool is endangered, you must deter further depletion immediately. D raises your payoff now, but more importantly it becomes a credible “hard stance” that can force others to stop defecting (because they see you will not be exploited).  
If everyone cooperated in danger, recovery might still be possible—but against unknown opponents, the priority is to avoid being the sole cooperator while others defect and drive stock to 0.

**Rule:** Play **D** until stock returns to the Caution zone *and* opponents show cooperation.

---

### B) If in **Caution zone** (\(0.40C \le S_t < 0.80C\)): **Reciprocity with strong protection**
- If **no one defected last round** (\(k_{t-1}=0\)): play **C**.
- If **some defected**: punish proportionally, but not forever:
  - If \(k_{t-1} \ge 1\): play **D** for the next **\(P\)** rounds, where  
    \[
    P = \min\Big(3,\; 1 + \mathbf{1}[k_{t-1} \ge \lceil n/3\rceil] + \mathbf{1}[S_t < 0.60C]\Big)
    \]
  - After punishment completes, **test cooperation**: play C once; if defections persist, restart punishment.

This creates a **forgiving but firm** cycle: punish briefly, then offer a route back.

---

### C) If in **Healthy zone** (\(S_t \ge 0.80C\)): **Cooperate unless there’s a clear defection pattern**
- Default: **C**.
- If defections occur:
  - If \(k_{t-1}=1\) (isolated defector): **C** (forgive once).  
    Rationale: in high stock, you can absorb a small shock and avoid escalating a single mistake/noise.
  - If \(k_{t-1}\ge 2\) or \(\bar{k}_t\) indicates sustained defection: switch to **D** for \(P=2\) rounds, then test C.

This prevents being farmed by strategies that “occasionally defect” to exploit unconditional cooperators.

---

# 2) Edge cases (first round, last round, etc.)

### First round (no history)
**Play C.**  
Reason: collective orientation and it’s the only way to establish a cooperative basin. Also, at \(S_1=\text{capacity}\), C is sustainable and signals willingness to share.

### Last round
There is no future stock to protect, so classic end-game logic tempts defection. But in a tournament of unknown opponents:
- Some strategies will punish last-round D in their own scoring dynamics? (Not possible since no future rounds.)  
So purely within this game, last-round D weakly dominates C.

**Rule for last round:**  
- If stock is **Healthy** and recent history shows **high cooperation** (e.g., last 3 rounds had \(k=0\)): play **C** (collective “finish strong”).  
- Otherwise play **D**.

This is a “collective if it’s working, pragmatic if not” finish. It avoids gratuitously breaking successful cooperation while not sacrificing payoff against exploiters.

### Very short games (small r)
If \(r\) is only 2–3 rounds, future benefits are limited.
- Keep the same policy but with slightly **shorter punishments** (cap \(P\) at 2) to avoid wasting rounds in retaliation spirals.

---

# 3) Collective mindset (explicitly)

This strategy is collective because it:
1. **Treats stock preservation as the primary objective** (Healthy→C, Danger→hard defense).
2. **Punishes only to restore cooperative extraction**, not to maximize retaliation.
3. **Forgives after short, predictable punishments** and re-tests cooperation repeatedly.
4. **Adapts to group behavior** (punishment length and trigger depend on how many defect, and on stock condition).

---

# Pseudocode (implementation-ready)

```python
# Parameters
H = 0.80 * capacity   # healthy threshold
DNG = 0.40 * capacity # danger threshold
MID = 0.60 * capacity

alpha = 0.7  # smoothing for defection rate

# State variables maintained by the agent
punish_timer = 0
kbar = 0

def choose_action(t, r, S_t, history_actions):
    global punish_timer, kbar

    if t == 1:
        return "C"

    # compute k_{t-1}: number of opponents who played D last round
    k_last = count_opponents_defect(history_actions[t-1])
    kbar = alpha * kbar + (1-alpha) * k_last

    # Last round rule
    if t == r:
        if S_t >= H and last_m_rounds_all_coop(history_actions, m=3):
            return "C"
        else:
            return "D"

    # If currently punishing, continue
    if punish_timer > 0:
        punish_timer -= 1
        return "D"

    # Stock-zone rules
    if S_t < DNG:
        # danger: hard defense; also set a short punishment inertia
        punish_timer = 1
        return "D"

    if S_t < H:  # caution zone
        if k_last == 0:
            return "C"
        else:
            P = 1
            if k_last >= ceil(n/3): P += 1
            if S_t < MID: P += 1
            P = min(P, 3)
            punish_timer = P - 1
            return "D"

    # healthy zone
    if k_last == 0:
        return "C"
    elif k_last == 1 and kbar < 1.2:
        # forgive isolated defection
        return "C"
    else:
        punish_timer = 1  # total of 2 Ds including this round
        return "D"
```

---

## Why this should be robust in a tournament
- **Against cooperators:** it stays at C almost always, sustaining stock near capacity, yielding high long-run totals.
- **Against always-defectors:** it quickly shifts to D; you won’t be a perpetual sucker.
- **Against “mostly cooperate but occasionally defect” strategies:** it forgives single events in healthy stock but punishes patterns, discouraging systematic exploitation.
- **Against trigger-happy punishers:** the punishments are finite and followed by a test-C, helping de-escalation.
- **Against chaotic/noisy play:** stock-zone safety nets prevent catastrophic collapse.

If you want, I can tune the thresholds (0.80/0.40) and punishment lengths analytically for specific \(n, r, capacity\) regimes, or propose an alternative variant that explicitly targets keeping the post-consumption stock near \(capacity/2\) (max-growth point).
'''

description_COLLECTIVE_46 = '''
## Strategy: **Stock-Guarded, Forgiving Reciprocity (SGFR)**  
Collective intent: keep the resource near the sustainable region (high stock), harvest efficiently, and only “punish” enough to stop exploitation—then return to cooperation quickly.

The key idea is:  
- **If the stock is healthy and others mostly cooperate, cooperate.**  
- **If others defect, respond proportionally (but briefly) to remove the incentive to keep defecting.**  
- **If the stock is low, prioritize rebuilding even if that means tolerating some short-term unfairness.**

This makes the strategy adaptive to: always-defectors, conditional cooperators, noisy/erratic players, and opportunists.

---

# 1) Decision rules: when to Cooperate vs Defect

### Quantities computed from history (round \(t-1\))
Let:
- \(S_t\) = current stock at start of round \(t\).
- \(k_{t-1}\) = number of players who defected in round \(t-1\) (observed).
- Defection rate last round: \(\rho_{t-1} = k_{t-1}/n\).

### Stock zones (based on capacity)
Define two thresholds:
- **Low-stock threshold**: \(S_t \le 0.5 \cdot \text{capacity}\)  
- **High-stock threshold**: \(S_t \ge 0.9 \cdot \text{capacity}\)

(These are chosen because your growth function is strongest around mid-stock and you want to avoid crashing toward 0 while also keeping near capacity when cooperation is working.)

### Core rule set
**Rule A — Rebuild mode (resource protection):**  
If \(S_t \le 0.5\cdot\text{capacity}\), **play C**, regardless of what others did last round.  
Rationale: defecting when stock is low accelerates collapse and reduces everyone’s future payoffs, including yours.

**Rule B — Normal mode (reciprocal cooperation):**  
If \(S_t > 0.5\cdot\text{capacity}\):  
- If \(\rho_{t-1} \le 0.25\) (at most 25% defected last round), **play C**.  
- If \(\rho_{t-1} > 0.25\), enter **measured punishment**: **play D** for a short, state-dependent duration, then return to C.

**Measured punishment (how long to defect):**  
Let punishment length \(L_t\) be:
- \(L_t = 1\) if \(0.25 < \rho_{t-1} \le 0.5\)
- \(L_t = 2\) if \(0.5 < \rho_{t-1} \le 0.75\)
- \(L_t = 3\) if \(\rho_{t-1} > 0.75\)

But **cap punishment by stock safety**: if during punishment the stock falls to \(S \le 0.5\cdot\text{capacity}\), immediately stop punishing and switch back to **C** (rebuild mode).

**Rule C — Forgiveness / return-to-C trigger:**  
After you defect for \(L_t\) rounds, return to **C** as long as:
- stock is not low: \(S > 0.5\cdot\text{capacity}\), and  
- last round’s defection rate is improving: \(\rho_{t-1}\) decreased compared to the defection rate that triggered punishment (or \(\rho_{t-1} \le 0.25\)).

If others keep defecting heavily (no improvement), you repeat measured punishment, again bounded by the stock safety rule.

---

# 2) Edge cases

### First round (no history)
**Round 1: play C.**  
Reason: cooperation at full capacity yields good payoffs and preserves the stock at/near capacity if others cooperate; it also gives conditional cooperators a reason to keep cooperating.

### Last round (end-game temptation)
In finite repeated games, many strategies defect at the end. SGFR uses a **stock- and norm-sensitive last-round rule**:

**On the final round \(t=r\):**
- If \(S_r \le 0.5\cdot\text{capacity}\): **play C** (avoid a final crash; also many opponents may already be in rebuild patterns).  
- Else (stock is healthy):  
  - If \(\rho_{r-1} \le 0.25\): **play C** (collective finish; rewards cooperative groups).  
  - If \(\rho_{r-1} > 0.25\): **play D** (don’t be the sucker when the population is already opportunistic).

This prevents being exploited in endgames against defect-prone populations while still allowing cooperative equilibria to persist in cooperative populations.

### If everyone is defecting (or near-everyone)
If \(\rho_{t-1} > 0.75\) and \(S_t\) is still high, SGFR will defect up to 3 rounds—but will **stop** if stock hits the low threshold.  
This avoids a mutual-defection death spiral when stock becomes scarce.

### If one “bully” defects repeatedly while others cooperate
You will punish when defection exceeds 25% in the previous round. In large \(n\), a single defector might be below 25% and won’t trigger punishment. That’s intentional: **over-punishing a lone defector can destroy collective welfare**.  
Instead, SGFR prioritizes sustaining the stock and keeping the cooperative majority stable. If multiple players begin defecting (contagion), punishment triggers quickly.

(If you want a stricter anti-bully version, lower the trigger from 25% to \(1/n\); but that tends to cause costly retaliation cycles in heterogeneous tournaments.)

---

# 3) Collective mindset and robustness

### Why this is “collective”
- **Stock-first safety:** when the system is at risk (\(S \le 0.5\,\text{capacity}\)), you always cooperate to rebuild—this protects everyone’s future payoffs.
- **Proportional response:** you don’t permanently punish; you respond just enough to make defection less attractive if it spreads.
- **Fast forgiveness:** as soon as behavior improves, you return to cooperation, enabling recovery of high-stock steady states.

### Why it’s robust in tournaments
- Against **always-cooperate**: you cooperate almost always; stock stays high.  
- Against **grim/reciprocal strategies**: your punishment is short and then you forgive, preventing endless wars.  
- Against **always-defect**: you defect when safe to avoid being exploited, but you stop defecting when stock becomes endangered.  
- Against **noisy/erratic**: the 25% threshold prevents overreacting to small random defection.

---

# Pseudocode (implementable)

```pseudo
params:
  LOW = 0.5 * capacity
  HIGH = 0.9 * capacity
  TRIGGER = 0.25        # defection-rate trigger
state variables:
  punish_remaining = 0
  punish_trigger_rate = 0

function action(t, S_t, history):
  if t == 1:
    return C

  k_prev = number_of_defectors_in_round(t-1)
  rho_prev = k_prev / n

  # hard safety: rebuild mode
  if S_t <= LOW:
    punish_remaining = 0
    return C

  # if currently punishing
  if punish_remaining > 0:
    punish_remaining -= 1

    # if others improved enough, forgive early
    if rho_prev <= TRIGGER or rho_prev < punish_trigger_rate:
      punish_remaining = 0
      return C
    else:
      return D

  # not punishing: decide whether to start punishment
  if rho_prev <= TRIGGER:
    # last-round special case
    if t == r:
      return C
    return C
  else:
    # start measured punishment
    punish_trigger_rate = rho_prev
    if rho_prev <= 0.5: punish_remaining = 1
    else if rho_prev <= 0.75: punish_remaining = 2
    else punish_remaining = 3

    # last-round special case: if final round and uncooperative environment, defect
    if t == r:
      return D

    return D
```

---

If you want, I can also provide:  
- a more “anti-exploitation” variant (stronger response to even one defector), or  
- a more “resource-maximizing” variant that explicitly targets the stock level that maximizes long-run yield under your logistic growth.
'''

description_COLLECTIVE_47 = '''
## Strategy: **Stock-Guarded Generous Trigger (SGGT)**  
Goal: keep the resource near the regenerative “sweet spot” while being hard to exploit. You *cooperate by default* when the stock and observed behavior indicate the group can sustain it; you *defect as a corrective/disciplinary move* when the stock is being overdrawn or opponents are persistently defecting.

This strategy uses only parameters `(n, r, capacity)`, current `stock S_t`, and full history of actions.

---

# 1) Decision rules: when to Cooperate vs Defect

### Key idea: manage the stock by targeting a safe region
With logistic growth `G(x)=2x(1-x/capacity)`, regeneration is strong when stock is mid-range; it collapses near 0. Overconsumption drives the system to 0 quickly (all-D wipes the pool in one round when S=capacity).

So we define two stock thresholds:

- **Danger threshold**:  
  \[
  S_{\text{low}} = 0.35 \cdot capacity
  \]
  Below this, the pool is fragile; a single “bad” round can cause long damage.  
- **Comfort threshold**:  
  \[
  S_{\text{high}} = 0.75 \cdot capacity
  \]
  Above this, the pool can tolerate some defection and still recover, and cooperation is most rewarding long-run.

(These constants aren’t magical; they’re chosen to (i) avoid the collapse region, (ii) be forgiving, and (iii) not require coordination.)

### Behavior signal: measure whether the table is “cooperation-capable”
Let `D_{t-1}` be the number of defectors last round (observed). Define:

- **Defection rate last round**:  
  \[
  p_{t-1} = D_{t-1}/n
  \]
- **Smoothed defection rate** (robust to noise): exponential moving average  
  \[
  \bar p_t = 0.7 \bar p_{t-1} + 0.3 p_{t-1}
  \]
  with initialization `\bar p_1 = 0`.

Interpretation:
- Low `\bar p_t` → table is mostly cooperative; cooperate.
- High `\bar p_t` → you’re being exploited / pool threatened; defect more.

### Punish persistent defectors, but be generous to one-offs
Track for each opponent `j` their recent defection streak length `streak_j` (consecutive D’s up to last round).

Define:
- **Hard-core defectors** count:  
  `H_{t-1} = # of opponents with streak_j ≥ 2`

This separates “accidental/strategic one-off D” from “always/mostly D”.

---

## Decision rule (core)
At round `t` with current stock `S_t`:

### A) Emergency conservation mode (stock fragile)
If `S_t ≤ S_low`:
- **Play C** *unless* the group is still heavily defecting.
- Specifically:
  - If `p_{t-1} ≤ 0.25` (at most 25% defected last round): **C**
  - Else: **D** (you cannot be the only one conserving while others drain)

Rationale: when stock is low, cooperation is the only path to recovery, but unilateral cooperation against many defectors is throwing good money after bad.

### B) Normal mode (stock healthy enough)
If `S_t > S_low`:

1) **If opponents are mostly cooperating**, cooperate:
- If `\bar p_t ≤ 0.20`: **C**

2) **If there’s moderate defection**, “proportionate firmness”:
- If `0.20 < \bar p_t ≤ 0.45`:
  - If `H_{t-1} = 0` (no persistent defectors): **C** (generous)
  - Else: **D** with probability  
    \[
    q = \min(1,\ 0.5 + \bar p_t)
    \]
    otherwise **C**  
  (So you start punishing if there are repeat defectors; otherwise you keep the door open.)

3) **If defection is high**, defect to avoid exploitation and to discipline:
- If `\bar p_t > 0.45`: **D**

### C) Stock-capacity “harvest window” (optional aggressiveness)
If `S_t ≥ S_high` and `\bar p_t` is not low:
- escalate one step toward D (because stock can buffer it and D deters exploitation):
  - If you would have played C under B2, instead play D with probability `min(1, q+0.2)`.

This makes the strategy less exploitable in high-stock periods where defectors can gain a lot.

---

# 2) Edge cases

## Round 1 (no history)
- **Play C.**
Reason: Cooperation from full stock yields high sustainable long-run payoffs; it also invites mutually cooperative dynamics. Starting with D tends to push systems into mutual defection spirals.

Initialize:
- `\bar p_1 = 0`
- all `streak_j = 0`

## Round 2 (first chance to react)
Use the core rule with `p_1` observed.

## Last round (round r)
There is a classic endgame temptation to defect. But in tournaments, strategies that always last-round defect often trigger preemptive endgame defection from others, lowering total payoffs across many matchups.

So use a **soft last-round rule**:

- If `S_r ≤ S_low`: **C** (protect against collapse; also often matched by cooperative types)
- Else if `\bar p_r ≤ 0.20`: **C** (reciprocate cooperation)
- Else: **D** (don’t be exploited at the end)

This still allows mutual cooperation in cooperative groups, but avoids being the sole cooperator among defectors.

## If stock is 0 or extremely low
If `S_t` is ~0, both C and D pay ~0, but actions determine whether growth can restart (it can only restart if some stock remains after consumption—here it’s already 0). In your dynamics, growth at 0 is 0, so the game is “dead”.
- If `S_t = 0`: action doesn’t matter for payoffs or recovery; choose **D** (standard best reply, and it signals refusal to be exploited if somehow stock revives later due to numerical issues).

---

# 3) Collective mindset: how this aligns with group welfare
This strategy is collective in three ways:

1) **Stock-first governance**: It treats the stock as a shared infrastructure. When stock is threatened, it prioritizes recovery (cooperation) unless the group is clearly not participating.

2) **Generous but not naive**: It cooperates by default and forgives isolated defections, preserving cooperation with “mostly cooperative” opponents.

3) **Disciplines persistent over-users**: It increases defection only when there is evidence of sustained exploitation (high smoothed defection and repeat defectors), protecting cooperative players from being permanently subsidized.

---

# Pseudocode (implementable)

```python
# Parameters: n, r, capacity
S_low  = 0.35 * capacity
S_high = 0.75 * capacity

# State maintained across rounds:
pbar = 0.0
streak = {j: 0 for j in opponents}

def action(t, S_t, last_actions): 
    global pbar, streak
    
    # Round 1
    if t == 1:
        return "C"
    
    # Update opponent streaks using last_actions (from round t-1)
    D_count = 0
    H = 0
    for j, a in last_actions.items():  # opponents only
        if a == "D":
            streak[j] += 1
            D_count += 1
        else:
            streak[j] = 0
        if streak[j] >= 2:
            H += 1

    p = D_count / n
    pbar = 0.7 * pbar + 0.3 * p

    # If stock dead, nothing regrows in this model
    if S_t <= 0:
        return "D"
    
    # Last round rule
    if t == r:
        if S_t <= S_low:
            return "C"
        if pbar <= 0.20:
            return "C"
        return "D"

    # Emergency conservation mode
    if S_t <= S_low:
        if p <= 0.25:
            return "C"
        else:
            return "D"

    # Normal mode
    if pbar <= 0.20:
        return "C"

    if pbar <= 0.45:
        if H == 0:
            return "C"
        q = min(1.0, 0.5 + pbar)  # punish more when defection persists
        if S_t >= S_high:
            q = min(1.0, q + 0.2)
        return "D" if random() < q else "C"

    # High defection environment
    return "D"
```

---

## What this strategy is robust against
- **Always-defect**: quickly switches to D (avoids being farmed), while still taking advantage of high stock early if possible.
- **Mostly-cooperate**: stays in C almost all the time, sustaining stock and high payoffs.
- **Noisy / occasional defectors**: forgiving via streak-based punishment; avoids needless collapse of cooperation.
- **Grim-trigger types**: starts C and avoids “unprovoked” D except in high-defection/high-stock contexts; reduces risk of triggering permanent retaliation.

If you want, I can tune the thresholds (`0.35`, `0.75`, and defection cutoffs) analytically for specific `(n, capacity)` ranges or propose a deterministic (non-random) variant for reproducibility.
'''

description_COLLECTIVE_48 = '''
## Strategy: **Stock-Guarded Reciprocal Cooperation (SGRC)**  
Goal: keep the resource near the regenerative sweet spot while being hard to exploit. We cooperate by default when the group is behaving sustainably and the stock is healthy; we defect when (a) the stock is being driven down or (b) others are exploiting, and we return to cooperation after evidence of recovery.

This is a **collective** strategy: it treats the stock as the primary shared objective and uses reciprocity only to prevent unilateral sacrifice.

---

# Key ideas (what the strategy tries to accomplish)

1. **Maintain stock at a safe operating range**  
   The logistic growth is strong when stock is moderate, but collapses at 0. Since *all-D collapses immediately*, we avoid trajectories that risk depletion. When stock is too low, we defect to (i) avoid being the “sucker” and (ii) make exploitation costly.

2. **Reciprocate based on *observed total consumption*** (not just who defected)  
   Because payoffs are stock-proportional, what matters is whether the group’s aggregate behavior is compatible with sustainability.

3. **Forgive after recovery**  
   If others return to cooperative behavior and the stock recovers, we revert to cooperation.

4. **Endgame realism**  
   In the last round, there’s no future stock to protect: defect is individually dominant. In the second-to-last round, we still condition on whether protecting stock has any remaining value.

---

# Quantities computed from history each round

Let:
- `S` = current stock at start of round.
- `cap` = capacity.
- `n` = number of players.
- Observed previous-round actions allow us to compute:
  - `kD_last` = number of defectors last round.

Define per-round total consumption given `kD` defectors:
- Total consumption fraction of stock:
  \[
  f(kD) = \frac{(n-kD)}{2n} + \frac{kD}{n} = \frac{1}{2} + \frac{kD}{2n}
  \]
So remaining stock after consumption:
- `S_rem = S * (1 - f(kD)) = S * (1/2 - kD/(2n))`

This shows why defectors are dangerous: if `kD = n`, remaining is 0.

We also track a **recent defection rate**:
- `d_bar` = average of `kD/n` over the last `W` rounds (window `W=3` works well; use fewer if `t<3`).

---

# Decision rules (cooperate vs defect)

### Parameters (fixed, only depend on game parameters)
- Window size: `W = 3`
- Stock safety thresholds (as fractions of capacity):
  - `S_low = 0.35 * cap`  (resource at risk)
  - `S_high = 0.70 * cap` (resource comfortably healthy)
- Tolerance of defection:
  - “Good behavior” threshold: `d_good = 0.15`  (≈ “almost everyone cooperates”)
  - “Bad behavior” threshold: `d_bad  = 0.35`  (≈ “a sizable minority defects”)

These values are chosen to be conservative: they aim to prevent downward spirals and discourage exploitation without overreacting to one-off noise.

---

## Round-by-round policy

### 1) First round (t = 1): **Cooperate**
Reason: establish a cooperative baseline; also, with full stock, cooperative play can regenerate back to capacity if many cooperate, and gives the group a chance to coordinate implicitly.

**Action:** `C`

---

### 2) Last round (t = r): **Defect**
No future stock value remains; defect strictly dominates in the stage game.

**Action:** `D`

---

### 3) All other rounds (2 ≤ t ≤ r−1): state- and reciprocity-based

We decide using **stock level** + **recent defection rate**.

#### Rule A — Emergency protection: if stock is low, defect
If `S <= S_low`, we defect regardless of others. This prevents being exploited when the system is fragile and pushes the game into a “no free riders” stance until recovery.

**If:** `S <= 0.35*cap` → **Play D**

#### Rule B — Healthy stock: cooperate if the group is mostly cooperating
If `S >= S_high` and recent defection is low, cooperate to keep the stock high and sustain long-run payoffs.

**If:** `S >= 0.70*cap` **and** `d_bar <= d_good` → **Play C**

#### Rule C — Punish sustained exploitation: defect if defection is prevalent
If recent defection is moderate/high, defect. This removes incentives for persistent defectors to farm cooperators.

**If:** `d_bar >= d_bad` → **Play D**

#### Rule D — Gray zone (middling stock, middling behavior): “conditional cooperation”
When neither stock nor behavior is clearly good/bad, we use the last round’s realized defection count:

- If last round had **any** defection and stock is not clearly high, defect once to signal intolerance.
- Otherwise cooperate.

Concretely:
- If `kD_last >= 1` and `S < S_high`: **Play D**
- Else: **Play C**

This makes the strategy **adaptive**: it is cooperative in stable regimes but quickly becomes unprofitable to exploit.

---

# Forgiveness / returning to cooperation
The strategy automatically forgives via the moving average `d_bar`:
- Once opponents reduce defection for a few rounds and stock recovers above `S_high`, we return to cooperation.
No special “reset” is required; it is built into Rules B and D.

---

# Pseudocode

```python
def SGRC_action(t, r, n, cap, S, history):
    # history contains past rounds actions by all players
    if t == 1:
        return "C"
    if t == r:
        return "D"

    W = 3
    S_low  = 0.35 * cap
    S_high = 0.70 * cap
    d_good = 0.15
    d_bad  = 0.35

    # compute kD_last
    kD_last = count_defectors(history[t-1])  # number of players who played D last round

    # compute moving average defection rate over last W rounds (or available rounds)
    rounds = range(max(1, t-W), t)  # previous rounds only
    d_bar = average(count_defectors(history[τ]) / n for τ in rounds)

    # Rule A: emergency
    if S <= S_low:
        return "D"

    # Rule B: healthy & cooperative environment
    if S >= S_high and d_bar <= d_good:
        return "C"

    # Rule C: punish sustained defection
    if d_bar >= d_bad:
        return "D"

    # Rule D: gray zone conditional response
    if kD_last >= 1 and S < S_high:
        return "D"
    return "C"
```

---

# Edge cases and robustness notes

- **If opponents always defect:**  
  After round 1 we quickly defect (Rule D/C), avoiding being the only cooperator. Stock collapses, but you avoid extra losses relative to naive cooperation.

- **If opponents are mostly cooperative with occasional mistakes:**  
  The moving average and thresholds provide forgiveness; a single defection doesn’t necessarily lock into permanent defection if the group returns to cooperation and stock remains healthy.

- **If opponents “probe” (defect sometimes to test exploitation):**  
  Conditional punishment (Rule D) makes probing costly. They won’t gain repeated advantage unless they accept dragging the system into lower stock where everyone defects more.

- **Second-to-last round (t = r-1):**  
  Still follows the main rules. That means if stock is healthy and others cooperated, we may cooperate; if not, we defect. This is intentional: it extracts remaining cooperative surplus when it’s safe, but won’t be exploited right before the end.

---

## Collective framing (what this strategy commits to)
- “We cooperate when the stock is safe and the group is behaving sustainably.”
- “We defect when the stock is endangered or when exploitation becomes common.”
- “We return to cooperation after a short, verifiable period of improved group behavior.”

If you want, I can tune the thresholds (`S_low`, `S_high`, `d_good`, `d_bad`, `W`) to emphasize either (a) higher cooperation against nice populations or (b) stronger anti-exploitation performance in adversarial tournaments.
'''

description_COLLECTIVE_49 = '''
## Collective Strategy: **Sustain–Reciprocate with Stock Safeguard (SRSS)**

Goal: keep the common stock near the regenerative sweet spot (high growth) while remaining robust to exploitation. The strategy is *collective-first* when the group is behaving sustainably, but it *escalates quickly* against over-consumption and *de-escalates* back to cooperation once behavior improves.

Key idea: infer how many opponents defected last round from the observed stock transition, then choose **C** when the group is sufficiently cooperative and the stock is healthy, otherwise choose **D** to (i) avoid being the sucker and (ii) “signal” a penalty that reduces incentives to defect.

---

# 1) Decision Rules (C vs D)

### A. Reconstruct “how many defected” from history (public state)
Because stock dynamics are deterministic and actions are binary, you can infer total consumption and therefore the number of defectors.

Let in round *t*:
- stock at start: `S_t`
- stock at start of next round: `S_{t+1}` (observed after the update)
- capacity: `K`

Compute remaining stock **after consumption** `R_t` by inverting the growth step:

Growth rule:  
`S_{t+1} = min(R_t + 2*R_t*(1 - R_t/K), K)`

For typical ranges, `S_{t+1} < K` unless it hit the cap; but we can handle both cases by solving the quadratic for `R_t`:

If `S_{t+1} < K`:
- `S_{t+1} = 3R_t - 2R_t^2/K`
- Solve: `2R_t^2/K - 3R_t + S_{t+1} = 0`
- Take the root in `[0, S_t]`.

If `S_{t+1} == K`:
- multiple `R_t` values could map to cap; choose the **largest feasible** `R_t` in `[0,S_t]` consistent with hitting capacity (this biases toward “more cooperative” inference, which supports collective play when ambiguous).

Then:
- total consumption: `C_t = S_t - R_t`

Given k defectors among n:
- each cooperator consumes `S_t/(2n)`
- each defector consumes `S_t/n`
- total consumption = `(n-k)*S_t/(2n) + k*S_t/n = S_t/2 + k*S_t/(2n)`

So:
- `C_t = S_t/2 + k*S_t/(2n)`
- `k_hat = round( (2n/S_t) * (C_t - S_t/2) )`
- clamp `k_hat` to `[0, n]`

This yields an estimate of defectors last round: `k_hat(t)`.

---

### B. Cooperation threshold: “How much defection can we tolerate?”
Use an adaptive tolerance that depends on stock health. When stock is high, we can be more forgiving; when stock is low, we require near-full cooperation to recover.

Define stock ratio: `x = S_t / K`.

Set tolerated defectors `T(x)`:
- If `x >= 0.75`: tolerate up to `floor(n/4)` defectors
- If `0.45 <= x < 0.75`: tolerate up to `floor(n/6)` defectors
- If `x < 0.45`: tolerate `0` defectors (needs full cooperation to rebuild)

(These cutoffs are simple and robust; they reflect that low stock makes the system fragile.)

---

### C. Core action rule each round (except special edge cases)
Maintain a “penalty counter” `P` (integer ≥ 0) that determines how long we punish after excessive defection.

At the start of round t (t>1), after inferring `k_hat(t-1)`:

1) **If last round looked sustainable** (`k_hat(t-1) <= T(S_{t-1}/K)`), then:
- Decrease penalty: `P = max(P - 1, 0)`
- **Play C**, unless stock is critically low (see safeguard below)

2) **If last round showed too much defection** (`k_hat(t-1) > T(...)`), then:
- Increase penalty proportional to how bad it was:
  - `P = min(P + 1 + (k_hat(t-1) - T(...)), P_max)`
  - with `P_max = 5` (keeps retaliation bounded)
- **Play D** while `P > 0`

3) **Stock safeguard (collective sustainability override)**  
Even if others were okay, if the stock is in danger, prioritize preventing collapse:
- If `S_t <= 2n` (near the problem’s stated lower band) OR `x < 0.30`:
  - **Play C** *only if* `k_hat(t-1) == 0` (full cooperation last round)
  - otherwise **Play D** (don’t be exploited when the resource is fragile)

This safeguard prevents being repeatedly milked when stock is already low.

---

### D. Why this is “collective”
- It cooperates by default under sustainable group behavior.
- It uses *measured*, state-dependent tolerance (forgiving when safe, strict when fragile).
- Punishment is **temporary and reversible**: cooperation quickly resumes after improvement.
- It is robust against:
  - Always-defect: you defect most rounds after detecting it.
  - Grim/trigger strategies: your quick return to C after compliance helps restore cooperation.
  - Noise-like behavior: bounded penalty prevents permanent collapse.

---

# 2) Edge Cases

### First round (t = 1)
There is no history; start collectively:
- **Play C** in round 1.

Rationale: with stock at capacity, mutual cooperation regenerates perfectly (in many parameterizations like the example). Starting with D needlessly risks rapid depletion and invites mutual defection dynamics.

### Last round (t = r)
Classic backward induction tempts defection, but in a tournament setting opponents may punish end-game opportunism (and you may benefit from keeping a reputation-like pattern across their logic even if not explicit). Still, there’s no future stock benefit.

Rule:
- If `P > 0` (we’re in punishment mode) or `k_hat(r-1) > 0`: **Play D**.
- Else (recent full cooperation and no active punishment): **Play C**.

This avoids being the only cooperator in the finale while not gratuitously betraying a cooperative group.

### If stock hits zero or very low
- If `S_t == 0`: payoff is 0 regardless; play **C** (neutral, but “cooperate” keeps you aligned if others attempt recovery later).
- If `S_t` is tiny and inference becomes numerically unstable, fall back to a simple robust rule:
  - If last observed `S_{t} <= S_{t-1}` (no recovery trend): **D**
  - Else **C**

### If inference is ambiguous due to cap at capacity
When `S_{t+1} == K`, multiple previous `R_t` could map to cap. Use “optimistic tie-breaking”:
- infer the **minimum** consumption consistent with the cap (i.e., largest `R_t`)
- this biases toward cooperation and helps maintain collective stability when the system is healthy.

---

# 3) Pseudocode (implementation-ready logic)

```pseudo
Initialize:
  P = 0
  action_1 = C

For t = 1..r:
  observe S_t

  if t == 1:
    play C
    continue

  # Infer k_hat from (S_{t-1}, S_t)
  k_hat = infer_defectors(S_{t-1}, S_t, n, K)

  # Compute tolerance based on stock health last round
  x_prev = S_{t-1} / K
  if x_prev >= 0.75: T = floor(n/4)
  else if x_prev >= 0.45: T = floor(n/6)
  else: T = 0

  # Update penalty
  if k_hat <= T:
    P = max(P - 1, 0)
  else:
    P = min(P + 1 + (k_hat - T), 5)

  # Stock safeguard (current stock)
  x = S_t / K
  fragile = (S_t <= 2*n) OR (x < 0.30)

  # Last round special handling
  if t == r:
    if P > 0 OR k_hat > 0: play D
    else: play C
    continue

  # Main action choice
  if fragile:
    if k_hat == 0 AND P == 0: play C
    else: play D
  else:
    if P > 0: play D
    else: play C
```

---

## Summary of the behavior you should expect
- **Forms cooperation quickly**: starts with C and stays with C when defection is rare.
- **Doesn’t get exploited for long**: detects excess defection via stock changes and retaliates with bounded but meaningful punishment.
- **Protects the resource**: becomes stricter as stock declines, requiring near-unanimous cooperation to keep cooperating.
- **Recovers cooperation**: once others reduce defection, it relaxes punishment and returns to C.

If you want, I can tune the tolerance cutoffs (`0.75/0.45/0.30`) and penalty dynamics (`P_max`, increment size) for specific ranges of `n`, `r`, and `capacity`, or for a known tournament meta (e.g., many unforgiving trigger strategies vs many exploiters).
'''

description_COLLECTIVE_50 = '''
## Strategy: **Stock‑Guarded Conditional Cooperation (SGCC)**  
Goal: keep the stock near **capacity** (where sustainable yield is high) while deterring persistent over-consumption. The strategy is *collective-first* but *state- and history-adaptive*.

### Key idea
- The resource is healthiest when, after consumption, the remaining stock is about **capacity/2**, because logistic growth is maximized there.  
- With this game’s consumption rules, **all cooperate (all C)** from full capacity returns stock to capacity each round in the provided example; more generally it tends to keep stock high when capacity ≥ 2n.  
- A single defector gains immediately but harms future stock; so we cooperate when the group appears cooperative and the stock is healthy, and we **punish** defections in a way that is strong enough to change incentives, but not so destructive that it collapses the stock.

---

# 1) Decision rules (when to C vs D)

### Quantities computed from history/state each round t
- `S` = current stock at start of round t (observed).
- `d_last` = number of defectors in round t−1 (from observed actions). For t=1, treat as 0.
- `p_hat` = estimated defection rate over a recent window (e.g., last `w = min(5, t-1)` rounds):  
  `p_hat = (total # of defections in window) / (n * w)`; for t=1, p_hat=0.

### Stock zones
Use two thresholds (fractions of capacity):
- **Healthy zone:** `S ≥ 0.75 * capacity`
- **Fragile zone:** `0.40 * capacity ≤ S < 0.75 * capacity`
- **Critical zone:** `S < 0.40 * capacity`

(These are simple and robust; they don’t depend on fine-tuned opponent modeling.)

---

## Action rule summary
### A) If stock is **Healthy**
- **Default:** play **C**.
- **Punish only if needed:**  
  If last round had defections (`d_last > 0`) or defection is trending (`p_hat > 0.10`), enter *targeted punishment*:
  - Play **D** for `L` rounds, where  
    `L = min(3, 1 + floor(2 * p_hat * 5))`  (so 1–3 rounds)
  - After punishment, return to **C** if no defections occurred during punishment; otherwise extend by 1 (cap at 3) and reassess.

**Collective meaning:** “We keep the resource thriving with C, but we immediately show that defection causes others to stop subsidizing.”

---

### B) If stock is **Fragile**
- Be stricter: cooperation only if the group is behaving.
- Play **C** only if:
  - `d_last == 0` **and** `p_hat ≤ 0.10`
- Otherwise play **D** (defensive stance).

**Collective meaning:** “When the commons is stressed, we cannot afford to be the only ones restraining consumption.”

---

### C) If stock is **Critical**
- Play **D** (protect against being exploited in a collapsing resource) **until** both conditions hold:
  - `d_last == 0` for **two consecutive rounds**, and
  - `S` has recovered into Fragile (≥ 0.40*capacity)
- Then return to Fragile-zone rule.

**Collective meaning:** “In crisis we stop unilateral restraint; we require clear evidence of renewed cooperation before rebuilding.”

---

# 2) Edge cases (first round, last round, etc.)

### First round (t = 1)
- Play **C**.
Rationale: with no history, choose the cooperative equilibrium candidate that sustains stock; also signals willingness to coordinate without communication.

### Last round (t = r)
- If `S` is Healthy **and** `p_hat ≤ 0.10` **and** `d_last == 0`: play **C**.
- Otherwise play **D**.

Rationale: end-game defection incentives are real, but if the group has been reliably cooperative and stock is high, maintaining C avoids provoking mutual collapse in the final steps. If there’s any sign of end-game opportunism, do not be the sole cooperator.

### Very small r
If `r` is close to 2–3, punishment still matters because it affects the immediately following round(s). SGCC’s punishments are short (1–3 rounds) to remain relevant.

---

# 3) “Collective” alignment (why this is a collective strategy)
SGCC is collective in three concrete ways:
1. **Defaults to C** when stock is healthy, maximizing long-run total payoffs and maintaining the renewable resource.
2. **Punishes defections quickly but briefly**, aiming to restore cooperation rather than spiral into mutual destruction.
3. **Becomes more conservative only when the stock is at risk**, prioritizing the commons’ viability and avoiding being exploited during fragile periods.

---

# Pseudocode (implementable)

```pseudo
parameters: n, r, capacity
state each round t: S_t, history of actions

constants:
  healthy = 0.75 * capacity
  fragile = 0.40 * capacity
  w_max = 5
  p_threshold = 0.10
  max_punish = 3

memory:
  punish_left = 0
  coop_streak = 0  // consecutive rounds with zero defections observed

function defection_rate(window w):
  return (# of D in last w rounds) / (n * w)

for t in 1..r:
  observe S = current stock
  if t == 1:
    play C
    continue

  d_last = # of D observed in round t-1
  if d_last == 0: coop_streak += 1 else coop_streak = 0

  w = min(w_max, t-1)
  p_hat = defection_rate(w)

  // last-round adjustment
  if t == r:
    if S >= healthy and d_last == 0 and p_hat <= p_threshold:
      play C
    else:
      play D
    continue

  // If currently punishing, continue unless cooperation restored
  if punish_left > 0:
    if d_last == 0:
      punish_left -= 1
    else:
      punish_left = max(punish_left, 1)  // keep at least 1 more
    play D
    continue

  // Zone logic
  if S >= healthy:
    if d_last > 0 or p_hat > p_threshold:
      L = min(max_punish, 1 + floor(2 * p_hat * 5))  // 1..3
      punish_left = L
      play D
    else:
      play C

  else if S >= fragile:  // Fragile zone
    if d_last == 0 and p_hat <= p_threshold:
      play C
    else:
      play D

  else:  // Critical zone
    if coop_streak >= 2 and S >= fragile:
      play C  // will fall into Fragile branch next round
    else:
      play D
```

---

## What this is robust against
- **Always Defect opponents:** SGCC quickly shifts to D, avoiding being exploited repeatedly.
- **Mostly cooperative populations with occasional noise:** short punishments, fast return to C.
- **Strategic “probe” defectors:** immediate, predictable retaliation makes probing unprofitable over repeated play.
- **Resource shocks (low S):** zone-based rules adapt without requiring opponent-type inference.

If you want, I can also provide a “softer” variant (more forgiving) and a “harder” variant (more deterrent) and explain when each is better depending on n, r, and capacity.
'''

description_COLLECTIVE_51 = '''
## Strategy: **Stock-Guardian with Credible Deterrence (SGCD)**  
Collective goal: keep the resource near its sustainable “high-growth” region (around **capacity/2** and above), while using **fast, state-based punishment** to make repeated defection unprofitable for a broad range of opponents. The strategy is *not* a fixed cooperation schedule; it adapts to (i) current stock, (ii) how many defected last round, and (iii) whether the system is recovering or collapsing.

Key idea:  
- When stock is healthy, **cooperate by default** to maximize long-run total yield.  
- When opponents defect, **punish quickly but proportionally**, then **forgive** once behavior improves and stock is safe.  
- When stock is low/critical, **shift to survival mode**: defect to secure private payoff because the public good is already failing and cooperation yields little.

---

# 1) Decision rules (C vs D)

### State variables computed each round \(t\)
Let:
- \(S_t\) = current stock at start of round \(t\)
- \(d_{t-1}\) = number of players who played D in round \(t-1\) (for \(t=1\), define \(d_0=0\))
- \(x_{t-1} = d_{t-1}/n\) = last-round defection rate
- Maintain an internal integer **punish_timer** (starts at 0)

### Stock zones (parameter-based thresholds)
Use these thresholds (robust across capacities as long as capacity ≥ 2n):
- **Critical**: \(S_t \le 0.25 \cdot capacity\)
- **Caution**: \(0.25 \cdot capacity < S_t < 0.60 \cdot capacity\)
- **Healthy**: \(S_t \ge 0.60 \cdot capacity\)

Rationale: logistic growth is strongest around \(capacity/2\); below ~0.25 capacity recovery is slower and the game is fragile.

---

## Core rule set

### A) Survival override (resource protection / realism)
If \(S_t \le 0.25\cdot capacity\): **Play D**.  
Reason: when the commons is near collapse, unilateral cooperation yields low payoff and often doesn’t restore the resource if others keep defecting. This rule prevents being exploited in endgame collapse.

---

### B) Punishment mechanism (deterrence)
If **punish_timer > 0**: **Play D** and decrement punish_timer by 1.  
This makes threats credible even in simultaneous play: after defection is observed, we commit to a fixed number of D rounds.

How punish_timer is set (after observing round \(t-1\)):  
- If \(x_{t-1} = 0\): set punish_timer = 0 (full forgiveness)
- Else if \(x_{t-1} < 0.5\): set punish_timer = **1**  
- Else if \(0.5 \le x_{t-1} < 0.8\): set punish_timer = **2**  
- Else (≥0.8): set punish_timer = **3**

Additionally, **escalate** if defection persists:
- If \(x_{t-1} > 0\) and also \(x_{t-2} > 0\) (two consecutive defection rounds observed), then  
  `punish_timer = max(punish_timer, 2)` even if the latest x is small.  
This stops “occasional” defectors from repeatedly nibbling without consequence.

---

### C) Cooperative driving (collective efficiency)
If not in survival mode and not currently punishing:

1) If \(S_t \ge 0.60\cdot capacity\) (healthy): **Play C**.  
   - This keeps stock in a regime where one round of cooperation tends to refill strongly.

2) If \(0.25\cdot capacity < S_t < 0.60\cdot capacity\) (caution zone):  
   - If \(x_{t-1} = 0\): **Play C** (support recovery)  
   - Else: **Play D** (don’t be the only one rebuilding while others extract)

This makes cooperation conditional on both **ecological state** and **social state**.

---

# 2) Edge cases (first round, last round, and special situations)

### First round (t = 1)
- **Play C** unless stock is already critical (\(S_1 \le 0.25\,capacity\)), in which case play D.  
Reason: start cooperatively to invite a cooperative basin of attraction; it’s also collectively optimal when stock begins at capacity.

### Last round (t = r)
- If \(S_r \ge 0.60\cdot capacity\) **and** last round had low defection \(x_{r-1}=0\): **Play C**.  
- Otherwise: **Play D**.

Why not always defect in the last round? Because this is a tournament against strategies that *respond to last-round behavior earlier*. Maintaining a “credible cooperative type” until the end can yield higher cumulative payoffs when others are conditional cooperators; the last-round defection gain is only one-round.

### Near-last (t = r-1)
- Use the normal rules, but cap punishments:  
  `punish_timer = min(punish_timer, r - t)`  
So you don’t “waste” punishment commitments that can’t be carried out.

### If stock hits exactly 0 or extremely low
- Always D (already covered by critical zone). There is no public resource left to protect; the only rational move is to take what you can if it regrows.

### If opponents alternate to manipulate (e.g., defect every other round)
- The “two consecutive defection rounds ⇒ punish_timer ≥ 2” plus proportional punishment makes alternating defection costly because it repeatedly triggers punishment and keeps the game from returning to the high-payoff cooperative basin.

---

# 3) Why this is “collective” and robust

### Collective alignment
- In healthy conditions, SGCD **drives the system toward the stable high-yield regime** by cooperating.
- It **does not over-punish**: punishments are short, proportional, and automatically forgiven when defection stops—this helps restore cooperation quickly (good for group welfare).
- It **protects the commons** by refusing to cooperate when stock is critical or when others are actively undermining recovery.

### Robustness to opponent types
- **Unconditional cooperators**: SGCD mostly cooperates; stock stays healthy; high mutual payoffs.
- **Unconditional defectors**: SGCD shifts to D after observing defection; avoids being exploited; survival override prevents chronic sucker outcomes.
- **Grim/trigger strategies**: SGCD minimizes accidental defections by cooperating in healthy states; if a punishment happens, it is short and then returns to C, often re-coordinating.
- **Noise-like or inconsistent strategies**: proportional punishment and forgiveness prevents endless retaliation spirals.
- **Strategic exploiters**: repeated opportunistic D gets met with escalating punishment and removal of “rebuild-for-you” cooperation in caution zone.

---

# Pseudocode (implementation-ready logic)

```pseudo
initialize punish_timer = 0

for t in 1..r:
    observe current stock S_t

    if t == 1:
        if S_t <= 0.25*capacity: action = D
        else action = C
        play action
        continue

    # update punishment based on last round behavior (after observing history)
    d_last = count_defections_in_round(t-1)
    x_last = d_last / n

    if x_last == 0:
        punish_timer = 0
    else:
        if x_last < 0.5: base = 1
        else if x_last < 0.8: base = 2
        else base = 3

        # escalation for persistence
        if t >= 3:
            d_prev = count_defections_in_round(t-2)
            if d_prev > 0:
                base = max(base, 2)

        punish_timer = max(punish_timer, base)

    # cap punishment to remaining rounds
    punish_timer = min(punish_timer, r - t + 1)

    # choose action
    if S_t <= 0.25*capacity:
        action = D
    else if punish_timer > 0:
        action = D
        punish_timer -= 1
    else:
        if S_t >= 0.60*capacity:
            action = C
        else: # caution zone
            if x_last == 0: action = C
            else action = D

    # last round tweak (optional but consistent)
    if t == r:
        if S_t >= 0.60*capacity and x_last == 0 and punish_timer == 0:
            action = C
        else:
            action = D

    play action
```

---

If you want, I can also provide (a) parameter sensitivity notes (e.g., alternative thresholds if capacity is very close to 2n), or (b) a version that explicitly targets \(S \approx capacity/2\) via a tighter “ecological controller” rather than the three-zone rule.
'''

description_COLLECTIVE_52 = '''
## Strategy: **StockGuard (for collective sustainability with disciplined retaliation)**

Goal: keep the common stock near **capacity** (where growth can restore what we take) by defaulting to **C**, but switch to **D** quickly when others’ behavior (or the stock trajectory) makes cooperation non-viable. The logic uses only public history, current stock, and parameters.

Key idea: with stock dynamics, *the group can sustain full replenishment in a round if the post-consumption remainder is about half the capacity* (because logistic growth is maximal around capacity/2). So we try to keep:
- **S_remaining ≈ capacity / 2** after consumption, which implies
- **Total consumption ≈ capacity / 2** per round, i.e. **average consumption per player ≈ capacity / (2n)**.

Since actions are only {C, D}, we implement this target via a rule that:
- cooperates when the stock is “safe” and opponents are not exploiting,
- defects when the stock is “at risk” or opponents are exploiting,
- returns to cooperation after a probation period if conditions improve.

---

# 1) Decision rules: when to cooperate vs defect

### Definitions (computed each round before choosing action)

Let:
- `S` = current stock at start of the round.
- `H` = recent history (actions of all players in prior rounds).
- `d_last` = number of defectors last round (0..n).
- `d_avg_k` = average number of defectors over the last `k` rounds (use `k = min(5, t-1)`).
- `t` = current round index (1..r).

Stock “zones” (thresholds depend only on parameters):
- `S_high = 0.85 * capacity`  (near full)
- `S_mid  = 0.60 * capacity`
- `S_low  = 0.45 * capacity`  (below this, even moderate extra defection is dangerous)
- `S_crit = 0.25 * capacity`  (critical; prioritize self-protection and deterrence)

Behavior thresholds:
- “Low defection environment”: `d_avg_k <= 0.15 * n`
- “Moderate defection”: `0.15n < d_avg_k <= 0.35n`
- “High defection”: `d_avg_k > 0.35 * n`

We also maintain an internal state variable:
- `punish_timer` (integer, starts at 0). If >0 we are in punishment mode and will choose D until it reaches 0.

---

## Core action rule

### A. If in punishment mode
- If `punish_timer > 0`: **play D**, then decrement `punish_timer -= 1`.
- Exception (de-escalation): if `S >= S_high` *and* `d_last == 0`, set `punish_timer = 0` and **play C** (immediate reconciliation when everyone is back to C and stock is safe).

### B. If not in punishment mode (punish_timer == 0)
Choose based on stock zone + recent defection:

**1) Stock is healthy (S >= S_mid):**
- If `d_avg_k` is low: **play C**.
- If `d_avg_k` is moderate:
  - If `d_last == 0`: **play C** (give room for recovery).
  - Else: **play D** (discourage drift to defection).
- If `d_avg_k` is high: **play D** (don’t be exploited).

**2) Stock is getting risky (S_low <= S < S_mid):**
- If `d_last == 0` and `d_avg_k` is low: **play C** (try to restore cooperative path).
- Otherwise: **play D** (protect stock and punish pressures that could push stock below sustainable region).

**3) Stock is low/critical (S < S_low):**
- **play D** (hardline stabilization / deterrence).
  - Rationale: when stock is low, each player’s immediate incentive to defect is strong; unilateral cooperation becomes very exploitable and may not restore stock fast enough if others defect.

---

## Triggering punishment (how punish_timer is set)

After observing round `t-1` outcomes (i.e., at start of round `t`), if not already punishing, set a punishment timer when defection is detected and seems harmful.

Set `punish_timer` when any of these conditions hold:
1. **Defection shock:** `d_last >= 1` and `S < S_high`  
2. **Defection trend:** `d_avg_k > 0.25*n`
3. **Stock drop warning:** stock decreased across rounds despite not being low already (implementation: compare last two stocks; if `S_t < S_{t-1}` and `S_{t-1} < S_high`, treat as warning)

Punishment length (short but meaningful, scales with severity):
- `punish_timer = ceil( 1 + 2 * (d_last / n) )`
So:
- 1 defector in large n → ~2 rounds punishment
- many defectors → up to ~3 rounds punishment

This is intentionally **finite** to avoid permanent defection traps, but long enough to make defection less attractive when others are conditionally cooperative.

---

# 2) Edge cases

### First round (t = 1)
- **Play C.**
Reason: stock starts at capacity; cooperation is the collectively optimal baseline and also a good “test” of the population.

### Last round (t = r)
Two variants exist; we choose the one that best supports collective outcomes in a tournament:

- If `d_avg_k` is low **and** `S >= S_mid`: **play C** (don’t trigger endgame unraveling; helps total welfare).
- Otherwise: **play D** (protect against likely endgame defection/exploitation).

This balances standard “last-round defection” logic with the reality that many tournament agents are not strict backward-induction players and will reward consistent cooperation.

### If stock hits (or is near) zero
- If `S <= 0.05 * capacity`: **play D** (always).  
At very low stock, payoffs are tiny anyway; the priority is to deter free-riding when/if recovery starts.

### If stock is exactly at capacity for many rounds
- Continue **C** unless defection appears (then follow punishment logic).  
This keeps the system in the “consume half, regrow half” sweet spot when most cooperate.

---

# 3) Collective mindset (what this strategy is “trying to do”)

- **Default trust:** Start and remain cooperative when the group demonstrates cooperative behavior and the stock is in a healthy region.
- **Sustainability-first:** Switch to D when stock enters danger zones, because the collective resource is what generates future payoffs.
- **Disciplined deterrence:** Retaliate quickly and in proportion to the observed level of defection, but **for a limited time**, so cooperation can re-emerge.
- **Forgiveness with conditions:** Return to C when the group’s recent behavior improves and the stock is safely rebuilding.

---

## Pseudocode (implementation-oriented)

```python
# Parameters: n, r, capacity
# Observables each round t: S (current stock), history actions a[1..t-1][1..n], stocks S_hist[1..t-1]
# Internal state: punish_timer = 0

def choose_action(t, S, history_actions, S_hist, punish_timer):
    if t == 1:
        return "C", 0

    k = min(5, t-1)
    d_last = count_defectors(history_actions[t-1])
    d_avg_k = avg([count_defectors(history_actions[t-j]) for j in range(1, k+1)])

    S_high = 0.85 * capacity
    S_mid  = 0.60 * capacity
    S_low  = 0.45 * capacity

    # De-escalation check
    if punish_timer > 0:
        if S >= S_high and d_last == 0:
            punish_timer = 0
            return "C", punish_timer
        else:
            punish_timer -= 1
            return "D", punish_timer

    # Consider triggering punishment
    stock_drop_warning = (t >= 3 and S_hist[t-1] < S_hist[t-2] and S_hist[t-2] < S_high)

    if (d_last >= 1 and S < S_high) or (d_avg_k > 0.25*n) or stock_drop_warning:
        punish_timer = ceil(1 + 2*(d_last/n))

    if punish_timer > 0:
        punish_timer -= 1
        return "D", punish_timer

    # Normal mode
    if S >= S_mid:
        if d_avg_k <= 0.15*n:
            return "C", 0
        elif d_avg_k <= 0.35*n:
            return ("C", 0) if d_last == 0 else ("D", 0)
        else:
            return "D", 0

    elif S >= S_low:
        if d_last == 0 and d_avg_k <= 0.15*n:
            return "C", 0
        else:
            return "D", 0

    else:
        return "D", 0


def final_round_adjustment(t, r, S, d_avg_k):
    # optional wrapper: call after choose_action if t == r
    if t == r:
        if d_avg_k <= 0.15*n and S >= 0.60*capacity:
            return "C"
        else:
            return "D"
```

---

### Why this tends to be robust in tournaments
- Beats unconditional cooperators (doesn’t get endlessly exploited).
- Can still cooperate with conditional cooperators (finite punishment + forgiveness).
- Avoids being the “sucker” against defect-heavy fields (switches to D when defection is common or stock is endangered).
- Uses the *state* (stock) explicitly, which many simple repeated-game strategies ignore—critical here because sustainability is dynamic.

If you want, I can also provide a simplified “one-page” version (fewer thresholds) or a more aggressive/prosocial variant depending on tournament meta (e.g., whether many agents are TFT-like vs always-defect-like).
'''

description_COLLECTIVE_53 = '''
## Strategy: **Stock-Guard Trigger (SGT)**  
Goal: keep the stock near *capacity* (maximizes long-run total surplus) while remaining robust to exploitation by defect-heavy opponents. The strategy is **collective** (defaults to C), but uses **history-based retaliation** and **state-based conservation** to (a) deter defection and (b) prevent collapse.

Key idea:  
- If everyone cooperates, the stock returns to capacity (as in your example), so **full cooperation is collectively optimal and dynamically stable**.  
- Defection gives higher immediate payoff and can crash the stock; thus we need a **credible, fast punishment** that does not require coordination or communication.

---

# 1) Decision rules (C vs D)

### Quantities to compute each round \(t\)
Let:
- \(S_t\): current stock before actions in round \(t\).
- \(d_{t-1}\): number of defectors observed in round \(t-1\).
- \(D^\text{rate}_{t-1} = d_{t-1}/n\).

We use two mechanisms:

## A) **Stock guardrail (state-based)**
If stock is low, defecting tends to accelerate collapse, but also increases your immediate share. In a tournament you still want survival + leverage. We use a *conservation mode* when the stock is threatened, because rebuilding requires cooperation.

Define a “danger threshold”:
- **Danger if** \(S_t \le \theta \cdot \text{capacity}\),
- with \(\theta = 0.5\).

When in danger, we **prefer C** unless punishment is active (see below). Rationale: at \(S=\frac{capacity}{2}\), the growth term is maximal; below that, keeping remaining stock is especially valuable collectively.

## B) **Retaliation trigger (history-based)**
We punish defection quickly and proportionally, but we also allow forgiveness when the group returns to cooperation.

Maintain a variable `punish_timer` (integer ≥ 0). After observing round \(t-1\):
- If \(d_{t-1} = 0\): decrease `punish_timer` by 1 down to 0 (forgiveness).
- If \(d_{t-1} > 0\): set  
  `punish_timer = max(punish_timer, P(d_{t-1}))`  
  where a simple proportional rule is:
  - \(P(d)= 1\) if \(d \le n/4\)
  - \(P(d)= 2\) if \(n/4 < d \le n/2\)
  - \(P(d)= 3\) if \(d > n/2\)

### Action choice in round \(t\)
1. **If `punish_timer > 0`: play D**  
   (credible deterrence; shows defection reduces future returns)
2. **Else** (no punishment active):
   - **If \(S_t \le 0.5\cdot capacity\)**: play C (rebuild mode)
   - **Else**: play C (default collective cooperation)

So outside punishment, you always cooperate. The only time you defect is **as a coordinated-by-history punishment**.

Why this works against varied opponents:
- Against cooperators: you always play C → stable high stock.
- Against occasional defectors: they trigger short punishment, making defection less attractive.
- Against persistent defectors: you spend more time defecting too, preventing being the “sucker,” and quickly pushing the stock to low levels where the opponent’s future gains are limited. (Not ideal socially, but robust competitively.)

---

# 2) Edge cases

## First round
- **Round 1: play C.**
Reason: establishes the cooperative baseline and keeps stock at capacity when others also cooperate; you lose little by trying once, and you gain maximum long-run potential if others are cooperative types.

Initialize:
- `punish_timer = 0`
- `last_defectors = 0`

## Last round (round r)
Standard repeated-game logic suggests end-game defection, but in a tournament setting you may be scored on total payoff and face many different strategies. Still, last-round cooperation is often exploitable with no future discipline.

Rule:
- **In round r: play D unless the entire history has been perfectly cooperative** (no defection ever observed).  
  - If **no defection observed in any prior round**: play C in round r.
  - Else: play D in round r.

This preserves collective outcomes with fully cooperative populations, while avoiding being exploited by strategies that “defect at the end.”

## Second-to-last round (round r−1)
No special rule beyond the normal trigger. (Keeps behavior predictable and deters “late defection” since it can still be punished.)

## Extremely low stock \(S_t \approx 0\)
If stock is ~0, both C and D yield ~0 this round, but choices affect whether stock can recover. Logistic growth from 0 is 0; from small positive it can regrow if not fully depleted.

- If **not in punishment**: play C (maximize chance stock remains >0 after consumption by others).
- If **in punishment**: still play D (consistency of deterrence).  
  (This is harsh, but if punishment is active, the group is already in a conflict regime; consistency matters for credibility.)

---

# 3) “Collective mindset” framing
SGT is explicitly collective-first:
- It **defaults to cooperation** in all normal conditions.
- It uses defection **only as a social enforcement tool** to keep the group near the sustainable optimum (capacity).
- It forgives automatically when others return to cooperation.
- It shifts into “rebuild mode” (cooperate) whenever stock is threatened—unless punishment is needed to stop exploitation.

---

# Pseudocode (implementable)

```python
# Parameters: n, r, capacity
theta = 0.5  # danger threshold fraction of capacity

punish_timer = 0
ever_saw_defection = False

def P(d, n):
    if d <= n/4: return 1
    elif d <= n/2: return 2
    else: return 3

for t in range(1, r+1):
    # observe state S_t at start of round
    # (and after round 1, observe previous actions)
    
    if t > 1:
        d_prev = number_of_defectors_in_round(t-1)
        if d_prev > 0:
            ever_saw_defection = True
            punish_timer = max(punish_timer, P(d_prev, n))
        else:
            punish_timer = max(0, punish_timer - 1)

    if t == r:
        if ever_saw_defection:
            action = "D"
        else:
            action = "C"
    else:
        if punish_timer > 0:
            action = "D"
            punish_timer -= 1
        else:
            # cooperative / rebuild mode
            action = "C"

    play(action)
```

---

## Notes on robustness (why this is tournament-sensible)
- **Doesn’t require coordination**: your response depends only on observable defections, not on shared schedules.
- **Adaptive**: punishment length scales with how many defected (captures severity).
- **Forgiving**: avoids endless mutual defection when opponents are noisy or experimental.
- **Collective-optimal attractor**: if others are willing to cooperate, this reaches the best steady state (stock at capacity, maximal sustainable payoffs).

If you tell me typical tournament opponents (e.g., many always-defect, many tit-for-tat-like, presence of random/noisy play), I can tune the punishment function \(P(d)\) and the last-round rule for better empirical performance.
'''

description_COLLECTIVE_54 = '''
### Strategy: **Stock-Guarded, Forgiving Reciprocity (SGFR)**  
Collective objective: keep the resource near **capacity** (high sustainable yield) while remaining hard to exploit by defect-heavy opponents. The strategy uses (i) **state-based safety thresholds** to protect the stock, and (ii) **history-based reciprocity** to reward cooperation and punish repeated overconsumption.

---

## Key ideas (collective mindset)
1. **When stock is healthy, cooperate by default** to maintain maximum long-run total payoffs.
2. **When stock is threatened, defect defensively** to avoid being the “sucker” and to signal/induce restraint (by reducing the advantage of unilateral defection in future rounds when stock collapses).
3. **Be forgiving**: return to cooperation quickly after opponents show restraint, because recovery requires coordinated underconsumption.
4. **Be robust**: if others are unconditional defectors, this strategy stops feeding them high payoffs and shifts to self-protection.

---

## Definitions (computed each round)
Let:
- `S_t` = current stock at start of round `t`
- `capacity` given
- `n` players
- Observed history of actions in previous rounds.

Compute:
- `D_{t-1}` = number of opponents who defected in round `t-1` (so out of `n-1`)
- `D̄_k` = average number of opponent defections over last `k` rounds (use `k = min(5, t-1)`)

Stock bands:
- **Safe band**: `S_t >= 0.85 * capacity`
- **Caution band**: `0.50 * capacity <= S_t < 0.85 * capacity`
- **Critical band**: `S_t < 0.50 * capacity`

(These cutoffs are intentionally simple and parameter-based; they work across many `n` and `capacity` values.)

---

## 1) Decision rules (cooperate vs defect)

### Rule A — First priority: prevent collapse (state-based)
- If `S_t` is **Critical**: **Play C** (under-consume to allow regrowth), *unless* opponents are persistently defecting (see Rule C).
- If `S_t` is **Caution**: normally **Play C**, but become more retaliatory if defections are common (Rule B).
- If `S_t` is **Safe**: default **Play C**, but punish recent defections (Rule B).

Why cooperate in low stock? Because if everyone defects at low stock, the pool can hit/hover near zero and everyone’s future payoffs crater. Collective recovery requires restraint.

### Rule B — Reciprocity trigger (history-based)
Use a “forgiving tit-for-tat with threshold”:

- If in round `t-1`, **any** opponent defected (`D_{t-1} >= 1`), then in round `t`:
  - **Play D** if either:
    1. `S_t` is **Safe**, OR
    2. `S_t` is **Caution** and `D_{t-1} >= ceil((n-1)/2)` (a majority of opponents defected)
  - Otherwise **Play C**.

Interpretation:
- In healthy stock, punishment is cheap and deters exploitation.
- In mid stock, only punish if defection is widespread; otherwise keep cooperating to stabilize stock.

### Rule C — Anti-exploitation fail-safe (persistent defection)
If opponents keep defecting, don’t keep “donating” cooperation forever.

Define persistent defection as:
- `D̄_k >= 0.6 * (n-1)` for the last `k` rounds (with `k = min(5, t-1)`).

Then:
- **Play D** regardless of stock band, *except* if `S_t <= 0.20 * capacity`, in which case **Play C** (emergency recovery attempt—defection at very low stock is self-defeating).

This makes the strategy robust against grim defectors or noisy exploiters.

### Rule D — Recovery reward (return to cooperation fast)
If in round `t-1` **no one defected** (`D_{t-1} = 0`), then:
- **Play C** (even if you defected before), unless it is the last round (see edge cases).

This ensures quick re-coordination once others behave collectively.

---

## 2) Edge cases

### First round (t = 1)
- **Play C**.
Rationale: With no history, collective-first behavior gives the best chance to lock into the high-yield path near capacity. Also, if others defect, you can punish immediately in round 2.

### Last round (t = r)
Endgame is where many strategies defect. We handle this carefully without fully unraveling cooperation:

- If **stock is Critical** (`S_r < 0.50*capacity`): **Play C**  
  (Defecting may give a short-term bump, but often the pool is so low that the marginal gain is small; plus this guards against strategies that try to “crash” you into low payoffs late.)
- Else (stock is Caution or Safe):
  - **Play D** if either:
    - any opponent defected in round `r-1`, or
    - persistent defection condition held at any point in last 3 rounds
  - otherwise **Play C**.

This makes you cooperative if the group has been cooperative, but not naive if endgame defection starts.

### Very low stock emergency (S_t extremely low)
If `S_t <= 0.20 * capacity`: **Play C**, unless it is the last round and opponents are unanimously defecting (then you may play D).  
Reason: recovery requires restraint; unilateral D at tiny stock yields tiny benefit and worsens future unless game ends.

### Two-player special case (n = 2)
The above rules naturally reduce to a forgiving TFT-like policy:
- Default C; punish D with D in safe stock; be more cautious in low stock. Works well.

---

## 3) Pseudocode (implementable)

```python
def SGFR_action(t, r, S, capacity, n, opp_actions_history):
    # opp_actions_history: list of lists; each entry is opponents' actions in that round
    # actions are 'C' or 'D'

    def stock_band(S):
        if S < 0.50 * capacity: return "CRITICAL"
        if S < 0.85 * capacity: return "CAUTION"
        return "SAFE"

    if t == 1:
        return 'C'

    band = stock_band(S)

    # Last round logic
    if t == r:
        if S < 0.50 * capacity:
            return 'C'
        last = opp_actions_history[-1]
        D_last = sum(1 for a in last if a == 'D')
        k = min(3, len(opp_actions_history))
        recent = opp_actions_history[-k:]
        Dbar = sum(sum(1 for a in rd if a == 'D') for rd in recent) / k
        if D_last >= 1 or Dbar >= 0.6*(n-1):
            return 'D'
        return 'C'

    # General rounds
    last = opp_actions_history[-1]
    D_last = sum(1 for a in last if a == 'D')

    k = min(5, len(opp_actions_history))
    recent = opp_actions_history[-k:]
    Dbar = sum(sum(1 for a in rd if a == 'D') for rd in recent) / k

    # Emergency low-stock recovery
    if S <= 0.20 * capacity:
        return 'C'

    # Persistent defection fail-safe
    if Dbar >= 0.6*(n-1):
        return 'D' if S > 0.20*capacity else 'C'

    # Recovery reward
    if D_last == 0:
        return 'C'

    # Reciprocity trigger with stock-sensitive punishment
    if band == "SAFE":
        return 'D'
    if band == "CAUTION" and D_last >= ((n-1)+1)//2:  # majority
        return 'D'
    return 'C'
```

---

## Why this should do well in a tournament
- **Against cooperators / conditional cooperators**: it converges to sustained C, keeping stock near capacity and generating high long-run payoffs.
- **Against occasional/noisy defectors**: it punishes quickly but forgives immediately after cooperation returns, limiting long-term damage.
- **Against systematic defectors**: it does not keep cooperating indefinitely; it shifts to D to avoid being exploited, while still attempting emergency recovery when stock is near collapse.
- **State-aware**: unlike pure TFT variants, it won’t escalate punishment in ways that permanently destroy the resource when stock is already low.

If you tell me typical tournament parameters (ranges of `n`, `r`, `capacity`) or whether action observation includes full action profile each round (it sounds like yes), I can tighten the thresholds to those regimes.
'''

description_COLLECTIVE_55 = '''
## Strategy: **StockGuard (for a cooperative coalition of one)**
Goal: keep the resource near its sustainable level (≈ capacity) while extracting good payoffs, but switch quickly to protection/retaliation when others over-extract. The strategy is **state-based** (depends on current stock) and **history-based** (tracks others’ recent extraction), requires no coordination, and is robust to exploiters.

Key idea: In a healthy stock, cooperation (C) is best collectively; defection (D) can be used as (i) **credible punishment** to deter persistent defectors and (ii) **resource triage** when the stock is already endangered (because if others are emptying it, you may as well take value before collapse).

---

# 1) Decision rules (C vs D)

### Definitions observed each round \(t\)
- \(S_t\): stock at start of round \(t\)
- For each opponent \(j\), observe last action \(a_{j,t-1}\in\{C,D\}\)
- Let \(d_{t-1}\) = number of opponents who defected last round (among \(n-1\))
- Let defect rate last round:  
  \[
  q_{t-1}=\frac{d_{t-1}}{n-1}
  \]
- Maintain a short memory of recent defection rates, e.g. last \(m=3\) rounds:
  \[
  \bar q_{t-1}=\text{average}(q_{t-1}, q_{t-2}, q_{t-3}) \quad \text{(use what exists early)}
  \]

### Stock “health” zones
Use thresholds as fractions of capacity:
- **Healthy:** \(S_t \ge 0.70\cdot capacity\)
- **Caution:** \(0.40\cdot capacity \le S_t < 0.70\cdot capacity\)
- **Critical:** \(S_t < 0.40\cdot capacity\)

(These cutoffs are chosen so you strongly favor rebuilding when the pool is threatened, but don’t overreact to small dips.)

---

## Action rule overview
You choose **C** by default to sustain the stock **unless** either (A) defection is widespread/persistent (punish), or (B) the stock is in critical danger and others are still defecting (salvage).

### Rule A — Cooperative stance (when others are mostly cooperative)
If **Healthy** and recent defection is low:
- If \(\bar q_{t-1} \le 0.25\) (≤ ~25% of opponents defecting on average): **Play C**

Rationale: With logistic regrowth, keeping the stock high allows repeated high payoffs; unilateral D gives you a one-round gain but risks spirals.

---

### Rule B — Graduated deterrence (punish persistent defectors)
If defection is nontrivial, punish in a way that is:
- strong enough to remove incentives to defect repeatedly,
- but forgiving enough to recover cooperation quickly.

**Trigger condition (punishment starts):**
- If \(\bar q_{t-1} \ge 0.40\) **OR** \(q_{t-1} \ge 0.50\): enter **Punishment Mode**.

**Punishment Mode behavior:**
- Play **D** for \(L\) rounds, where:
  \[
  L = 1 + \left\lceil 3\cdot(\bar q_{t-1}-0.40)\right\rceil
  \]
  capped to \(L \in [1,4]\).

**Early exit (forgiveness):**
- If in punishment mode and in the most recent round \(q_{t-1} \le 0.20\), stop punishment early and return to cooperation (C), **provided stock is not critical**.

Rationale: This creates a clear “if you defect a lot, I defect for a while” response, but you don’t stay hostile forever if they reform.

---

### Rule C — Stock triage (protect/rebuild when low)
When the stock is low, the collective priority is to rebuild—**unless** you are surrounded by defectors, in which case cooperating just lets them extract more while still likely collapsing.

**If Critical (\(S_t < 0.40\,capacity\)):**
- If \(q_{t-1} \le 0.25\): **Play C** (rebuild attempt)
- Else (\(q_{t-1} > 0.25\)): **Play D** (salvage + punish)

**If Caution (\(0.40\,capacity \le S_t < 0.70\,capacity\)):**
- If \(\bar q_{t-1} \le 0.33\): **Play C**
- Else: **Play D** for 1 round (a “warning shot”), then reassess next round.

Rationale: In low stock, even a few defectors can prevent recovery; conditional salvage avoids being the only one rebuilding while others harvest.

---

### Rule D — Anti-exploitation guardrail (don’t be the “sucker” repeatedly)
Track your own recent relative payoff vs average (you can compute from observed actions and \(S_t\)). If for the last \(m=3\) rounds:
- you played C at least twice, **and**
- at least one opponent defected in each of those rounds,
then: **play D next round** (even if other rules would say C), unless \(S_t\) is Healthy and \(q_{t-1}\) dropped to 0.

Rationale: prevents strategies that “occasionally defect” from milking you indefinitely.

---

# 2) Edge cases

### First round (no history)
- **Play C** in round 1.
Reason: stock starts at capacity; cooperation is collectively optimal, and you don’t want to initiate a defection spiral. Also it tests whether the population is cooperative.

### Last round
Because this is a tournament and opponents may “endgame defect,” you hedge—but don’t automatically defect (that would destroy cooperation with strategies that don’t endgame).
- If \(S_t\) is Healthy **and** \(\bar q_{t-1} \le 0.25\): **Play C** (reward cooperative populations)
- Otherwise: **Play D** (protect against endgame defection / salvage value)

### If stock hits (or is near) zero
- If \(S_t \le \epsilon\) (use \(\epsilon=0.01\cdot capacity\)): **Play D**
Reason: cooperation yields almost nothing anyway; D is a best response and signals toughness.

### Very small n (e.g., n=2)
Use the same logic, but the defection thresholds become effectively:
- “low defection” means the other player cooperated last round,
- “high defection” means they defected last round.
So the strategy behaves like a **forgiving tit-for-tat with state awareness**.

---

# 3) “Collective mindset” framing (why this is collective)
This strategy treats the common pool as a shared asset to be kept near capacity whenever feasible, because that maximizes *long-run total surplus*. It:
- **starts cooperative** and remains cooperative when others show restraint,
- **punishes** behavior that threatens the group resource,
- **forgives quickly** when the group returns to cooperative extraction,
- **switches to triage/salvage** only when the group is already failing to protect the resource.

It’s cooperative by design, but not naïve: it makes sustained exploitation unprofitable while keeping a path back to cooperation.

---

## Pseudocode (implementable sketch)

```python
def action(t, S, capacity, history, n):
    # history contains past actions for all players; assume we can compute q_k
    HEALTHY = 0.70 * capacity
    CAUTION = 0.40 * capacity
    EPS = 0.01 * capacity

    if t == 1:
        return "C"

    # compute last-round defect rate among opponents
    q_last = defect_rate_opponents(history, t-1, n)  # in [0,1]
    q_bar = avg_defect_rate_opponents(history, t-1, m=3, n=n)

    # last round index used for "anti-sucker" guardrail
    if was_suckered_recently(history, t-1, m=3, n=n) and not (S >= HEALTHY and q_last == 0):
        return "D"

    # near-empty
    if S <= EPS:
        return "D"

    # Punishment mode tracking (store remaining punishment rounds in internal state)
    if internal.punish_remaining > 0:
        # forgive early if others become cooperative and stock not critical
        if q_last <= 0.20 and S >= CAUTION:
            internal.punish_remaining = 0
            return "C"
        internal.punish_remaining -= 1
        return "D"

    # trigger punishment
    if (q_bar >= 0.40) or (q_last >= 0.50):
        L = 1 + ceil(3 * (q_bar - 0.40))
        L = max(1, min(L, 4))
        internal.punish_remaining = L - 1
        return "D"

    # stock triage rules
    if S < CAUTION:  # critical
        return "C" if q_last <= 0.25 else "D"

    if S < HEALTHY:  # caution
        return "C" if q_bar <= 0.33 else "D"

    # healthy
    return "C" if q_bar <= 0.25 else "D"
```

This policy is adaptive (responds to both stock and behavior), robust (handles exploiters and endgame defection), and collective (keeps cooperation as the stable default whenever the population makes it viable).
'''

description_COLLECTIVE_56 = '''
## Strategy: **Stock-Guard Conditional Cooperation (SGCC)**  
Goal: keep the stock near capacity (maximizes long-run total extraction), while remaining *individually robust* against persistent defectors by escalating to defection when others over-extract and relaxing back to cooperation when behavior improves.

This is a *collective* strategy: default is to cooperate to sustain the resource; punishment is used only to stop exploitation and restore sustainable play.

---

# 1) Decision rules (C vs D)

### Key ideas
- **Sustainability target**: keep stock high. With all-C, stock returns to capacity in one step when starting at capacity and often remains healthy. Defection can crash the stock to 0 (especially when many defect).
- **Attribution**: because actions are observable, we can directly count defectors each round.
- **Adaptive enforcement**: punish when defection is frequent or stock is in danger; forgive once conditions improve.

### Quantities computed each round \(t\)
Let:
- \(S_t\) = stock at start of round \(t\)
- \(d_{t-1}\) = number of players who played D in round \(t-1\)
- \(\bar d\) = recent defection rate over a short window (e.g., last \(w=3\) rounds), normalized to \([0,1]\):
  \[
  \bar d = \frac{1}{w}\sum_{k=1}^{w}\frac{d_{t-k}}{n}
  \]
  (use fewer rounds if \(t\le w\))

Define thresholds (parameter-only):
- **Danger stock threshold**: \(S_{\text{danger}} = 0.5 \cdot \text{capacity}\)
- **Critical stock threshold**: \(S_{\text{crit}} = 0.25 \cdot \text{capacity}\)
- **Defection tolerance**: allow occasional defection without collapsing cooperation:
  - “small” defection: \(d_{t-1} \le \lfloor n/4 \rfloor\)
  - “large” defection: \(d_{t-1} \ge \lceil n/2 \rceil\)

### Decision rule summary
You maintain an internal variable **punish_timer** (integer ≥ 0).

Each round \(t\):

**A) If punish_timer > 0 → play D**, then decrement punish_timer by 1.  
(You’re in punishment mode.)

**B) Else (not in punishment mode), decide based on stock + recent behavior:**

1. **If \(S_t \le S_{\text{crit}}\)**: play **C** (resource is fragile; prioritize recovery).  
   *Rationale:* When stock is very low, defecting yields little and delays recovery; cooperation helps rebuild faster.

2. **Else if \(S_t \le S_{\text{danger}}\)**:  
   - If last round had any meaningful defection ( \(d_{t-1} \ge 1\) ), **enter punishment**: set  
     \[
     \text{punish\_timer} = 2
     \]
     and play **D** now.  
   - Otherwise play **C**.  
   *Rationale:* In danger zone, even a little defection risks a slide; punish quickly to deter.

3. **Else (stock healthy, \(S_t > S_{\text{danger}}\))**:  
   - If **large** defection last round ( \(d_{t-1} \ge \lceil n/2 \rceil\) ), set punish_timer = 3 and play **D**.  
   - Else if **moderate** sustained defection ( \(\bar d \ge 0.25\) ), set punish_timer = 2 and play **D**.  
   - Else play **C**.  
   *Rationale:* With healthy stock, tolerate rare noise, but respond to patterns that will erode the commons.

### Forgiveness / return to cooperation
Punishment is *time-limited* (2–3 rounds) and automatically ends. After that, you revert to the same rule: if others have stopped defecting and stock is healthy, you go back to C.

This makes the strategy:
- **Collective-first** (defaults to C)
- **Not exploitable indefinitely** (punishes persistent defectors)
- **Not stuck in permanent retaliation** (forgives)

---

# 2) Edge cases

### First round (t = 1)
- Play **C**.
- Reason: no history; collective optimum is to start cooperatively and see who deviates.

### Last round (t = r)
- **Default to C**, *unless* you are currently in punishment mode (punish_timer > 0), in which case play **D**.
- Reason: Pure end-game defection logic destroys collective performance in tournaments with mixed strategies. Keeping “C unless actively punishing” preserves cooperation with cooperative populations and doesn’t reward recent defectors (since punishment carries through).

### Very low stock (near 0)
- If \(S_t \le S_{\text{crit}}\): always **C** (even if others defected).  
  Reason: “defecting on scraps” is individually tempting but collectively suicidal; moreover it often yields tiny absolute gains and prevents stock rebound.

### Everyone else defects persistently
- The rule will frequently trigger punishment, so you will often play D when stock is not critical.
- When stock collapses into critical zone, you switch to C to rebuild; if others keep defecting, the stock won’t recover and everyone earns little—unavoidable without coordination. The strategy avoids being the sole cooperator funding others when stock is still sizable.

---

# 3) Collective mindset (how it aligns incentives)

SGCC implements a **“stewardship with enforcement”** posture:

- **Stewardship:** cooperate whenever the system is stable or fragile—especially when stock is low, where cooperation is most valuable.
- **Enforcement:** when stock is healthy and others defect, you defect temporarily to remove the unilateral advantage of exploiting cooperators and to signal that defection triggers a cost.
- **Forgiveness:** limited punishment prevents endless vendettas and allows return to mutually beneficial cooperation as soon as behavior improves.

This is robust across opponent types:
- **Always-C opponents:** you mostly cooperate; high payoffs.
- **Occasional/noisy defectors:** you tolerate small one-offs; cooperation survives.
- **Grim/punishing opponents:** you don’t over-punish; you de-escalate quickly.
- **Always-D opponents:** you don’t keep donating; you punish when it matters, and you prioritize recovery when the resource is critically low.

---

## Pseudocode (implementable)

```pseudo
params: n, r, capacity
constants:
  w = 3
  S_danger = 0.5 * capacity
  S_crit   = 0.25 * capacity

state variables:
  punish_timer = 0
  history_defectors = []  // store d_t each round

function decide(t, S_t, history_defectors, punish_timer):
  if t == 1:
    return C

  d_last = history_defectors[t-1]  // number of Ds last round
  bar_d = average over last min(w, t-1) rounds of (d_k / n)

  if punish_timer > 0:
    punish_timer -= 1
    return D

  if S_t <= S_crit:
    return C

  if S_t <= S_danger:
    if d_last >= 1:
      punish_timer = 2
      return D
    else:
      return C

  // stock healthy
  if d_last >= ceil(n/2):
    punish_timer = 3
    return D
  if bar_d >= 0.25:
    punish_timer = 2
    return D

  return C
```

If you want, I can also provide a tighter mathematical justification for the thresholds (in terms of expected stock evolution under k defectors) or propose a variant tuned for very small/very large n.
'''

description_COLLECTIVE_57 = '''
## Strategy: **Sustain–Punish–Recover (SPR)**  
Goal: keep the stock near *capacity* (maximizes long-run total payoffs) while being robust to exploitation by defectors. The strategy is **collective-first**, but switches to **credible punishment** when others over-extract, and returns to cooperation once behavior improves.

Key idea: use the *observed* total extraction each round to infer whether the group is acting sustainably, independent of any assumed coordination.

---

# 1) Decision rules (Cooperate vs Defect)

### Quantities you can compute each round (from state/history)
Let:
- `S_t` = current stock at start of round `t`
- Observe after round `t`: how many players defected `k_t` (since actions are observable).
- Total extraction fraction in round `t`:
  - If `k_t` defect and `n-k_t` cooperate, total consumption  
    \[
    E_t = (n-k_t)\frac{S_t}{2n} + k_t\frac{S_t}{n} = \frac{S_t}{2}\left(1 + \frac{k_t}{n}\right)
    \]
- Remaining stock after consumption:
  \[
  R_t = S_t - E_t = \frac{S_t}{2}\left(1 - \frac{k_t}{n}\right)
  \]

### Sustainability benchmark (what “collective good” looks like)
The stock regenerates via logistic growth:
\[
g(R)=2R\left(1-\frac{R}{capacity}\right)
\]
A simple robust target is to keep the post-consumption remainder near `capacity/2`, because logistic growth is maximized at `R = capacity/2`, and from there stock rebounds strongly.

So define a “good stewardship” condition:
- **Stewardship is good** if \( R_t \ge capacity/2 - \Delta \)
- **Stewardship is bad** if \( R_t < capacity/2 - \Delta \)

Choose tolerance:
- `Δ = 0.05 * capacity` (5% slack).  
This avoids punishing minor noise and makes the rule robust.

### State machine with three modes
Each player runs the same automaton:

**Mode A — Cooperative (default):**  
- Play **C** as long as stewardship has been good recently.

**Mode B — Punishment:**  
- Play **D** for `P` rounds to make over-extraction unprofitable and stop being the “sucker”.

**Mode C — Recovery/Testing:**  
- Play **C** for `T` rounds to see if others return to stewardship; if not, go back to punishment.

Parameters (depend only on `n`, `r`):
- `P = 1 + floor(log2(n))`  (short but noticeable punishment; scales gently)
- `T = 2` (quick test window)
- “Recently” = last 2 rounds.

### Triggers (when to switch modes)
At the end of each round `t`, compute `R_t` and `k_t`.

**Trigger into Punishment (from Cooperative or Recovery):**
Enter **Punishment** if *either*:
1) **Severe defection:** `k_t >= ceil(n/2)`  
   (majority defected → cooperation is not stable)
2) **Stock harmed:** `R_t < capacity/2 - Δ`  
   (group is extracting too much relative to sustainable rebound)
3) **Repeat offender environment:** in the last 2 rounds, total defectors ≥ `ceil(n/2)` at least once.

**Exit Punishment → Recovery:**
After you have punished for `P` rounds, switch to **Recovery**.

**Recovery evaluation:**
During Recovery (play C), if in any test round you see:
- `k_t >= ceil(n/2)` or `R_t < capacity/2 - Δ`  
then immediately return to **Punishment** (reset punishment counter).
If Recovery completes `T` rounds with no trigger, go back to **Cooperative**.

### In-round action choice (summary)
- If `mode == Cooperative`: play **C**
- If `mode == Punishment`: play **D**
- If `mode == Recovery`: play **C**

This is “collective” because the default is always to replenish and stabilize the resource; defection is used only as a disciplined tool to deter chronic over-extraction and to avoid being exploited.

---

# 2) Edge cases (first round, last round, low stock, etc.)

### First round
- **Play C**.  
Reason: starting at capacity, universal C keeps the stock at capacity (in many parameterizations like your example), and provides the strongest cooperative signal without sacrificing future leverage (punishment still exists).

### Last round (and last few rounds)
Classic backward induction would suggest defecting at the end, but tournaments often include mixed horizons/strategies; unconditional endgame defection can destroy otherwise high long-run payoffs if others are conditional cooperators.

Rule:
- If `t == r`:  
  - Play **C** if you were in Cooperative/Recovery and last round had good stewardship (`R_{r-1} >= capacity/2 - Δ` and `k_{r-1} < ceil(n/2)`), else play **D**.
- If `t >= r - 1` and you are currently punishing, **finish punishment** (keep D).  
Rationale: remain credible; don’t reward late opportunism.

### Very low stock protection
If current stock is already endangered, prioritize rebuilding:
- If `S_t <= capacity/4`: play **C** regardless of mode **unless** `k_{t-1} >= ceil(n/2)` (i.e., you’re in a clearly hostile population).  
This prevents “burning the commons” further when recovery is still possible.

### If capacity is huge relative to n / growth very strong
The stewardship test uses `capacity/2`; even if growth is strong, keeping `R` near `capacity/2` is still near-optimal for sustained yield. The tolerance `Δ` prevents overreacting.

---

# 3) Clear collective mindset (what this strategy “believes”)
1) **The common pool is the engine of future payoffs.** Default behavior should keep it healthy.  
2) **Conditional cooperation is necessary** in a tournament with unknown opponents—otherwise exploiters dominate.  
3) **Punishment is finite and restorative**, not vengeful: it’s triggered by measurable harm (low remainder stock) or broad defection, and it explicitly includes a “recovery/test” path back to cooperation.

---

## Pseudocode (implementation-ready)

```pseudo
params:
  Δ = 0.05 * capacity
  P = 1 + floor(log2(n))
  T = 2
state variables:
  mode ∈ {COOP, PUNISH, RECOVER} initially COOP
  punish_left = 0
  recover_left = 0

function stewardship_bad(S_t, k_t):
  # remainder after consumption
  R_t = 0.5 * S_t * (1 - k_t/n)
  return (R_t < capacity/2 - Δ)

function severe_defection(k_t):
  return (k_t >= ceil(n/2))

each round t with current stock S_t:

  # Action selection (with low-stock safeguard)
  if S_t <= capacity/4 and not severe_defection(k_{t-1} if t>1 else 0):
      action = C
  else if mode == COOP:
      action = C
  else if mode == PUNISH:
      action = D
  else if mode == RECOVER:
      action = C

  play action simultaneously

  observe k_t (number of defectors) and compute stewardship_bad(S_t, k_t)

  if t == r:
      end

  # Mode transitions
  if mode != PUNISH:
      if severe_defection(k_t) or stewardship_bad(S_t, k_t):
          mode = PUNISH
          punish_left = P
  else:
      punish_left -= 1
      if punish_left <= 0:
          mode = RECOVER
          recover_left = T

  if mode == RECOVER:
      if severe_defection(k_t) or stewardship_bad(S_t, k_t):
          mode = PUNISH
          punish_left = P
      else:
          recover_left -= 1
          if recover_left <= 0:
              mode = COOP
```

---

### Why this is robust in a tournament
- Against cooperators: quickly converges to all-C, keeps stock high, yields high total payoffs.
- Against occasional defectors/noise: tolerance + short punishments prevent overreacting; returns to C quickly.
- Against persistent defectors: shifts to D enough to avoid being exploited; doesn’t keep donating.
- Against other conditional strategies: uses transparent, state-based criteria (stock stewardship), making it easier to coordinate implicitly without prearranged schedules.

If you share typical tournament settings (ranges of `n`, `r`, `capacity`), I can tune `Δ`, `P`, and the low-stock threshold for better performance.
'''

description_COLLECTIVE_58 = '''
## Strategy: **Stock-Steward with Guardrails (SSG)**  
A collective, state-aware strategy that (i) tries to keep the stock near its sustainable sweet spot, (ii) cooperates by default when the group appears safe, and (iii) escalates quickly (but reversibly) against depletion to prevent collapse. It uses only parameters `(n, r, capacity)`, the observed stock, and full history.

### Key idea
In this game, **all‑C** is perfectly sustainable at full capacity (it returns to capacity each round), while **too many D** can drive the stock down and potentially to zero. So the collective goal is:
- Maintain stock high (avoid extinction),
- Reward cooperative environments with continued cooperation,
- Punish/contain defect-heavy environments enough to stop free-riding and protect the stock, but return to cooperation when conditions improve.

---

# 1) Decision rules: when to Cooperate vs Defect

### Notation observed each round
At round `t` you observe:
- `S_t`: current stock at start of the round.
- `kD_{t-1}`: number of defectors last round (from history). For `t=1`, treat `kD_0 = 0`.
- `S_{t-1}`: previous round’s start stock (if `t>1`).

### Internal thresholds (computed from parameters)
These are deliberately simple and robust:
- **Critical stock**: `S_crit = 0.25 * capacity`  
  Below this, collapse risk is high: prioritize immediate containment.
- **Caution stock**: `S_caution = 0.60 * capacity`  
  Below this, start being more defensive if defection is present.
- **Defection tolerance**: `D_tol = floor(n/4)`  
  Up to ~25% defectors is tolerated before escalating.
- **Hard defection**: `D_hard = ceil(n/2)`  
  If ≥ half defected, assume non-cooperative environment.

### Core rule (per round)
You choose **C** unless one of the “guardrail triggers” fires; otherwise you choose **D**.

**Guardrail triggers → play D**
1. **Stock emergency**: if `S_t <= S_crit`, play **D**.  
   Rationale: prevent being the “last cooperator” while stock is low; also stops being exploited during recovery attempts.
2. **Defection spike**: if `kD_{t-1} >= D_hard`, play **D**.  
   Rationale: when the majority defects, unconditional cooperation is dominated.
3. **Caution + meaningful defection**: if `S_t <= S_caution` **and** `kD_{t-1} > D_tol`, play **D**.  
   Rationale: when stock is not very safe and defection is more than minor noise, contain it.
4. **Rapid decline**: if `t>1` and `S_t < 0.85 * S_{t-1}` and `kD_{t-1} > 0`, play **D**.  
   Rationale: if stock is falling fast and defection exists, escalate before hitting the danger zone.

**Otherwise → play C**
- When stock is healthy and defection is limited, be a cooperative “steward” to keep the system at/near capacity and encourage reciprocity.

---

# 2) Edge cases & round-specific handling

### First round (t = 1)
**Play C.**  
Reason: stock starts at `capacity`, and all‑C is perfectly sustainable; opening cooperative is the best collective signal and doesn’t risk immediate collapse.

### Last round (t = r)
Still follow the same rule (no “endgame defection” by default).  
Reason: tournaments reward strategies that maintain cooperation across repeated settings; unconditional last-round defection tends to poison earlier cooperation in adaptive opponents.  
**Exception (strict safety):** if any guardrail trigger fires at `t=r`, play **D** (same as usual).

### Recovery mode (after emergency)
If stock was critical recently, you need a clear way back to cooperation.

Define an internal boolean `recovery`:
- Enter `recovery = true` when `S_t <= S_crit`.
- Exit `recovery = false` only after **two consecutive rounds** where:
  - `S_t >= S_caution` and
  - `kD_{t-1} <= D_tol`

**In recovery mode:**  
- Play **D** if `kD_{t-1} > 0` (any defection persists), else play **C**.  
This makes recovery conditional on the environment actually calming down.

### Handling noisy / alternating opponents
Use the tolerance band:
- If defections are rare (`<= D_tol`) and stock is healthy, **don’t overreact** (keep C).  
- If defections are frequent or stock is trending down, escalate to D quickly.

---

# 3) “Collective mindset” alignment

This strategy behaves like a **steward of the shared resource**:
- **Cooperate by default** when it is collectively safe, sustaining high stock (and thus high future payoffs for everyone).
- **Protect the commons** when depletion risk rises by refusing to be exploited during dangerous phases (D is used as a containment/punishment tool, not as a default).
- **Forgive and restore** cooperation once stock and behavior improve, enabling the group to return to the high-payoff steady state.

---

## Pseudocode (implementation-ready)

```python
def SSG_action(t, r, n, capacity, S_t, history):
    # history contains past rounds: (S_start, kD, my_action, etc.)
    S_crit = 0.25 * capacity
    S_caution = 0.60 * capacity
    D_tol = n // 4
    D_hard = (n + 1) // 2  # ceil(n/2)

    if t == 1:
        recovery = False
        return "C"

    kD_prev = history[t-2]["kD"]          # defectors in round t-1
    S_prev = history[t-2]["S_start"]      # stock at start of round t-1

    # Maintain recovery flag in state (store it externally between calls)
    recovery = history[t-2].get("recovery", False)
    if S_t <= S_crit:
        recovery = True

    # Exit recovery only after stability (track consecutive stable rounds)
    stable_prev = history[t-2].get("stable_count", 0)
    if S_t >= S_caution and kD_prev <= D_tol:
        stable_count = stable_prev + 1
    else:
        stable_count = 0
    if stable_count >= 2:
        recovery = False

    # Guardrails
    if recovery:
        action = "C" if kD_prev == 0 else "D"
    else:
        rapid_decline = (S_t < 0.85 * S_prev) and (kD_prev > 0)
        if (S_t <= S_crit or
            kD_prev >= D_hard or
            (S_t <= S_caution and kD_prev > D_tol) or
            rapid_decline):
            action = "D"
        else:
            action = "C"

    # Store recovery and stable_count for next round
    # (implementation detail: return them or write to persistent state)
    return action, recovery, stable_count
```

---

### Why this tends to do well in tournaments
- Against cooperators: quickly converges to all‑C and stays there (maximizes long-run collective payoffs).
- Against occasional defectors: tolerates limited noise without collapsing cooperation.
- Against exploiters / high-defection strategies: switches to D fast enough to avoid being repeatedly milked while stock declines.
- Against mixed populations: uses both **state (stock trend/level)** and **history (defection rate)**, making it robust across many opponent types.

If you want, I can also provide (i) an equivalent finite-state machine version, or (ii) a more “quantitative” variant that estimates the next stock under different defection counts and chooses the action that best keeps stock near a target.
'''

description_COLLECTIVE_59 = '''
## Strategy: **Stock-Guard with Graduated Reciprocity (SGGR)**  
Goal: keep the stock near **capacity** (where regeneration is strongest) while remaining hard to exploit. The strategy cooperates by default, but switches to defection when the observed group behavior is depleting the resource too aggressively, and it returns to cooperation once the group stabilizes.

This is a *collective* strategy: it treats the stock as the shared objective, and uses retaliation only as a tool to stop persistent overconsumption.

---

# 1) Decision rules (C vs D)

### Key idea: infer “how many defectors” occurred last round, then respond
At round \(t>1\), you observe last round’s stock \(S_{t-1}\), the new stock \(S_t\), and everyone’s actions. So you can directly count defectors \(k_{t-1}\).

Let:
- \(S =\) current stock at start of this round
- \(k =\) number of players who defected in the **previous** round (if \(t=1\), treat \(k=0\))
- \(\hat{k} =\) a smoothed estimate of defection pressure (to avoid overreacting to noise)
  - \(\hat{k} \leftarrow 0.7\hat{k} + 0.3k\) each round (initialize \(\hat{k}=0\))

### Stock zones
Define three stock regions based on capacity:

- **Healthy:** \(S \ge 0.80 \cdot capacity\)  
- **Watch:** \(0.50\cdot capacity \le S < 0.80\cdot capacity\)  
- **Critical:** \(S < 0.50\cdot capacity\)

(These are parameter-only thresholds; they scale with capacity and work across \(n\).)

### Cooperation rule
You choose **C** when the stock is not in danger *and* defection pressure is low/moderate.

You choose **D** when the stock is threatened or recent behavior indicates the group is drifting into collapse.

Concretely:

**Rule A — Critical stock safeguard (always defect):**
- If \(S < 0.50\cdot capacity\): play **D**.  
Rationale: when stock is low, each unit of remaining stock is “too valuable” to risk losing to others’ defection. Defection here is a protective move that discourages further free-riding and prevents being the sucker while collapse is underway.

**Rule B — Watch zone reciprocity:**
- If \(0.50\cdot capacity \le S < 0.80\cdot capacity\):
  - Play **C** if \(\hat{k} \le 0.25n\)
  - Otherwise play **D**
Rationale: in the watch zone, cooperate only if a *clear majority* is effectively cooperating. If a sizable minority is defecting, punish to halt the slide.

**Rule C — Healthy zone generosity with teeth:**
- If \(S \ge 0.80\cdot capacity\):
  - Play **C** if \(\hat{k} \le 0.40n\)
  - Otherwise play **D**
Rationale: when stock is abundant, be tolerant (collective-first). But if defection becomes common, retaliate.

### “Forgiveness” / return-to-cooperation condition
To avoid permanent defection spirals, you re-enter cooperation quickly once the group improves.

If you defected last round, switch back to **C** when:
- \(S \ge 0.80\cdot capacity\) **and** \(k \le 1\)  
(i.e., stock recovered and only isolated defection remains)

This makes the strategy *forgiving* and capable of re-establishing cooperation after temporary shocks.

---

# 2) Edge cases

### First round (no history)
**Play C.**  
Rationale: cooperation from full capacity is collectively optimal and also tests whether others are cooperative. Starting with D invites immediate collapse in many populations.

### Last round
There is a standard endgame incentive to defect. But because you cannot coordinate and because the stock still affects your own immediate payoff (and you want tournament robustness), use a **conditional endgame adjustment**:

- In the **final round \(t=r\)**:
  - If \(S \ge 0.80\cdot capacity\) *and* \(k_{r-1}=0\): play **C**
  - Else: play **D**

Interpretation: “I’ll preserve the cooperative outcome if the group proved fully cooperative right up to the end; otherwise I protect myself.”

### Second-to-last round
To reduce last-round unraveling:
- In round \(t=r-1\), tighten tolerance slightly:
  - In Healthy zone: require \(\hat{k}\le 0.25n\) to cooperate (instead of 0.40n)

This discourages opportunists who try to “prime” a last-round grab by defecting at \(r-1\).

### Stock at (near) zero
If \(S\) is extremely small (e.g., \(S < 0.05\cdot capacity\)), the game is effectively in collapse mode:
- Always **D** until \(S\) rises above \(0.50\cdot capacity\).  
(You cannot single-handedly restore the stock; you need others to stop overconsuming.)

---

# 3) Collective mindset (how it aligns with the group)

This strategy is explicitly “pro-social by default”:
- It **starts cooperative**, aiming for maximal sustainable regeneration near capacity.
- It **tracks group extraction** and only retaliates when defection becomes frequent enough to endanger the resource.
- It **forgives** and returns to cooperation once the stock is healthy and exploitation subsides.

It is also robust:
- Against always-defectors: quickly shifts to D and avoids being exploited every round.
- Against noisy / mixed strategies: smoothing (\(\hat{k}\)) prevents overreacting to one-off defections.
- Against conditional cooperators: the transparent “cooperate when stock is healthy and defection is rare” pattern helps coordination emerge without communication.

---

# Pseudocode (implementable)

```python
# Parameters: n, r, capacity
# State each round t: stock S_t (start-of-round stock)
# History: actions from previous rounds, stocks

hat_k = 0.0
last_action = None

def choose_action(t, S, prev_actions, prev_stock, curr_stock):
    global hat_k, last_action

    # Count previous-round defectors
    if t == 1:
        k = 0
    else:
        k = sum(1 for a in prev_actions if a == "D")

    # Update smoothed defection pressure
    hat_k = 0.7 * hat_k + 0.3 * k

    healthy = (S >= 0.80 * capacity)
    watch   = (S >= 0.50 * capacity and S < 0.80 * capacity)
    critical= (S < 0.50 * capacity)

    # Endgame tightening
    healthy_tol = 0.40 * n
    if t == r-1:
        healthy_tol = 0.25 * n

    # Final round rule
    if t == r:
        if healthy and k == 0:
            return "C"
        else:
            return "D"

    # Critical safeguard
    if critical:
        return "D"

    # Watch zone reciprocity
    if watch:
        if hat_k <= 0.25 * n:
            return "C"
        else:
            return "D"

    # Healthy zone generosity with teeth
    if healthy:
        if hat_k <= healthy_tol:
            return "C"
        else:
            return "D"
```

---

If you want, I can also provide a variant that *explicitly targets a desired steady-state stock* (e.g., around capacity by keeping expected total extraction near \(S\) each round), but the above is simpler and tends to perform well in heterogeneous tournaments because it’s cooperative, reactive, and hard to exploit.
'''

description_COLLECTIVE_60 = '''
## Strategy: **State‑Triggered Collective Reciprocity (STCR)**  
Goal: keep the resource near *capacity* (so everyone’s per‑round payoffs stay high), while remaining hard to exploit and able to recover cooperation with strangers.

Core idea:  
- **Default to cooperation** when the stock is healthy and others are not actively depleting it.  
- **Switch to defection** only when (a) the stock is in danger or (b) others are clearly over‑extracting, and do so in a way that (c) restores incentives for restraint and (d) allows re‑entry to cooperation once behavior improves.

---

# 1) Decision rules (C vs D)

### Quantities observed each round \(t\)
Let:
- \(S_t\) = stock at start of round \(t\).
- \(k_t\) = number of opponents who defected in round \(t-1\) (for \(t=1\), undefined).
- \(f_t = \frac{k_t}{n-1}\) = last‑round defection rate among opponents (for \(t=1\), set \(f_1=0\)).
- Also track a short memory: defection counts over last \(m\) rounds (recommend \(m=3\)).

### Stock “health” zones  
Define thresholds based only on parameters:
- **High**: \(S_t \ge 0.85 \cdot \text{capacity}\)
- **Medium**: \(0.60 \cdot \text{capacity} \le S_t < 0.85 \cdot \text{capacity}\)
- **Low**: \(S_t < 0.60 \cdot \text{capacity}\)

Rationale: with logistic growth, stock near capacity sustains high payoffs and robust regrowth; below ~0.6 capacity you’re at risk of spiraling down if extraction stays high.

### Opponent behavior “pressure” zones
Use last round + short memory to avoid overreacting to noise:
- **Low pressure**: last round \(f_t \le 0.25\) *and* average defection over last \(m\) rounds \(\le 0.25\)
- **Moderate pressure**: in between
- **High pressure**: last round \(f_t \ge 0.50\) *or* average defection over last \(m\) rounds \(\ge 0.50\)

### Main action rule  
At round \(t\), play:

**Rule A — Protect the stock when it’s low:**  
- If \(S_t < 0.60\cdot \text{capacity}\):  
  - **Play C** *unless* you are facing **high pressure** (≥ half of others defecting recently), in which case **play D**.
  - Intuition: when the stock is low, unilateral “race to the bottom” is disastrous; start with restraint to enable regrowth, but don’t be the lone sacrificer against a majority of defectors.

**Rule B — Cooperate when stock is healthy and others mostly cooperate:**  
- If \(S_t \ge 0.85\cdot \text{capacity}\) and pressure is low: **play C**.

**Rule C — Reciprocal deterrence in the medium zone:**  
- If \(0.60\cdot \text{capacity} \le S_t < 0.85\cdot \text{capacity}\):  
  - If pressure is low: **play C**.  
  - If pressure is moderate: **play C with probability \(p_C = 0.7\)**, else D.  
  - If pressure is high: **play D**.
  - Intuition: in the “buffer” zone you can afford some forgiveness to re‑stabilize cooperation, but you must respond strongly to sustained over‑extraction.

**Rule D — Exploitation guard (being singled out):**  
If in the last round you cooperated and **at least one opponent defected**, then:
- If \(S_t < 0.85\cdot \text{capacity}\): **defect next round** (a one‑round punishment), **unless** pressure has dropped back to low and stock is high (then revert to C).
This prevents “always‑D” types from farming you indefinitely while still allowing recovery.

---

# 2) Edge cases (first round, last round, recovery)

### First round (no history)
- **Play C** in round 1.
Reason: stock starts at capacity; mutual cooperation preserves capacity and tests whether others are willing to sustain the commons. Starting with D destroys the chance of stable high stock in many groups.

### Last round
With a known finite horizon, pure backward induction suggests defection, but in tournaments many agents still condition on the last move, and your last move can also affect your payoff *within* the last round only (no future stock). So choose last‑round action based on two considerations: immediate payoff vs norm consistency.

**Last round rule:**
- If in round \(r-1\) pressure was low (≤ 25% opponents defected): **play C** in round \(r\).  
- Otherwise: **play D** in round \(r\).

This keeps you cooperative in cooperative groups (maximizing joint outcomes and avoiding needless collapse in earlier rounds due to anticipated endgame), but captures value when the group is already defecting.

### Recovery / return to cooperation
If you have entered a punitive/defensive phase (frequent D):
- Return to **C** once **both** are true for one full round:
  1. Stock is **High** (\(S_t \ge 0.85\cdot \text{capacity}\)), and  
  2. Opponent pressure is **Low** (≤ 25% defection last round and in short memory).

This makes cooperation “sticky” once restored, but not gullible.

---

# 3) Collective mindset (explicit alignment)

This strategy treats the stock as a shared capital asset:
- **Primary objective:** keep \(S_t\) near capacity so everyone’s per‑round payoffs remain high and sustainable.  
- **Reciprocity:** cooperate by default, punish depletion to deter free‑riding.  
- **Forgiveness:** allow return to cooperation when others show restraint, preventing permanent collapse due to occasional mistakes or exploratory defections.  
- **Robustness:** if faced with persistent defectors, shift to D to avoid being exploited, while still minimizing irreversible stock collapse by reverting to C as soon as conditions support regrowth.

---

## Pseudocode (implementable)

```python
# parameters: n, r, capacity
m = 3  # memory length
def_hist = []  # list of k values (opponents defecting) from previous rounds

def pressure(def_hist, n):
    if len(def_hist) == 0:
        return "low", 0.0, 0.0
    f_last = def_hist[-1] / (n-1)
    avg = sum(def_hist[-m:]) / (len(def_hist[-m:]) * (n-1))
    if f_last >= 0.50 or avg >= 0.50:
        return "high", f_last, avg
    if f_last <= 0.25 and avg <= 0.25:
        return "low", f_last, avg
    return "moderate", f_last, avg

def stock_zone(S, capacity):
    if S >= 0.85 * capacity: return "high"
    if S >= 0.60 * capacity: return "medium"
    return "low"

def choose_action(t, S_t, n, r, capacity, def_hist, i_cooperated_last_round):
    zone = stock_zone(S_t, capacity)
    pres, f_last, avg = pressure(def_hist, n)

    # round 1
    if t == 1:
        return "C"

    # last round special
    if t == r:
        if pres == "low":
            return "C"
        else:
            return "D"

    # exploitation guard: if I played C and someone defected last round
    if i_cooperated_last_round and def_hist[-1] >= 1 and zone != "high":
        return "D"

    # main rules
    if zone == "low":
        return "D" if pres == "high" else "C"

    if zone == "high":
        return "C" if pres == "low" else ("D" if pres == "high" else "C")

    # zone == "medium"
    if pres == "low":
        return "C"
    if pres == "high":
        return "D"
    # moderate
    return "C" with prob 0.7 else "D"
```

---

### Why this tends to work well in tournaments
- In cooperative populations, it quickly settles into all‑C, sustaining capacity and maximizing long‑run payoffs.  
- Against mixed strategies, it uses stock health to avoid overreacting when the system can absorb shocks, and clamps down when depletion becomes dangerous.  
- Against defect‑heavy groups, it doesn’t keep donating; it defects to protect itself, but still leaves a path back to cooperation if others shift.

If you want, I can tune the numeric thresholds (0.85/0.60 and 25%/50%) for specific \(n, r, capacity\) regimes (e.g., large \(n\) tends to require stricter deterrence).
'''

description_COLLECTIVE_61 = '''
## Strategy: **Stock-Guarded Generous Trigger (SGGT)**  
Goal: keep the stock near-capacity (maximizes long-run total surplus) while being **hard to exploit**. Core idea: **cooperate by default**, but **defect responsively** when (a) the stock is being driven down or (b) others are systematically taking the higher extraction rate.

This is a *collective* strategy because it treats “good behavior” as: preserving the shared stock so everyone can keep earning high future payoffs, and it uses punishment only to stop behaviors that endanger the common pool.

---

## Key quantities (computed each round from observable history)

Let at round \(t\), before choosing action, current stock is \(S_t\). Let \(k_{t-1}\) = number of defectors in round \(t-1\) (observable from actions).

### 1) “Safe stock band”
Choose two stock thresholds based only on parameters:
- **High/target band:** \(S \ge 0.9 \cdot \text{capacity}\)
- **Guard band:** \(S \in [0.6, 0.9)\cdot \text{capacity}\)
- **Danger band:** \(S < 0.6 \cdot \text{capacity}\)

Rationale: with your growth rule, stock near capacity can be sustainably replenished under cooperation; below some point, you need to prevent free-riding and stock collapse quickly.

### 2) Recent defection pressure
Maintain a short memory score:
- \(D\_rate = \) fraction of defections among *other players* in the last \(m\) rounds (suggest \(m=5\), or \(m=\min(5,t-1)\)).

Also track “last round was clean”:
- **Clean(t−1)** if \(k_{t-1}=0\) (everyone cooperated).

---

## Decision rules (cooperate vs defect)

### Baseline intent
- **Cooperate** whenever the group is mostly cooperating and the stock is healthy.
- **Defect** only as a corrective tool to (i) deter exploitation and (ii) prevent stock from drifting into the danger band.

### Rule set (in priority order)

#### Rule 0 — First round (bootstrapping)
**Round 1: Play C.**  
Start cooperative to invite the efficient path and reveal who is willing to preserve the resource.

---

#### Rule 1 — Emergency stock protection
If \(S_t < 0.6\cdot\text{capacity}\):  
**Play D.**  

Reason: when stock is low, any cooperator is very exploitable and the group is at real risk of hitting 0 (which destroys all future payoffs). Defection here is a “brace” that discourages others from continued high extraction by making it unprofitable to be the lone cooperator.

(Yes, D extracts more this round; but strategically it functions as a deterrent regime once the commons is endangered, and it prevents being the only one restraining consumption.)

---

#### Rule 2 — Punish clear defection (but with forgiveness)
If \(S_t \ge 0.6\cdot\text{capacity}\) and **someone defected last round** (\(k_{t-1} \ge 1\)):  
- **Defect for \(p\) rounds**, where  
  \[
  p = \min\Big(2,\; 1 + \mathbb{1}[k_{t-1} \ge \lceil n/2\rceil]\Big)
  \]
  i.e., punish 1 round for a small deviation; punish 2 rounds if a majority defected.

Then attempt to return to cooperation if conditions improve (Rule 4).

Rationale: fast, proportional punishment makes exploiting cooperators unattractive, but the cap at 2 rounds prevents endless mutual retaliation.

Implementation note: you store a `punish_counter` that is set by this rule and decremented each round; while it’s positive you play D (unless Rule 3 below overrides).

---

#### Rule 3 — Last round (endgame robustness)
**Round r: Play D unless all of the last 2 rounds were clean (no defections) AND stock is in the high band.**  
Formally, in final round:
- If \(S_r \ge 0.9\cdot\text{capacity}\) and \(k_{r-1}=0\) and \(k_{r-2}=0\) (when defined), play **C**.
- Else play **D**.

Rationale: finite horizon creates endgame incentives to defect. This rule is robust: it still allows a “clean-cooperation finish” when the group has demonstrated stability, but it avoids being the sucker in typical tournament populations.

---

#### Rule 4 — Default cooperative mode with “majority test”
If none of Rules 1–3 trigger and `punish_counter == 0`:

Compute:
- \(D\_rate\) among others over last \(m\) rounds.

Then:
- If \(S_t \ge 0.9\cdot\text{capacity}\) **and** \(D\_rate \le 0.2\): play **C**.
- Else if \(S_t \in [0.6,0.9)\cdot\text{capacity}\):
  - play **C** if \(D\_rate \le 0.1\) (very cooperative environment)
  - otherwise play **D** (guard band is where exploitation can gradually push you into danger)

Rationale: when stock is merely “okay,” you require stronger evidence the population is cooperative; when stock is excellent, you can be more generous.

---

## Edge cases & clarifications

1. **If history is too short** (e.g., round 2), compute rates on the available rounds.
2. **Noise/one-off defection:** A single defection triggers only a short punishment (1 round), then the strategy tries to reset to cooperation if the group returns to clean play.
3. **Many always-defectors:** The strategy quickly shifts into frequent D (via Rules 2/4), preventing persistent exploitation and minimizing regret.
4. **All-cooperators / mostly cooperative pool:** The strategy stays at C almost always, keeping stock near capacity and maximizing collective surplus.
5. **Stock capped at capacity:** The strategy’s “high band” is tuned to keep you near that cap, where sustainable payoffs are best.

---

## Pseudocode (implementable)

```python
# parameters
HIGH = 0.9 * capacity
GUARD = 0.6 * capacity
m = 5

# state variables maintained by the strategy
punish_counter = 0

def decide(t, S_t, history_actions):  # history_actions: list of rounds, each round list of actions length n
    global punish_counter

    # helper: count defectors last round
    def count_defectors(round_actions):
        return sum(1 for a in round_actions if a == 'D')

    # First round
    if t == 1:
        return 'C'

    # compute k_{t-1}
    last_round = history_actions[t-2]
    k_last = count_defectors(last_round)

    # compute D_rate among others over last m rounds
    start = max(0, (t-1) - m)  # number of completed rounds is t-1
    recent = history_actions[start:t-1]
    # assume we know which index we are; for D_rate, exclude self
    # here: others_defections / others_actions
    others_defections = 0
    others_actions = 0
    for ra in recent:
        for j,a in enumerate(ra):
            if j == self_index: 
                continue
            others_actions += 1
            if a == 'D':
                others_defections += 1
    D_rate = others_defections / max(1, others_actions)

    # Rule 3: last round behavior
    if t == r:
        k_prev = k_last
        k_prev2 = count_defectors(history_actions[t-3]) if t >= 3 else 999  # not clean by default
        if S_t >= HIGH and k_prev == 0 and k_prev2 == 0:
            return 'C'
        else:
            return 'D'

    # Rule 1: emergency stock protection
    if S_t < GUARD:
        punish_counter = max(punish_counter, 1)  # keep in hard mode at least 1
        return 'D'

    # If currently punishing, continue
    if punish_counter > 0:
        punish_counter -= 1
        return 'D'

    # Rule 2: punish defections last round (proportional, capped)
    if k_last >= 1:
        majority = (k_last >= (n + 1)//2)
        punish_counter = 2 if majority else 1
        punish_counter -= 1  # spend one now
        return 'D'

    # Rule 4: default mode (cooperate if environment is sufficiently cooperative)
    if S_t >= HIGH and D_rate <= 0.2:
        return 'C'
    elif S_t >= GUARD:
        return 'C' if D_rate <= 0.1 else 'D'
    else:
        return 'D'
```

---

## Why this is strong in tournaments (strategic rationale)

- **Collectively efficient:** In cooperative populations it stays at C and keeps stock near capacity, maximizing long-run payoffs for all.
- **Exploit-resistant:** Any observed defection triggers immediate, limited retaliation—enough to remove the incentive to pick off cooperators.
- **Forgiving:** Punishment is short and conditional; cooperation can re-emerge quickly.
- **Stock-aware:** Many repeated-game strategies ignore the state; this one explicitly protects the resource when it matters most.
- **Finite-horizon aware:** A guarded final-round rule reduces being exploited by endgame defection while still allowing “clean” groups to finish cooperatively.

If you want, I can tune the thresholds (0.9/0.6) and memory window \(m\) analytically for different \(n\) and capacity regimes, but the above is parameter-only, adaptive, and robust out of the box.
'''

description_COLLECTIVE_62 = '''
## Strategy: **Stock-Guarded Reciprocity (SGR)**  
Goal: keep the resource near the “safe” high-stock region where everyone can earn sustainably, while being hard to exploit. The strategy uses (i) **state-based conservation** (protect the stock when it’s fragile) and (ii) **history-based reciprocity** (punish over-consumption, forgive when behavior improves).

Key idea:  
- When stock is healthy, try to cooperate—*unless* others are defecting enough that cooperating just feeds them.  
- When stock is low, defecting accelerates collapse, so switch to stock protection and only resume full cooperation once behavior and stock recover.

---

# 1) Decision rules (C vs D)

### Notation observed each round
- `S_t`: stock at start of round `t`
- `d_{t-1}`: number of defectors in previous round (among the other `n-1` players; you can observe actions)
- `D̄_{t-1}`: fraction of defectors last round among others: `d_{t-1}/(n-1)`
- `D̄_lastk`: average defector fraction over the last `k` rounds (suggest `k=3`, or fewer if early)
- `ΔS`: stock trend estimate (optional): `S_t - S_{t-1}`

### Derived “stock risk” thresholds (parameter-only)
We want simple, robust thresholds tied to `capacity`:
- `S_high = 0.8 * capacity` (abundant)
- `S_mid  = 0.5 * capacity` (caution)
- `S_low  = 0.3 * capacity` (danger of collapse / slow recovery)

### Core rule set
You choose action each round using two gates:

## Gate A — **Resource protection (state-first)**
1) **If `S_t ≤ S_low`: play `C`.**  
   Rationale: when the pool is small, defecting is collectively catastrophic; even if others defect, your best collective move is to stop accelerating depletion. This also signals “I’m not the one collapsing it.”

2) **If `S_low < S_t ≤ S_mid`: play `C` unless exploitation is severe.**  
   Define severe exploitation as: `D̄_lastk ≥ 0.6`.  
   - If severe exploitation: play `D`
   - Else: play `C`

3) **If `S_t > S_mid`: move to Gate B (reciprocity).**

## Gate B — **Reciprocity (history-first when stock can handle it)**
When stock is in decent shape, enforce cooperation by punishing defections proportionally:

- Compute `p = clamp(D̄_lastk + bonus, 0, 1)` where:
  - `bonus = 0.15` if `S_t < S_high` (extra strict when not fully abundant), else `0`
- Then:
  - Play `D` with probability `p`
  - Play `C` with probability `1 - p`

This makes you:
- Mostly cooperate if others mostly cooperate.
- Rapidly shift toward defection if others defect a lot.
- Slightly harsher when stock is not near capacity.

### Deterministic variant (if you want no randomness)
If stochastic play is undesirable, replace Gate B by:
- If `D̄_lastk ≥ 1/3` then play `D`, else play `C`, and use the `bonus` by lowering the threshold to `0.25` when `S_t < S_high`.

---

# 2) Edge cases (first round, last round, recovery, etc.)

### Round 1 (no history)
- **Play `C` if `capacity` is at least `2n` (it is by spec) and stock starts at capacity.**  
  Start cooperative to attempt to reach the high-sustainability path immediately.

### Last round (end-game temptation)
Finite-horizon games invite last-round defection. But in tournaments, strategies that always last-round defect tend to trigger earlier punishments from others. So:

- **If `S_t ≤ S_mid`: play `C`** (avoid mutual collapse spirals / retaliatory patterns).
- **If `S_t > S_mid`: follow the same reciprocity rule as usual** (do *not* auto-defect).  
This keeps your behavior time-consistent and avoids being exploited by “endgame detectors.”

### After a collapse (`S_t` very small)
If `S_t ≤ S_low`, you already cooperate by rule. Additional recovery tweak:
- Stay in “protection mode” (always `C`) until `S_t ≥ S_mid` **for two consecutive rounds**.  
This prevents oscillating between recovery and re-collapse.

### Forgiveness / de-escalation
To be robust against occasional noise or experimental defections:
- Use `k=3` memory (short) and **drop punishment quickly** if defection rate falls.
- Concretely: as soon as `D̄_lastk < 0.2` and `S_t ≥ S_mid`, revert to mostly `C` (Gate B yields low `p`).

### Exploitation ceiling (don’t be the “sucker” forever)
If others keep defecting while stock remains high (possible early on):
- Gate B ensures you increasingly defect; you won’t keep donating indefinitely.
- Additionally, if **everyone else defected last round** (`d_{t-1} = n-1`) and `S_t > S_low`, then **play `D`** (pure retaliation) because unilateral cooperation is pointless.

---

# 3) Collective mindset (what it’s optimizing for)
This strategy is “collective” in two ways:

1) **Stock stewardship:** When the resource is fragile, it prioritizes stock recovery over short-term private gains (always cooperate at low stock, and maintains recovery mode). This maximizes total future payoffs for the group if others can be brought back.

2) **Reciprocity to enforce norms:** When stock is healthy, it punishes defection in proportion to observed defection frequency, discouraging exploitation and making cooperation a stable focal point without communication.

It is adaptive across opponent types:
- Against cooperators: converges to near-all `C`, maintaining high stock and high long-run returns.
- Against defectors: quickly shifts to `D` when stock allows, minimizing exploitation, while still switching to conservation when the stock is endangered.
- Against mixed / chaotic players: short memory and forgiveness prevent permanent feuds; stock-based gate prevents catastrophic spirals.

---

## Pseudocode (implementable sketch)

```python
def action(t, S_t, history, n, capacity, r):
    S_high = 0.8 * capacity
    S_mid  = 0.5 * capacity
    S_low  = 0.3 * capacity

    # Helper: last k rounds defection rate among others
    k = 3
    Dbar_lastk = avg_defector_fraction_over_last_k(history, k, exclude_self=True)

    # Round 1
    if t == 1:
        return "C"

    # Recovery lock: if stock was low recently, require 2-round confirmation above S_mid
    if S_t <= S_low:
        return "C"
    if was_in_protection_mode_recently(history) and not two_consecutive_rounds_stock_ge(history, S_mid):
        return "C"

    # Mid stock region
    if S_t <= S_mid:
        if Dbar_lastk >= 0.6:
            return "D"
        else:
            return "C"

    # High enough stock: reciprocity
    bonus = 0.15 if S_t < S_high else 0.0
    p = clamp(Dbar_lastk + bonus, 0.0, 1.0)

    # Pure retaliation edge: all others defected last round
    if all_others_defected_last_round(history, n) and S_t > S_low:
        return "D"

    # Stochastic choice (or replace with deterministic threshold)
    return "D" if random() < p else "C"
```

If you tell me whether the tournament implementation prefers **deterministic** strategies (for reproducibility) or allows **randomized** actions, I can provide the best tuned variant for that setting.
'''

description_COLLECTIVE_63 = '''
## Strategy: **Stock-Guard Reciprocal (SGR)**  
Goal: keep the resource near **capacity** (maximizes long-run total surplus), while being **hard to exploit**: cooperate by default when the group appears sustainable; switch to defection when others over-extract or when the stock is in danger; return to cooperation quickly when conditions improve.

The key idea is to treat each round as a “stress test” of whether the group’s *effective extraction rate* is compatible with sustaining the stock.

---

# 1) Decision rules (C vs D)

### Quantities you can compute from history/state
At the start of round *t*, you know current stock \(S_t\) and, from prior rounds, everyone’s actions.

Let:
- \(k_{t-1}\) = number of defectors in the previous round (if \(t=1\), undefined)
- **Total consumption fraction** last round, given \(k\) defectors:
  \[
  f(k)=\frac{\text{total consumption}}{S}=\frac{(n-k)\cdot(S/(2n)) + k\cdot(S/n)}{S} = \frac{n+k}{2n} = \frac12 + \frac{k}{2n}
  \]
- Remaining fraction after consumption:
  \[
  \alpha(k)=1-f(k)=\frac{n-k}{2n}
  \]
- Next-stock map (ignoring the min-cap at the end) if stock is \(S\) and defectors are \(k\):
  \[
  S' = \alpha S + 2(\alpha S)\left(1-\frac{\alpha S}{\text{capacity}}\right)
  \]
This lets you judge whether the *observed behavior* is sustainable.

### Core rule: “Cooperate when safe & fair, defect when unsafe or exploited”
We maintain two modes: **Cooperative mode** and **Protection mode**.

#### A. Cooperative mode (default)
Play **C** if all of the following hold:

1) **Stock safety**: \(S_t \ge S_{\text{low}}\)  
   where  
   \[
   S_{\text{low}} = 0.6\cdot \text{capacity}
   \]
   (Below this, the stock is too fragile; you prioritize recovery.)

2) **Opponent discipline (recent)**: In the last round, the number of defectors \(k_{t-1}\) is not too high:
   \[
   k_{t-1} \le k_{\max}
   \]
   where  
   \[
   k_{\max} = \left\lfloor 0.2n \right\rfloor
   \]
   (Tolerate some noise/mistakes, but not sustained overuse.)

3) **Sustainability check (trend-based)**: If \(t\ge 3\), estimate whether observed extraction is keeping the stock near capacity. Compute the **2-round stock trend**:
   \[
   \Delta = S_{t-1}-S_{t-2}
   \]
   If \(\Delta < -0.05\cdot \text{capacity}\), treat it as an overuse warning ⇒ do **not** cooperate.

If all three pass ⇒ **play C**.

#### B. Protection mode (triggered response)
Play **D** if *any* of these triggers fire:

- **Stock is threatened**: \(S_t < S_{\text{low}}\)
- **Too many defectors last round**: \(k_{t-1} > k_{\max}\)
- **Sharp downward trend**: \(\Delta < -0.05\cdot\text{capacity}\)

While in Protection mode, you keep defecting until you observe **two consecutive rounds** that indicate recovery and discipline:

Exit Protection mode when both are true:
- Stock is back to safe: \(S_t \ge 0.8\cdot\text{capacity}\)
- In each of the last **two** rounds, defectors were limited: \(k_{t-1}\le k_{\max}\) and \(k_{t-2}\le k_{\max}\)

Then return to Cooperative mode (play C).

**Why this works:**  
- If others cooperate, C keeps the stock near capacity (high long-run payoff for all).  
- If others defect a lot, Protection mode prevents you from being the “sucker” and also accelerates the collapse they are causing (making defection less profitable long-run, pushing adaptive opponents toward cooperation).  
- The two-round exit prevents being whipsawed by alternating/noisy opponents.

---

# 2) Edge cases

### First round (t = 1)
Play **C**.  
Rationale: with initial stock at capacity, the efficient collective outcome starts with C, and it tests whether others are capable of discipline without prematurely escalating.

### Second round (t = 2)
Use the **defectors count in round 1**:
- If \(k_1 \le k_{\max}\) and \(S_2 \ge S_{\text{low}}\): play **C**
- Else: enter Protection mode and play **D**

### Last round (t = r)
Still follow the same rules (no unconditional endgame defection).  
Rationale: (i) you cannot assume others will “forgive” last-round defection in a tournament; (ii) many strategies punish late defection; (iii) maintaining a consistent rule improves robustness.

(If you want a mild endgame tweak: if \(t=r\) and \(S_t \ge 0.9\cdot\text{capacity}\) and last round had zero defectors, still play C—same outcome.)

### Stock near zero
If \(S_t \le 0.1\cdot\text{capacity}\): play **C** (even if in Protection mode).  
Reason: when the stock is extremely low, everyone’s immediate payoff is tiny, and the best chance to ever regain value is to reduce extraction. Defecting here usually just keeps the system dead.

This is the only “override” that can force C during Protection.

---

# 3) Collective mindset (how it aligns with group welfare)
- **Primary objective** is maintaining the stock near capacity because that maximizes the sustainable per-round surplus for the whole group.
- **Reciprocity**: you contribute (C) as long as the group is broadly contributing; you protect yourself (D) when the group over-extracts.
- **Forgiveness**: you return to cooperation after *observed* improvement, not permanently punishing.
- **Robustness**: tolerates a small fraction of defectors (noise), resists exploitation by persistent defectors, and avoids mutual collapse when recovery is possible.

---

## Pseudocode (implementable)

```python
# Parameters
S_low = 0.6 * capacity
S_recover = 0.8 * capacity
k_max = floor(0.2 * n)
trend_drop = 0.05 * capacity
near_zero = 0.1 * capacity

mode = "COOP"  # initial

def decide(t, S_t, history_actions, history_stocks):
    global mode

    if t == 1:
        return "C"

    # count defectors last round
    k_last = count_D(history_actions[t-1])

    # trend requires t>=3
    trend_bad = False
    if t >= 3:
        delta = history_stocks[t-1] - history_stocks[t-2]
        trend_bad = (delta < -trend_drop)

    # near-zero override: prioritize recovery
    if S_t <= near_zero:
        mode = "COOP"
        return "C"

    # triggers for protection
    trigger = (S_t < S_low) or (k_last > k_max) or trend_bad
    if trigger:
        mode = "PROTECT"

    if mode == "COOP":
        return "C"

    # mode == PROTECT
    # exit condition: two disciplined rounds and stock recovered
    if t >= 3:
        k_prev = count_D(history_actions[t-2])
        disciplined_two = (k_last <= k_max) and (k_prev <= k_max)
    else:
        disciplined_two = (k_last <= k_max)

    if (S_t >= S_recover) and disciplined_two:
        mode = "COOP"
        return "C"
    else:
        return "D"
```

This strategy is collective-first when feasible, but it has clear, parameter-based guardrails that make it resilient across cooperative, noisy, exploitative, and mixed opponent populations.
'''

description_COLLECTIVE_64 = '''
## Strategy: **Stock-Guard with Graduated Punishment (SGGP)**  
Goal: keep the resource near *capacity* (high sustained payoffs) while remaining resilient to exploitation by defectors. The strategy is “collective-first” but enforces cooperation through fast, state-based punishment and slow forgiveness.

### Intuition
- If the stock stays high, everyone can keep earning high per-round payoffs indefinitely.
- Defection is individually tempting but can collapse the stock, destroying future payoffs.
- Because actions are simultaneous and there’s no communication, the best “collective” strategy is:
  1) default to cooperation when the system is healthy,  
  2) punish quickly when opponents over-consume (to deter),  
  3) forgive only when the stock recovers and others show restraint.

---

## 1) Decision rules: when to Cooperate vs Defect

### Key quantities observed each round \(t\)
- \(S_t\): stock at start of round \(t\)
- \(k_{t-1}\): number of defectors in round \(t-1\) (observed)
- \(S_{t}\) also implicitly reflects past behavior via dynamics.

### Stock “health” thresholds (parameter-only)
Use simple fractions of `capacity`:
- **Healthy:** \(S_t \ge 0.80 \cdot capacity\)
- **Stressed:** \(0.50 \cdot capacity \le S_t < 0.80 \cdot capacity\)
- **Critical:** \(S_t < 0.50 \cdot capacity\)

(These are robust across \(n\) and capacities because the growth process is logistic and collapse risk rises sharply once stock is reduced.)

### A single internal variable: `punish_level` (integer ≥ 0)
Represents how much we are currently prioritizing deterrence over collective rebuilding.

- Initialize: `punish_level = 0`
- Update after each round based on observed defection and stock stress.

#### Updating `punish_level`
After round \(t\) (having observed actions in that round), set for next round:
- If **any** defection occurred:  
  `punish_level = min(punish_level + 1 + floor(2*k_t/n), 5)`  
  (More defectors → faster escalation; cap at 5 to avoid permanent rage.)
- Else (no defection):
  - If stock is **Healthy**: `punish_level = max(punish_level - 2, 0)` (forgive faster when safe)
  - If stock is **Stressed**: `punish_level = max(punish_level - 1, 0)`
  - If stock is **Critical**: keep as is (don’t forgive while collapsing)

This makes punishment **fast** and forgiveness **conditional on recovery**.

---

### Action choice rule (core)
In round \(t\), choose **C** unless deterrence is necessary *and* system can afford it.

**Rule:**
1. **If \(t = r\) (last round): play D.**  
   (End-game: no future to protect; collective incentives disappear. This is standard and unavoidable.)
2. Else if stock is **Critical** (\(S_t < 0.50\,capacity\)): play C.  
   (When near collapse, defection accelerates ruin; “collective rescue mode.”)
3. Else if `punish_level == 0`: play C.  
4. Else if stock is **Healthy** and `punish_level ≥ 1`: play D.  
   (Punish when the system can absorb it; creates a credible cost for defectors.)
5. Else if stock is **Stressed**:
   - play D only if `punish_level ≥ 3` (severe/ongoing defection)
   - otherwise play C

This ensures we punish opportunists *when it won’t crash the resource*, but we do not “punish into collapse.”

---

## 2) Edge cases and special handling

### First round
- **Round 1:** play C.  
Rationale: with stock initially at capacity, cooperation is the socially efficient “offer.” It also prevents mutual paranoia from causing immediate collapse.

### Last round (round r)
- **Always play D.**  
Rationale: there is no future stock value to preserve, and opponents will anticipate this. Any “collective-minded” algorithm that cooperates on the last round is exploitable.

### Near-last-round tightening (optional but recommended)
In rounds close to the end, punishment has less time to work, so we become more conservative:
- If \(t \ge r-1\): treat the **Healthy** threshold as 0.90 instead of 0.80  
  (i.e., punish only when stock is very high, because there’s less time to recover.)

### If opponents are unconditional defectors
- They will trigger `punish_level` quickly.
- We will switch to D in healthy/stressed states to avoid being the only cooperator.
- But if their behavior drives stock into **Critical**, we switch back to C to slow collapse and harvest whatever regrowth is possible—this is “damage control,” not generosity.

### If opponents are noisy / occasionally defect by mistake
- A single defection raises `punish_level`, but forgiveness happens quickly if subsequent rounds are all-C and stock stays healthy.
- This avoids permanent breakdown due to one-off errors.

### If opponents try “exploit then cooperate”
- The moment defection appears, we punish (often immediately next round) *only if stock can withstand it*.
- They cannot repeatedly skim extra payoff without repeatedly triggering punishment.

---

## 3) Collective mindset: what this is optimizing
This strategy is designed to be a **stabilizer** for the common pool:

- **Primary objective:** keep \(S_t\) high so that per-round payoffs remain high for everyone.
- **Secondary objective:** maintain incentive compatibility—if others defect, they should not earn a sustained advantage.
- **Tertiary objective:** avoid “mutual assured destruction” punishment spirals by punishing only when stock is healthy and forgiving when cooperation returns.

It behaves like a community that:
- starts with trust,
- enforces norms when cheating appears,
- but prioritizes resource survival when the ecosystem is at risk.

---

## Pseudocode (implementable)

```python
# Parameters: n, r, capacity
punish_level = 0

def stock_zone(S):
    if S < 0.50 * capacity: return "critical"
    if S < 0.80 * capacity: return "stressed"
    return "healthy"

for t in 1..r:
    zone = stock_zone(S_t)

    # Action
    if t == r:
        a_t = "D"
    elif zone == "critical":
        a_t = "C"
    elif punish_level == 0:
        a_t = "C"
    else:
        if zone == "healthy":
            # optional near-end conservatism
            if t >= r-1 and S_t < 0.90 * capacity:
                a_t = "C"
            else:
                a_t = "D"
        else:  # stressed
            a_t = "D" if punish_level >= 3 else "C"

    # After observing all actions in round t:
    k_t = number_of_defectors_among_others_in_round_t  # observable from history
    if k_t > 0:
        punish_level = min(punish_level + 1 + (2*k_t)//n, 5)
    else:
        if zone == "healthy":
            punish_level = max(punish_level - 2, 0)
        elif zone == "stressed":
            punish_level = max(punish_level - 1, 0)
        else:
            punish_level = punish_level  # no forgiveness in critical zone
```

---

If you share typical tournament settings (ranges for \(n\), \(r\), and capacity), I can tune the thresholds (0.8/0.5 and punishment escalation) to better match the growth curve and horizon length.
'''

description_COLLECTIVE_65 = '''
## Strategy: **Stock-Guard Trigger (SGT)**  
Collective objective: keep the stock near a “safe/high-growth” region so everyone can earn high payoffs repeatedly, while still being able to **punish** depletion quickly and **recover** when others return to restraint.

Key idea:  
- When stock is healthy, **cooperate by default** to sustain the resource.  
- If others over-consume, **defect proportionally** to (a) stop being exploited and (b) create immediate consequences that push the group back toward restraint.  
- If stock becomes endangered, **switch to “conservation mode”** (cooperate) to allow regrowth—because punishment via further depletion becomes self-harm once the stock is low.

This is a robust “carrot + stick + recovery” policy that does not require shared schedules.

---

# 1) Decision rules (C vs D)

### Definitions (computed each round from observed history)
Let in round \(t-1\):
- \(S_{t-1}\) = stock at start of round \(t-1\)
- \(k_{t-1}\) = number of players who defected in round \(t-1\)

We also track a short memory of defections:
- \(K =\) total number of defections by others over the last \(m\) rounds (recommend \(m=3\))

We define two stock thresholds based only on parameters:
- **High-stock threshold:** \(S \ge 0.8 \cdot capacity\)
- **Low-stock threshold:** \(S \le 0.4 \cdot capacity\)

(These are intentionally simple and robust across capacities; they target staying away from the “cliff” and keeping near replenishing levels.)

---

## Core rule
### A. **Conservation mode (stock is low):**
If \(S_t \le 0.4\cdot capacity\): play **C**.

Rationale: when stock is low, defecting accelerates collapse and reduces everyone’s future payoffs. The best collective move is to rebuild stock.

---

### B. **Normal mode (stock is moderate/high):**
If \(S_t > 0.4\cdot capacity\), decide based on others’ recent behavior:

1) **If no one defected last round** (\(k_{t-1}=0\)): play **C**.  
   - This is the default cooperative stance.

2) **If some defected last round** (\(k_{t-1}>0\)): use **graded retaliation**:

- Compute a retaliation intensity:
  \[
  p = \min\left(1,\ \alpha \cdot \frac{k_{t-1}}{n-1} + \beta \cdot \frac{K}{(n-1)m}\right)
  \]
  Recommended parameters: \(\alpha=0.9,\ \beta=0.6,\ m=3\).

- Then:
  - Play **D** with probability \(p\), otherwise **C**.

Interpretation:
- If defections are rare/small: mostly keep cooperating (gives room for noise/experimentation).
- If defections are frequent/widespread: rapidly shift to defection (prevents being the “sucker” and creates strong incentives to return to C).

---

### C. **Stock-guard override (rapid stock decline):**
Even if stock isn’t yet “low,” react to dangerous trends:

Let \(\Delta S = S_t - S_{t-1}\) (change in stock from last round start to this round start).  
If \(\Delta S < -0.25\cdot capacity\) (a big drop), then **increase punishment** by forcing **D** in this round *unless* \(S_t \le 0.4\cdot capacity\) (conservation dominates).

This catches “sudden raids” where opponents defect en masse and stock is sliding fast.

---

# 2) Edge cases

### First round (t = 1)
Play **C**.

Reason: establishes the cooperative baseline, and in this game cooperation at high stock is collectively optimal and reveals who is inclined to raid.

---

### Last round (t = r)
Play **D** unless stock is low (\(S_r \le 0.4\cdot capacity\)), in which case play **C**.

Why:
- Standard endgame logic makes cooperation fragile in the final round because future punishment/reward disappears.
- However, if stock is already low, defecting yields little extra (since payoff scales with \(S\)) and can still reduce your immediate payoff via lowering \(S\) before growth is irrelevant. So at low stock, staying with **C** is weakly safer.

(If you prefer strictly self-interested last-round play, always D; but this variant is slightly more “collective” while still robust.)

---

### Round 2 (after initial probe)
Apply the normal rules. If many defect immediately, you’ll retaliate quickly via the graded retaliation.

---

### Handling “always defect” opponents
- In high/moderate stock, repeated defections push \(p\) to 1 quickly → you defect often, preventing persistent exploitation.
- If stock collapses toward low-stock threshold, you switch to **C** to attempt regrowth; but if others keep defecting, regrowth may fail—still, your rule avoids making collapse faster than necessary.

---

### Handling “mostly cooperative” populations
- You mostly play **C**, keeping stock near capacity and earning stable repeated returns.
- Occasional single defections are met with mild, probabilistic punishment, which is enough to discourage opportunistic deviations without collapsing cooperation.

---

# 3) Collective alignment (what this strategy “stands for”)
- **Default is stewardship:** cooperate whenever the resource is endangered or when others show restraint.
- **Punishment is conditional and proportional:** defect only to deter exploitation and only strongly when the group demonstrates a pattern of overuse.
- **Recovery is prioritized:** when the stock is low, the strategy refuses to “race to the bottom,” even if others previously misbehaved.

---

# Pseudocode (implementable)
```python
# parameters
m = 3
alpha = 0.9
beta  = 0.6

HIGH = 0.8 * capacity
LOW  = 0.4 * capacity

# state/history available each round t:
# S_t: current stock at start of round t
# history of actions by all players for rounds < t
# store k_prev = number of defectors in t-1
# store K = total defections by others over last m rounds

def choose_action(t, S_t, S_prev, k_prev, K):
    # edge: first round
    if t == 1:
        return "C"

    # edge: last round
    if t == r:
        if S_t <= LOW:
            return "C"
        else:
            return "D"

    # conservation mode
    if S_t <= LOW:
        return "C"

    # stock-guard override on big drop (but not if in conservation mode)
    if S_prev is not None:
        if (S_t - S_prev) < -0.25 * capacity:
            return "D"

    # normal mode
    if k_prev == 0:
        return "C"
    else:
        p = alpha * (k_prev / (n - 1)) + beta * (K / ((n - 1) * m))
        p = min(1.0, p)
        return "D" if random() < p else "C"
```

---

If you want, I can also provide:
- recommended values for the thresholds as functions of \(n\) (not just capacity),
- a fully deterministic variant (no randomness) for tournaments that dislike stochastic play,
- or a version that explicitly estimates whether the group is in a “cooperative equilibrium” vs “collapse regime” using a simple classifier on recent \(S_t\) and defection rates.
'''

description_COLLECTIVE_66 = '''
## Collective Strategy: **Stock-Guarded Generous Grim (SGGG)**

Goal: keep the resource near **capacity** (maximizes long-run total pie via logistic regrowth), while remaining **robust** to exploiters by (i) reacting quickly to over-consumption and (ii) forgiving once the stock is safe again.

Key idea: Use the **stock level** as the primary signal (because it aggregates everyone’s past behavior), and use **history** (estimated number of defectors) to decide whether to punish.

---

## Intuition (why this works)

- When stock is high, **mutual C is self-sustaining**: with all C, stock returns to capacity in one step under the provided growth rule (as in your example).
- Defection is individually tempting but collectively destructive; if many defect, stock collapses.
- Therefore:
  - **Cooperate by default** when the stock is healthy and the group isn’t currently exploiting.
  - **Punish (defect)** when the observed behavior implies too much extraction or when stock is endangered.
  - **Forgive** after a short punishment if the stock recovers and opponents stop over-extracting.

This is a “collective-first” policy because it prioritizes maintaining the stock at safe levels, only using defection as a tool to deter depletion.

---

## Observable quantities you can compute each round

At round \(t\), before choosing action, you know current stock \(S_t\) and the full history of actions.

From the previous round \(t-1\), you can infer how many players defected:

- In round \(t-1\), each C consumed \(S_{t-1}/(2n)\) and each D consumed \(S_{t-1}/n\).
- Total consumption = \(\frac{S_{t-1}}{2n}(n + k)\) where \(k\) = #defectors.
- So \(k\) can be inferred directly from observed actions, or (if needed) from total consumption/stock change.

We’ll use:
- \(k_{t-1}\): number of defectors last round (0..n)
- \(d_{t-1} = k_{t-1}/n\): defection rate last round

---

## Decision Rules (Cooperate vs Defect)

### Parameters (computed from game parameters only)
Let:

- **Safe stock threshold**:  
  \[
  S_{\text{safe}} = 0.8 \cdot \text{capacity}
  \]
- **Danger stock threshold**:  
  \[
  S_{\text{danger}} = 0.5 \cdot \text{capacity}
  \]
- **Critical stock threshold** (near collapse):  
  \[
  S_{\text{crit}} = 0.25 \cdot \text{capacity}
  \]
- **Tolerance for defection when stock is safe**: allow some noise/experimentation:  
  \[
  k_{\text{tol}} = \max(1,\lceil 0.2n \rceil)
  \]
- **Punishment length** (short, to avoid death-spirals):  
  \[
  L = 2 \text{ rounds}
  \]
- **Forgiveness requirement**: need at least one low-defection round to resume cooperation:  
  “low-defection” means \(k_{t-1} \le k_{\text{tol}}\)

We also keep a state variable:
- `punish_timer` (integer, initially 0)

---

## Core policy

### 1) Stock emergency rule (resource-first)
If the stock is in danger, prioritize deterrence and self-protection:

- If \(S_t \le S_{\text{crit}}\): **Cooperate (C)**  
  Rationale: when near collapse, extra extraction is catastrophic; C is the least harmful action available and helps stock recover. Collective mindset: “stop bleeding the resource.”
- Else if \(S_t \le S_{\text{danger}}\): **Cooperate (C)** unless you are currently in a punishment phase triggered by exploitation (see below).  
  Rationale: keep extraction low to let growth work; but don’t be endlessly exploited—punishment may still be needed if others keep defecting.

### 2) Punish exploitation when stock is healthy enough
If stock is healthy, punish only if exploitation is clearly present:

Trigger punishment if all are true:
- \(S_t \ge S_{\text{safe}}\) (resource can handle short retaliation)
- and \(k_{t-1} > k_{\text{tol}}\) (too many defectors last round)
- and `punish_timer == 0`

Then set `punish_timer = L` and **Defect (D)** this round.

While `punish_timer > 0`:
- Play **D**
- Decrement `punish_timer` by 1 each round
- But **override to C** if \(S_t \le S_{\text{danger}}\) (don’t burn the resource down during punishment)

### 3) Cooperate by default with forgiveness
If not in emergency and not punishing, play **C**.

This makes the strategy collectively oriented and forgiving, enabling recovery of cooperation after brief conflict.

---

## Edge Cases

### First round
- **Round 1: play C**
Reason: no history; collective-first; also capacity start makes cooperation sustainable and reveals who exploits.

### Last round
- **If stock is healthy and cooperation has been stable** (e.g., last round had \(k_{t-1}\le k_{\text{tol}}\)): still play **C**.
- **If there is active exploitation** (e.g., \(k_{t-1} > k_{\text{tol}}\)) and \(S_t \ge S_{\text{safe}}\): play **D**.
Rationale: last round removes future deterrence, so being exploited on the final move is strictly bad; but if the group is cooperating, maintain the collective norm.

(Implementationally: apply the same rules; they already handle this, but explicitly note that punishment triggers still apply in the last round.)

### If stock hits 0
- Always play **C** (both actions yield 0 immediate payoff anyway, but C is consistent with recovery if any regrowth were possible; under your rule, growth is 0 at 0, so it won’t recover—still, C is the collective-consistent action and doesn’t worsen anything).

### If opponents alternate / are noisy
- The tolerance \(k_{\text{tol}}\) prevents overreacting to a single defector in large groups.
- The short punishment \(L=2\) prevents endless mutual retaliation.
- The stock override (switch to C when \(S_t\) is low) prevents punishment from causing collapse.

---

## Pseudocode

```python
# Inputs each round t:
# n, r, capacity
# S_t = current stock before choosing action
# history provides k_{t-1} for t>1 (num defectors last round)

S_safe   = 0.8 * capacity
S_danger = 0.5 * capacity
S_crit   = 0.25 * capacity

k_tol = max(1, ceil(0.2 * n))
L = 2

state: punish_timer = 0

def act(t, S_t, k_prev=None):
    global punish_timer

    # Round 1
    if t == 1:
        return "C"

    # Emergency: protect the resource
    if S_t <= S_crit:
        punish_timer = 0
        return "C"

    # If punishing, continue unless stock is getting dangerous
    if punish_timer > 0:
        punish_timer -= 1
        if S_t <= S_danger:
            return "C"
        else:
            return "D"

    # Trigger punishment only if stock is safe enough and exploitation is clear
    if S_t >= S_safe and k_prev > k_tol:
        punish_timer = L - 1   # this round counts as first punishment move
        return "D"

    # Default: cooperate
    return "C"
```

---

## Why this is “collective” and tournament-robust

- **Collective**: defaults to C; prioritizes keeping stock high; refuses to escalate when stock is low.
- **Robust**: detects group-level exploitation (via defection count), punishes briefly, then forgives—works against:
  - always-defectors (won’t stay naïvely cooperative),
  - conditional cooperators (restores cooperation quickly),
  - noisy strategies (tolerates some defection),
  - endgame opportunists (still punishes in last round when warranted).

If you want, I can also provide a variant tuned for very large \(n\) (where single-player punishment is weaker) by making punishment probabilistic based on \(k_{t-1}\) and \(S_t\).
'''

description_COLLECTIVE_67 = '''
## Strategy: **Stock-Guard Grim-Trigger with Forgiveness (SGGTF)**  
Collective objective: keep the resource near *capacity* so everyone can repeatedly harvest high per-round payoffs. The key lever is the stock dynamic: if the post-consumption remaining stock is at least half of capacity, logistic growth restores it to capacity in one step. So the collective “safe zone” is to ensure **S_remaining ≥ capacity/2** each round.

Because actions are only {C,D} and moves are simultaneous, the strategy must (i) **attempt to sustain** the safe zone, (ii) **punish over-harvesting** to deter exploitation, and (iii) **forgive** when cooperation resumes so the group can recover.

---

# 1) Decision rules: when to Cooperate vs Defect

### Definitions (computed each round *after observing last round*, before choosing current action)
Let:
- `S` = current stock at start of this round (observed state).
- `k` = number of defectors in the **previous** round (from history).
- `S_rem_prev` = remaining stock after consumption in the previous round (can be computed exactly from actions and previous stock).

**Safe-zone condition (what we want each round):**  
To keep stock fully replenishing, we need `S_remaining ≥ capacity/2`.

Given starting stock `S`, total consumption if `k` players defect and `n-k` cooperate is:
- Cooperators consume `S/(2n)` each → total coop consumption = `(n-k)*S/(2n)`
- Defectors consume `S/n` each → total def consumption = `k*S/n`
So total consumption fraction is `(n-k)/(2n) + k/n = (n + k)/(2n)`, hence:
- `S_remaining = S * (1 - (n+k)/(2n)) = S * (n-k)/(2n)`

So safe-zone condition becomes:
- `S * (n-k)/(2n) ≥ capacity/2`
- Equivalent: `k ≤ n - n*(capacity/S)` which only feasible when `S` is close to `capacity`.  
At `S = capacity`, this simplifies to: `S_remaining = capacity*(n-k)/(2n) ≥ capacity/2` → `n-k ≥ n` → `k = 0`.  
**Interpretation:** when stock is at capacity, *any defection prevents full rebound to capacity next round*. Full sustainability at peak requires *all cooperate*.

### Core policy (high level)
1. **Default stance: Cooperate (C)** whenever the group appears to be cooperating and stock is healthy.
2. **If defection is observed**, switch into **punishment mode** to remove the benefit of unilateral defection and to stop being exploited.
3. **Return to cooperation** after a short, explicit “forgiveness” condition: once others stop defecting, we resume C to rebuild the stock.

### Detailed rule set
We maintain a mode variable: `mode ∈ {COOP, PUNISH}`.

**COOP mode (collective growth mode):**
- Play **C** if:
  - (a) `k == 0` in the previous round **and**
  - (b) `S` is not critically low (see “critical stock” below).
- Otherwise (any defection observed last round), switch to `PUNISH` and play **D** this round.

**PUNISH mode (anti-exploitation mode):**
- Play **D** while defection persists:
  - If `k > 0` in the previous round → play **D**.
- Forgive and return to COOP when defection stops:
  - If `k == 0` in the previous round → play **C** and set `mode = COOP`.

This is essentially: **“Cooperate until someone defects; then defect until a full round of universal cooperation is observed; then cooperate again.”**  
The forgiveness clause prevents permanent collapse when noise/experimentation happens, and gives adaptive re-coordination without communication.

### Critical-stock override (resource-preservation clause)
When stock is low, the group is near collapse and must prioritize regeneration. But note: with only C/D, there is no “abstain” action; both actions still consume a fraction of S. Still, **C halves your take** and leaves more stock to regrow.

Define a critical threshold:  
- `S_crit = capacity / 4` (can tune; this is a robust default)

Override:
- If `S ≤ S_crit`, always play **C** (even in PUNISH), because defecting accelerates extinction and reduces future payoffs for everyone.  
This is explicitly collective: when the pool is endangered, we stop punishing and focus on recovery.

So final action rule each round:
1. If `S ≤ capacity/4` → play **C**.
2. Else if `mode == COOP`:
   - if last round had any defection → play **D**, set `mode=PUNISH`
   - else play **C**
3. Else if `mode == PUNISH`:
   - if last round had any defection → play **D**
   - else play **C**, set `mode=COOP`

---

# 2) Edge cases (first round, last round, etc.)

### First round
- Start in `COOP` and play **C**.  
Rationale: With stock initially at capacity, universal cooperation yields immediate maximal sustainable performance (stock returns to capacity each round). Starting with D risks immediate collapse if others also do.

### Last round (finite-horizon problem)
In standard repeated games with known end, backward induction pushes toward defection. But in a tournament against varied strategies, many opponents won’t follow strict backward induction; additionally, the “collective” tournament objective typically rewards maintaining cooperation across the horizon.

Rule:
- **Do not automatically defect in the final round.**  
Continue using the same rules.  
Reason: unconditional last-round defection destroys trust in penultimate rounds for strategies that anticipate it, and reduces long-run tournament performance.

### After a collapse (S near 0)
- If `S` is extremely small (e.g., `S < 1e-9`), your action barely matters (payoff ~0 either way). Still:
  - play **C** to signal recovery intent and align with stock-regeneration.

### Handling “always defect” opponents
- You’ll switch to PUNISH and mostly play D (except in critical stock). This avoids being the only cooperator (which would halve your payoff relative to defecting) while still allowing forgiveness if they ever switch.

### Handling intermittent defectors / exploiters
- One defection triggers punishment immediately; they lose the ability to alternate D while you keep C.
- Forgiveness requires a clean round of zero defections, so “on-off” exploiters get contained.

---

# 3) Collective mindset (why this is collectively aligned)

- **Explicit sustainability target:** keep the system in the region where regeneration is strong and near-capacity yields repeated high payoffs.
- **Deterrence without permanent war:** punishment protects cooperators from being systematically exploited, but forgiveness restores cooperation when possible.
- **Resource triage:** when the pool is endangered (`S ≤ capacity/4`), the strategy prioritizes collective survival over retaliation.

---

## Pseudocode (implementation-ready)

```python
# Parameters: n, r, capacity
mode = "COOP"   # initial mode
S_crit = capacity / 4

for t in range(1, r+1):
    observe current stock S  # state at start of round t

    if t == 1:
        action = "C"
    else:
        k = num_defectors_in_round(t-1)  # from history, exact

        if S <= S_crit:
            action = "C"
            # optional: do not change mode; or set mode="COOP"
            mode = "COOP"
        else:
            if mode == "COOP":
                if k > 0:
                    action = "D"
                    mode = "PUNISH"
                else:
                    action = "C"
            else:  # mode == "PUNISH"
                if k > 0:
                    action = "D"
                else:
                    action = "C"
                    mode = "COOP"

    play(action)
```

---

### Notes on robustness
- Works against: cooperators, tit-for-tat-like, grim-trigger-like, random, exploitative alternators, and always-defect.
- Requires no communication, only public history and stock.
- Adapts to state via the critical-stock override, preventing “punishment spirals” from destroying the resource when it’s already fragile.

If you want, I can also provide a tuned variant that uses the observed stock trajectory to infer “effective defection pressure” even when opponents use nonstationary or state-contingent strategies (e.g., attempting to defect only when stock is high).
'''

description_COLLECTIVE_68 = '''
## Strategy: **StockGuard (Collective, state-based Grim-with-Recovery)**

Goal: keep the common stock near **capacity** (where growth is strong and stable), extract sustainably, and deter repeated over-extraction. The strategy is *collective-minded* (defaults to C) but *robust* (punishes persistent defection and protects the stock when it becomes fragile).

Key idea: In this game, the stock update depends only on **how many** players choose D each round. So we can infer the “defection level” from the observed stock drop, and respond without needing communication.

---

## Observables and inference

Let current round be `t`, stock at start of round be `S_t`.

Per-player consumption:
- If C: `S_t/(2n)`
- If D: `S_t/n` (= double the cooperative take)

Total consumption if `k` players defect:
\[
\text{consumption} = (n-k)\frac{S_t}{2n} + k\frac{S_t}{n} = \frac{S_t}{2} + k\frac{S_t}{2n}
\]
So remaining stock after consumption:
\[
S^{rem}_t = S_t - \left(\frac{S_t}{2} + k\frac{S_t}{2n}\right)=\frac{S_t}{2}\left(1-\frac{k}{n}\right)
\]
Hence we can infer:
\[
k \approx n\left(1 - \frac{2S^{rem}_t}{S_t}\right)
\]
We can compute `S_rem` from observed next stock `S_{t+1}` by inverting growth:
- Growth rule: `S_{t+1} = min(S_rem + 2*S_rem*(1 - S_rem/capacity), capacity)`
- If `S_{t+1} < capacity`, then:
  \[
  S_{t+1} = 3S^{rem} - 2(S^{rem})^2/capacity
  \]
  Solve quadratic for `S_rem` in `[0, capacity]`:
  \[
  2x^2/capacity - 3x + S_{t+1}=0
  \]
- If `S_{t+1} == capacity`, then `S_rem` could be any value high enough to regrow to capacity; in that case we don’t need exact `k`—we treat it as “stock safe”.

In implementation, you can:
- Numerically solve for `S_rem` (stable and easy), or
- Use the quadratic formula when `S_{t+1} < capacity`.

Then estimate `k` and clamp to `[0,n]`, rounding to nearest integer.

---

## Decision rules (C vs D)

We maintain a simple internal state: `mode ∈ {COOP, PUNISH}` and a counter `punish_left`.

### Parameters used by the strategy
- `S_safe = 0.9 * capacity`  (stock considered healthy)
- `S_crit = 0.5 * capacity`  (stock considered fragile; below this we prioritize deterrence/containment)
- `tol = 0.5` (tolerance on estimated number of defectors; effectively “did someone defect?”)

### Core rule summary
1. **Default**: Cooperate to sustain high stock.
2. **Trigger punishment** when we detect nontrivial defection while stock is not already critically low.
3. **Punishment**: Defect for a limited number of rounds to make defection unprofitable and signal intolerance for exploitation.
4. **Recovery**: Return to cooperation once opponents appear to return to cooperation and/or stock is healthy again.
5. **Stock protection**: If stock is critically low, do not be the “last cooperator”—defect to prevent being systematically exploited and to discourage further depletion.

---

## Detailed policy

### Round 1 (edge case)
- **Play C**.
Rationale: with full stock at capacity, cooperation yields maximum sustainable collective welfare, and you lose little by trying once.

### General rounds `t = 2..r`

#### Step A — Update beliefs about last round
From `(S_{t-1}, S_t)` infer `k_{t-1}` (estimated number of defectors last round). Define:
- `defection_detected = (k_{t-1} >= 1 - tol)`  (i.e., at least ~1 defector)

Also track a short “trend” over last 2 rounds (optional but robust):
- `k_avg = average(k_{t-1}, k_{t-2} if exists)`

#### Step B — Decide mode transitions
**Enter punishment** if:
- We are in `COOP`, and
- `defection_detected`, and
- stock was not already critically low: `S_{t-1} >= S_crit`

Then set punishment length proportional to severity:
- `punish_left = min(3, ceil(k_{t-1}))`
- `mode = PUNISH`

Interpretation: if 1 defector shows up, punish 1 round; if many defect, punish up to 3 rounds.

**Exit punishment early** if:
- During punishment, stock becomes very healthy (`S_t >= S_safe`) *and*
- estimated defectors drop near zero for one full round (`k_{t-1} ≈ 0`)

Otherwise decrement `punish_left` each round; when it hits 0, return to `COOP`.

#### Step C — Action choice within a mode

**If `mode = COOP`:**
- If `S_t >= S_crit`: **Play C**
- Else (`S_t < S_crit`): **Play D**
  - Rationale: when stock is fragile, a lone cooperator is easily exploited (defectors get double payoff). Defecting here is a defensive move that pressures the group to stop over-consuming and avoids being the “sucker” while the resource is at risk.

**If `mode = PUNISH`:**
- **Play D**
  - But add a “mercy clause”: if `S_t` is extremely low (near 0), defecting and cooperating both give near-zero anyway, but defecting is still the right deterrent signal. So keep **D**.

### Last round (edge case)
In many repeated games, the last round tempts defection. But here, the collective objective is tournament performance across many opponent types, not one-shot extraction. Also, defecting in the last round can be dominated by its reputational effect earlier if others anticipate it.

So:
- If `t = r`:
  - If `S_r >= S_crit` and we are not in punishment: **Play C**
  - If in punishment or `S_r < S_crit`: **Play D**

This keeps a cooperative stance when the system is stable, but doesn’t allow endgame exploitation if we’re already in conflict or the stock is fragile.

---

## Pseudocode

```python
init:
  mode = "COOP"
  punish_left = 0
  play C in round 1

for t in 2..r:
  # infer k_{t-1} from S_{t-1} and S_t (using inverted growth)
  k = estimate_defectors(S_prev=S[t-1], S_next=S[t], capacity, n)

  defection_detected = (k >= 1)

  # mode transitions
  if mode == "COOP":
    if defection_detected and S[t-1] >= 0.5*capacity:
      mode = "PUNISH"
      punish_left = min(3, ceil(k))

  else:  # mode == "PUNISH"
    punish_left -= 1
    # optional early exit if peace restored
    if k == 0 and S[t] >= 0.9*capacity:
      punish_left = 0
    if punish_left <= 0:
      mode = "COOP"

  # choose action
  if t == r:  # last round rule
    if mode == "COOP" and S[t] >= 0.5*capacity:
      action = "C"
    else:
      action = "D"
  else:
    if mode == "COOP":
      action = "C" if S[t] >= 0.5*capacity else "D"
    else:
      action = "D"

  play(action)
```

---

## Why this is collectively aligned *and* robust

- **Collective-first default**: It starts with C and returns to C whenever the environment looks cooperative and the stock is healthy.
- **State-aware sustainability**: It explicitly protects the stock—cooperation is favored when the stock can sustain it, while low stock triggers defensive defection to avoid being exploited and to push behavior away from collapse.
- **Punishes opportunism without permanent war**: Short, severity-scaled punishment discourages “try a D and see” opponents, but the recovery path prevents endless mutual defection.
- **Works without coordination**: No reliance on synchronized schedules or shared norms—only uses public history and stock dynamics.

If you want, I can also provide a concrete numerical method for `estimate_defectors()` that is stable under floating-point error and the `min(..., capacity)` cap.
'''

description_COLLECTIVE_69 = '''
## Collective strategy: **Stock-Guarded Forgiving Trigger (SGFT)**

Goal: keep the stock near capacity (high sustainable yields) while being robust to exploitation. The strategy cooperates by default, but quickly switches to defection when (a) others are over-consuming or (b) the stock is at risk, and returns to cooperation after a short “cooldown” once behavior improves.

Key design ideas:
- The system is efficient when stock stays high; “all C” at capacity is typically self-replenishing.
- Defection is individually tempting, so we need a *credible, state-based punishment*.
- Because actions are observable, we can detect who defected and respond proportionally.
- Because the state is dynamic, we also punish *outcomes* (stock falling) even if we can’t perfectly attribute causes (e.g., mixed play).

---

# 1) Decision rules: when to cooperate vs defect

### Quantities computed each round \(t\)
From history you know:
- Previous stock \(S_t\) at start of round \(t\)
- Actions in round \(t-1\): number of defectors \(d_{t-1}\)
- Previous post-growth stock \(S_t\) (already given as current state)

Define thresholds (depend only on parameters):
- **Safe stock level**:  
  \[
  S_{\text{safe}} = 0.9 \cdot \text{capacity}
  \]
- **Danger stock level**:  
  \[
  S_{\text{danger}} = 0.6 \cdot \text{capacity}
  \]
- **Critical stock level**:  
  \[
  S_{\text{crit}} = 0.3 \cdot \text{capacity}
  \]
- **Tolerance for defections** (how many defectors we “forgive” without punishing):  
  \[
  d_{\text{tol}} = \max\left(0, \left\lfloor \frac{n}{4} \right\rfloor - 1\right)
  \]
  (For small n this is 0; for larger n it allows a little noise.)

Maintain an internal variable:
- `punish_timer` (integer ≥ 0): how many future rounds we will defect as punishment.
- `escalation_level` (integer ≥ 0): increases if exploitation repeats; lengthens punishment.

### Core rule
**Play C unless (i) the stock is low/risky, or (ii) recent behavior shows too much defection. Otherwise punish briefly, then forgive.**

#### Trigger conditions (set/extend punishment)
At the start of round \(t\), compute:

1) **Behavior trigger** (too many defectors last round):
- If \(d_{t-1} > d_{\text{tol}}\), then increase punishment.

2) **State trigger** (stock deterioration):
- If \(S_t < S_{\text{danger}}\), then increase punishment.
- If \(S_t < S_{\text{crit}}\), go into emergency mode (defect until recovery).

#### Punishment length
When a trigger fires, set:
- `escalation_level += 1` (cap it, e.g. at 5)
- `punish_timer = max(punish_timer, base_punish + escalation_level)`

Where:
- `base_punish = 1` if \(S_t \ge S_{\text{danger}}\) (mild)
- `base_punish = 2` if \(S_{\text{crit}} \le S_t < S_{\text{danger}}\) (stronger)
- `base_punish = 3` if \(S_t < S_{\text{crit}}\) (emergency)

#### Action choice each round
- If `punish_timer > 0`: **play D** and decrement `punish_timer`.
- Else if \(S_t < S_{\text{safe}}\) and (some defection occurred recently): **play D** (pre-emptive protection).
- Else: **play C**.

#### Forgiveness / de-escalation
If for **two consecutive rounds**:
- \(d_{t-1} = 0\) and \(S_t \ge S_{\text{safe}}\)

Then:
- Reduce `escalation_level = max(escalation_level - 1, 0)`
- Keep `punish_timer = 0`

This makes it return to cooperation when the group stabilizes.

---

# 2) Edge cases

### First round
- **Round 1: play C.**
Rationale: establish cooperation, preserve stock, and allow observation of opponents. Starting with D destroys trust and often collapses stock.

Initialize:
- `punish_timer = 0`
- `escalation_level = 0`

### Last round (round r)
Finite-horizon temptation exists, but if everyone defects in the last round, you lose the last-round cooperative surplus and also reward defectors earlier. In tournaments, “grim last-round defection” tends to backfire because others anticipate it or because you can’t coordinate.

Rule:
- **In the last round, follow the same rule** (do not automatically defect).
- Exception: if \(S_r < S_{\text{danger}}\) or `punish_timer > 0`, defect as usual.

### Very low stock / near collapse
If \(S_t\) is extremely low, cooperation and defection both yield small absolute payoffs, but uncontrolled behavior can prevent recovery.

Emergency rule:
- If \(S_t < S_{\text{crit}}\): **defect until \(S_t \ge S_{\text{danger}}\) AND last round had \(d_{t-1} \le d_{\text{tol}}\)**.
This is a hard “resource protection” stance: don’t risk being the only cooperator while others keep extracting.

### All others always defect
You will quickly enter repeated punishment (defection). This avoids being systematically exploited. You won’t restore the stock by yourself, but the strategy’s objective here becomes “minimize disadvantage,” since unilateral cooperation is dominated.

### All others always cooperate
You will keep cooperating (maximizes long-run total payoffs by keeping stock at/near capacity).

---

# 3) Collective alignment (why this is “collective”)

- **Default cooperative posture**: starts with C and returns to C quickly after compliance.
- **Stock-first governance**: uses stock thresholds to protect the shared resource, not just retaliation.
- **Proportional punishment**: responds to *degree of defection* and *severity of stock decline*; doesn’t over-punish one-off noise.
- **Forgiving**: explicit mechanism to de-escalate after stability, enabling recovery of cooperation with mixed populations.
- **Robustness**: performs reasonably against (i) cooperators, (ii) opportunists, (iii) noisy strategies, and (iv) unconditional defectors.

---

## Pseudocode (implementable)

```python
# Parameters: n, r, capacity
S_safe   = 0.90 * capacity
S_danger = 0.60 * capacity
S_crit   = 0.30 * capacity
d_tol = max(0, (n // 4) - 1)
ESC_MAX = 5

punish_timer = 0
escalation = 0

def choose_action(t, S_t, d_prev, d_prev2):
    global punish_timer, escalation

    if t == 1:
        return "C"

    # triggers
    trigger = False
    if d_prev > d_tol:
        trigger = True
    if S_t < S_danger:
        trigger = True

    if trigger:
        escalation = min(ESC_MAX, escalation + 1)

        if S_t >= S_danger:
            base = 1
        elif S_t >= S_crit:
            base = 2
        else:
            base = 3

        punish_timer = max(punish_timer, base + escalation)

    # forgiveness / de-escalation
    if d_prev == 0 and d_prev2 == 0 and S_t >= S_safe and punish_timer == 0:
        escalation = max(0, escalation - 1)

    # action
    if punish_timer > 0:
        punish_timer -= 1
        return "D"

    # precaution if stock not healthy and there was any recent defection
    if S_t < S_safe and d_prev > 0:
        return "D"

    return "C"
```

If you want, I can tune the stock thresholds and punishment lengths specifically for typical tournament settings (e.g., large r vs small r, high vs low capacity relative to n), but the above is intentionally parameter-driven and general.
'''

description_COLLECTIVE_70 = '''
## Strategy: **Stock‑Guarded Win–Stay / Lose–Shift (SG‑WSLS)**  
Collective goal: keep the resource near full capacity (high sustainable yield), while deterring exploitation. The strategy uses (i) a **biological sustainability trigger** from the stock dynamics and (ii) a **fairness trigger** from observed actions. It tries to cooperate whenever the stock can reliably recover, and defects only when needed to (a) punish defectors and (b) prevent being the “sucker” while others over-harvest.

---

# Key idea (why this works here)
With your growth rule, stock growth is maximized when the **post-consumption remainder** is at **capacity/2**, yielding growth = capacity/2 and returning the stock to capacity next round.  
So the collective sweet spot each round is: leave **S_remaining ≈ capacity/2**.

Given current stock \(S\) and **k defectors** among the other \(n-1\) players:
- total consumption = \(S\left(\frac{k}{n} + \frac{n-k}{2n}\right)=S\frac{n+k}{2n}\)
- remainder = \(S - S\frac{n+k}{2n} = S\frac{n-k}{2n}\)

So cooperation is safe only if expected k is small enough that we still leave enough remainder.

---

# Notation computed from history/state
At round \(t\), before choosing action, you can compute:

- \(S_t\): current stock.
- \(k_{t-1}\): number of defectors in the previous round (observed).
- \(k^\text{ema}\): smoothed estimate of “typical defectors” using exponential moving average:
  \[
  k^\text{ema} \leftarrow \alpha\cdot k_{t-1} + (1-\alpha)\cdot k^\text{ema}
  \]
  with \(\alpha = 0.5\) (responsive but not jittery).
- “Urgency” from stock:
  - **Healthy** if \(S_t \ge 0.8\cdot capacity\)
  - **Warning** if \(0.5\cdot capacity \le S_t < 0.8\cdot capacity\)
  - **Critical** if \(S_t < 0.5\cdot capacity\)

We also compute a **sustainability threshold**: maximum defectors we can tolerate while still leaving at least capacity/2 after consumption *assuming we cooperate*.

If you cooperate and expect \(k\) defectors among the other \(n-1\), remainder would be:
\[
S_t\frac{n-k-1}{2n} \quad \text{(because your own action is C)}
\]
We want remainder \(\ge capacity/2\). Solve:
\[
S_t\frac{n-k-1}{2n} \ge \frac{capacity}{2}
\Rightarrow n-k-1 \ge \frac{n\cdot capacity}{S_t}
\]
This is often impossible unless \(S_t\) is near capacity and \(k\) is tiny. Practically, we implement a simpler robust rule: **cooperate only when stock is high and defections have been rare**; otherwise defect to cut your losses and punish.

---

# 1) Decision rules (cooperate vs defect)

### Rule A — Default cooperative stance (collective mode)
**Play C** when both are true:
1) **Stock is healthy**: \(S_t \ge 0.8\cdot capacity\)  
2) **Defection pressure is low**: \(k^\text{ema} \le 0.15\cdot (n-1)\) and \(k_{t-1}=0\) or \(k_{t-1}=1\)

Interpretation: we only “go all-in cooperative” when the group is behaving and the stock can reliably stay near the regenerative region.

---

### Rule B — Targeted retaliation (deterrence mode)
If last round had meaningful defection:
- If \(k_{t-1} \ge 2\) **or** \(k^\text{ema} > 0.15\cdot(n-1)\), then **play D**.

This is a simple, legible punishment: widespread defection triggers immediate defection.

---

### Rule C — Forgiveness / re-entry to cooperation
After defecting due to retaliation, return to cooperation only if:
- \(S_t \ge 0.8\cdot capacity\) **and**
- \(k_{t-1}=0\) for **two consecutive rounds** (a “cool-down”)
  
This prevents oscillations where one round of cooperation gets exploited immediately.

---

### Rule D — Resource emergency brake (stabilize the stock)
If stock falls into danger, switch behavior to limit further collapse:

- If **Critical** (\(S_t < 0.5\cdot capacity\)): **play C regardless of history**.  
  Rationale: when stock is low, everyone defecting drives it to 0; cooperating is the only chance to let growth rebuild. Even if others defect, you want to reduce total extraction.

- If **Warning** (\(0.5\cdot capacity \le S_t < 0.8\cdot capacity\)):  
  - play **C** if \(k^\text{ema} \le 0.3\cdot(n-1)\)  
  - otherwise play **D** (you’re being milked too hard)

This makes the strategy “collective-first” when the resource itself is at risk, but still not naively exploitable when opponents are systematically predatory.

---

# 2) Edge cases

### First round
- **Play C**.  
No history exists; starting cooperative maximizes the chance of reaching a cooperative basin (and in many populations rewards you with high long-run yield).

Initialize:
- \(k^\text{ema} = 0\)

### Last round
Tournament settings often reward end-game defection. However, going D in the last round is individually profitable (double harvest) and cannot be punished. Still, a purely selfish last-round D can destabilize earlier cooperation if others anticipate it. Since you can’t assume shared backward induction sophistication across AIs, use a **soft last-round rule**:

- If \(t = r\):  
  - play **C** if \(S_t < 0.8\cdot capacity\) (protect stock isn’t relevant anymore, but this avoids needless “final betrayal” against cooperators and keeps your strategy more partnerable in mixed populations that use “end-game detection”)  
  - otherwise play **D** (take the one-shot gain when stock is abundant)

### Near-zero stock
- If \(S_t\) is extremely small, payoffs are tiny either way, but defecting can prevent recovery. Keep **C** under Critical.

### Very large n
The thresholds scale with \(n-1\) via \(k^\text{ema}\), so the rule remains meaningful as group size changes.

---

# 3) Collective mindset, clearly stated
This strategy treats the stock as a shared asset worth protecting first, **but** it enforces cooperation by making exploitation unprofitable:

- **Protect the commons** when it’s fragile (Critical ⇒ unconditional C).
- **Reward cooperative groups** with steady C when stock is high and defection is rare.
- **Punish free-riding** quickly and predictably (retaliation mode).
- **Forgive** after sustained good behavior (two clean rounds), so cooperation can re-emerge.

---

# Pseudocode (implementation-ready)
```python
# parameters: n, r, capacity
alpha = 0.5
k_ema = 0
clean_streak = 0   # consecutive rounds with k_{t-1} == 0

def action(t, S_t, history):
    global k_ema, clean_streak

    if t == 1:
        return "C"

    k_prev = number_of_defectors_in_round(t-1, history)  # among all players
    k_ema = alpha * k_prev + (1 - alpha) * k_ema

    if k_prev == 0:
        clean_streak += 1
    else:
        clean_streak = 0

    # stock regimes
    healthy = (S_t >= 0.8 * capacity)
    warning = (0.5 * capacity <= S_t < 0.8 * capacity)
    critical = (S_t < 0.5 * capacity)

    # last round rule
    if t == r:
        if S_t < 0.8 * capacity:
            return "C"
        else:
            return "D"

    # emergency brake
    if critical:
        return "C"

    if warning:
        if k_ema <= 0.3 * (n - 1):
            return "C"
        else:
            return "D"

    # healthy stock
    # retaliation
    if (k_prev >= 2) or (k_ema > 0.15 * (n - 1)):
        return "D"

    # forgiveness / return to cooperation
    if healthy and clean_streak >= 2:
        return "C"

    # default cooperative stance when defection is very low
    if healthy and (k_ema <= 0.15 * (n - 1)) and (k_prev <= 1):
        return "C"

    # otherwise cautious
    return "D"
```

---

If you want, I can tune the numeric thresholds (0.8/0.5 stock cutoffs; 0.15/0.3 defection cutoffs; “k_prev≥2” trigger; last-round choice) for specific tournament expectations (e.g., more adversarial fields vs mostly cooperative fields).
'''

description_COLLECTIVE_71 = '''
## Strategy: **Stock-Guarded Reciprocal Cooperation (SGRC)**  
Goal: keep the common stock near a “safe” level that can regenerate well, cooperate by default, but switch to disciplined defection when (a) the stock is endangered or (b) others are over-consuming relative to what a cooperative group would do.

This is a *collective* strategy because it treats the stock as the primary public good and uses retaliation only as a tool to restore sustainable behavior, not to “win” individual rounds.

---

# Key idea (what we’re trying to stabilize)
Let current stock be `S`. After total consumption, remaining stock is `S_rem`, and then it grows logistically. The growth is strong when `S_rem` is around `capacity/2` and weak near 0 or capacity. In your examples, **all-C** at full stock drives `S_rem` to `S/2`, which then regrows to capacity. That’s a very healthy cycle.

So the strategy’s baseline is:  
- **Cooperate when the stock is healthy and others are not over-consuming.**  
- **Defect when stock is at risk or when opponents are clearly extracting too much.**  
- **Return to cooperation quickly once conditions improve.**

---

# Observables we use
At round `t`, before choosing an action, we know:
- `S_t` (current stock)
- History of all players’ past actions
- So we can compute, for round `t-1`:
  - `k_{t-1}` = number of defectors (players who played D) last round

---

# Useful thresholds (depend only on parameters)
Define:

- **Healthy-stock threshold:**  
  `S_safe = capacity/2`  
  Rationale: keeping post-consumption stock near half is good for regeneration; also if stock ever falls far below this, collapse risk increases.

- **Critical-stock threshold (emergency):**  
  `S_crit = capacity/(4)`  
  Below this, growth is limited and one more bad round can push it near 0. We switch to “emergency protection”.

- **Defection tolerance (how many defectors we can “absorb” while still cooperating):**  
  We tolerate up to about a quarter of the group defecting without immediate punishment (to be robust to noise/experiments):  
  `k_tol = floor((n-1)/4)`  (excluding self, but for simplicity count all defectors last round and compare to `floor(n/4)`)

- **Punishment length (scales mildly with group size):**  
  `P = 1 + floor(log2(n))` rounds.  
  Rationale: enough to deter persistent defection, but short enough to recover cooperation quickly.

---

# 1) Decision rules (C vs D)

### Rule A — First priority: protect stock if it’s low
If `S_t <= S_crit`: **Play C**.  
Collective rationale: when stock is critical, defecting accelerates collapse; the best chance to recover is minimizing extraction.

If `S_crit < S_t < S_safe`: play based on whether others have been extracting too much recently:
- If last round had *many defectors* (`k_{t-1} > floor(n/4)`), **Play D** (controlled retaliation, because cooperation is being exploited).
- Else **Play C** (try to rebuild stock while maintaining cooperative posture).

### Rule B — If stock is healthy: cooperate unless there’s exploitation
If `S_t >= S_safe`:
- Default: **Play C**
- Exception: if opponents defected “too much” recently, retaliate:
  - If `k_{t-1} > k_tol` then **enter Punishment Mode** (described below) and play **D**.

### Punishment Mode (reciprocity enforcement)
We maintain an internal counter `punish_remaining`. When it’s > 0:
- Play **D**
- Decrement `punish_remaining` by 1 each round

**Entering punishment:**  
If not already punishing and `k_{t-1} > k_tol` and `S_t >= S_crit`, set  
`punish_remaining = P`.

**Early exit from punishment (forgiveness):**  
If during punishment we observe **no defectors** last round (`k_{t-1} == 0`) *and* stock is at least safe (`S_t >= S_safe`), then set `punish_remaining = 0` (return immediately to C).  
Rationale: quick restoration of collective cooperation once others comply.

---

# 2) Edge cases

### First round (t = 1)
Play **C**.  
Rationale: establishes cooperative intent, and at `S = capacity` all-C is stock-sustaining.

Initialize:
- `punish_remaining = 0`

### Last round (t = r)
Still follow the same rules (no endgame defection).  
Rationale: in a tournament, “always defect at the end” invites pre-emptive defection by others and destroys long-run performance across many matchups. A collective strategy stays consistent.

### Stock at/near zero
If `S_t` is extremely small (e.g., `S_t < 1e-9`), action doesn’t matter for immediate payoff, but still play **C** to signal rebuilding intent and avoid restarting collapse cycles when growth resumes.

### Everyone else always defects
You will:
- Cooperate at very low stock (trying to recover)
- Retaliate with D when stock is not critical and defection is rampant
This tends to avoid being a pure “sucker” while still occasionally allowing recovery if defectors ever shift.

### Everyone else always cooperates
You always play C; stock remains near capacity; you match the collective optimum.

---

# 3) Collective framing (what this strategy “stands for”)
- **Stock-first:** the common pool is the scarce asset; never choose an action that predictably accelerates collapse when stock is critical.
- **Reciprocal and enforceable:** cooperate by default, but punish sustained over-extraction to prevent being exploited.
- **Forgiving:** return to cooperation quickly once others do.
- **Robust:** tolerates a small amount of “testing” or noise (a few defectors) without immediately triggering mutual retaliation spirals.

---

# Pseudocode (implementable)
```python
# Parameters: n, r, capacity
S_safe = capacity / 2
S_crit = capacity / 4
k_tol  = (n - 1) // 4
P      = 1 + int(log2(n))

punish_remaining = 0

def choose_action(t, S_t, k_prev):  # k_prev undefined at t=1
    global punish_remaining

    if t == 1:
        punish_remaining = 0
        return "C"

    # Emergency stock protection
    if S_t <= S_crit:
        punish_remaining = 0  # don't escalate when near collapse
        return "C"

    # If currently punishing, maybe forgive
    if punish_remaining > 0:
        if (k_prev == 0) and (S_t >= S_safe):
            punish_remaining = 0
            return "C"
        punish_remaining -= 1
        return "D"

    # Not punishing: decide whether to start
    if k_prev > k_tol:
        punish_remaining = P
        punish_remaining -= 1
        return "D"

    # Otherwise cooperate (with mild extra caution in mid-stock range)
    if S_t < S_safe and k_prev > (n // 4):
        return "D"
    return "C"
```

---

If you want, I can also provide (a) a variant tuned to be more exploit-resistant (harsher punishment), or (b) one tuned to maximize recovery from low stock (more cooperative even under defection), depending on what kinds of opponents you expect in the tournament.
'''

description_COLLECTIVE_72 = '''
## Strategy: **Stock-Guarded, Forgiving Trigger (SGFT)**  
Goal: keep the stock near capacity (so everyone’s per-round payoffs stay high) while remaining hard to exploit by persistent defectors. The strategy is *collective-first* when the resource is healthy, but switches to *resource-protection and discipline* when depletion or exploitation is detected.

Key idea: In this game, **all-C is self-sustaining at capacity** (returns stock to capacity each round), while **too many D collapses stock to 0 quickly**. So we:  
1) cooperate by default when the stock is healthy and opponents are not abusing,  
2) punish (defect) when opponents over-consume,  
3) return to cooperation after a short, clear recovery condition.

---

# 1) Decision rules (C vs D)

### Observables each round
At start of round \(t\), you observe current stock \(S_t\) and full history of actions. From last round \(t-1\), compute:
- \(d_{t-1}\): number of players who played D
- \(S_t\): resulting stock after consumption + growth (given by the game)

### Parameters used by the strategy
- **Stock safety threshold**:  
  \[
  S_{\text{safe}} = 0.9 \times \text{capacity}
  \]
- **Stock danger threshold**:  
  \[
  S_{\text{danger}} = 0.5 \times \text{capacity}
  \]
- **Defection tolerance when stock is healthy**: allow a *little* noise but not sustained abuse:  
  \[
  d_{\text{tol}} = \max\left(1,\ \left\lfloor 0.1n \right\rfloor\right)
  \]
- **Punishment length baseline**:  
  \[
  L = 2
  \]
  (short but meaningful; escalates if defection persists)

### State tracked by the strategy
- `punish_remaining` (integer ≥ 0): how many future rounds you will play D
- `escalation` (integer ≥ 0): increases if defection continues during/after punishment

---

## Core rule set

### A. Cooperative mode (default)
You play **C** if *all* are true:
1) Stock is healthy: \(S_t \ge S_{\text{safe}}\)  
2) Recent behavior acceptable: in the previous round, \(d_{t-1} \le d_{\text{tol}}\)  
3) You are not currently punishing: `punish_remaining == 0`

**Rationale:** When stock is high, cooperation yields a stable high-payoff path for everyone. Small amounts of D might happen due to exploration/bugs; tolerate limited noise to avoid unnecessary collapse.

---

### B. Trigger to punishment (discipline)
You enter punishment (set `punish_remaining`) and play **D** immediately if *either*:
1) **Over-consumption detected:** \(d_{t-1} > d_{\text{tol}}\)  
2) **Stock decline warning:** \(S_t < S_{\text{safe}}\) and \(d_{t-1} \ge 1\)  
3) **Stock is already in danger:** \(S_t \le S_{\text{danger}}\)

When triggered, set:
\[
\text{punish\_remaining} = L + \text{escalation}
\]

And update escalation:
- If trigger reason includes \(d_{t-1} > d_{\text{tol}}\), then `escalation += 1` (cap it at, say, 5)

**Rationale:** If others defect enough, “being nice” just subsidizes them and risks long-run collapse. Punishment is short but ramps up if opponents keep defecting.

---

### C. Punishment mode (play D)
If `punish_remaining > 0`, play **D** and decrement `punish_remaining -= 1`.

**Rationale:** Punishment must be predictable and costly to defectors. Defecting during punishment reduces the immediate advantage of unilateral defection and signals you won’t be a soft target.

---

### D. Return-to-cooperation (forgiveness with conditions)
After punishment ends (`punish_remaining == 0`), you *do not automatically* go back to C. You require a “calm & recovery” condition:

Play **C** only if:
- \(S_t \ge S_{\text{safe}}\), **and**
- In the most recent round, \(d_{t-1} \le d_{\text{tol}}\)

Otherwise, restart punishment (as in B).

Additionally, if you observe **two consecutive rounds** with \(d \le d_{\text{tol}}\) while stock is rising (or already safe), reduce escalation by 1 (down to 0).

**Rationale:** This prevents being repeatedly exploited by “defect right after forgiveness” strategies, but still allows rebuilding cooperation.

---

# 2) Edge cases

### First round (t = 1)
Play **C**.

**Why:** Starting cooperative is collectively optimal, and it also tests whether others are willing to cooperate when the resource is abundant.

---

### Last round (t = r)
Play **D** **unless** all the following hold:
- \(S_t \ge S_{\text{safe}}\)
- In round \(r-1\), \(d_{r-1} = 0\) (full cooperation last round)
- You are not in punishment mode

So by default last-round is D, but you “reward” a fully cooperative group with C.

**Why:** With a known finite horizon, end-game defection pressure is real. But conditioning on perfect cooperation in the penultimate round allows mutual “honor” finishes when the table is clearly cooperative, while not being naïve against opportunists.

---

### Very low stock (near collapse)
If \(S_t \le 2n\) (i.e., close to the minimum described range / severe depletion), always play **C** *unless* you are already in punishment and defection remains widespread.

Practical rule:
- If \(S_t \le 2n\) and \(d_{t-1} \le d_{\text{tol}}\): play **C** (resource rescue)
- If \(S_t \le 2n\) and \(d_{t-1} > d_{\text{tol}}\): play **D** (you’re being farmed; don’t be the only rescuer)

**Why:** When the resource is nearly gone, everyone’s absolute payoffs are low; cooperation is needed to allow regrowth. But if others keep defecting heavily, unilateral rescue just enables them.

---

# 3) Collective mindset (what the strategy is “trying to do”)
- **Primary objective:** keep stock at/near capacity for maximal sustainable group payoff (the all-C path is ideal).
- **Secondary objective:** enforce norms *without communication* by making defection reliably unprofitable over time.
- **Robustness:** tolerates small noise, punishes clear over-consumption, escalates against persistent defectors, and forgives when cooperation resumes.

---

# Pseudocode (implementation-oriented)

```python
# Parameters
S_safe   = 0.9 * capacity
S_danger = 0.5 * capacity
d_tol    = max(1, int(0.1 * n))
L        = 2
ESC_MAX  = 5

# State
punish_remaining = 0
escalation = 0
calm_streak = 0  # consecutive rounds with low defection

def decide(t, S_t, history_actions):
    global punish_remaining, escalation, calm_streak

    if t == 1:
        return "C"

    # Count defections in previous round
    last_round = history_actions[t-1]  # list length n of "C"/"D"
    d_last = sum(1 for a in last_round if a == "D")

    # Update calm streak
    if d_last <= d_tol:
        calm_streak += 1
    else:
        calm_streak = 0

    # De-escalate if things have been calm
    if calm_streak >= 2 and escalation > 0 and S_t >= S_safe:
        escalation -= 1
        calm_streak = 0  # avoid rapid oscillation

    # Last round logic
    if t == r:
        if punish_remaining > 0:
            punish_remaining -= 1
            return "D"
        if S_t >= S_safe and d_last == 0:
            return "C"
        return "D"

    # If currently punishing
    if punish_remaining > 0:
        punish_remaining -= 1
        return "D"

    # Resource rescue edge case
    if S_t <= 2*n:
        if d_last <= d_tol:
            return "C"
        # if others still defect a lot, punish
        punish_remaining = L + escalation
        escalation = min(ESC_MAX, escalation + 1)
        return "D"

    # Trigger punishment conditions
    trigger = False
    if d_last > d_tol:
        trigger = True
    if (S_t < S_safe and d_last >= 1):
        trigger = True
    if S_t <= S_danger:
        trigger = True

    if trigger:
        punish_remaining = L + escalation
        if d_last > d_tol:
            escalation = min(ESC_MAX, escalation + 1)
        return "D"

    # Default cooperate if safe and calm enough
    if S_t >= S_safe and d_last <= d_tol:
        return "C"

    # Otherwise cautious punish
    punish_remaining = L + escalation
    return "D"
```

---

This SGFT policy is simple enough to implement, aligns with collective sustainability when possible, and is designed to avoid being exploited by a wide range of opponent behaviors (always-D, occasional-D, grim triggers, noisy cooperators, and opportunistic “defect-on-forgiveness” types).
'''

description_COLLECTIVE_73 = '''
## Strategy: **Stock-Safe Reciprocal (SSR)**  
Collective goal: keep the common pool in the “high-regeneration” region while using **credible, history-based reciprocity** to deter exploitation. The strategy is **state-aware** (reacts to stock level) and **opponent-aware** (reacts to observed defection rates), with a built-in “rescue mode” to prevent collapse.

Key idea:  
- When stock is healthy, **cooperate by default**, but only if others aren’t persistently free-riding.  
- When stock is threatened, **prioritize recovery** (cooperate) unless punishment is necessary and safe.  
- Punish defectors **proportionally and temporarily**, then return to cooperation quickly if behavior improves.

---

# 1) Decision rules (C vs D)

### Notation (computed each round before choosing action)
- Parameters: `n, r, capacity`
- Current round: `t ∈ {1..r}`
- Current stock: `S_t`
- History: all past actions `a_j,τ` for all players `j` and rounds `τ < t`
- Let `Dcount_lastW` = number of opponents who defected in the last `W` rounds (counting each player-round)
- Let `rateD` = `Dcount_lastW / ((n-1)*W)` = observed defection rate among opponents in a sliding window

Choose window length:
- `W = min(5, t-1)` (use up to 5 rounds of memory; early game uses whatever exists)

### Stock zones (based on sustainability)
We use two thresholds derived from the stock/capacity ratio:

- **Healthy zone:** `S_t ≥ 0.75 * capacity`  
  The resource can absorb some punishment/experimentation.
- **Caution zone:** `0.40 * capacity ≤ S_t < 0.75 * capacity`
- **Critical zone:** `S_t < 0.40 * capacity`  
  Collapse risk dominates; stop “hard punishment” that would further drain stock.

(These are intentionally simple and robust across capacities.)

---

## Core policy
### A. First, check “Critical stock rescue”
If `S_t < 0.40*capacity`:  
**Play C**, unless the round is the last round and you’re certain punishment cannot help (see endgame rules).  
Rationale: Defecting when stock is low accelerates collapse; collective priority is regeneration.

### B. Otherwise (stock not critical), use **reciprocal cooperation with proportional punishment**
Compute `rateD` over last `W` rounds.

- If `rateD ≤ 0.20`: **Play C**  
  (Most opponents are cooperating most of the time; stay cooperative.)

- If `0.20 < rateD ≤ 0.50`: **Mixed deterrence:**  
  Play **D with probability p = (rateD - 0.20) / 0.30**, otherwise C.  
  (So p ramps linearly from 0 to 1 across that interval.)
  - Additionally, **never defect two rounds in a row** in this band (cap escalation): if you defected last round, play C this round.
  Rationale: Apply measured pressure without triggering mutual collapse.

- If `rateD > 0.50`: **Play D** (strong punishment mode), *but only if stock is not in caution-low*:
  - If `S_t ≥ 0.55*capacity`: play **D**
  - Else (i.e., `0.40*cap ≤ S_t < 0.55*cap`): play **C**
  Rationale: When many opponents defect, you must avoid being the sole cooperator—unless stock is too low to sustain punishment.

### C. Forgiveness / return-to-cooperation rule
After any round you play D, you immediately become willing to return to C when either condition holds:
- `rateD ≤ 0.35` (opponents calm down), **or**
- `S_t` enters **caution** or **critical** zone (`S_t < 0.75*capacity`) and you are not facing extreme defection (`rateD ≤ 0.70`)

This makes the strategy forgiving and prevents endless retaliation spirals.

---

# 2) Edge cases

### Round 1 (no history)
- **Play C**.
Rationale: Sets cooperative baseline; also keeps stock high which benefits everyone. If others defect immediately, the strategy shifts in round 2 based on observed actions.

### Last round (t = r)
Endgame tempts defection, but the “collective” goal is still to avoid mutual destruction and to avoid being exploited when others are clearly defecting.

Rule for last round:
- If `rateD_lastW ≤ 0.35` and `S_t ≥ 0.40*capacity`: **Play C**  
  (Reward cooperative groups; avoid triggering last-round collapse.)
- Else: **Play D** **unless** `S_t < 0.40*capacity`, in which case **Play C** (rescue still dominates).  
Interpretation: cooperate in the last round only if the group earned it; otherwise protect yourself.

### Very small r (e.g., r=2)
- Still works: Round 1 defaults to C; Round 2 uses “last round” rule based on what happened in round 1.

### Persistent single defector among cooperators
- Their defections raise `rateD` gradually; SSR responds with occasional D (in the mid band), creating a cost to defect without collapsing the pool. If the defector persists and pushes `rateD` above 0.5, SSR escalates to D when stock can handle it.

### Everyone defects early and stock crashes
- SSR switches to **C** in critical zone, attempting recovery. If others keep defecting, recovery may fail, but SSR avoids making collapse strictly worse.

---

# 3) Collective alignment (why this is “collective” but tournament-robust)

- **Protect the regenerative engine:** The stock dynamics strongly reward keeping `S_remaining` away from zero; SSR cooperates aggressively when stock is threatened.
- **Reciprocity, not naive altruism:** Cooperation is conditional on observed opponent behavior; exploitation triggers proportional deterrence.
- **Forgiveness:** Prevents lock-in to mutual defection after temporary shocks or mistakes.
- **State-aware punishment:** SSR avoids “punishing into collapse” by conditioning escalation on stock health.

---

## Pseudocode (implementation-ready)

```python
def SSR_action(t, r, n, capacity, S, history_actions):
    # history_actions[round][player] in {C, D}, includes all players; our id known to caller
    if t == 1:
        return "C"

    W = min(5, t-1)
    # compute opponents' defection rate in last W rounds
    Dcount = 0
    total = (n-1) * W
    for tau in range(t-W, t):  # last W rounds
        for j in opponents:
            if history_actions[tau][j] == "D":
                Dcount += 1
    rateD = Dcount / total if total > 0 else 0.0

    # stock zones
    critical = (S < 0.40 * capacity)
    caution_low = (S < 0.55 * capacity)
    not_healthy = (S < 0.75 * capacity)

    # last round override
    if t == r:
        if (rateD <= 0.35) and (S >= 0.40 * capacity):
            return "C"
        return "C" if critical else "D"

    # critical rescue
    if critical:
        return "C"

    # main reciprocal logic
    if rateD <= 0.20:
        return "C"

    if 0.20 < rateD <= 0.50:
        p = (rateD - 0.20) / 0.30
        # cap escalation: don't defect twice in a row in this band
        if my_last_action == "D":
            return "C"
        return "D" if random() < p else "C"

    # rateD > 0.50: strong punishment if stock can take it
    if not caution_low:  # S >= 0.55*capacity
        return "D"
    else:
        return "C"
```

---

If you share typical tournament meta assumptions (e.g., whether opponents include “always defect”, “grim trigger”, “random”, “learning agents”), I can tune the thresholds (0.75/0.55/0.40 and 0.20/0.50) for that ecology without changing the overall structure.
'''

description_COLLECTIVE_74 = '''
## Strategy: **Stock-Guard Reciprocal (SGR)**  
Collective objective: keep the common pool near a “safe” level that allows regeneration, while punishing exploitation enough that defecting becomes unattractive over time. The strategy is *state-based* (protect the stock) and *history-based* (reciprocity against over-consumers), with forgiveness to recover cooperation.

### Key ideas (collective mindset)
1. **Preserve the resource**: if stock is low, everyone must reduce extraction; if stock is high, cooperation keeps it high.
2. **Reciprocate**: cooperate by default, but respond quickly when others defect.
3. **Forgive**: return to cooperation after evidence of restraint, so the group can recover.
4. **Avoid endgame collapse when possible**: even if last-round incentives favor defection, preserving stock earlier typically yields more total payoff across the horizon. Still, the strategy includes a controlled endgame rule.

---

## Notation
- \(S_t\): stock at start of round \(t\)
- \(n\): number of players
- \(r\): number of rounds
- \(D_{t-1}\): number of opponents (out of \(n-1\)) who defected last round
- \(k\): number of *total* defectors last round (including you), observable from history
- “Safe stock band”: a range where the logistic growth is strong and collapse risk is low.

---

## Parameters (computed from game parameters)
We define two stock thresholds as fractions of `capacity`:

- **Low-stock threshold**:  
  \[
  S_{\text{low}} = 0.35 \cdot \text{capacity}
  \]
- **Target threshold** (comfortable safety):  
  \[
  S_{\text{target}} = 0.60 \cdot \text{capacity}
  \]

Rationale: below ~0.35 capacity, the pool is vulnerable; above ~0.60, it’s comfortably renewable and cooperation sustains high long-run payoffs.

We also track a short “punishment window” length:
- **Punishment length**: \(L = 2\) rounds (escalates if abuse continues).

---

## 1) Decision rules (when to C vs D)

### Rule A — **First-round stance (pro-social baseline)**
- **Round 1: play C** always.

This seeds a cooperative trajectory and keeps stock high; defecting round 1 often starts a collapse spiral.

---

### Rule B — **Stock emergency protection**
If the resource is in danger, prioritize recovery over reciprocity:

- If \(S_t \le S_{\text{low}}\): **play C**, regardless of opponents.
  - Intuition: when stock is low, defection accelerates collapse; cooperating is the best collective move and also often best-response if everyone is near-zero next round.

---

### Rule C — **Reciprocity when stock is healthy**
When \(S_t > S_{\text{low}}\), respond to exploitation:

Let \(D_{t-1}\) be the number of opponents who defected in round \(t-1\).

- If \(D_{t-1} = 0\): **play C** (full cooperation).
- If \(D_{t-1} \ge 1\): enter **punishment mode** with intensity based on how many defected:

  **Punishment trigger:**
  - If *any* opponent defected last round **and** \(S_t \ge S_{\text{target}}\): **play D** for the next \(L\) rounds *unless* cooperation is re-established early (see forgiveness).

  **Escalation:**
  - If in punishment mode and in the most recent round still \(D_{t-1} \ge \lceil (n-1)/2 \rceil\) (a majority of opponents defected), extend punishment by +1 round (capped at 4).

This makes unilateral defection less profitable by quickly matching it, while not permanently destroying cooperation.

---

### Rule D — **Forgiveness / returning to cooperation**
Even in punishment mode, switch back to C early if opponents show restraint:

- If in punishment mode and in the last round **no opponents defected** (\(D_{t-1}=0\)) **and** \(S_t \ge S_{\text{low}}\): immediately **return to C** (exit punishment).

This is important because the best collective outcome is sustained cooperation; punishment is only a tool to re-align incentives.

---

### Rule E — **Stock-sensitive “do not over-punish” brake**
Punishing by defecting can itself drain stock. So add a brake:

- If in punishment mode but \(S_t < S_{\text{target}}\): **play C** (even if punishment timer remains).

So: punish only when the stock can afford it; otherwise prioritize rebuilding.

---

## 2) Edge cases (first round, last round, weird histories)

### First round
- Always **C**.

### Last round (round r)
There is a classic endgame incentive to defect. However, unconditional endgame defection destroys cooperation incentives in the second-to-last round once others anticipate it.

SGR uses a **conditional last-round rule**:

- In round \(r\):
  - If **no opponents defected in round \(r-1\)** *and* \(S_r \ge S_{\text{target}}\): **play C** (reward sustained cooperation).
  - Otherwise: **play D** (don’t be the sucker at the end if cooperation already broke down).

This preserves “cooperate through the end” when the group actually maintained it, but doesn’t get exploited in a degraded environment.

### Second-to-last round (round r-1)
- Use normal rules, but with slightly stronger reciprocity:
  - If \(D_{r-2} \ge 1\) and \(S_{r-1} \ge S_{\text{target}}\), ensure you are in punishment mode (i.e., don’t “forgive” unless you observe a clean cooperative round).

This reduces the chance you get farmed right before the end.

### If stock hits ~0
- If \(S_t\) is extremely small (e.g., \(S_t < 10^{-6}\)), action barely matters for immediate payoff. Still:
  - Play **C** to maximize regrowth chance if others also restrain (since total extraction is proportional to \(S_t\), it’s mostly symbolic but aligns with recovery).

---

## 3) Collective alignment (explicit)
SGR behaves like a “resource steward with teeth”:
- It **starts cooperative** and is **easy to coordinate with** (simple “be good, get good” logic).
- It **punishes quickly** when the stock is high enough that punishment won’t cause collapse, making exploitation unattractive.
- It **forgives quickly** to restore the collective optimum.
- It **prioritizes sustainability** whenever stock falls into a danger zone, even if that means temporarily tolerating unfairness—because survival of the stock dominates.

---

## Pseudocode (implementable)

```python
# Precompute thresholds
S_low = 0.35 * capacity
S_target = 0.60 * capacity
L_base = 2
L_max = 4

punish_timer = 0

for t in 1..r:
    observe S_t
    if t == 1:
        action = "C"
    else:
        D_prev = number_of_opponents_who_played_D(t-1)

        # Last round special
        if t == r:
            if D_prev == 0 and S_t >= S_target:
                action = "C"
            else:
                action = "D"

        else:
            # Stock emergency rule
            if S_t <= S_low:
                punish_timer = 0
                action = "C"
            else:
                # If currently punishing, consider forgiveness/brake
                if punish_timer > 0:
                    if D_prev == 0 and S_t >= S_low:
                        punish_timer = 0
                        action = "C"
                    elif S_t < S_target:
                        # brake to avoid collapsing the resource
                        action = "C"
                    else:
                        action = "D"
                        punish_timer -= 1
                else:
                    # Not currently punishing
                    if D_prev == 0:
                        action = "C"
                    else:
                        # Start punishment only if stock can afford it
                        if S_t >= S_target:
                            punish_timer = L_base - 1
                            action = "D"
                        else:
                            action = "C"

        # Escalation (after choosing action, based on observed behavior)
        # Apply next round: if many opponents defected while we were punishing
        if punish_timer > 0 and D_prev >= ceil((n-1)/2):
            punish_timer = min(punish_timer + 1, L_max)

    play(action)
```

---

### What this is robust against
- **Always-defectors**: you quickly mirror them when stock is high, preventing persistent sucker payoffs; when stock is low you rebuild rather than futilely “punish into extinction.”
- **Occasional defectors / testers**: short punishment makes testing costly; fast forgiveness restores cooperation.
- **Grim-trigger / harsh reciprocators**: you don’t defect unless provoked (and only when stock is safe), so you’re less likely to accidentally trigger permanent wars.
- **Noisy dynamics (stock fluctuations)**: the stock thresholds prevent overreaction when the resource cannot handle retaliation.

If you share the tournament’s scoring emphasis (e.g., average per-round payoff vs. total) or typical opponent classes, the thresholds (0.35/0.60 and punishment length) can be tuned further.
'''

description_COLLECTIVE_75 = '''
## Strategy: **Stock-Guard Trigger (SGT)**  
A collective-minded strategy that (i) tries to keep the resource near the regenerative sweet spot, (ii) tolerates some noise/experimentation by others, and (iii) uses simple, state-based punishment when others over-extract.

### Intuition (collective objective)
- The stock growth function is logistic; growth is strong when the post-consumption stock is not too high or too low, and collapses at 0.  
- With **all C**, the group consumes **S/2** each round, leaving **S/2**, which (given the provided growth rule) tends to regenerate back toward capacity (as in your example).
- With **all D**, the group consumes **S**, leaving **0** ⇒ permanent collapse.
- So the collective goal is: **keep stock high and stable** by defaulting to cooperation, but **deter defection** quickly enough that exploitation doesn’t become profitable.

---

# 1) Decision rules: when cooperate vs defect

### Key quantities observed each round
Let:
- `S_t` = stock at start of round `t`
- `k_{t-1}` = number of defectors observed in the previous round (`t-1`)  
- `p_{t-1} = k_{t-1}/n` = defection rate last round
- Define **stock safety threshold**:  
  `S_safe = capacity/2`  (below this, the system is at meaningful risk; above it, regeneration is strong)

### Core rule set
**Rule A — Default collective mode (Cooperate):**  
If stock is healthy and opponents were mostly cooperative, play **C**.
- Play **C** when:
  - `S_t >= S_safe` **and**
  - `p_{t-1} <= 1/n` (at most one defector last round)

This expresses a “forgive isolated deviation” stance that helps robustness against occasional exploratory defection while staying cooperative.

---

**Rule B — Proportional deterrence (Punish with D):**  
If defection becomes nontrivial, respond with **D** to remove the incentive to exploit.
- Play **D** when:
  - `p_{t-1} >= 2/n` (two or more defectors last round), **or**
  - `S_t < S_safe` (stock is getting risky)

This is a collective “protect the commons” trigger: once the group shows meaningful over-extraction or the stock is falling, you stop being the sucker.

---

**Rule C — Recovery mode (return to C once safe):**  
After punishing, return to cooperation **as soon as**:
- `S_t >= S_safe` **and**
- `p_{t-1} == 0` (no one defected last round)

This creates a clear path back to collective cooperation and avoids endless retaliation spirals.

---

### Why this is robust
- Against always-cooperators: you cooperate almost always → high collective payoff.
- Against occasional defectors: you forgive single defects while stock is safe, but punish coordinated or repeated defection.
- Against persistent defectors: you defect after you detect the pattern; you won’t be exploited.
- Against chaotic strategies: the state trigger (`S_t < capacity/2`) prevents stock collapse by switching to defensive behavior early.

---

# 2) Edge cases

### First round
There is no history. Start in collective mode:
- **Round 1: play C.**  
Rationale: capacity starts at max; cooperation is the only way to test whether mutual sustainability is possible. Starting with D immediately destroys the collective outcome and can collapse the resource fast.

### Last round (endgame)
This game has a standard endgame temptation to defect. However, **mass endgame defection can still reduce your own last-round payoff if others also defect** (since payoffs scale with current stock `S_t`). Also, you can’t coordinate.

So use a “soft last-round” modification:
- **If `t == r` (last round):**
  - Play **D** only if either:
    - `p_{t-1} >= 2/n` (defection is already happening), or
    - `S_t < S_safe` (stock already in danger)
  - Otherwise play **C**.

This keeps you collective when cooperation is stable, but avoids being the lone cooperator in a late defection wave.

### Very low stock emergency
If `S_t` is extremely low, the game is close to an absorbing collapse. You need to avoid being the only cooperator while others take double.
- If `S_t <= capacity/(4)` (hard emergency), play **D** regardless of history.  
Reason: at very low stock, any asymmetry is catastrophic; you must not subsidize defectors.

*(Note: in a binary action game, you can’t “consume less than C”. This emergency rule is purely about not being exploited when the commons is near failure.)*

---

# 3) “Collective” alignment (explicit)
This strategy is collective in three ways:
1. **Cooperation is the default** when the resource and group behavior indicate sustainability.
2. **Punishment is conditional and state-based**—it exists to protect the stock and deter exploitation, not to maximize short-term gain.
3. **It includes a clear recovery path** to re-enter cooperation as soon as the group demonstrates restraint, preventing permanent conflict.

---

## Pseudocode (implementation-ready)

```python
def choose_action(t, r, n, capacity, S_t, history):
    # history contains actions from previous rounds for all players

    S_safe = capacity / 2
    S_emergency = capacity / 4

    if t == 1:
        return "C"

    # compute defection rate in previous round
    prev_actions = history[t-1]              # list length n of "C"/"D"
    k_prev = sum(1 for a in prev_actions if a == "D")
    p_prev = k_prev / n

    # emergency stock protection
    if S_t <= S_emergency:
        return "D"

    # last round adjustment
    if t == r:
        if (p_prev >= 2/n) or (S_t < S_safe):
            return "D"
        else:
            return "C"

    # main rules
    if (S_t >= S_safe) and (p_prev <= 1/n):
        return "C"   # collective mode, forgive isolated defection
    else:
        return "D"   # deterrence / stock protection mode
```

---

### Optional refinement (if you want slightly more “adaptive”)
If you can track *consecutive* rounds of low defection, you can require `p_prev == 0` for 1 round (as above) or 2 rounds before returning to C after punishment. This reduces cycling against alternating strategies, at the cost of slower recovery.

---

If you share typical tournament opponents (e.g., always-D, grim trigger variants, stochastic defectors), I can tune the thresholds (`capacity/2`, `capacity/4`, `2/n`) for better performance across that mix.
'''

description_COLLECTIVE_76 = '''
## Strategy: **Stock‑Sustaining Grim‑Trigger with Forgiveness (SSGTF)**  
Goal: keep the resource near a self-renewing level (so everyone can keep earning), but protect against exploitation by switching to defection when others demonstrably overharvest, with a clear path back to cooperation if they stop.

Key idea: In this game, the *socially sustainable* profile is typically “all C”: it keeps stock high (often at capacity) and yields long-run high total payoffs. But unilateral D is immediately tempting. So we:  
1) default to C while the group is behaving sustainably,  
2) punish quickly when the group overconsumes, and  
3) forgive when the group returns to sustainable behavior.

---

# 1) Decision rules (C vs D)

### Definitions from history (round \(t-1\) observed)
Let:
- \(S_{t-1}\) = stock at start of previous round  
- \(k_{t-1}\) = number of players who defected in previous round (observed)
- “Overharvest severity” is captured by \(k_{t-1}\) and the resulting stock drop.

We also maintain an internal state variable:
- `mode ∈ {COOP, PUNISH}`
- `punish_left` = remaining punishment rounds (integer)

### Sustainable trigger thresholds
We use a *stock safety threshold* and a *defection tolerance*:

- **Safety stock**:  
  \[
  S_{\text{safe}} = 0.8 \times \text{capacity}
  \]
  Intuition: if stock remains high, cooperation is working; if it falls far below capacity, recovery becomes fragile and exploitation is likely.

- **Defection tolerance**:  
  Allow *at most* a small amount of defection without immediate collapse into punishment:
  - Tolerate \(k_{t-1} \le 1\) **only if** stock stayed healthy (≥ \(S_{\text{safe}}\)).
  - Otherwise treat as a breakdown and punish.

This is intentionally strict when the stock is deteriorating and lenient only when the stock is robust.

---

## Core rule set

### A. Default cooperative rule
Play **C** if all are true:
1. `mode == COOP`, and
2. either:
   - previous round had **no defectors** (\(k_{t-1}=0\)), or
   - previous round had **one defector** (\(k_{t-1}=1\)) *and* \(S_{t-1} \ge S_{\text{safe}}\)
3. current stock \(S_t\) is not critically low (see “critical stock” below)

### B. Enter punishment
Switch to **PUNISH** (play D for some rounds) if any of these occur:
- **Multiple defectors** last round: \(k_{t-1} \ge 2\)  
- **Stock is no longer safe** and anyone defected: \(k_{t-1}\ge 1\) and \(S_{t-1} < S_{\text{safe}}\)
- **Critical stock event**: stock fell very low (defined below), regardless of who defected (this covers strategies that cause collapse via mixed behavior over time)

When entering punishment, set punishment length proportional to how bad it was:
\[
\text{punish\_left} = \min\Big(5,\ 1 + 2\cdot \mathbf{1}[k_{t-1}\ge2] + \mathbf{1}[S_{t-1} < 0.5\cdot \text{capacity}]\Big)
\]
So typical punishments last 2–5 rounds: long enough to deter, not so long that we lock into mutual destruction.

### C. Punishment behavior
If `mode == PUNISH`:
- Play **D** while `punish_left > 0`, decrement each round.
- After punishment expires, attempt a **test return** to cooperation:
  - play **C** for 1 round (“probe”)
  - if \(k=0\) in that probe round, go back to `COOP`
  - otherwise re-enter `PUNISH` with length 3 (baseline)

### D. Critical stock override (resource triage)
If current stock is extremely low, cooperation is no longer “collective”—it’s usually just letting others take what’s left. So we use:

- **Critical stock**:  
  \[
  S_t \le S_{\text{crit}} = \max(2n,\ 0.25\cdot \text{capacity})
  \]
If \(S_t \le S_{\text{crit}}\), play **D** (regardless of mode), because:
- any single round can be the last meaningful extraction opportunity,
- and recovery requires others to restrain *simultaneously*, which we cannot coordinate without evidence.

Once stock rises above \(0.5\cdot \text{capacity}\) *and* we observe a full-cooperation round, we allow returning to `COOP`.

---

# 2) Edge cases

### First round
- **Play C.**  
Rationale: starting cooperative maximizes chances of locking into the high-stock attractor (often capacity). Also reveals who defects.

Initialize:
- `mode = COOP`, `punish_left = 0`.

### Last round
- **Play D** in the final round \(t=r\).  
Rationale: there is no future to discipline behavior; cooperation has no strategic leverage. This is standard in finitely repeated settings.  
(Everything else equal, D strictly dominates C in the last round given the per-round payoff definition.)

### Near-last rounds (optional mild endgame)
To avoid triggering a late collapse too early, use:
- if \(t = r-1\) and stock is high (\(S_t \ge S_{\text{safe}}\)) and last round had \(k=0\), you may still play **C**; otherwise play **D**.  
This preserves value if the group has been cooperative, while guarding against being the sucker.

---

# 3) Why this is “collective” and robust

### Collective alignment
- The strategy’s default is to keep stock high and renewable, which maximizes total group payoff across rounds.
- It does not demand pre-coordination: it simply rewards observed restraint and punishes observed overuse.
- Forgiveness allows recovery from noise, occasional experimentation, or one-off defections without permanently collapsing cooperation.

### Robustness to opponent types
- **Always-Cooperate opponents**: we play C almost always (until last round), sustaining capacity and high payoffs.
- **Always-Defect opponents**: we quickly switch to punishment (D), preventing being consistently exploited.
- **Tit-for-tat / conditional cooperators**: we coordinate on C as long as the group stays near safe stock; punishments are finite and followed by probes, enabling re-coordination.
- **Mixed / opportunistic defectors**: the “one defector tolerated only when stock is safe” rule prevents slow erosion: once defection starts hurting the stock, punishment triggers.

---

# Pseudocode (implementation-ready outline)

```pseudo
init:
  mode = COOP
  punish_left = 0

constants:
  S_safe = 0.8 * capacity
  S_crit = max(2*n, 0.25*capacity)

for t in 1..r:
  if t == r:
    action = D
    continue

  observe S_t (current stock at start of round t)

  if S_t <= S_crit:
    action = D
    continue

  if t == 1:
    action = C
    continue

  observe k_prev = #defectors in round t-1
  observe S_prev = stock at start of round t-1

  if mode == PUNISH:
    if punish_left > 0:
      action = D
      punish_left -= 1
    else:
      # probe
      action = C
      # after round resolves, update:
      # if k_this == 0 -> mode=COOP else mode=PUNISH; punish_left=3
    continue

  # mode == COOP
  if (k_prev == 0):
    action = C
  else if (k_prev == 1 and S_prev >= S_safe and S_t >= S_safe):
    action = C
  else:
    mode = PUNISH
    punish_left = min(5, 1 + 2*(k_prev>=2) + (S_prev < 0.5*capacity))
    action = D
```

(Probe-resolution update is done after seeing current round outcomes.)

---

If you want, I can also provide a “softer” variant (more tolerant, higher cooperation in noisy populations) or a “harder” variant (more exploit-resistant) depending on what kinds of strategies you expect in the tournament.
'''

description_COLLECTIVE_77 = '''
## Strategy: **Sustain–Reciprocate with Stock Safeguard (SRSS)**  
Collective goal: keep the stock near the regenerative sweet spot (high long-run payoffs), cooperate by default, but punish over-consumption fast enough that unilateral defecting is unattractive, and automatically shift to “salvage mode” when stock is endangered.

### Key idea (why this works)
- If everyone cooperates, stock can stay high (often at/near capacity), maximizing repeated payoffs.
- Defection gives a one-round advantage but risks collapsing future stock; so we (i) reward cooperative groups, (ii) retaliate when others defect, and (iii) stop retaliating once cooperation resumes.
- Because the game is finite, we also need an endgame rule: avoid being exploited late, but don’t trigger premature collapse if the stock is still valuable.

---

## Observables and derived quantities each round
At round \(t\) with current stock \(S_t\):
- Let \(d_{t-1}\) = number of opponents who defected in the previous round (from history). For \(t=1\), set \(d_0 = 0\).
- Let \(p_{t-1} = d_{t-1}/(n-1)\) = observed opponent defection rate last round.
- Let \(T = r - t + 1\) = rounds remaining.

We also define two stock thresholds (depend only on parameters):
- **Danger threshold:** \(S_{\text{low}} = 2n\). (Near the lower bound of the state space; collapse risk is high.)
- **Comfort threshold:** \(S_{\text{high}} = 0.6 \cdot \text{capacity}\). (Above this, the system can absorb occasional punishment without immediate ruin; below it, be more conservative.)

(If capacity is small relative to \(n\), the thresholds still behave sensibly because \(S_{\text{low}}\) is tied to \(n\).)

---

## 1) Decision rules (C vs D)

### Rule A — **Stock safeguard (salvage mode)**
If stock is endangered, prioritize recovery and long-run feasibility over punishment.

**If \(S_t \le S_{\text{low}}\): play C.**  
Rationale: With low stock, defecting accelerates collapse; cooperating preserves what remains and allows regrowth.

---

### Rule B — **Start cooperative**
**If \(t = 1\): play C.**  
Rationale: establish the cooperative path; it’s also the best way to keep the state high when others might also be “nice by default.”

---

### Rule C — **Reciprocal punishment proportional to recent defection**
When stock is not endangered (\(S_t > S_{\text{low}}\)), respond to what opponents did most recently.

Compute a **punishment probability** \(q_t\) (chance we defect this round):

- Base reciprocity: defect in proportion to last-round defection rate:
\[
q^{\text{base}}_t = p_{t-1}.
\]

- Make punishment **stronger when stock is high** (safe to punish) and **weaker when stock is middling** (avoid collapse):
\[
m(S_t) =
\begin{cases}
1.2 & \text{if } S_t \ge S_{\text{high}} \\
0.8 & \text{if } S_{\text{low}} < S_t < S_{\text{high}}
\end{cases}
\]
\[
q_t = \min(1,\; m(S_t)\cdot q^{\text{base}}_t).
\]

- Add a small “forgiveness floor” so we don’t spiral into permanent mutual defection due to noise-like behaviour:
  - If \(d_{t-1} = 0\), set \(q_t = 0\) (pure C).
  - If \(d_{t-1} > 0\), cap punishment below total war unless everyone defected:
    - If \(d_{t-1} < n-1\), cap \(q_t \le 0.9\).

**Action:** play D with probability \(q_t\), else play C.

This makes the strategy:
- **Nice:** immediate cooperation when others do.
- **Provokable:** reacts quickly to defection.
- **Forgiving:** returns to cooperation as soon as others do.
- **State-aware:** avoids “punishing into collapse.”

---

### Rule D — **Endgame protection (finite-horizon robustness)**
In late rounds, some strategies will defect because the future is short. We don’t want to be a “sucker” in the final stretch, but also don’t want to destroy remaining value unnecessarily.

Let **endgame window** \(W = \max(2,\lceil 0.1r \rceil)\) (last 10% of rounds, at least 2 rounds).

If \(T \le W\) (we are in the last \(W\) rounds) and \(S_t > S_{\text{low}}\):
- Use a **harsher reciprocity**:  
  \[
  q_t \leftarrow \min(1,\; q_t + 0.25\cdot p_{t-1})
  \]
- Additionally, in the **final round** \(t=r\):
  - If \(p_{r-1} > 0\), play D.
  - Else play C.  
This keeps cooperation if the group stayed cooperative, but avoids being exploited at the very end if defection has appeared.

---

## 2) Edge cases

### First round
- Always **C**.

### After a full-collapse trajectory
If \(S_t = 0\):
- Both C and D yield 0 that round, but **C** is chosen (consistent with recovery attempt and with Rule A).

### Everyone defected last round
If \(d_{t-1} = n-1\) and \(S_t > S_{\text{low}}\):
- \(q_t\) becomes 1 (defect for sure) **unless** we are in salvage mode \(S_t \le S_{\text{low}}\), in which case play C.

### Very small number of rounds (e.g., r=2 or 3)
- Still: Round 1 C.
- Endgame window triggers quickly, so retaliation is stronger in round 2/3 if any defection is observed.

### Unclear/noisy opponents (frequent switching)
- The probabilistic proportional response avoids overreacting to a single defection (not always all-out D), but still increases pressure as defection frequency rises.

---

## 3) “Collective mindset” commitments (what the strategy is trying to do)
1. **Preserve the commons first when it’s fragile:** below \(2n\), always cooperate to avoid irreversible collapse dynamics.
2. **Reward cooperation immediately:** if opponents were fully cooperative last round, we are fully cooperative now.
3. **Make exploitation unprofitable:** proportional retaliation ensures defect-heavy populations face reduced future stock and lower payoffs, while keeping a path back to cooperation.
4. **Avoid pointless endgame altruism:** in the final window, we become harder to exploit, but still maintain cooperation if the group remained cooperative.

---

## Pseudocode (implementation-ready)
```python
def SRSS_action(t, r, n, capacity, S_t, opponent_actions_prev):
    # opponent_actions_prev: list of length n-1 with 'C'/'D' from t-1; empty if t==1

    S_low  = 2*n
    S_high = 0.6*capacity
    W = max(2, math.ceil(0.1*r))
    T = r - t + 1

    if t == 1:
        return 'C'

    d_prev = sum(1 for a in opponent_actions_prev if a == 'D')
    p_prev = d_prev / (n-1)

    # Salvage mode
    if S_t <= S_low:
        return 'C'

    # Base proportional reciprocity
    q = p_prev

    # Stock-aware multiplier
    if S_t >= S_high:
        q *= 1.2
    else:
        q *= 0.8

    # Forgiveness / anti-spiral cap (unless unanimous defection)
    if d_prev == 0:
        q = 0.0
    elif d_prev < (n-1):
        q = min(q, 0.9)
    else:
        q = 1.0

    # Endgame protection
    if T <= W:
        q = min(1.0, q + 0.25*p_prev)

    # Final round special-case
    if t == r:
        if p_prev > 0:
            return 'D'
        else:
            return 'C'

    return 'D' if random.random() < q else 'C'
```

This strategy is cooperative by default, state-aware to prevent collapse, retaliatory enough to deter persistent defectors, forgiving enough to re-stabilize cooperation, and guarded against late-stage exploitation.
'''

description_COLLECTIVE_78 = '''
## Strategy: **Stock-Guardian with Forgiveness (SGF)**  
Goal: keep the resource near a high-yield region (close to capacity) while deterring over-consumption. The strategy cooperates by default when the stock is healthy, escalates quickly when others deplete the pool, and returns to cooperation after evidence of restraint. It uses only parameters, current stock, and public history.

### Intuition (collective mindset)
- **Collective optimum**: if everyone plays **C**, stock cycles back to capacity (as in your example), sustaining high long-run payoffs.
- **Primary risk**: even a few **D** actions can push stock down; if stock hits 0, growth stops and the game collapses.
- **Deterrence**: we punish defection by switching to **D** when others over-consume, making defection less attractive and signaling “you can’t free-ride.”
- **Forgiveness**: we don’t lock into permanent retaliation; we allow return to cooperation if the group demonstrates restraint and stock recovers.

---

## 1) Decision rules: when to Cooperate vs Defect

### Key computed signals each round \(t\)
Let:
- \(S_t\) = current stock at start of round \(t\).
- \(k_{t-1}\) = number of players who played **D** in round \(t-1\) (observable from history).
- **Defection rate** last round: \(d_{t-1} = k_{t-1}/n\).

Define stock zones (fractions of capacity):
- **Green**: \(S_t \ge 0.80 \cdot capacity\) (healthy)
- **Yellow**: \(0.50 \cdot capacity \le S_t < 0.80 \cdot capacity\) (watchful)
- **Red**: \(S_t < 0.50 \cdot capacity\) (danger of collapse)

### Core policy
**A. Protect the stock (state-based):**
- If **Red**: play **C** (conserve; “stop the bleeding”).
- If **Yellow**: play **C** unless there was substantial defection last round.
- If **Green**: play **C** unless defection is persistent/high.

**B. Deter exploitation (history-based):**
Use a “trigger with forgiveness”:
- If last round had **high defection** \(d_{t-1} \ge 0.50\): play **D** *unless stock is Red*.
- If last round had **moderate defection** \(0 < d_{t-1} < 0.50\): play **D** only in Green; otherwise play C.

**C. Forgiveness rule (return to C):**
- After we play **D** as punishment, we return to **C** once we observe **two consecutive rounds** with **low defection** (\(d \le 1/n\), i.e., at most one defector) **or** once stock enters **Red** (emergency conservation).

This makes retaliation credible but not permanent, and it prevents spirals when the stock is already low.

---

## 2) Edge cases (first round, last round, unusual stock levels)

### First round (no history)
- **Round 1: play C.**  
Rationale: establishes a cooperative baseline and keeps stock high; also avoids needless early collapse.

### Last round (end-game temptation)
In a finite repeated game, there’s a classic temptation to defect at the end. But in a tournament, being predictably “always defect last” is exploitable (others will anticipate it). SGF uses a **conditional last-round rule**:

- **If round \(t=r\)**:
  - Play **C** if \(S_r < 0.80 \cdot capacity\) (protect collective outcome and avoid rewarding earlier defectors with a final grab after depletion).
  - Play **D** only if:
    - \(S_r \ge 0.80 \cdot capacity\) **and**
    - the previous round had at least one defector (\(k_{r-1} \ge 1\)).  
  This is “no free last-round gift”: if someone defected recently while stock is high, don’t end by being the only cooperator.

### Extremely low stock (near 0)
- If \(S_t \le \epsilon\) (e.g., \(\epsilon = 10^{-9}\)): play **C**.
Defecting yields almost nothing and can prevent any recovery.

### Capacity condition / parameter extremes
- Works for any \(n \ge 2\), any \(r>1\), any capacity ≥ 2n.
- Uses stock as a fraction of capacity, so it scales.

---

## 3) Collective alignment (how it stays “collective”)
SGF is explicitly designed to:
- **Keep the pool regenerative**: default is C, and C is enforced when stock is threatened (Red).
- **Punish behaviors that endanger the group**: defection triggers retaliation primarily when stock is healthy enough that punishment is meaningful and visible (Green/Yellow), discouraging exploitation.
- **Avoid collapse spirals**: in Red, we *always* conserve regardless of past, prioritizing collective recovery over “revenge.”
- **Allow re-coordination**: forgiveness after evidence of restraint lets heterogeneous opponents re-converge to cooperation.

---

## Pseudocode (implementable)

```python
def SGF_action(t, r, n, capacity, S_t, history):
    # history provides actions last rounds for all players
    GREEN = 0.80 * capacity
    YELLOW = 0.50 * capacity

    # First round
    if t == 1:
        return "C"

    # Compute last round defection stats
    last_actions = history[t-1]           # list length n of "C"/"D"
    k_last = sum(1 for a in last_actions if a == "D")
    d_last = k_last / n

    # Emergency conservation
    if S_t < YELLOW:
        # Red zone: always conserve
        return "C"

    # Last round rule
    if t == r:
        if S_t >= GREEN and k_last >= 1:
            return "D"
        else:
            return "C"

    # Forgiveness check: if we have been in punishment mode recently,
    # return to C after 2 consecutive low-defection rounds.
    def low_defection(round_idx):
        actions = history[round_idx]
        return sum(1 for a in actions if a == "D") <= 1  # <= 1 defector

    if t >= 3:
        if low_defection(t-1) and low_defection(t-2):
            return "C"

    # Retaliation rules by zone
    if S_t >= GREEN:
        # Green: punish any nontrivial defection
        if k_last >= 1:
            return "D"
        else:
            return "C"
    else:
        # Yellow: punish only substantial defection
        if d_last >= 0.50:
            return "D"
        else:
            return "C"
```

---

### Why this is robust in a tournament
- Against cooperative strategies: quickly settles into all-C with stable high stock and high long-run payoff.
- Against occasional/noisy defectors: retaliates enough to reduce profitability of sporadic exploitation, but forgives to restore cooperation.
- Against always-defect: shifts toward D when stock is high, but switches to C when stock becomes endangered (minimizes long-run collapse damage and can’t be baited into self-destructive overharvesting).
- Against sophisticated strategists: not trivially exploitable by “last-round sucker punch” or by inducing endless grudges; it uses both stock state and observed defection frequency.

If you want, I can also provide a more “mathematical” variant that explicitly estimates the implied number of defectors from observed stock transitions (useful if action observability were reduced), but under your assumptions, the above is simpler and stronger.
'''

description_COLLECTIVE_79 = '''
## Strategy: **Stock-Guard with Forgiving Accountability (SGFA)**  
Collective goal: keep the stock near capacity (so everyone’s per-round payoffs stay high) while **deterring repeated over-consumption**. The strategy is intentionally simple: **cooperate by default**, but **punish defect-heavy behavior enough to make defection unattractive**, and **recover quickly** once others return to restraint.

Key idea: In this game, if everyone plays **C**, stock tends to return to capacity (given capacity ≥ 2n). If too many play **D**, stock can crash to 0 and never recover. So the collective-minded strategy must:
- Maintain a **safe stock buffer**.
- Use **credible, history-based punishment** when others take too much.
- Be **forgiving** to restore cooperation and avoid permanent collapse.

---

# 1) Decision rules: when to Cooperate vs Defect

### Observables each round \(t\)
- Current stock \(S_t\).
- Past actions of all players.
- Compute last round’s defect count:  
  \(d_{t-1} = \#\{j : a_{j,t-1} = D\}\) (for \(t>1\))

### Core thresholds (parameter-only; no tuning to opponents)
Let:
- **Safe stock**: \(S_{\text{high}} = 0.8 \cdot \text{capacity}\)
- **Danger stock**: \(S_{\text{low}} = 0.5 \cdot \text{capacity}\)

These are deliberately conservative: below ~0.5 capacity, a couple of D’s can push the system toward irreversible depletion.

### “Punishment pressure” score
Maintain a scalar internal state `P` (“punishment level”), updated from observed defection rates.

- Initialization: `P = 0`
- After each round \(t-1\), update:
  - Let \(q = d_{t-1}/n\) (fraction who defected)
  - Increase if defection is above a cooperative norm, decay otherwise:
    - `P = max(0, P * 0.5 + max(0, q - 0.25))`

Interpretation:
- If up to 25% defect (noise / experimentation), we don’t escalate much.
- Sustained defection accumulates pressure quickly.
- Pressure decays by half each round if behavior improves (forgiveness).

### Action rule each round \(t\)
We choose **C** unless we are in a situation where a punishment signal is needed to stop collapse.

**Play D if and only if** at least one of these holds:
1) **Crisis protection**: \(S_t < S_{\text{low}}\)  
   - Rationale: when stock is already low, one-sided cooperation just subsidizes defectors and encourages more D, often preventing recovery. A short, strong signal is needed.

2) **Punishment trigger**: \(S_t < S_{\text{high}}\) **and** `P ≥ 0.25`  
   - Meaning: stock is no longer “comfortably high” and we’ve observed meaningful defection recently. We punish to make continued defection unattractive.

Otherwise play **C**.

This creates three regimes:
- **High stock** (≥ 0.8 cap): cooperate almost always; don’t overreact to small defections.
- **Mid stock** (0.5–0.8 cap): cooperate if others are mostly cooperating; punish if defection persists.
- **Low stock** (< 0.5 cap): defect (temporary hard line) to stop being exploited and to force a strategic reset.

---

# 2) Edge cases (first round, last round, etc.)

### First round \(t=1\)
**Play C.**  
- With initial stock = capacity, C yields high payoffs and establishes the cooperative baseline. Defecting immediately risks inviting collapse dynamics.

### Last round \(t=r\)
Still follow the same rule (do **not** “endgame defect” automatically).  
Reason: You cannot coordinate on last-round defection, and if everyone does it, you can crash stock to 0 *before* payoffs are taken? (Payoffs are taken from current \(S\), so last-round defection raises your payoff, but it also signals nothing and just contributes to mutual harm if others also defect. In tournaments, unconditional last-round D often triggers earlier retaliation from sophisticated strategies anticipating it.)

That said, the strategy already defects when:
- stock is low (crisis), or
- defection has been persistent and stock has slipped.

So it’s robust without requiring a special “final round exception” that others might exploit.

### After a full-collapse round (stock hits 0)
If \(S_t = 0\), both C and D give 0 payoff and growth remains 0. The game is dead.  
Rule: **Play C** (doesn’t matter), but keep tracking history. (This is mostly for algorithmic completeness.)

### If the game stays at/near capacity for many rounds
Continue cooperating. We only punish when (a) stock drops from comfort and (b) defections persist.

---

# 3) Collective alignment (why this is a “collective” strategy)

This strategy is explicitly designed to:
- **Maximize long-run total extraction** by keeping the resource in a high-growth/high-stock region.
- **Avoid spirals**: over-punishment can itself crash the stock; therefore we punish only when stock is no longer very high *and* defection is meaningfully persistent.
- **Be forgiving**: pressure decays quickly, so a return to cooperation restores cooperation in 1–3 rounds.
- **Be robust to exploiters**: if others repeatedly defect, we switch to D in the mid/low stock region so we are not the lone cooperator funding their higher payoff.

---

## Pseudocode (implementable)

```python
# Parameters: n, r, capacity
S_high = 0.8 * capacity
S_low  = 0.5 * capacity

P = 0.0  # punishment pressure

for t in 1..r:
    observe current stock S_t

    if t == 1:
        action = "C"
    else:
        # update P using last round history
        d = number_of_defectors_last_round  # from observed actions
        q = d / n
        P = max(0.0, P * 0.5 + max(0.0, q - 0.25))

        # decision
        if S_t < S_low:
            action = "D"
        elif S_t < S_high and P >= 0.25:
            action = "D"
        else:
            action = "C"

    play(action)
```

---

### What this does well in a tournament
- Against cooperators / conditional cooperators: converges to near-full cooperation and maintains capacity → high sustained payoffs.
- Against occasional defectors: tolerates “testing” without overreacting, preserving cooperation.
- Against persistent defectors: escalates to punishment once their behavior starts harming stock, reducing their incentive and preventing being exploited indefinitely.
- Against chaotic/noisy strategies: pressure smoothing + forgiveness avoids constant retaliation cycles.

If you want, I can also provide a more aggressive variant (faster punishment) and a more forgiving variant (higher tolerance) and explain the tradeoffs for different opponent populations.
'''

description_COLLECTIVE_80 = '''
## Strategy: **Stock-Guarded Reciprocal (SGR)**  
Collective goal: keep the resource near **capacity** (where the logistic growth replenishes strongly) while still being **hard to exploit**. We do this by (i) defaulting to cooperation when the stock is healthy, (ii) switching to defection when the group is depleting the pool, and (iii) using **forgiveness** when behavior improves.

Key idea: your action can’t directly “save” the pool if others defect, but you *can* (a) avoid being a sucker when others over-consume, and (b) return to cooperation quickly once the group returns to sustainable use.

---

# 1) Decision rules: when to cooperate vs defect

### Definitions observed each round \(t\)
- \(S_t\): stock at start of round \(t\)
- For each player \(j\), previous action \(a_{j,t-1}\in\{C,D\}\) (observable)
- \(k_{t-1}\): number of defectors last round \(=\#\{j: a_{j,t-1}=D\}\)

### Sustainability thresholds (depend only on parameters)
We use two stock thresholds:

- **Safe stock threshold**:  
  \[
  S_{\text{safe}} = 0.8 \cdot \text{capacity}
  \]
  Above this, the pool is healthy; prioritize cooperation.

- **Critical stock threshold**:  
  \[
  S_{\text{crit}} = 0.4 \cdot \text{capacity}
  \]
  Below this, the pool is fragile; prioritize self-protection (defect) unless there is clear evidence of broad restraint.

(These are simple and robust; they don’t depend on assumptions about opponents.)

### Behavior thresholds (reciprocity)
Convert last round’s observed group behavior into a rule:

- Let **defection rate** last round be:
  \[
  d_{t-1} = \frac{k_{t-1}}{n}
  \]

We define:
- “Mostly cooperative” if \(d_{t-1} \le 0.25\) (at most a quarter defected)
- “Mixed/uncertain” if \(0.25 < d_{t-1} < 0.5\)
- “Mostly defecting” if \(d_{t-1} \ge 0.5\)

### Core action rule (per round \(t\ge 2\))
**Cooperate** if and only if all of the following hold:
1) Stock is not critical: \(S_t \ge S_{\text{crit}}\), and  
2) The group showed restraint recently: \(d_{t-1} \le 0.25\), and  
3) The stock is not currently collapsing: \(S_t \ge S_{t-1}\) **or** \(S_t \ge S_{\text{safe}}\)

Otherwise **Defect**.

Intuition:
- If many defected last round, defect now to avoid being exploited.
- If stock is low or falling, defect to avoid being the only one conserving (which doesn’t save the pool alone).
- If stock is healthy and the group is mostly cooperating, cooperate to sustain capacity and maximize long-run collective payoffs.

---

# 2) Edge cases and round-specific handling

### Round 1 (no history)
- **Play C** in round 1.
Rationale: with \(S_1=\) capacity, cooperation can keep stock at/near capacity when enough others also cooperate; starting with D immediately accelerates collapse and invites retaliation spirals.

### Last round \(t=r\)
- **Play D** unless **both**:
  - \(S_r \ge S_{\text{safe}}\), and
  - \(d_{r-1} \le 0.25\)
Otherwise D.

Rationale: endgame incentives push toward defection; however, if the group has been clearly cooperative and stock is abundant, cooperating is still “collective” and costs less in opportunity (since the pool is full and stable). This balances robustness (don’t be naive) with collective intent (don’t gratuitously defect in a clearly cooperative environment).

### “Recovery / forgiveness” after punishment
If you defected last round due to high defection rate, you return to cooperation **immediately** once:
- \(d_{t-1} \le 0.25\) and \(S_t \ge S_{\text{crit}}\)

No long grudges. This is important because the pool can regenerate strongly when kept away from low levels, and permanent punishment can trap everyone in mutual defection.

### “Meltdown” handling (very low stock)
If \(S_t \le \frac{2n}{n} = 2\) is near the minimum scale of per-round extraction:
- **Always D**.
Reason: at extremely low stock, one cooperator’s restraint is negligible against others’ incentives; the priority becomes not being the only cooperator while waiting for others to change.

---

# 3) Collective mindset and robustness

This strategy is collective in the sense that it:
- **Treats cooperation as the default** when the pool is healthy and others are largely cooperating.
- **Punishes over-consumption quickly** to reduce exploitability and discourage continued defection.
- **Forgives quickly** to restore cooperation and keep stock near capacity (where everyone can keep earning high payoffs).

It is robust because:
- Against always-defectors: it quickly shifts to D and stops being exploited.
- Against mixed or noisy players: it cooperates when cooperation is viable (stock healthy + low defection rate) and otherwise protects itself.
- Against conditional cooperators: it provides a clear, stable signal—cooperate when most do; defect when many defect—helping coordination emerge without communication.

---

## Pseudocode (implementable)

```python
def action(t, r, n, capacity, S_t, S_prev, actions_prev):
    S_safe = 0.8 * capacity
    S_crit = 0.4 * capacity

    if t == 1:
        return "C"

    # Count defectors last round
    k_prev = sum(1 for a in actions_prev if a == "D")
    d_prev = k_prev / n

    # Extreme low-stock safeguard
    if S_t <= 2:
        return "D"

    # Last round bias toward robustness
    if t == r:
        if S_t >= S_safe and d_prev <= 0.25:
            return "C"
        else:
            return "D"

    # Core rule
    mostly_coop = (d_prev <= 0.25)
    stock_not_critical = (S_t >= S_crit)
    not_collapsing = (S_t >= S_prev) or (S_t >= S_safe)

    if mostly_coop and stock_not_critical and not_collapsing:
        return "C"
    else:
        return "D"
```

If you want, I can tune the numeric thresholds (0.8/0.4 capacity; 25%/50% defection) for specific \(n, r,\) and capacity regimes, but the above is designed to work reasonably across a wide range without overfitting.
'''

description_COLLECTIVE_81 = '''
### Goal
Sustain the stock near the *high-yield, renewable* region while protecting against exploitation. The key is that the post-consumption stock drives future value; mutual restraint can keep the system at/near capacity, but unchecked defection collapses it to (near) zero.

A robust collective strategy should therefore:
- **Cooperate by default** when the resource is healthy.
- **Escalate quickly** against over-consumption to deter persistent defectors.
- **Forgive** when the group returns to restraint (because rebuilding stock is valuable).
- **Adapt to state (stock) and horizon (rounds remaining)**.

---

## Strategy: **State-Adjusted Generous Grim (SAGG)**

### Core idea
Maintain the stock by targeting a safe “post-consption remaining” level, punish over-consumption, and re-open cooperation when the stock recovers and others show restraint.

Because actions are only {C,D}, we implement this with:
- a **state rule** (based on current stock),
- a **history rule** (based on recent observed defections),
- and a **horizon rule** (endgame protection).

---

## 1) Decision rules (C vs D)

### Quantities computed each round \(t\)
Let:
- \(S_t\) = current stock at start of round \(t\).
- \(k_{t-1}\) = number of players who defected in round \(t-1\) (for \(t=1\), set \(k_0=0\)).
- \(m\) = length of recent window to judge behavior (recommend \(m=2\)).
- \(K_t\) = total number of defections in the last \(m\) rounds (for missing rounds early, count what exists).
- \(R = r - t + 1\) = rounds remaining.

#### Intuition for thresholds
- If stock is **high**, cooperation is best for collective yield because it keeps the system at capacity (as shown in your example).
- If stock is **low**, the group must *rebuild*; defection accelerates collapse, so we should still prefer C **unless** we are being exploited repeatedly, in which case we punish.
- If near the **end of the game**, incentives to defect rise; we respond by becoming less forgiving.

---

### Rule A — Stock-based “health zones”
Define three zones using parameters only:

- **Healthy zone:** \(S_t \ge 0.9 \cdot \text{capacity}\)  
  Default to **C**, because the system can sustain high yield if restraint holds.

- **Recovery zone:** \(0.4\cdot \text{capacity} \le S_t < 0.9\cdot \text{capacity}\)  
  Default to **C**, but be more sensitive to defections (since stock is not fully buffered).

- **Critical zone:** \(S_t < 0.4\cdot \text{capacity}\)  
  Default to **C** *unless* there is clear ongoing exploitation; prioritize rebuilding.

(These constants are not magic; they’re simple, implementable, and robust across capacities.)

---

### Rule B — Punishment trigger (history-based)
We punish when there is **evidence of sustained over-consumption**, not just a single deviation.

Use a short memory window \(m=2\) and define:
- If \(K_t \ge \lceil n/2 \rceil\): the group is trending defect-heavy.
- If **any single opponent defects in both of last 2 rounds** (persistent defection), we also treat this as exploitation pressure.

Because we cannot target individuals with only C/D (everyone faces the same stock), punishment is *public*: we defect to reduce the gain from unilateral defection and signal intolerance.

**Punishment action:** play **D** for \(p\) rounds, where
- \(p = 1\) if stock is Healthy,
- \(p = 2\) if stock is Recovery,
- \(p = 3\) if stock is Critical.

This makes punishment harsher when the resource is fragile.

---

### Rule C — Forgiveness / return to cooperation
After punishment, return to **C** if:
- In the most recent round, defections were low: \(k_{t-1} \le 1\), **and**
- stock is not decreasing sharply (proxy: \(S_t \ge S_{t-1}\), when defined).

This prevents getting stuck in mutual defection when others are willing to come back.

---

### Rule D — Endgame tightening (horizon-based)
Defection becomes more tempting near the end because future stock value matters less.

So adjust forgiveness based on rounds remaining:
- If \(R \le 2\): become strict.  
  Play **D** unless the last round had **zero defections** and stock is Healthy.
- If \(R = 1\) (last round): play **D** (standard endgame protection).  
  This is the only explicitly non-collective-looking step, but it prevents being the “sucker” when others defect at the end. In many tournaments, this improves robustness without destroying earlier cooperation.

---

## 2) Edge cases

### First round (t = 1)
- Play **C**.
Rationale: With full stock, C supports maximal sustainable path and tests whether opponents are cooperative.

### After a collapse (S very low, e.g., near 0)
- Continue to play **C** unless you are in an active punishment phase triggered by repeated defections.
Rationale: If everyone defects, the stock stays at ~0; only restraint can rebuild.

### If capacity is barely above \(2n\)
- The same rules work; the zones scale with capacity.  
- If capacity is small, stock volatility is higher; the “Critical zone” will occur more often, which automatically increases punishment duration and reduces forgiveness.

### If opponents alternate C/D to game forgiveness
- The “window” rule \(m=2\) plus the “persistent defector” check and state-based harsher punishments in low stock makes cycling less profitable: repeated defection triggers longer D phases, which reduces the exploiter’s advantage.

---

## 3) “Collective mindset” explanation (why this is collective)
- **Default is cooperation** whenever the stock is healthy or recoverable, because that is the only way to maintain near-capacity dynamics where everyone earns consistently.
- **Punishment is conditional and state-aware**, used to protect the commons from being driven into the critical zone.
- **Forgiveness is explicit**, because restoring cooperation is socially efficient and grows future stock.
- The strategy treats the commons as the shared objective, not one-round exploitation.

---

## Pseudocode (implementable)

```python
# Parameters: n, r, capacity
m = 2  # memory window
punish_remaining = 0

def stock_zone(S):
    if S >= 0.9 * capacity: return "healthy"
    if S >= 0.4 * capacity: return "recovery"
    return "critical"

def punishment_length(zone):
    if zone == "healthy": return 1
    if zone == "recovery": return 2
    return 3

# History maintained by implementation:
# actions_history[t][i] for all i, and stock_history[t]
# k_last = number of D in last round
# K_window = total D in last m rounds (or fewer early)

def decide_action(t, S_t, history):
    global punish_remaining

    R = r - t + 1
    zone = stock_zone(S_t)

    # Endgame tightening
    if R == 1:
        return "D"
    if R <= 2:
        if history.exists_round(t-1) and history.k_last == 0 and zone == "healthy":
            return "C"
        return "D"

    # If currently punishing, continue
    if punish_remaining > 0:
        punish_remaining -= 1
        return "D"

    # Compute defection signals
    k_last = history.k_last if history.exists_round(t-1) else 0
    K_window = history.total_defections_last_m_rounds(m)

    sustained_group_defection = (K_window >= (n+1)//2)

    # Optional: persistent individual defection (needs per-player history)
    persistent_someone = history.any_player_defected_in_both_last_two_rounds()

    if sustained_group_defection or persistent_someone:
        punish_remaining = punishment_length(zone) - 1
        return "D"

    # Forgiving cooperative default
    return "C"
```

---

### Minimal summary
- **Round 1:** C.  
- **Normally:** C to keep stock high.  
- **If defections become frequent (recent window) or persistent:** switch to D for 1–3 rounds depending on stock health.  
- **Forgive quickly** when defections drop and stock stabilizes.  
- **Final round:** D; last two rounds: mostly D unless everyone stayed perfectly cooperative and stock is high.

If you want, I can also provide a variant that *never* defects in the last round (pure collective stance), or a version that uses a numeric “defection score” for smoother adaptation.
'''

description_COLLECTIVE_82 = '''
## Strategy: **State-Triggered Collective Restoration (STCR)**  
Goal: keep the stock near **capacity** (maximizes long-run per-round payoffs for everyone) while being **robust** to defectors by (i) not over-punishing in ways that collapse the stock, and (ii) switching to self-protection when cooperation is clearly not reciprocated.

### Core idea
- The resource is healthiest when **post-consumption stock stays near capacity** so growth replenishes quickly.
- **Mutual C** preserves the stock best; **mutual D** collapses it.
- So we use:
  1) **Stock-based triggers** (ecological safety first),  
  2) **Reciprocity** (reward/punish based on observed cooperation rate),  
  3) **Forgiveness** (avoid spirals after one-off noise),  
  4) **Endgame realism** (expect more defection late, but don’t “panic defect” if the stock is fragile).

---

# 1) Decision rules (when to C vs D)

### Quantities tracked from history (public information)
At round \(t\), before choosing, observe current stock \(S_t\) and previous round actions.

Let:
- \(k_{t-1}\) = number of players who cooperated in round \(t-1\)
- \(c_i(t-1)\in\{0,1\}\) = whether player \(i\) cooperated last round
- **Recent cooperation rate** (others):  
  \[
  \rho_t = \frac{1}{m}\sum_{\tau=t-m}^{t-1}\frac{k_\tau - c_i(\tau)}{n-1}
  \]
  where \(m = \min(5, t-1)\) (use last up to 5 rounds; exclude self)

Also compute a simple **stock stress index**:
\[
x_t = S_t / \text{capacity}
\]
So \(x_t\in[0,1]\).

---

## Rule set

### A. Ecological safety trigger (stock-first)
1. **If stock is low, always cooperate** to avoid collapse:
- If \(x_t \le 0.35\): play **C** unconditionally.

Rationale: when stock is low, defection accelerates depletion; the best chance to restore is to reduce extraction.

---

### B. Reciprocity regime (normal stock)
When \(x_t > 0.35\), base your action on whether others are broadly cooperating.

2. **If others are mostly cooperating, cooperate**
- If \(\rho_t \ge 0.60\): play **C**

3. **If others are mostly defecting, defect (self-protection)**
- If \(\rho_t \le 0.35\): play **D**

4. **Gray zone: use a “cautious collective” stance**
- If \(0.35 < \rho_t < 0.60\):
  - If \(x_t \ge 0.80\): play **C** (resource abundant; try to pull group toward cooperation)
  - Else play **C** if \(k_{t-1}\ge \lceil n/2\rceil\), otherwise **D**

This makes the strategy:
- generous when stock is high (good collective leadership),
- but not endlessly exploitable when cooperation is not emerging.

---

### C. One-step forgiveness & anti-spiral
To avoid mutual collapse after a single bad round:

5. **Forgive a single defection burst if stock remains healthy**
- If last round had low cooperation (e.g., \(k_{t-1} < \lceil n/2\rceil\)) **but** \(x_t \ge 0.85\), then still choose **C** once (a “repair attempt”) *unless* \(\rho_t \le 0.35\) (persistent defection).

This prevents harsh retaliation cycles that destroy future value.

---

# 2) Edge cases

### First round (t = 1)
- Play **C**.
Reason: with stock initially at capacity, collective optimum is to sustain; also establishes cooperative intent at zero cost of information.

### Last round (t = r)
Endgame makes others more likely to defect, so we protect ourselves—but only if the stock is not in danger.

- If \(x_r \le 0.50\): play **C** (don’t “take it down” at the end; keep the public good stable)
- Else (stock healthy): play **D** *unless* \(\rho_r \ge 0.75\) (very cooperative group), in which case play **C**

This balances:
- collective stewardship when fragile,
- realistic self-interest when the horizon removes future discipline.

### Very short games (small r)
If \(r \le 3\):
- Round 1: C
- Round 2: apply rules above but with \(m=1\)
- Round r (last): apply last-round rule

### Stock at (or near) zero
If \(S_t \approx 0\), payoffs are tiny regardless; still choose **C** (restoration attempt). Defecting cannot meaningfully help you and may further hinder recovery.

---

# 3) Collective alignment (what makes it “collective”)
This strategy explicitly prioritizes:
- **Resource sustainability**: unconditional cooperation under low stock to preserve future group welfare.
- **Group-leading behavior**: when stock is high, it “invests” in cooperation to pull the system to the high-yield attractor (near capacity).
- **Conditional protection**: it does not sacrifice itself indefinitely—if others persistently defect, it switches to D to avoid being the sole cooperator funding others’ higher immediate payoffs.
- **Anti-collapse forgiveness**: avoids destructive tit-for-tat cascades that hurt everyone.

---

## Pseudocode (implementable sketch)

```python
def STCR_action(t, r, n, capacity, S_t, history_actions):
    x = S_t / capacity

    # First round
    if t == 1:
        return "C"

    # Compute recent cooperation rate of others
    m = min(5, t-1)
    # history_actions[round] = list of actions length n, each "C" or "D"
    # assume we know our index i
    recent = history_actions[t-m : t]  # last m rounds
    coop_rates = []
    for actions in recent:
        k = sum(1 for a in actions if a == "C")
        k_others = k - (1 if actions[i] == "C" else 0)
        coop_rates.append(k_others / (n-1))
    rho = sum(coop_rates) / m

    # Last-round adjustment
    if t == r:
        if x <= 0.50:
            return "C"
        else:
            return "C" if rho >= 0.75 else "D"

    # Ecological safety
    if x <= 0.35:
        return "C"

    # Reciprocity regimes
    if rho >= 0.60:
        return "C"
    if rho <= 0.35:
        return "D"

    # Gray zone
    k_last = sum(1 for a in history_actions[t-1] if a == "C")

    # One-step forgiveness/repair attempt when stock is very healthy
    if x >= 0.85 and k_last < (n+1)//2 and rho > 0.35:
        return "C"

    if x >= 0.80:
        return "C"
    else:
        return "C" if k_last >= (n+1)//2 else "D"
```

---

### What this will do against common opponent types
- **Always-Cooperate**: stays mostly C, keeps stock high, high long-run payoff.
- **Always-Defect**: quickly detects low \(\rho\), defects (except when stock is critically low where it still attempts restoration), avoiding being exploited too long.
- **Grim Trigger / TFT-like**: tends to coordinate on C because it starts with C, repairs after isolated shocks, and punishes persistent defection.
- **Opportunists (defect when stock high)**: the rolling \(\rho\) drops; strategy shifts toward D, limiting exploitation.

If you share the tournament’s typical \(n, r, capacity\) ranges, I can tune the numeric thresholds (0.35, 0.60, etc.) for that environment.
'''

description_COLLECTIVE_83 = '''
## Strategy: **Stock‑Guarded Conditional Cooperation (SGCC)**  
Collective goal: keep the stock near capacity (so everyone’s future payoffs stay high) while being hard to exploit by persistent defectors. The strategy is **state-aware** (uses stock level) and **history-aware** (responds to observed defections), and it escalates punishment quickly but returns to cooperation after compliance.

---

# 1) Decision rules: when to Cooperate vs Defect

### Key ideas
- **Sustainability target:** if the stock is healthy, mutual cooperation keeps it at capacity (because total take is S/2, leaving S/2 which regrows to S when S ≤ capacity).  
- **Main threat:** any defection increases total take and can drive the stock down; at low stock, even one defector can collapse the resource.
- **Response principle:**  
  - Cooperate when stock is healthy and recent behavior is cooperative.  
  - Defect to **punish** defectors (to remove their advantage) and to **protect** yourself from being the “sucker” during exploitation.  
  - But when the stock is fragile, prioritize **resource recovery** over punishment (because punishment via defection can finish the stock).

---

## Quantities tracked each round
Let:
- \(S_t\) = current stock at start of round \(t\)
- \(d_{t-1}\) = number of defectors observed in previous round (0..n)
- Maintain a nonnegative integer **punishment counter** \(P\) (starts 0).

Define stock zones (depend only on parameters):
- **Healthy zone:** \(S_t \ge 0.8 \cdot capacity\)
- **Caution zone:** \(0.4\cdot capacity \le S_t < 0.8\cdot capacity\)
- **Critical zone:** \(S_t < 0.4 \cdot capacity\)

(These thresholds are deliberately simple and robust; they can be tuned, but this works broadly.)

---

## Rule set (high level)

### A. Stock-first rule (safety override)
1) **If in Critical zone** (\(S_t < 0.4C\)):  
   - **Play C**, unless it is the *final round*, in which case play D.  
   Rationale: with low stock, defection accelerates collapse; the best collective move is to stop over-harvesting and let logistic growth recover the pool.

### B. Punishment/forgiveness rule (when stock allows it)
2) Update punishment counter after observing last round:
- If \(d_{t-1}=0\):  
  \(P \leftarrow \max(P-1, 0)\)  (gradual forgiveness)
- If \(d_{t-1}>0\):  
  \(P \leftarrow \min(P + 1 + d_{t-1},\; P_{max})\)  
  where \(P_{max} = 6\) (cap to avoid endless vendetta)

Interpretation: one defector triggers punishment; multiple defectors trigger stronger/longer punishment.

3) Action choice (when **not** Critical):
- If \(P=0\): **Play C** (default collective stance).
- If \(P>0\):
  - If in **Healthy zone**: **Play D** (punish effectively while stock can absorb it).
  - If in **Caution zone**: **Play C** (resource protection takes precedence; punishment would be too costly).
  - After playing, decrement \(P \leftarrow P-1\) each round (punishment “served” gradually).

So: punish only when the stock is high enough that punishment doesn’t jeopardize the commons; otherwise, stabilize the stock.

---

# 2) Edge cases

### First round
- **Play C**.
Reason: the commons starts at capacity, and cooperation is the collectively optimal focal point; it also avoids needless early depletion and gives opponents a chance to reveal type.

### Last round
- If stock is **Critical** (< 0.4C): **Play D** (no future to protect; take what you can).
- Otherwise:  
  - If there was **any defection in round r−1**, **Play D** (avoid being exploited at the end).  
  - Else **Play C** (keeps collective stance; also avoids triggering last-round races in some populations).

### “Everyone else defects” scenario
- If you observe persistent high defection, your \(P\) will rise and you’ll defect in Healthy stock periods to avoid being the sucker.  
- If their defection collapses the stock into Critical, you switch to C to maximize chances of any recovery (you cannot recover alone, but you avoid being the one finishing the stock).

### “One occasional noisy defector” scenario
- A single defection increases \(P\), causing **brief punishment in Healthy** states, but forgiveness reduces \(P\) quickly if cooperation resumes. This discourages opportunistic single-round grabs without locking into mutual destruction.

---

# 3) Collective mindset and why this is robust

**Collective alignment:**  
- The strategy’s default is **cooperate** whenever it is safe and not currently responding to exploitation.  
- It uses **targeted, temporary punishment** only when the ecosystem can tolerate it (Healthy zone), which is the only time punishment is not self-defeating for the group.

**Robustness across opponent types:**  
- **Against unconditional cooperators:** you cooperate almost always; stock stays high; group welfare is maximized.  
- **Against occasional defectors (testing/exploration):** you punish enough to remove the incentive, then forgive.  
- **Against grim-trigger or retaliators:** your punishment is finite and state-gated, reducing the chance of permanent spirals; you also return to cooperation when stock is at risk.  
- **Against unconditional defectors:** you will not be consistently exploited; you defect during Healthy phases and avoid accelerating collapse during Critical phases.

---

# Pseudocode (implementable)

```python
# Parameters: n, r, capacity
HEALTHY = 0.8 * capacity
CRITICAL = 0.4 * capacity
PMAX = 6

P = 0  # punishment counter

for t in 1..r:
    observe S_t  # stock at start of round t
    if t == 1:
        action = "C"
    else:
        d_prev = number_of_defectors_in_round(t-1)

        # update punishment counter
        if d_prev == 0:
            P = max(P - 1, 0)
        else:
            P = min(P + 1 + d_prev, PMAX)

        # last-round special handling
        if t == r:
            if S_t < CRITICAL:
                action = "D"
            else:
                if d_prev > 0:
                    action = "D"
                else:
                    action = "C"
        else:
            # safety override
            if S_t < CRITICAL:
                action = "C"
            else:
                if P == 0:
                    action = "C"
                else:
                    if S_t >= HEALTHY:
                        action = "D"  # punish
                    else:
                        action = "C"  # protect stock
                    P = max(P - 1, 0)

    play(action)
```

---

If you want, I can also provide: (a) a tighter analytical justification for the stock thresholds in terms of expected next-period recovery under various defection counts, or (b) a variant tuned specifically for small r (endgame-heavy) vs large r (sustainability-heavy).
'''

description_COLLECTIVE_84 = '''
## Strategy: **Stock-Guardian with Credible Retaliation (SGCR)**  
Goal: keep the common stock near **capacity** (so everyone’s per-round payoff stays high), while being robust to exploitation by triggering **fast, state-based retaliation** against persistent defection and then **forgiving** when cooperation resumes.

The key idea is to treat the game as resource management with enforcement:
- If the group keeps stock high, everyone can keep earning high payoffs every round.
- Defection is individually tempting, but it risks collapsing stock to 0 (catastrophic).
- So we use **conditional cooperation** anchored on **stock health** and **observed defection rate**, not on any pre-agreed schedule.

---

# 1) Decision rules: when to Cooperate vs Defect

### Definitions computed each round \(t\) before choosing action
Let:
- \(S_t\): current stock at start of round \(t\)
- \(H_t\): number of defectors in previous round \(t-1\) (observable after round \(t-1\))
- \(d_t = H_t / n\): defection fraction last round  
- “Healthy stock” threshold:  
  \[
  S_{\text{healthy}} = 0.8 \times \text{capacity}
  \]
- “Danger stock” threshold:
  \[
  S_{\text{danger}} = 0.5 \times \text{capacity}
  \]
(These are intentionally simple and parameter-only.)

### Core behavioral modes
We maintain a mode variable: `mode ∈ {COOP, PUNISH, RECOVER}`.

#### A. COOP mode (default)
**Play C** if the system looks sustainable and not being exploited.

Trigger to stay in COOP:
- If \(S_t \ge S_{\text{healthy}}\) **and** \(d_{t} \le 1/n\) (at most one defector last round), then **C**.

Rationale:
- A single defector could be noise or experimentation; collapsing cooperation over one defection is too brittle.
- When stock is high, the social optimum is continued cooperation.

#### B. PUNISH mode (credible retaliation)
Enter PUNISH if any of these hold:
- **Exploitation signal:** \(d_{t} > 1/n\) (more than one defector last round), OR
- **Stock is slipping:** \(S_t < S_{\text{healthy}}\) and last round had any defection, OR
- **Emergency:** \(S_t \le S_{\text{danger}}\) (stock is in real trouble)

In PUNISH:
- **Play D** for a fixed short retaliation burst:
  - `punish_len = 2` rounds if \(S_t \ge S_{\text{danger}}\)
  - `punish_len = 3` rounds if \(S_t < S_{\text{danger}}\)

Rationale:
- D is destructive, but it is the only lever you have to make defection unattractive in a simultaneous game.
- Retaliation is **short and state-aware** so you don’t destroy the resource unnecessarily.

#### C. RECOVER mode (forgiveness + rebuilding trust)
After finishing a punishment burst, switch to RECOVER:
- In RECOVER, **play C** if either:
  - last round defection fraction \(d_{t} \le 1/n\), OR
  - stock is still below healthy and you need growth to restore it (because C leaves more remaining stock).

If defection persists in RECOVER (i.e., \(d_{t} > 1/n\)), immediately return to PUNISH.

Rationale:
- You must be willing to re-cooperate quickly, otherwise everyone gets stuck in mutual destruction.
- But you also immediately re-punish if exploitation continues.

---

# 2) Edge cases (first round, last round, etc.)

### First round (no history)
**Play C** in round 1.

Reason:
- With stock initially at capacity, cooperation is the best collective “investment.”
- Starting with D invites collapse dynamics and provokes other strategies’ retaliation.

### Last round
Two cases depending on tournament incentives:

- If you want strict one-shot rationality: defecting in the last round is tempting.
- But in tournaments, strategies are often evaluated across many matches and may include “endgame punishment.” Also, a late collapse can reduce your last-round payoff if others defect too.

**Rule:**  
- If \(S_t \ge S_{\text{healthy}}\) and the last 2 rounds had \(d \le 1/n\), **play C** even in the last round.  
- Otherwise **play D**.

This preserves collective behavior when the group has been cooperative, but prevents being the “sucker” in an obvious endgame grab.

### If stock is extremely low
If \(S_t\) is near 0, both C and D yield tiny payoffs; the priority becomes allowing recovery. Since cooperation consumes less, it supports regrowth.

**Emergency recovery override:**  
- If \(S_t < 0.2 \times \text{capacity}\), **play C** unless defection fraction last round was very high (e.g., \(d_t \ge 0.5\)), in which case **play D** (you’re being farmed and recovery won’t happen anyway).

---

# 3) Collective mindset (how it aligns with “we”)

This strategy treats the group as managing a renewable asset:
- **Cooperate when the commons is healthy and others mostly cooperate**, maximizing long-run total extraction.
- **Retaliate quickly but briefly** to prevent persistent free-riding from becoming a stable pattern.
- **Forgive and return to cooperation** as soon as the environment indicates it’s safe—because the stock dynamics reward rebuilding.
- **Prioritize stock health** (sustainability) over myopic extraction, except when others demonstrate that sustainability is not being respected.

---

## Pseudocode (implementable)

```python
# Parameters: n, r, capacity
S_healthy = 0.8 * capacity
S_danger  = 0.5 * capacity
S_emerg   = 0.2 * capacity

mode = "COOP"
punish_remaining = 0

# track last two rounds defection fractions for last-round rule
d_hist = []  # list of previous d values

for t in range(1, r+1):
    S = current_stock_start_of_round(t)

    if t == 1:
        action = "C"
    else:
        d_last = d_hist[-1]  # fraction of defectors in round t-1

        # emergency recovery override
        if S < S_emerg:
            if d_last >= 0.5:
                action = "D"
            else:
                action = "C"
        else:
            if mode == "PUNISH":
                action = "D"
                punish_remaining -= 1
                if punish_remaining <= 0:
                    mode = "RECOVER"

            elif mode == "RECOVER":
                if d_last > 1/n:
                    mode = "PUNISH"
                    punish_remaining = 3 if S < S_danger else 2
                    action = "D"
                else:
                    action = "C"
                    # return to COOP if stock is healthy again
                    if S >= S_healthy:
                        mode = "COOP"

            else:  # COOP
                # trigger punish if exploitation or slipping stock with defection
                if (d_last > 1/n) or ((S < S_healthy) and (d_last > 0)) or (S <= S_danger):
                    mode = "PUNISH"
                    punish_remaining = 3 if S < S_danger else 2
                    action = "D"
                else:
                    action = "C"

        # last round adjustment
        if t == r:
            if len(d_hist) >= 2:
                if (S >= S_healthy) and (d_hist[-1] <= 1/n) and (d_hist[-2] <= 1/n):
                    action = "C"
                else:
                    action = "D"
            else:
                # if insufficient history, be cautious but not purely greedy
                action = "C" if S >= S_healthy else "D"

    play(action)
    # after round resolves, observe number of defectors H_t and update:
    d_hist.append(H_t / n)
```

---

### Why this should perform well in a mixed tournament
- Against cooperators: it converges to stable **all-C**, keeping stock near capacity and maximizing repeated payoffs.
- Against occasional defectors: it doesn’t overreact to one-off defection, but it **disciplines** repeated exploitation.
- Against always-defect: it avoids being endlessly exploited by switching to **D**, but still uses state-based cooperation when recovery is possible.
- Against “grim trigger” types: it minimizes accidental triggering (tolerates one defector), and once conflict occurs it has a clear path back to cooperation.

If you want, I can also provide a variant tuned for “more forgiving” or “more aggressive” tournaments by adjusting only the thresholds and punishment length.
'''

description_COLLECTIVE_85 = '''
## Strategy: **Stock-Guard with Credible Punishment (SGCP)**  
Goal: keep the resource near **capacity** (maximizes long-run total payoffs) while being **hard to exploit**. The strategy is: cooperate by default when the stock is healthy; punish defection quickly when it threatens the stock; forgive once the stock has recovered; and switch to endgame behavior in the final rounds.

This is a **collective** strategy: it treats “good behavior” as actions that preserve the shared stock, and “bad behavior” as actions that measurably degrade it.

---

# 1) Decision rules (Cooperate vs Defect)

### Key idea
At any round, use the observed history to estimate:
- **How cooperative the group is** (fraction of cooperators last round).
- **How safe the stock is** (current stock relative to capacity).
Then choose:
- **C** when the stock is safe *and* the group is sufficiently cooperative.
- **D** to **punish** (to deter exploitation) or to **protect** yourself when cooperation is clearly failing and the stock is likely to collapse anyway.

### Notation
- Parameters: `n, r, capacity`
- Round index: `t = 1..r`
- Current stock at start of round: `S_t`
- From previous round (if `t>1`): observe each player action → count cooperators `c_{t-1}` and defectors `d_{t-1}=n-c_{t-1}`.

Define thresholds:
- **Safe stock threshold:** `S_safe = 0.8 * capacity`
- **Critical stock threshold:** `S_crit = 0.4 * capacity`
- **Collapse threshold:** `S_collapse = 0.15 * capacity`

Define cooperation levels:
- `coop_rate = c_{t-1} / n`

Define an internal “punishment counter” `P` (starts at 0) indicating how many punishment rounds remain.

---

## Core rules

### Rule A — Default cooperative stance
If stock is healthy and others are mostly cooperating, cooperate:
- If `t>1`, `P == 0`, `S_t >= S_safe`, and `coop_rate >= 1 - 1/n` (i.e., at most one defector last round), then play **C**.

Rationale: one “mistake” defector doesn’t justify collapse; keep the stock at/near capacity.

---

### Rule B — Trigger punishment when defection is meaningful
If there were **≥2 defectors** last round *or* the stock is falling into danger, trigger punishment:
- If `t>1` and `P == 0` and `(d_{t-1} >= 2 or S_t < S_safe)`, then set  
  `P = 2` (two-round punishment) and play **D** this round.

Rationale: punishment must be **credible** and swift. Two rounds is long enough to make defection unprofitable in many mixed populations but not so long that it permanently destroys recovery.

---

### Rule C — While punishing
If `P > 0`, play **D** and decrement:
- Play **D**
- `P -= 1`

But with an important safety override:

**Safety override during punishment:**  
If `S_t <= S_collapse`, switch to **C** even if punishing (to avoid irreversible depletion):
- If `S_t <= S_collapse`, play **C** and set `P = 0`.

Rationale: when the stock is extremely low, mutual defection can permanently zero it; collective survival dominates punishment.

---

### Rule D — Forgive and return to cooperation when recovery conditions hold
After punishment ends (or if no punishment is active), cooperate again once the group demonstrates sufficient cooperation and stock is not critical:
- If `P == 0` and `t>1` and `S_t >= S_crit` and `coop_rate >= 0.75`, play **C**.

Rationale: forgiveness enables rebuilding cooperation with diverse opponents (including noisy or adaptive ones).

---

### Rule E — If cooperation is clearly failing, protect yourself (but don’t accelerate collapse)
If group cooperation is low, defect unless stock is near-collapse:
- If `P == 0` and `t>1` and `coop_rate < 0.5`:
  - If `S_t > S_collapse`, play **D**
  - Else play **C**

Rationale: if most players defect, unilateral cooperation is exploited; but near-collapse requires restraint to preserve any future value.

---

# 2) Edge cases

### First round (t = 1)
Play **C**.

Rationale: establishes the cooperative baseline and, given high initial stock (capacity), yields high collective value. It also avoids prematurely triggering retaliation cycles.

---

### Last round (t = r)
Play **D**, **unless** the stock is already critically low:
- If `S_r <= S_collapse`, play **C**
- Else play **D**

Rationale: standard endgame logic makes cooperation hard to sustain in the final round; but if the stock is near-zero, defecting may just finalize collapse and yields little incremental gain (and in some implementations could reduce even your own realized future if there are any terminal bonuses—none here, but this is still a safe guardrail).

---

### Second-to-last round (t = r-1)
If cooperation is high and stock is safe, still cooperate (try to keep value high), but be stricter about punishment:
- If `S_{r-1} >= S_safe` and `coop_rate >= 1 - 1/n`: play **C**
- Else: play **D** (unless `S_{r-1} <= S_collapse`, then **C**)

Rationale: near the end, deterrence is weaker; this tightens exploitation resistance.

---

### If stock hits 0 (or extremely low)
Always play **C** until stock rises above `S_collapse`.

Rationale: defection yields nearly zero anyway and prevents recovery.

---

# 3) “Collective mindset” alignment

This strategy is collective in three concrete ways:

1. **Primary objective is stock stability near capacity**, which maximizes *total* long-run payoffs (because logistic growth replenishes best when stock is mid-range and capped at capacity; your examples show full recovery under all-C).
2. **Punishment is targeted and temporary**, designed to deter free-riding without spiraling into permanent depletion.
3. **Safety overrides prevent tragedy-of-the-commons lock-in**: when the stock is near collapse, the strategy prioritizes recovery even if others behaved badly.

---

# Pseudocode (implementable)

```python
# internal state
P = 0  # punishment rounds remaining

def act(t, r, n, capacity, S_t, last_actions=None):
    global P

    S_safe = 0.8 * capacity
    S_crit = 0.4 * capacity
    S_collapse = 0.15 * capacity

    if t == 1:
        return "C"

    # compute last-round stats
    c = sum(1 for a in last_actions if a == "C")
    d = n - c
    coop_rate = c / n

    # endgame
    if t == r:
        return "C" if S_t <= S_collapse else "D"
    if t == r-1:
        if S_t <= S_collapse:
            return "C"
        if S_t >= S_safe and coop_rate >= 1 - 1/n:
            return "C"
        return "D"

    # safety override
    if S_t <= S_collapse:
        P = 0
        return "C"

    # continue punishment
    if P > 0:
        P -= 1
        return "D"

    # trigger punishment
    if d >= 2 or S_t < S_safe:
        P = 2 - 1  # count this round as first punishment round
        return "D"

    # forgiveness / normal cooperation
    if S_t >= S_safe and coop_rate >= 1 - 1/n:
        return "C"
    if S_t >= S_crit and coop_rate >= 0.75:
        return "C"

    # cooperation failing -> protect self unless near collapse
    if coop_rate < 0.5:
        return "D"

    # default
    return "C"
```

---

## Why this is robust in a tournament
- **Against unconditional cooperators:** it mostly cooperates; only brief punishment if noise/rare defection occurs; keeps stock high.
- **Against unconditional defectors:** it defects quickly (avoids being exploited), but switches to cooperation when stock is near-collapse to allow some regrowth if others ever relent.
- **Against tit-for-tat / grim-trigger types:** the short, clearly defined punishment then forgiveness helps re-coordinate after deviations.
- **Against opportunists exploiting “always cooperate”:** the ≥2-defector trigger plus endgame tightening reduces exploitability while preserving high-payoff paths when the population is cooperative.

If you want, I can tune the numeric thresholds (`0.8, 0.4, 0.15`, punishment length `2`, and the defector trigger `≥2`) for specific `n`, `r`, or to optimize for “maximize own payoff” vs “maximize total welfare” objectives.
'''

description_COLLECTIVE_86 = '''
## Strategy: **Stock‑Guarded Generous Grim (SGGG)**  
Collective goal: keep the stock near *capacity* (so everyone can earn high payoffs every round) while still being robust to exploitation. The key idea is:  
- **Default to C** when the resource is healthy and others aren’t depleting it.  
- **Escalate to D** when the group is overdrawing the stock (to prevent being the “sucker” and to discourage continued depletion).  
- **Forgive** after recovery to re-enable long-run cooperation.

This strategy uses only parameters *(n, r, capacity)*, current *stock S*, and full history (observed actions).

---

# 1) Decision rules (when to C vs D)

### Definitions computed each round \(t\) before acting
Let:
- \(S_t\) = current stock at start of round \(t\)  
- \(k_{t-1}\) = number of players who defected in round \(t-1\) (observable after the round)  
- \( \hat{k}_t \) = predicted number of defectors this round (we use \(k_{t-1}\) as the prediction; see below)

**Critical stock threshold (guardrail):**
- \(S_{\text{safe}} = 0.8 \times \text{capacity}\)  
- \(S_{\text{low}} = 0.5 \times \text{capacity}\)  
- \(S_{\text{critical}} = 0.25 \times \text{capacity}\)

Rationale: with logistic growth, the system is very forgiving around mid stock but can get trapped near 0 if repeatedly over-consumed. These thresholds create a simple, robust “risk meter.”

### Core rule set
**Rule A — “Collective default”:**  
If stock is healthy and recent play is not destructive, play **C**.
- If \(S_t \ge S_{\text{safe}}\) **and** \(k_{t-1} \le 1\): play **C**

**Rule B — “Proportional protection”:**  
If defections are emerging or stock is declining, become defensive.
- If \(S_t \in [S_{\text{low}}, S_{\text{safe}})\):  
  - play **C** if \(k_{t-1} = 0\)  
  - else play **D** (don’t subsidize defectors while stock is slipping)

**Rule C — “Emergency stabilization”:**  
If stock is low/critical, play **D** to avoid being exploited and to push others to reduce depletion through deterrence.
- If \(S_t < S_{\text{low}}\): play **D**

This may feel counterintuitive (why defect when stock is low?), but under this payoff structure “C” does not conserve the pool unless *enough* others also choose C. When the group is already in a depletion regime, unilateral cooperation mainly transfers payoff to defectors without reliably restoring the stock. The fastest route back to a cooperative basin is **credible punishment** that makes continued defection unattractive.

**Rule D — “Forgiveness / return to collective mode”:**  
After a punishment phase, return to cooperation once the group demonstrates restraint and the pool recovers.
- If you played **D** last round due to Rule B/C, then switch back to **C** when both hold:
  - \(S_t \ge S_{\text{safe}}\) **and** \(k_{t-1} = 0\)

This makes the strategy *forgiving* (not permanently grim), but only once the system is clearly safe again.

---

# 2) Edge cases (first round, last round, and transitions)

### First round \(t=1\)
Play **C**.  
Reason: the pool starts at capacity, cooperation is collectively optimal, and you need to give other strategies a chance to reveal whether they are cooperative types.

### Last round \(t=r\)
Play **D** *unless* the stock is already low and your defection would collapse it (which doesn’t help you either, since payoff depends on current stock). Concretely:
- If \(S_r \ge S_{\text{low}}\): play **D**  
- Else (\(S_r < S_{\text{low}}\)): play **C**

Reasoning: there is no future to protect, so standard end-game logic pushes toward D; however, if stock is already very low, D may only marginally increase your payoff while further reducing it via lower \(S_r\). This rule preserves a small amount of “resource rationality” even at the end.

### Second-to-last round \(t=r-1\)
Use normal rules, but slightly more defensive:
- Treat \(S_{\text{safe}}\) as \(0.9 \times \text{capacity}\) in round \(r-1\) (harder to justify risking a slide when only one recovery round remains).

### Handling noisy / inconsistent opponents
Some strategies may alternate or use reactive triggers. SGGG avoids being dragged into endless D-D by:
- Only punishing when stock is meaningfully threatened or defections are nontrivial.
- Only forgiving when stock has recovered and last-round defections drop to zero.

---

# 3) Collective mindset (how this aligns with “we” not “me”)
This strategy behaves like a *resource steward with enforcement*:
- It **rewards restraint** (C when others C and stock is healthy).
- It **defends against free riding** (quickly switches to D when others defect and the pool is at risk).
- It **prioritizes recovery** (forgives only when the pool is back in a safe region and the group shows restraint).
- It’s **adaptive across populations**: cooperative groups stay at high stock; exploitative groups are met with deterrence; mixed groups are pushed toward the cooperative basin by making defection less profitable long-run.

---

## Pseudocode (implementation-ready)
```python
def SGGG_action(t, r, n, capacity, S_t, history):
    # history contains prior-round defect counts or actions
    if t == 1:
        return "C"

    k_prev = history.defectors_in_round(t-1)

    S_safe = 0.8 * capacity
    S_low = 0.5 * capacity

    # endgame tweaks
    if t == r:
        return "D" if S_t >= S_low else "C"
    if t == r-1:
        S_safe = 0.9 * capacity

    # main rules
    if S_t >= S_safe and k_prev <= 1:
        return "C"

    if S_low <= S_t < S_safe:
        return "C" if k_prev == 0 else "D"

    # low stock emergency
    return "D"
```

---

### Optional small refinement (if you want extra robustness)
Track a short window of defection rates (e.g., last 3 rounds) instead of only last round:
- Replace `k_prev` with `k_bar = avg(defectors over last W rounds)` and compare against 1.  
This reduces overreaction to one-off defections and improves stability against “probing” opponents.

If you tell me typical tournament parameter ranges (n, r, capacity) I can tune the thresholds (0.8/0.5/0.25) to those regimes.
'''

description_COLLECTIVE_87 = '''
## Strategy: **Stock-Guard with Graduated Sanctions (SGGS)**  
Collective objective: keep the resource near *capacity* (high sustainable yield), while making unilateral defection unprofitable by triggering fast, proportionate punishment that (i) protects the stock from collapse and (ii) pressures defectors back into cooperation. The strategy is Markovian in state (stock) plus uses short memory of history for accountability.

Key idea:  
- **Default = cooperate** when stock is healthy and others are not persistently over-consuming.  
- **Defect only** (a) to prevent collapse when stock is low, or (b) as a temporary sanction against over-consumers.  
- **Return to cooperation quickly** once behavior improves and stock recovers.

---

# 1) Decision rules: when to cooperate vs defect

### Definitions computed each round \(t\)
Let:
- \(S_t\): stock at start of round \(t\)
- For each player \(j\), infer last-round action from observed payoff vs stock:
  - If \(\pi_{j,t-1} \approx S_{t-1}/(2n)\) then \(a_{j,t-1}=C\); if \(\approx S_{t-1}/n\) then \(a_{j,t-1}=D\).
- Let \(d_{t-1}\): number of defectors last round.
- Let \(f_{t-1} = d_{t-1}/n\): defection fraction last round.

Maintain a per-opponent “debt” score \(B_j \ge 0\) capturing recent defections (fades over time).

Update after observing round \(t-1\):
- If \(a_{j,t-1}=D\): \(B_j \leftarrow B_j + 1\)
- Else: \(B_j \leftarrow \max(0, B_j - 1)\)  (forgiveness)

Let:
- \(B_{\max} = \max_{j\ne i} B_j\)
- \(B_{\text{sum}} = \sum_{j\ne i} B_j\)

### Stock zones (purely state-based)
Use two stock thresholds:
- **Safe zone**: \(S_t \ge 0.7\cdot \text{capacity}\)
- **Caution zone**: \(0.4\cdot \text{capacity} \le S_t < 0.7\cdot \text{capacity}\)
- **Danger zone**: \(S_t < 0.4\cdot \text{capacity}\)

Rationale: logistic growth is strong when stock is moderate; once depleted, the group risks being dragged into a low-stock trap by continued defection.

---

## Action rule (core)
You choose \(C\) unless one of the following triggers says “defect”.

### Trigger A — **Resource protection (danger)**
If \(S_t < 0.4\cdot \text{capacity}\):  
**Play C.**  
Reason: when stock is low, the collective priority is to stop extraction pressure. Even though \(D\) yields higher immediate payoff, it accelerates collapse and makes future payoffs tiny.

### Trigger B — **Caution + high defection**
If \(0.4\cdot \text{capacity} \le S_t < 0.7\cdot \text{capacity}\) and \(f_{t-1} \ge 0.5\):  
**Play D** for *one round*, then reassess.  
Reason: if a majority is defecting in a medium stock regime, unilateral cooperation is mostly exploited and does not meaningfully “save” the stock by itself. A one-round sanction also signals “I will not be the sucker,” while keeping escalation limited.

### Trigger C — **Targeted sanction for persistent defectors (safe zone)**
If \(S_t \ge 0.7\cdot \text{capacity}\) and \(B_{\max} \ge 2\):  
**Play D** until either:
- \(B_{\max}\) drops to 0 (i.e., everyone has cooperated enough to “repay”), **or**
- stock leaves the safe zone (then switch to the stock-protection logic).

This is “graduated sanctions”: you only punish when stock is high enough that a brief sanction doesn’t endanger the resource, and only when defection is *persistent*, not a one-off.

### Otherwise (default)
**Play C.**

---

## Intuition: why this is collective and robust
- **Collective-first**: In low stock, you *always* cooperate to maximize regrowth chances.
- **Not naive**: In high stock, you tolerate occasional noise but punish repeat exploiters.
- **Not vindictive**: Debt decays; cooperation restores trust.
- **Adaptive**: Responds to both *state* (stock level) and *behavior* (defection rates / persistent defectors).

---

# 2) Edge cases

### Round 1 (no history)
- **Play C**.
- Initialize all \(B_j=0\).
Reason: starting cooperative is the only move compatible with a collective norm and gives others a chance to reveal types without immediate escalation.

### Last round \(t=r\)
Use a “soft endgame” because there is no future to incentivize cooperation, but collapsing stock in the last round also doesn’t matter for you (only for hypothetical continuation). Still, the tournament objective is usually cumulative payoff, so you should not sacrifice yourself.

Rule for last round:
- If \(S_r < 0.4\cdot \text{capacity}\): **Play C** (still maximizes expected immediate payoff? Actually D gives more immediate payoff, but it also risks driving remaining stock to ~0; since no future, that doesn’t matter. However with simultaneous moves and fixed per-round payoff = fraction of current S, D strictly dominates C in the *final* round given S is pre-consumption. So:)
- **In final round, play D unless you are in the middle of a sanction-recovery protocol where playing C is necessary to end punishment.**  

Practical final-round rule (simple and strong):
- **Play D in round r.**

(If you want to keep the strategy “collective-minded,” you can justify this as: with no future rounds, cooperation cannot be enforced; preserving stock has no instrumental value.)

### Penultimate round \(t=r-1\)
Anticipate last-round defection by others:
- If \(S_{r-1} \ge 0.7\cdot \text{capacity}\): **Play D** *only if* there has been any defection in the last 2 rounds (i.e., \(B_{\max}\ge 1\) or \(f_{r-2}>0\)); else **play C**.
- If stock is not safe: follow normal rules.

This avoids being exploited in common “endgame unraveling” while still rewarding clean cooperation histories.

### Ties / inference noise
If payoffs are noisy or floating-point ambiguous, infer action with a tolerance:
- classify as D if \(\pi_{j,t-1} > 0.75 \cdot (S_{t-1}/(2n) + S_{t-1}/n)/2\) etc.  
Implementation detail: compare \(\pi_{j,t-1}\) to \(S_{t-1}/(2n)\) and \(S_{t-1}/n\) using epsilon.

### If stock hits 0
- Always **C** thereafter (though payoffs are 0 either way) to allow any possible regrowth (here growth at 0 is 0, so it won’t recover, but C is still the “no further harm” action).

---

# 3) Collective alignment (explicit)
This strategy treats the stock as a shared asset whose value comes from staying near capacity, where growth replenishes what’s taken. It:
- cooperates by default to maintain a stable high-yield regime;
- uses **measured, temporary** defection as a *sanctioning tool* against persistent over-consumption;
- shifts to strict conservation (cooperate) when the shared resource is at risk.

---

# Pseudocode (implementable)
```python
# parameters: n, r, capacity
# state each round: S_t, history of actions/payoffs

initialize B[j]=0 for all j != me

for t in 1..r:
    observe S_t

    if t == 1:
        action = "C"

    else:
        # infer last round actions from payoffs
        d = 0
        for j != me:
            if inferred_action(j, t-1) == "D":
                B[j] += 1
                d += 1
            else:
                B[j] = max(0, B[j]-1)

        f = d / n
        B_max = max(B.values())

        # endgame
        if t == r:
            action = "D"

        elif t == r-1 and S_t >= 0.7*capacity:
            if f > 0 or B_max >= 1:
                action = "D"
            else:
                action = "C"

        else:
            # main policy
            if S_t < 0.4*capacity:
                action = "C"
            elif S_t < 0.7*capacity and f >= 0.5:
                action = "D"  # one-round sanction; reassess next round naturally
            elif S_t >= 0.7*capacity and B_max >= 2:
                action = "D"
            else:
                action = "C"

    play(action)
```

---

If you tell me typical tournament settings (ranges of \(n\), \(r\), and capacity relative to \(2n\)), I can tune the thresholds (0.4/0.7 and the “debt” trigger 2) for better performance under those conditions.
'''

description_COLLECTIVE_88 = '''
## Strategy: **Stock-Guard with Graduated Reciprocity (SGGR)**  
Goal: keep the stock near **capacity** (high sustainable yield) while making defection unprofitable via **fast, proportional retaliation** and **measured forgiveness**. The strategy uses only \((n, r, capacity)\), current stock \(S_t\), and full history.

### Core idea
- The resource has a “good” region: keeping post-consumption stock around **capacity/2** yields maximal growth and returns stock to capacity quickly.
- If too many defect, stock collapses and everyone loses.
- So we:
  1) **Cooperate by default** when the group is behaving and stock is healthy.  
  2) **Punish defection quickly** (defect for a short, state-dependent window).  
  3) **Return to cooperation** as soon as opponents do and stock is safe again.  
  4) **Emergency defect** when stock is critically low (to avoid being the “sucker” in a dying pool).

---

## 1) Decision rules: when to Cooperate vs Defect

### Quantities computed each round \(t\)
Let:
- \(S_t\) = stock at start of round \(t\)
- \(D_{t-1}\) = number of opponents who defected last round (from observed history)
- \(d_{t-1} = D_{t-1}/(n-1)\) = opponent defection rate last round  
- Maintain an internal variable **punish_timer** (nonnegative integer), initially 0.

Define stock thresholds (fractions of capacity):
- **safe**: \(S_t \ge 0.80\cdot capacity\)
- **warning**: \(0.50\cdot capacity \le S_t < 0.80\cdot capacity\)
- **critical**: \(S_t < 0.50\cdot capacity\)

(These are intentionally simple and robust across parameterizations.)

### Rule A — Emergency protection (state first)
If stock is **critical** \((S_t < 0.50\,capacity)\), play **D**.  
Rationale: when stock is low, growth is not enough to guarantee recovery if others defect; being exploited here is especially costly. This also creates pressure for others to reduce extraction.

### Rule B — Graduated retaliation (behavior second)
If stock is not critical and **punish_timer > 0**, play **D** and decrement punish_timer.

How to set punish_timer after observing last round:
- If \(D_{t-1} = 0\): set punish_timer = 0 (immediate forgiveness).
- Else increase punishment proportionally:
  - Base retaliation length:  
    \[
    L = 1 + \left\lceil 2\cdot d_{t-1}\right\rceil
    \]
    So small defections trigger short punishment; widespread defections trigger longer punishment.
  - Make punishment harsher when stock is only “warning” (not fully safe):  
    - If \(S_t \in\) warning: \(L := L+1\)
  - Update:  
    \[
    punish\_timer := \max(punish\_timer, L)
    \]
This avoids being “bled” by intermittent defectors.

### Rule C — Cooperative default (when safe & calm)
If stock is safe or warning, and punish_timer == 0:
- If last round had **no defections** among opponents \((D_{t-1}=0)\), play **C**.
- If last round had defections, initialize punish_timer as above and play **D** (i.e., retaliation starts immediately).

### Optional refinement: “single-mutant tolerance” when very safe
To be more robust to noise-like one-off defections (some AIs “probe” once):
- If \(S_t \ge 0.90\,capacity\) and \(D_{t-1}=1\), then **do not punish immediately**: play **C** and set punish_timer = 0.
- If that same opponent defects again within the next 2 rounds, treat it as real defection and apply Rule B with \(d_{t-1}\) computed normally.

This prevents endless feuds triggered by a single exploratory defection while stock is abundant.

---

## 2) Edge cases (first round, last round, etc.)

### First round (t = 1)
Play **C**.  
Rationale: establishes cooperative intent and maximizes chance of reaching the high-yield steady state. Since stock starts at capacity, the system can absorb one round of exploitation without immediate collapse, and early cooperation is the only path to sustained high payoffs.

### Last round (t = r)
Still follow the same rules (including punishment and emergency defect).  
Rationale: although one-shot incentives would push toward endgame defection, blindly defecting in the last round makes you an easy target for reciprocal punishers and collapses trust in tournaments where strategies adapt. Keeping consistency improves expected payoff across unknown opponents.

### If stock hits 0 (or extremely low)
If \(S_t \le 0.05\,capacity\): play **D** until \(S_t\) recovers above \(0.50\,capacity\) *and* opponents show \(D_{t-1}=0\) for one full round.  
Rationale: when the pool is near-dead, you need both ecological recovery and social recovery.

### If opponents always defect
Your behavior converges to mostly **D** (punish_timer stays positive; stock often critical). This is unavoidable; the strategy minimizes being the only cooperator and prevents you from donating value to defectors.

### If opponents mostly cooperate with occasional defections
You cooperate most rounds, with short retaliation bursts that deter repeated exploitation and then reset quickly.

---

## 3) “Collective mindset” alignment
This strategy is explicitly pro-collective:
- **Cooperation is the default**, conditioned only on observed cooperation and ecological health.
- **Retaliation is calibrated**, not punitive for its own sake: it is proportional to group defection and tighter when the resource is stressed.
- **Forgiveness is immediate** when others return to cooperation, enabling the group to re-lock into the high-growth regime (near capacity).
- **Stock-based emergency rules** prioritize the long-run viability of the common pool over short-run niceness.

---

## Pseudocode (implementable)

```pseudo
init punish_timer = 0
init probe_memory = 0  // counts recent single defections when very safe (optional)

for t in 1..r:
    observe S_t

    if t == 1:
        play C
        continue

    observe D_{t-1} among opponents
    d = D_{t-1} / (n-1)

    // Emergency state rule
    if S_t < 0.50 * capacity:
        play D
        // optionally: keep punish_timer > 0 so we don't immediately forgive during collapse
        punish_timer = max(punish_timer, 1)
        continue

    // Optional single-defection tolerance when very safe
    if S_t >= 0.90 * capacity and D_{t-1} == 1 and punish_timer == 0:
        // treat as probe once
        play C
        probe_memory = probe_memory + 1
        continue
    else:
        probe_memory = 0

    if D_{t-1} == 0:
        punish_timer = 0
        play C
        continue

    // If defections occurred, set/extend punishment window
    L = 1 + ceil(2 * d)
    if S_t < 0.80 * capacity:   // warning region
        L = L + 1
    punish_timer = max(punish_timer, L)

    // Execute punishment if active
    if punish_timer > 0:
        play D
        punish_timer = punish_timer - 1
    else:
        play C
```

---

### Why this should perform well in a tournament
- Against cooperators: quickly converges to all-C, sustaining capacity and maximizing long-run payoffs.
- Against exploiters: avoids being persistently suckered; retaliation is immediate and sticky enough to deter “periodic thieves.”
- Against mixed/learning strategies: provides a clear gradient—cooperate gets rewarded quickly; defect gets punished reliably; return to cooperate is met with forgiveness.
- Handles ecological feedback: when stock deteriorates, it becomes stricter automatically, prioritizing recovery.

If you want, I can also propose a more “ecology-optimized” variant that tries to target a specific post-consumption stock level (near capacity/2) using inferred total extraction, but the above is intentionally simple and robust.
'''

description_COLLECTIVE_89 = '''
## Strategy: **Stock-Guard with Graduated Sanctions (SGGS)**  
A collective, state-aware strategy that tries to keep the resource near “safe” levels, cooperates by default, but applies *proportional* punishment when others over-extract—then quickly forgives once behavior improves. It does **not** rely on shared norms or pre-coordination; it infers cooperativeness from observed extraction.

### Core idea (collective mindset)
- The group does best when stock stays high (near `capacity`) because everyone’s per-round payoff scales with current stock.
- The main collective risk is **collapse**: too much extraction drives stock toward 0 and kills all future payoffs.
- Therefore: **cooperate to maintain stock**, but **sanction defect-heavy behavior** to make over-extraction less attractive, while **avoiding spiral-to-collapse punishment** when stock is already low.

---

## Key quantities computed each round
Let round index be `t ∈ {1..r}` and current stock be `S_t`.

From last round’s observed actions, compute:
- `d_{t-1}` = number of players who defected in round `t-1`
- `f_{t-1} = d_{t-1}/n` = defection fraction

Define stock zones (depend only on parameters):
- **High stock**: `S_t ≥ 0.8 * capacity`
- **Mid stock**: `0.4 * capacity ≤ S_t < 0.8 * capacity`
- **Low stock / danger**: `S_t < 0.4 * capacity`

Intuition: below ~0.4 capacity, the system is fragile; punishment that increases extraction can accelerate collapse.

---

## 1) Decision rules (when to C vs D)

### Rule A — First principle: “Protect the stock when it’s low”
- If `S_t < 0.4*capacity`: **Play C**, regardless of history.  
Rationale: when the stock is low, defecting is collectively disastrous and also yields diminishing future value. Even if others defect, adding further extraction reduces the chance of recovery.

### Rule B — Cooperative default in safe conditions
- If `S_t ≥ 0.4*capacity` and (no history yet OR recent defection is low): **Play C**.
- Concretely:
  - If `t = 1`: **Play C**
  - Else if `f_{t-1} ≤ 0.25`: **Play C** (tolerate occasional noise or a single deviant in large n)

### Rule C — Graduated sanction when others over-extract (but only when stock can handle it)
If `S_t ≥ 0.4*capacity` and `f_{t-1} > 0.25`, respond proportionally:

- If `0.25 < f_{t-1} ≤ 0.5`: **Play D with probability 0.5**, else C  
- If `f_{t-1} > 0.5`: **Play D**  

This “mixed” middle response avoids all players flipping to full defection immediately (which would often crash stock), but still makes defection less profitable for others by reducing the payoff advantage of being a lone defector among cooperators.

### Rule D — Fast forgiveness / return to cooperation
After any sanctioning, if the next observed `f_{t-1} ≤ 0.25`, immediately revert to **C** (unless stock is low, where you were already C).

This prevents endless retaliation cycles and helps re-stabilize the stock near capacity.

---

## 2) Edge cases

### First round (`t=1`)
- **Play C**.
Reason: establishes maximum stock preservation and doesn’t require any assumptions.

### Last round (`t=r`)
A purely self-interested last-round defection is tempting, but in tournaments you want robustness against strategies that condition on endgame behavior. Also, the stock level in the last round still determines that round’s payoff.

Use:
- If `S_r < 0.4*capacity`: **C** (protect against total collapse; also D isn’t “worth it” when S is already small in absolute terms)
- Else: follow the same rule as usual (A–D), i.e., do **not** automatically defect just because it’s the last round.

This avoids being exploited by “grim” or “endgame punishment” strategies and sustains cooperation with conditional cooperators.

### Very small n (e.g., n=2)
The defection fraction thresholds still work, but you effectively have coarse steps:
- One defector implies `f=0.5` → triggers the “mixed/strong sanction” region. That’s intended: in small groups, a single defector is a bigger threat to stock.

### Capacity extremely large relative to 2n
Still fine: thresholds scale with `capacity`. If capacity is huge, stock tends to stay high under C; strategy remains cooperative unless defection becomes common.

---

## 3) “Collective” alignment (explicitly)
This strategy is collective because:
- It prioritizes maintaining `S_t` in a regime where logistic growth restores the pool and future payoffs remain high.
- It treats punishment as an instrument to **restore cooperation**, not to “win” a single round.
- It avoids retaliating when the pool is already endangered (low stock), because that harms everyone—including the punisher.

---

## Pseudocode (implementable)
```python
def SGGS(t, r, n, capacity, S_t, history_actions):
    # history_actions[t-1] is list of actions in previous round, if t>1

    LOW = 0.4 * capacity

    # Rule A: protect stock in danger zone
    if S_t < LOW:
        return "C"

    # First round: cooperative default
    if t == 1:
        return "C"

    prev = history_actions[t-1]
    d = sum(1 for a in prev if a == "D")
    f = d / n

    # Rule B: tolerate low defection
    if f <= 0.25:
        return "C"

    # Rule C: graduated sanctions
    if f <= 0.5:
        # mixed response: defect with probability 0.5
        return "D" if random() < 0.5 else "C"
    else:
        return "D"
```

---

### Why this is robust in a tournament
- Against unconditional cooperators: stays cooperative; maintains high stock.
- Against occasional/noisy defectors: tolerates small defection rates; avoids overreaction.
- Against persistent defectors: escalates to D when defection becomes common (deterring exploitation).
- Against strategies that punish harshly: avoids endgame defection and forgives quickly, reducing the chance of spirals.
- When stock becomes fragile: always switches to stock-preserving behavior (C), which is the best collective stabilizer available given the action set.

If you want, I can also provide a deterministic (non-random) variant of the “mixed sanction” step to ensure reproducibility in environments without RNG.
'''

description_COLLECTIVE_90 = '''
## Strategy: **Stock-Guarded Reciprocator (SGR)**  
Collective goal: keep the stock near capacity (so everyone’s future payoffs stay high) while deterring persistent over-extraction. The strategy is **lenient to noise**, **punishes exploitation**, and **recovers cooperation quickly** once others do.

Key idea: cooperate whenever the resource is healthy and opponents are mostly cooperative; defect only when (a) the stock is in danger, or (b) opponents are exploiting cooperation.

---

## 1) Decision rules (C vs D)

### Quantities computed each round \(t\)
Let:
- \(S_t\) = current stock at start of round \(t\).
- \(m_{t-1}\) = number of opponents who defected in round \(t-1\) (for \(t=1\), undefined).
- \(p_{t-1} = m_{t-1}/(n-1)\) = observed opponent defection rate last round.
- \(k\) = number of consecutive “bad” rounds up to \(t-1\), where a round is “bad” if **either**:
  - stock was low: \(S_{t-1} < S_{\text{low}}\), **or**
  - many defected: \(p_{t-1} \ge p_{\text{bad}}\).

Thresholds (parameter-based):
- **Stock thresholds**
  - \(S_{\text{safe}} = 0.80 \cdot \text{capacity}\)
  - \(S_{\text{low}}  = 0.50 \cdot \text{capacity}\)
  - \(S_{\text{critical}} = 0.25 \cdot \text{capacity}\)
- **Behavior thresholds**
  - \(p_{\text{bad}} = 0.40\) (if ~40%+ of opponents defected last round, treat as exploitation risk)
  - \(p_{\text{good}} = 0.15\) (if ≤15% defected, treat as cooperative environment)

These numbers are chosen to be robust across \(n\): they scale on *fractions*, not counts.

---

### Core rule set

#### Rule A — Protect the stock when it’s in danger (resource-first)
1) If \(S_t \le S_{\text{critical}}\): **Play C**.  
Reason: when stock is very low, further depletion risks collapse; “punishment by defection” is counterproductive here. The best collective move is to reduce extraction.

2) Else if \(S_t \le S_{\text{low}}\):  
- If last round had heavy defection \(p_{t-1} \ge p_{\text{bad}}\): **Play C** (stabilize first).  
- Otherwise **Play C**.  
(So: in low-stock states, always cooperate.)

#### Rule B — Conditional cooperation when stock is healthy
If \(S_t \ge S_{\text{safe}}\) (stock healthy):
- If \(p_{t-1} \le p_{\text{good}}\): **Play C** (reward cooperation).
- If \(p_{\text{good}} < p_{t-1} < p_{\text{bad}}\): **Play C** (lenient; don’t spiral).
- If \(p_{t-1} \ge p_{\text{bad}}\): **Play D** **for one round**, then reassess next round.

This is “single-shot punishment”: enough to signal unwillingness to be exploited, but not enough to destroy the stock.

#### Rule C — Intermediate stock: mix deterrence with sustainability
If \(S_{\text{low}} < S_t < S_{\text{safe}}\) (stock middling):
- If \(p_{t-1} \ge p_{\text{bad}}\): **Play D** *only if* \(S_t\) is still comfortably above low, i.e. \(S_t \ge 0.65 \cdot \text{capacity}\); otherwise **C**.
- Else **C**.

Interpretation: when stock isn’t super healthy, prioritize rebuilding unless exploitation is severe and stock can tolerate a brief deterrent.

---

### Rule D — Escalation against persistent exploiters (but capped)
Maintain a counter \(k\): consecutive bad rounds.

- If \(k \ge 2\) and \(S_t \ge S_{\text{safe}}\): **Play D** (continue deterrence).
- If \(k \ge 3\): switch to a “firm mode” for **2 rounds**: play **D** if \(S_t \ge S_{\text{safe}}\), else **C**.

Cap: never defect when \(S_t < S_{\text{low}}\). This prevents “mutual punishment” from driving the stock into collapse.

Reset: if \(p_{t-1} \le p_{\text{good}}\) for one round, set \(k = 0\) (rapid forgiveness).

---

## 2) Edge cases

### First round
**Play C.**  
Rationale: (i) establishes a cooperative baseline, (ii) if others are cooperative, it keeps stock at/near capacity, (iii) if others defect, you learn immediately and can respond next round.

### Last round (round \(r\))
If you only care about your own payoff, last-round defection is tempting. But you asked for a **collective** strategy suitable for a tournament against unknown AIs. Many strategies reciprocate and will punish earlier; consistent cooperation often yields higher total payoff over \(r\) rounds.

So:
- If \(p_{r-1} \ge p_{\text{bad}}\) and \(S_r \ge S_{\text{safe}}\): **Play D** (don’t be the only cooperator at the end).
- Otherwise: **Play C**.

This is a “collective-first, but not naive” endgame rule.

### If stock hits (or is near) zero
Always **C** until \(S_t\) rises above \(S_{\text{low}}\). The growth function can recover stock if remaining stock is not driven to 0 repeatedly; cooperation is the only stabilizer.

### Very small \(n\)
The thresholds use fractions; still, with \(n=2\), one opponent’s move flips \(p\) between 0 and 1. This strategy becomes essentially:
- cooperate unless the other defects (and stock is healthy), in which case defect briefly, then forgive quickly if they return to C.

---

## 3) Collective alignment (what this strategy “stands for”)
- **Sustainability first**: when the resource is threatened, always reduce extraction (C), even if others are misbehaving—because collapse harms everyone and removes future leverage.
- **Reciprocity with forgiveness**: punish only enough to discourage systematic free-riding, and forgive quickly to restore the high-stock cooperative regime.
- **State-aware enforcement**: deterrence happens mainly when the stock can afford it (near capacity). When it can’t, the strategy prioritizes rebuilding.

---

## Pseudocode (implementable)

```python
def SGR_action(t, S_t, capacity, n, history_actions):
    S_safe     = 0.80 * capacity
    S_low      = 0.50 * capacity
    S_critical = 0.25 * capacity
    p_bad      = 0.40
    p_good     = 0.15

    if t == 1:
        return "C"

    # compute p_{t-1}
    opp_defects = count_opponent_defections(history_actions[t-1])
    p_last = opp_defects / (n - 1)

    # update consecutive-bad counter k from stored state (or recompute)
    # bad if low stock last round OR many defected last round
    bad_last = (previous_stock < S_low) or (p_last >= p_bad)
    k = prev_k + 1 if bad_last else 0
    if p_last <= p_good:
        k = 0

    # resource-first safety
    if S_t <= S_critical:
        return "C"
    if S_t <= S_low:
        return "C"

    # escalation (only when stock healthy)
    if S_t >= S_safe and k >= 3:
        return "D"
    if S_t >= S_safe and k >= 2:
        return "D"

    # last round adjustment
    if t == r:
        if (p_last >= p_bad) and (S_t >= S_safe):
            return "D"
        else:
            return "C"

    # main policy by stock band
    if S_t >= S_safe:
        if p_last >= p_bad:
            return "D"   # one-shot punishment unless k causes escalation
        else:
            return "C"
    else:
        # intermediate stock
        if (p_last >= p_bad) and (S_t >= 0.65 * capacity):
            return "D"
        else:
            return "C"
```

---

### Why this should perform well in a tournament
- Against cooperators: converges to all-C, maintaining stock near capacity (high long-run payoffs).
- Against occasional defectors/noisy players: lenience + quick forgiveness avoids destructive retaliation cycles.
- Against persistent exploiters: state-conditional punishment reduces being a perpetual sucker without tanking the resource.
- Against “always defect”: you can’t save the resource alone, but you also don’t accelerate collapse when stock is low; you defect mainly when stock is high enough to make deterrence worthwhile.

If you want, I can also provide a stricter variant (more punitive) and a more prosocial variant (more forgiving) tuned for different expected opponent mixes.
'''

description_COLLECTIVE_91 = '''
## Strategy: **Stock-Guard with Forgiving Trigger (SGFT)**  
Goal: keep the stock in the high-growth, high-yield region (near capacity), while being hard to exploit and quick to recover cooperation when others allow it. The strategy is “collective” because it treats cooperation as the default and uses defection only as (i) a protective brake when the stock is endangered, or (ii) a calibrated sanction to restore cooperation.

---

# Intuition (why this works here)

- If everyone plays **C**, the stock tends to recover to **capacity** (stable and efficient).
- If too many play **D**, stock can crash to 0 and stay there, harming everyone.
- Your action affects two things: your immediate payoff and how fast the stock collapses or recovers.
- Since you can’t coordinate, your best leverage is **conditional cooperation**: cooperate when the group is behaving sustainably; defect as a **temporary punishment** or **emergency measure** when the group is not.

---

# Key quantities computed each round

Let:
- \(S_t\) = stock at start of round \(t\)
- From last round actions, compute:
  - \(d_{t-1}\) = number of opponents who defected (played D) in round \(t-1\)
  - \(D\_rate_{t-1} = d_{t-1}/(n-1)\)

Also define two stock thresholds (depend only on parameters):
- **Safe stock**: \(S_{\text{safe}} = 0.85 \times capacity\)
- **Danger stock**: \(S_{\text{danger}} = 0.55 \times capacity\)

And two defection-rate thresholds:
- **Tolerable defection**: \(\theta_{\text{low}} = 0.20\)  (a few mistakes/noise)
- **Serious defection**: \(\theta_{\text{high}} = 0.40\) (coordination breakdown)

These are chosen to be robust across n: they don’t assume “exactly k defectors”, but adapt by fraction.

---

# 1) Decision rules: when to Cooperate vs Defect

### Rule A — **Default to Cooperation when sustainable**
If stock is healthy and recent behavior is mostly cooperative, play **C**.

**Play C if:**
- \(S_t \ge S_{\text{safe}}\) **and**
- \(D\_rate_{t-1} \le \theta_{\text{low}}\) (or it’s round 1 with no history)

This promotes the collectively optimal steady state.

---

### Rule B — **Graduated sanction when others defect**
If recent defection is meaningful, punish with **D** to make defection unprofitable and push others back toward C.

**If \(D\_rate_{t-1} \ge \theta_{\text{high}}\):**  
Enter “punishment mode” for **P rounds**, where:
- \(P = 1 + \lceil 2 \times D\_rate_{t-1} \rceil\)  
So punishment lasts 2–3 rounds depending on how widespread defection was.

During punishment mode:
- Play **D** if \(S_t \ge S_{\text{danger}}\)
- Play **C** if \(S_t < S_{\text{danger}}\) (because the stock is too fragile to keep extracting hard)

This is collective: you punish when it can still be afforded; you stop punishing if it risks collapse.

---

### Rule C — **Emergency stock protection**
If the stock is low, prioritize recovery even if others are misbehaving, because mutual ruin dominates.

**If \(S_t < S_{\text{danger}}\): play C.**  
Rationale: With low stock, defection accelerates collapse, and your extra short-term gain is small compared to the loss of future rounds.

This rule makes the strategy robust against “death spirals”.

---

### Rule D — **Forgiveness / return-to-cooperation test**
After punishment mode ends, attempt to restore cooperation quickly.

- Play **C** for one “test” round if \(S_t \ge S_{\text{safe}}\).
- If defection remains high after the test (again \(D\_rate \ge \theta_{\text{high}}\)), re-enter punishment mode.

This prevents endless retaliation cycles and enables recovery when opponents are conditional cooperators.

---

# 2) Edge cases

### First round (t = 1)
- **Play C.**
Reason: sets a cooperative baseline and costs little when stock starts at capacity; also many strategies reciprocate.

### Last round (t = r)
There is end-game temptation to defect, but if everyone does so earlier, the stock may already be low. Use a mild end-game adjustment:

- If \(S_r \ge S_{\text{safe}}\) **and** last-round defection was non-serious (\(D\_rate_{r-1} \le \theta_{\text{low}}\)): **play C** (collective finish).
- Else: **play D** if \(S_r \ge S_{\text{danger}}\), otherwise **C**.

This avoids being the only cooperator in a final-round grab, while still protecting low stock.

### Stock exactly zero or extremely low
- Always **C**. (Defecting when \(S \approx 0\) yields negligible gain and worsens recovery odds in general.)

### Small n vs large n
Because the rule uses **defection rates** rather than counts, it scales with n without needing hand-tuning.

---

# 3) Collective alignment (what the strategy is “trying to do”)

This strategy treats the group as managing a renewable asset:

- **Cooperate by default** to keep stock near capacity where growth is strong.
- **Punish defection** to prevent free-riding from becoming the stable norm.
- **Stop punishing when stock is at risk** (collective risk management beats retribution).
- **Forgive quickly** to rebuild cooperation when possible.

It is not “nice at all costs” (so it won’t be exploited indefinitely), but it is also not “grim” (so it can recover from errors and noise).

---

## Pseudocode sketch

```python
# Parameters
S_safe   = 0.85 * capacity
S_danger = 0.55 * capacity
theta_low  = 0.20
theta_high = 0.40

punish_timer = 0

def action(t, S_t, history):
    global punish_timer

    if t == 1:
        return "C"

    # compute last-round defection rate among opponents
    d = count_opponent_defections(history[t-1])
    D_rate = d / (n-1)

    # Emergency protection
    if S_t < S_danger:
        punish_timer = 0  # stop punishment if any
        return "C"

    # If currently punishing
    if punish_timer > 0:
        punish_timer -= 1
        # punish only while stock isn't endangered (already ensured above)
        return "D"

    # Decide whether to start punishment
    if D_rate >= theta_high:
        punish_timer = 1 + ceil(2 * D_rate)  # 2-3 typically
        punish_timer -= 1
        return "D"

    # Default cooperation when sustainable
    if S_t >= S_safe and D_rate <= theta_low:
        return "C"

    # Middle zone: cautious cooperation
    # If stock is okay but trust is unclear, cooperate once to test.
    if S_t >= S_safe:
        return "C"

    # If stock is moderate and others showed some defection, be cautious:
    # defect to avoid being exploited, but not if close to danger (handled above).
    return "D"
```

This “middle zone” logic (moderate stock + some defection) is intentionally cautious: it prevents repeated exploitation, yet still cooperates whenever stock is clearly healthy.

---

If you share typical tournament opponent types you expect (e.g., always-D, tit-for-tat variants, random, “exploit then repent”), I can tune the thresholds and punishment length to that meta without changing the core collective philosophy.
'''

description_COLLECTIVE_92 = '''
## Collective Strategy: **Stock-Sustaining Generous Trigger (SSGT)**

Goal: maximize long-run total extraction by keeping the stock near a high, self-regenerating region, while remaining robust to selfish opponents by (i) not letting the resource collapse, (ii) punishing sustained over-extraction, and (iii) quickly forgiving once opponents return to sustainable behavior.

This strategy uses only: parameters `(n, r, capacity)`, current stock `S_t`, and full observed history of actions.

---

## Key idea (why this works collectively)
- The stock growth is logistic and can “refill” well when remaining stock is moderate-to-high.
- If too many players defect, the pool can crash to 0 and never recovers (because growth at 0 is 0).
- So the collective objective is: **keep remaining stock after consumption safely above 0** and preferably in a region where growth is strong, while discouraging repeated defection.

We implement:
1) **A sustainability rule**: cooperate when the stock is fragile.
2) **A reciprocity rule**: cooperate when others are mostly cooperating; punish when defection is excessive.
3) **A recovery rule**: once stock is endangered or has been hit, switch to conservative play that prevents collapse and rebuilds.

---

## Definitions computed each round
At round `t`, before choosing action, observe current stock `S`.

Let:
- `k_{t-1}` = number of defectors in previous round (from history). For `t=1`, set `k_0 = 0`.
- Sustainability thresholds:
  - **Danger stock**: `S_danger = 2n`  
    (near the minimum region; below this the system is extremely vulnerable and a single round of heavy defection may collapse it)
  - **Caution stock**: `S_caution = 0.25 * capacity`  
    (below this, we prioritize rebuilding and risk control)

Also define a “defection tolerance” based on the last observed behavior:
- `tol = floor((n-1)/2)`  (we tolerate up to about half defecting; more than that triggers punishment)

---

## Decision rules (when to cooperate vs defect)

### Rule 1 — **Never risk collapse (resource-first)**
If `S <= S_danger` then **play C** no matter what.

Rationale: when stock is low, defecting increases the probability the pool hits 0 (irreversible). The most collective action is to reduce extraction.

---

### Rule 2 — **Rebuild when stock is low (recovery mode)**
If `S_danger < S <= S_caution` then:
- If `k_{t-1} >= 1` (someone defected last round), **play C**.
- Else (everyone cooperated last round), **play C**.

So in recovery mode we **always play C**.

Rationale: below the caution threshold, the game is about avoiding depletion and letting growth do its work. Any defection pressure is met by not escalating extraction; we preserve the commons even if exploited—because collapse is worse for everyone.

---

### Rule 3 — **Reciprocal cooperation when stock is healthy**
If `S > S_caution` (healthy stock), use a generous reciprocal trigger:

- If `k_{t-1} == 0`: **play C** (reward full cooperation).
- If `1 <= k_{t-1} <= tol`: **play C** (be forgiving; don’t spiral into mutual defection).
- If `k_{t-1} > tol`: **play D** (punish when a majority over-extracts).

Rationale:  
- When only a few defect, continuing to cooperate helps keep the stock high and invites defectors back to cooperation.
- When many defect, cooperation becomes a sucker outcome and also enables rapid resource decline; a coordinated punishment signal (defect) is needed to change incentives.

---

### Rule 4 — **Punishment is state-limited (don’t punish into collapse)**
Even when Rule 3 would punish with `D`, override to `C` if stock is not comfortably high.

Concretely:
- If `S <= 0.5 * capacity`, then **play C** even if punishment is triggered.
- Only punish with `D` when `S > 0.5 * capacity`.

Rationale: punishment that accelerates depletion is self-defeating. We punish only when the stock buffer can absorb it.

---

## Edge cases

### First round (`t = 1`)
**Play C.**  
Rationale: sets a cooperative baseline and keeps stock maximal; also safe against unknown opponents because it preserves the resource.

### Last round (`t = r`)
Use a “final-round caution” to prevent endgame collapse:

- If `S <= 0.5 * capacity`: **play C**
- Else (stock very high): follow the normal rules (often still C unless major defection last round triggers D)

Rationale: Many strategies defect in the last round. We avoid contributing to irreversible collapse, especially if stock is not safely high.

### If stock ever hits 0
If `S == 0`, the game is locked at 0 forever (growth = 0). Actions no longer matter for payoffs (all payoffs 0).  
Strategy: **play C** (arbitrary, but consistent with collective stance).

---

## Pseudocode (implementable)

```python
def choose_action(t, S, history_actions, n, r, capacity):
    S_danger  = 2*n
    S_caution = 0.25*capacity
    tol = (n-1)//2

    if t == 1:
        return "C"

    # count defectors last round
    last_round = history_actions[t-1]  # list length n with "C"/"D"
    k = sum(1 for a in last_round if a == "D")

    # irreversible collapse
    if S == 0:
        return "C"

    # Rule 1: danger zone
    if S <= S_danger:
        return "C"

    # Rule 2: recovery zone
    if S <= S_caution:
        return "C"

    # Last-round caution
    if t == r and S <= 0.5*capacity:
        return "C"

    # Rule 3 + Rule 4: reciprocal with state-limited punishment
    if k <= tol:
        return "C"
    else:
        # punish only if stock buffer is large
        if S > 0.5*capacity:
            return "D"
        else:
            return "C"
```

---

## Why this is adaptive and robust in a tournament
- **Against cooperators**: converges to all-`C`, maintaining high stock and stable high long-run payoffs.
- **Against occasional defectors / noisy strategies**: remains cooperative (forgiving), preventing unnecessary collapse and avoiding retaliation spirals.
- **Against persistent defectors**: switches to `D` when safe to punish, signaling that exploitation won’t be rewarded—yet avoids punishing when the stock is at risk (so it doesn’t help defectors destroy the commons).
- **Against endgame defectors**: maintains conservative play when the stock is not clearly safe, reducing the chance of permanent depletion that harms everyone.

This is a “collective mindset” strategy because its primary invariant is: **never take actions that materially increase collapse risk when the stock is fragile**, while still applying **measured reciprocity** when the stock buffer makes punishment viable.
'''

description_COLLECTIVE_93 = '''
## Strategy: **Stock-Guard with Forgiving Reciprocity (SGFR)**  
Goal: keep the stock near a high, sustainable level (so everyone’s per-round payoffs stay large), while being robust to exploitation and to noise/experimentation by others. The strategy is *collective-minded*: it cooperates by default when the group appears willing to sustain the resource, and it escalates to defection only when needed to prevent being a “sucker” or to stop collapse.

---

# 1) Decision rules (C vs D)

### Key idea
Your action affects (i) your immediate payoff and (ii) the next round’s stock via total consumption. The “good” outcome is to keep the post-consumption stock in the region where logistic growth restores stock close to capacity.

Given current stock \(S\):  
- If a player plays **C** they take \(S/(2n)\).  
- If **D** they take \(S/n\) (twice as much).  
Total consumption depends on how many defect.

So we condition on **(a)** stock health and **(b)** whether others have recently over-consumed (defected).

---

## State variables from history
At round \(t\), you observe previous actions. Maintain:

- `defect_count_last`: number of players who played D in round \(t-1\).
- `defect_rate_recent`: fraction of Ds over a recent window \(W\) (e.g., last 5 rounds), across all opponents.
- `punish_timer`: integer ≥ 0. When positive, you defect for that many rounds to deter exploitation.
- `rebuild_mode`: boolean; true when stock is dangerously low and we should “go easy” to restore it.

Recommended constants (work across many n, r, capacity):
- `W = 5`
- `k_trigger = 1` (any defection triggers a response when stock is healthy)
- `punish_len = 2` (short punishment)
- `forgive_condition = 2 consecutive rounds with 0 defections`
- Stock thresholds (relative to capacity):
  - `S_high = 0.8 * capacity`
  - `S_mid  = 0.5 * capacity`
  - `S_low  = 0.25 * capacity`

(These are intentionally simple and parameter-based.)

---

## Core action rule

### A. **Rebuild priority when stock is low**
If stock is scarce, mutual defection can lock in collapse (stock hits 0 and stays 0). So when stock is low, be *collective-first*:

- If `S <= S_low`: **Play C** (unless it is the last round; see edge cases).  
  Rationale: when S is tiny, defection yields little extra anyway, and collective restraint is the only way back.

- If `S_low < S <= S_mid`:
  - If many others defected recently (e.g., `defect_rate_recent > 0.4`): **Play D** (avoid being exploited while others are not rebuilding).
  - Else **Play C** (try to restore).

### B. **Reciprocity when stock is healthy**
When `S > S_mid`, the stock can sustain cooperation and returns to capacity if consumption is moderate. Here we enforce norms:

- If `punish_timer > 0`: **Play D**, decrement timer.
- Else (no active punishment):
  - If `defect_count_last >= k_trigger` and `S > S_mid`: start punishment:
    - set `punish_timer = punish_len`
    - **Play D**
  - Else: **Play C**

### C. **Forgiveness / de-escalation**
After punishment, return to cooperation quickly if opponents do:

- If `punish_timer == 0` and the last `forgive_condition` rounds had **0 defections by anyone else**, revert fully to cooperative stance (i.e., follow the above rules without initiating new punishment unless new defections occur).

This makes the strategy robust to:
- one-off probing defections,
- mixed populations,
- strategies that learn over time.

---

# 2) Edge cases

### First round (t = 1)
- **Play C**.
  - Rationale: sets a cooperative baseline; with capacity initially high, C is consistent with maintaining the resource and gives room to detect opponent types without immediate collapse risk.

### Last round (t = r)
Finite-horizon unraveling is a risk: many strategies defect at the end. But blindly defecting last round can cause avoidable collapses in tournaments where others remain cooperative.

Use a stock-conditional last-round rule:

- If `S <= S_mid`: **Play C** (protect against irreversible collapse; D gains little when S is low).
- Else (`S > S_mid`):
  - If there was **any defection in the last 2 rounds** by others: **Play D**
  - Else: **Play C**

This keeps you cooperative when the group is clearly cooperating, but not naïve if endgame defection begins.

### Round r-1 (second-to-last)
Same as normal rules, but slightly more sensitive:
- If `S > S_mid` and `defect_count_last >= 1`, punish immediately (as usual).  
This helps deter “late defection waves”.

### Stock at/near zero
If `S == 0`, all payoffs are 0 regardless. Still:
- **Play C** (doesn’t matter directly, but keeps consistent “rebuild” posture if stock can recover—here it can’t recover from exactly 0 given the growth formula, but it avoids pointless escalation logic and is harmless).

---

# 3) Collective mindset (what the strategy is “trying” to do)
- **Sustain the commons** when possible (default cooperation).
- **Deter exploitation** with short, clear retaliation when stock is healthy (so defecting isn’t profitable).
- **Avoid mutual ruin spirals** by prioritizing rebuilding when stock is low (even if others are only partially cooperative).
- **Forgive quickly** once the population returns to restraint, maximizing long-run group payoff.

---

## Pseudocode (implementation-ready outline)

```python
# Parameters: n, r, capacity
W = 5
S_high = 0.8 * capacity
S_mid  = 0.5 * capacity
S_low  = 0.25 * capacity

k_trigger = 1
punish_len = 2
forgive_condition = 2

punish_timer = 0

def action(t, S, history):
    global punish_timer

    # helper stats from history
    defect_count_last = count_defections(history, round=t-1) if t > 1 else 0
    defect_rate_recent = recent_defection_rate(history, window=W, upto=t-1) if t > 1 else 0
    recent_any_defection_2 = any_defection(history, rounds=[t-1, t-2]) if t > 2 else (defect_count_last > 0)

    # First round
    if t == 1:
        return "C"

    # Last round special
    if t == r:
        if S <= S_mid:
            return "C"
        else:
            return "D" if recent_any_defection_2 else "C"

    # Low stock rebuild region
    if S <= S_low:
        return "C"

    if S <= S_mid:
        if defect_rate_recent > 0.4:
            return "D"
        else:
            return "C"

    # Healthy stock: reciprocity + punishment
    if punish_timer > 0:
        punish_timer -= 1
        return "D"

    if defect_count_last >= k_trigger:
        punish_timer = punish_len - 1  # counting this round as first punishment action
        return "D"

    # default cooperative
    return "C"
```

---

### Why this should do well in a tournament
- Against cooperators: stays at high stock, high long-run payoffs.
- Against occasional defectors / noisy learners: punishes briefly, then forgives—prevents long retaliatory cycles.
- Against persistent defectors: defects often enough to avoid being exploited, while still cooperating in low-stock states where defection is self-defeating.
- Against endgame defectors: doesn’t give away the final rounds if defections appear, but won’t cause needless collapse if the group remains cooperative.

If you tell me typical tournament settings (ranges for n, r, capacity) I can tune the thresholds (`S_low`, `S_mid`) and punishment length to better match the most common regimes.
'''

description_COLLECTIVE_94 = '''
## Strategy: **Stock-Guard GRIM with Forgiveness (SGGF)**  
Collective goal: keep the stock near **capacity** (where growth is high and sustainable) while defending against exploitation. The strategy is “cooperate by default when the stock is healthy, punish quickly when others over-consume, and forgive after a short, stock-aware probation.”

The key design idea is that in this game, *full cooperation* is self-sustaining at capacity (it returns to capacity), while too much defection can crash the stock to zero. So we treat **stock protection** as the primary collective norm and use **history-based punishment** as enforcement.

---

# 1) Decision rules (C vs D)

### Definitions observed each round \(t\)
- \(S_t\): stock at start of round \(t\).
- Let \(d_{t-1}\): number of opponents who played **D** in round \(t-1\) (i.e., among the other \(n-1\) players).
- Let \(\text{DefRate}_{t-1} = d_{t-1}/(n-1)\).

### Internal mode (state machine)
You maintain one of three modes:

1. **COOP mode**: play **C**.
2. **PUNISH mode**: play **D** for a fixed number of rounds.
3. **PROBATION mode**: play **C**, but watch closely; relapse triggers harsher punishment.

---

## Core triggers

### A. Stock safety rule (stock-first collective protection)
- If stock is **low**, prioritize rebuilding and avoid “finishing it off.”
- Let  
  - **Low-stock threshold**: \(S_t \le S_{\text{low}} := 2n\) (the max stock bound in your state definition; also a natural danger zone).
  - **Critical-stock threshold**: \(S_t \le S_{\text{crit}} := n\).

**Action under low stock:**
- If \(S_t \le S_{\text{crit}}\): play **C** regardless of history (defecting here tends to collapse remaining stock and kills future payoffs).
- Else if \(S_t \le S_{\text{low}}\): play **C** unless you are currently in **PUNISH** and punishment time remains **and** last round had heavy defection (see “punishment override” below).

Interpretation: even if others are nasty, when stock is critically low the collective move is to cooperate to allow regrowth.

---

### B. Exploitation detection rule (when to punish)
When stock is not in the critical zone (so punishment won’t destroy the resource), punish defection to deter free-riding.

Trigger punishment if **either**:
1. **Any defection in previous round**, AND stock is not low:  
   - If \(d_{t-1} \ge 1\) and \(S_t > S_{\text{low}}\), then enter punishment with severity depending on how many defected.
2. **Stock collapse signal** (detect coordinated overconsumption):  
   - If \(S_t\) dropped “too much” compared to \(S_{t-1}\) given what you observed, treat it as defection-heavy and punish. (This catches weird edge cases/implementation noise.)

### Punishment severity (adaptive, stock-aware)
Let punishment length be:
\[
L = \text{clamp}\Big(1 + \lceil 2\cdot \text{DefRate}_{t-1}\cdot (n-1)\rceil,\ 1,\ 4\Big)
\]
Practical interpretation:
- If 1 opponent defects: short punishment (1–2 rounds).
- If many defect: longer punishment (up to 4 rounds).

**During PUNISH mode:** play **D** each round, but with a stock-protection override:
- If \(S_t \le S_{\text{crit}}\): play **C** (don’t torch the resource).
- Otherwise play **D**.

---

### C. Forgiveness rule (how we return to collective play)
After completing \(L\) punishment rounds:
- Enter **PROBATION** for \(F=2\) rounds:
  - Play **C**.
  - If **any** opponent defects during probation and \(S_t > S_{\text{low}}\), immediately re-enter **PUNISH** with **+1** extra round (capped at 4).

If probation passes with no observed defection (or stock is low so punishment would be self-harm), return to **COOP**.

This yields a “forgiving grim trigger”: quick to punish, but not permanently locked, and sensitive to stock health.

---

# 2) Edge cases

### First round (t = 1)
- Play **C**.
Rationale: sets the cooperative baseline and avoids needless early depletion; you cannot infer anything yet.

### Last round (t = r)
- Still follow the same rules, **except**:
  - If you are in **COOP/PROBATION** and the history shows persistent defection (e.g., in the last 2 rounds, at least half of opponents defected) **and** stock is healthy \(S_r > S_{\text{low}}\), then play **D**.
Rationale: with no future, deterrence is weaker; but we only take the endgame defection when (i) others already demonstrated non-cooperation and (ii) stock isn’t in the fragile zone.

### Very small stock (S near 0)
- Always **C** when \(S_t \le S_{\text{crit}}=n\).  
Rationale: defecting when stock is tiny gives little immediate gain and prevents regrowth.

### If everyone else always defects
- You will: C initially → punish → oscillate with stock-aware cooperation when the resource is critical.
This is robust: you avoid being the sucker forever, while not accelerating total collapse when the stock is near-zero.

### If there is one occasional defector among cooperators
- You punish briefly and then return to cooperation; the cost is limited, and occasional mistakes don’t permanently destroy cooperation.

---

# 3) Collective mindset made explicit

This strategy enforces three collective principles:

1. **Resource primacy:** When the shared stock is fragile, cooperate even against defectors to preserve the possibility of future collective gains.
2. **Reciprocity with proportional accountability:** Any defection triggers a visible consequence (punishment), scaled to how widespread defection was.
3. **Restoration over vendetta:** Forgive after a short, structured probation to recover cooperation quickly and keep the stock near capacity.

---

## Pseudocode (implementable)

```python
# Parameters: n, r, capacity
S_low  = 2*n
S_crit = n
MAX_PUNISH = 4
F = 2  # probation length

mode = "COOP"
punish_left = 0
prob_left = 0
extra_punish_bonus = 0  # increments on relapse, capped implicitly

def choose_action(t, S_t, history):
    global mode, punish_left, prob_left, extra_punish_bonus
    
    # Helper: observe last round defections among others
    if t == 1:
        last_defections = 0
        defrate = 0.0
        last2_majority_defection = False
    else:
        last_defections = count_opponents_D(history[t-1])
        defrate = last_defections / (n-1)
        if t >= 3:
            last2_majority_defection = (
                (count_opponents_D(history[t-1]) >= (n-1)/2) and
                (count_opponents_D(history[t-2]) >= (n-1)/2)
            )
        else:
            last2_majority_defection = False

    # Stock-protection override: critical stock => cooperate
    if S_t <= S_crit:
        return "C"

    # Last round adjustment (only if others clearly non-cooperative and stock healthy)
    if t == r and mode in ["COOP", "PROBATION"] and last2_majority_defection and S_t > S_low:
        return "D"

    # State machine
    if mode == "PUNISH":
        if punish_left > 0:
            punish_left -= 1
            if S_t <= S_low:
                return "C"  # avoid harming a low stock
            return "D"
        else:
            mode = "PROBATION"
            prob_left = F

    if mode == "PROBATION":
        # If defection observed and stock not low, relapse => harsher punish
        if t > 1 and last_defections >= 1 and S_t > S_low:
            mode = "PUNISH"
            extra_punish_bonus = min(extra_punish_bonus + 1, 2)  # mild escalation
            L = min(MAX_PUNISH, 2 + extra_punish_bonus)
            punish_left = L
            if S_t <= S_low:
                return "C"
            return "D"
        prob_left -= 1
        if prob_left <= 0:
            mode = "COOP"
        return "C"

    # mode == "COOP"
    # If defection observed and stock not low => punish proportionally
    if t > 1 and last_defections >= 1 and S_t > S_low:
        mode = "PUNISH"
        extra_punish_bonus = 0
        L = int(max(1, min(MAX_PUNISH, 1 + (2 * last_defections))))
        punish_left = L
        if S_t <= S_low:
            return "C"
        return "D"

    # Otherwise cooperate
    return "C"
```

If you want, I can tune the thresholds/length formulas specifically for tournaments with known \(n, r, capacity\) ranges (e.g., making punishment depend on remaining rounds, or using a more precise “expected stock next round” computation).
'''

description_COLLECTIVE_95 = '''
## Strategy: **Stock‑Guarded, Forgiving Trigger (SGFT)**  
Goal: keep the resource near the sustainable “high stock” region (where growth can refill), while being hard to exploit by persistent defectors and still able to recover cooperation after mistakes.

Key idea:  
- When stock is healthy, default to **C** to maintain regeneration and long-run payoffs.  
- If others over-consume (too many **D**) or stock falls into danger, temporarily **D** to (i) avoid being the sole sucker and (ii) force a reset dynamic (either everyone defects to zero, or others return to C).  
- Use a *forgiving but not naive* rule: you return to C after a short “penalty phase” **only if** the group shows enough recent cooperation and the stock is recovering.

---

# 1) Decision rules (C vs D)

### Observables each round \(t\)
- Current stock \(S_t\)
- History of actions: for each player \(j\), action \(a_{j,t-1}\in\{C,D\}\)
- Let \(d_{t-1}\) = number of opponents (excluding you) who played **D** last round  
  (or use total \(D\)s including you, but excluding you is cleaner)
- Let \(D\_rate\_{t-1} = d_{t-1}/(n-1)\)

### Internal state you maintain
- `penalty` (integer ≥ 0): remaining rounds you will play D as retaliation
- `trust` (float in [0,1]): exponentially-weighted estimate of cooperation level

Update `trust` after observing last round:
- Let \(c_{t-1}\) = number of opponents who played **C** last round
- Instant cooperation fraction: \(q_{t-1} = c_{t-1}/(n-1)\)
- Update: `trust = (1-α)*trust + α*q_{t-1}`, with \(α = 0.3\)

---

## Thresholds derived from parameters (no tuning to opponents)
We want simple, robust cutoffs:

- **Safe stock level**:  
  \(S_{\text{safe}} = 0.8 \cdot \text{capacity}\)  
  (Above this, playing C tends to keep things near capacity if most cooperate.)

- **Danger stock level**:  
  \(S_{\text{danger}} = 0.4 \cdot \text{capacity}\)  
  (Below this, you prioritize avoiding being exploited and preventing slow death spirals.)

- **Overconsumption trigger** (how many defections you tolerate):  
  Tolerate at most a *minority* of defectors.  
  Define: `D_tolerated = floor((n-1)/3)`  
  If more than that defect, punish.

- **Penalty length**:  
  `L = 2` if \(r\) is small, else `L = 3`. Concretely:  
  `L = 2 if r <= 10 else 3`  
  (Short enough to be forgiving, long enough to discourage one-off exploitation.)

---

## Core action rule

### A. If in penalty phase → play D
If `penalty > 0`: play **D**, decrement `penalty -= 1`.

### B. Otherwise (not currently punishing), decide using stock + recent behavior

Play **C** if all are true:
1. Stock is not in danger: \(S_t \ge S_{\text{danger}}\)
2. Recent defections are limited: \(d_{t-1} \le D_{\text{tolerated}}\)
3. Trust is decent: `trust >= 0.6` **or** last round had near-unanimous cooperation (`d_{t-1} == 0`)

Else play **D**.

### C. When to start penalty
If last round’s defections were “too many” or stock is falling into danger, start punishment:
- If \(d_{t-1} > D_{\text{tolerated}}\) **or** \(S_t < S_{\text{danger}}\):  
  set `penalty = L` and play **D** now.

### D. Forgiveness / returning to cooperation
After penalty ends, you do **not** immediately trust again unless evidence supports it:
- You return to cooperation when:
  - \(S_t \ge S_{\text{safe}}\) **and**
  - last round defections were small: \(d_{t-1} \le 1\) (for any n) **or** `trust >= 0.7`

This allows recovery from noise but prevents getting stuck cooperating while others repeatedly defect.

---

# 2) Edge cases

## First round (t = 1)
- Play **C**.
- Initialize `trust = 1.0` (optimistic start), `penalty = 0`.
Rationale: Cooperation at high initial stock is collectively optimal and gives others a chance.

## Last round (t = r)
Unlike a standard repeated PD, the *state* (stock) affects earlier payoffs, but last-round incentives still push toward D. However, unconditional last-round defection destroys collective outcomes in tournaments if others are cooperative (and many strategies retaliate).  
Rule:
- If `trust >= 0.75` and \(S_t \ge S_{\text{safe}}\): play **C** in last round.
- Otherwise play **D**.

This makes you “end cooperatively” only in clearly cooperative groups, and opportunistic otherwise.

## Stock at/near zero
If \(S_t\) is extremely low (e.g., \(S_t \le 0.05\cdot capacity\)):
- Play **D** (it doesn’t help to be the only cooperator; payoffs are tiny anyway).
- You will only resume C after stock recovers above \(S_{\text{danger}}\) *and* trust improves.

## Very small n (e.g., n = 2)
Then `D_tolerated = floor(1/3)=0`. So *any* opponent defection triggers penalty. This is appropriate: in n=2, a single defector is already a large overuse shock.

## Very short horizons (small r)
If \(r \le 5\):
- Use `L = 2` and require slightly higher trust to cooperate late:
  - For rounds \(t \ge r-1\), cooperate only if `trust >= 0.8` and \(S_t \ge S_{\text{safe}}\).

---

# 3) “Collective mindset” justification
This strategy is collective in three concrete ways:

1. **Default cooperative stewardship at healthy stock**: it actively tries to keep the stock in the regenerative regime (near capacity), which maximizes total long-run extraction opportunities.

2. **Conditional punishment to deter free-riding**: punishment is not vindictive; it is short, rule-based, and aimed at restoring cooperation by making defection less profitable over time.

3. **State-aware conservation**: when stock drops toward danger, it stops “donating” to defectors and shifts to defensive play until recovery is plausible—preventing a slow collapse where cooperators carry the cost.

---

# Pseudocode (implementable)

```python
# Parameters: n, r, capacity
S_safe   = 0.8 * capacity
S_danger = 0.4 * capacity
D_tolerated = (n-1) // 3
alpha = 0.3
L = 2 if r <= 10 else 3

# State
penalty = 0
trust = 1.0
last_defectors = 0  # opponents who played D last round (unknown for t=1)

def choose_action(t, S_t, opp_actions_prev):  # opp_actions_prev list length n-1 for t>1
    global penalty, trust, last_defectors
    
    if t == 1:
        penalty = 0
        trust = 1.0
        return "C"

    # update stats from previous round
    d = sum(1 for a in opp_actions_prev if a == "D")
    c = (n-1) - d
    q = c / (n-1)
    trust = (1 - alpha) * trust + alpha * q
    last_defectors = d

    # last round rule
    if t == r:
        if trust >= 0.75 and S_t >= S_safe:
            return "C"
        else:
            return "D"

    # penalty phase
    if penalty > 0:
        penalty -= 1
        return "D"

    # start penalty if needed
    if d > D_tolerated or S_t < S_danger:
        penalty = L - 1  # counting this round as first punishment action
        return "D"

    # cooperate conditions
    if S_t >= S_danger and d <= D_tolerated and (trust >= 0.6 or d == 0):
        return "C"
    else:
        return "D"
```

---

If you tell me typical tournament settings (common values of n, r, capacity) I can tighten the thresholds (e.g., pick stock cutoffs based on the game’s exact growth/consumption map rather than fixed 0.8/0.4 fractions) while keeping the same collective logic.
'''

description_COLLECTIVE_96 = '''
## Strategy: **Stock-Guardian with Forgiving Reciprocity (SGFR)**  
Collective objective: keep the stock near a high, self-renewing level while deterring exploitation. The strategy cooperates by default, escalates to defection when over-harvesting is detected (to avoid being the “sucker”), and returns to cooperation once behavior and stock recover.

Key design idea:  
- When the stock is healthy, *mutual cooperation* is sustainable and yields high long-run payoffs.  
- Defection is individually tempting but can collapse the stock.  
- Because actions are binary, enforcement must be simple: punish over-harvesters and stock-threatening play, but forgive after recovery to re-enable cooperation.

---

# 1) Decision rules (C vs D)

### Compute these each round \(t\) from history and current stock \(S_t\):

**A. “How cooperative was the group last round?”**  
Let \(k_{t-1}\) = number of players who played **C** in round \(t-1\). (Everyone observes actions.)

**B. “Is the stock in danger?”**  
Use two stock thresholds (depend only on parameters):
- **Safe threshold**: \(S_{\text{safe}} = 0.8 \cdot \text{capacity}\)  
- **Danger threshold**: \(S_{\text{danger}} = 0.5 \cdot \text{capacity}\)

(These are deliberately coarse; they work across many capacities and \(n\).)

**C. “Who is exploiting?”**  
Track for each opponent \(j\) a rolling “defection count” over the last \(W\) rounds, where \(W = \min(5, t-1)\).  
Let \(d_j\) = number of times \(j\) played **D** in those \(W\) rounds.

---

## Core rule set

### Rule 0 — Default cooperate (collective baseline)
If there is no strong reason to punish or protect the resource, play **C**.

### Rule 1 — Immediate resource protection
If the stock is low, prioritize preventing collapse:
- If \(S_t \le S_{\text{danger}}\): play **C** (even if others defect).  
Rationale: when the stock is low, defection accelerates collapse; cooperating maximizes chance of regrowth and keeps the game alive.

### Rule 2 — Triggered punishment for over-harvesting
If stock is not in the danger zone, punish when evidence suggests the group is over-harvesting:
- If \(S_t > S_{\text{danger}}\) **and** \(k_{t-1} \le n-2\) (i.e., at least **2** defectors last round), play **D** for a short punishment burst.

Punishment length (deterministic, history-based):
- Set punishment horizon \(P = 2\) rounds if \(S_t \ge S_{\text{safe}}\)  
- Set \(P = 1\) round if \(S_{\text{danger}} < S_t < S_{\text{safe}}\)

During punishment, play **D**.

Rationale:  
- With multiple defectors, unconditional cooperation is exploited.  
- Short, non-eternal punishment makes you hard to farm but still allows return to cooperation.

### Rule 3 — Targeted escalation if a persistent defector exists
Even if only one player defects occasionally, you need deterrence against “always defect” types. Use a stricter trigger:
- If there exists any opponent \(j\) with \(d_j / W \ge 0.6\) (defected in ≥60% of last \(W\) rounds),
  - and \(S_t \ge S_{\text{safe}}\): play **D** (one-round warning/punish)
  - otherwise: play **C** (don’t worsen stock when it’s not safe)

Rationale: persistent defectors can be “taxed” when stock is abundant; when stock is middling/low, focus on recovery.

### Rule 4 — Forgiveness / return to cooperation
Return to **C** when both conditions hold:
- The last round had high cooperation: \(k_{t-1} \ge n-1\) (at most one defector), **and**
- The stock is not falling sharply: \(S_t \ge S_{t-1}\) (weak recovery/steady condition)

Rationale: you don’t want to lock into mutual defection spirals; forgiveness restores collective gains once the environment stabilizes.

---

# 2) Edge cases (first round, last round, etc.)

### Round 1
Play **C**.
- Starting stock is at capacity; cooperation is sustainable and invites collective equilibrium.
- Also avoids needlessly triggering retaliation from conditional cooperators.

### Last round \(t=r\)
Play **D** **only if** either:
- You are currently punishing (punishment burst active), **or**
- Last round had ≥2 defectors: \(k_{r-1} \le n-2\)

Otherwise play **C**.

Rationale: end-game incentives favor defection, but unconditional last-round defection destroys cooperation with strategies that condition on the end. This rule defects only when cooperation is already broken, while preserving collective tone when the group is cooperating.

### Stock near zero
If \(S_t\) is extremely low (e.g., \(S_t < 0.1\cdot \text{capacity}\)), always play **C** regardless of history.
- Defecting when stock is near zero yields tiny immediate gains and risks keeping the system collapsed.

### Punishment overlap
If multiple triggers suggest punishment, do not extend punishment indefinitely. Cap continuous punishment to **2** rounds, then re-evaluate using Rules 1–4.
- Prevents deadlock vs noisy or mixed populations.

---

# 3) “Collective mindset” clarity

This strategy is collective in three explicit ways:

1. **Cooperation-first**: it opens with **C** and returns to **C** quickly when the group behaves well.  
2. **Resource stewardship**: when stock is low, it refuses to “race to the bottom” and instead plays **C** to restore the shared resource.  
3. **Deterrence not vengeance**: punishment is short, triggered by clear over-harvesting signals, and capped to avoid mutual destruction. The goal is to *shift incentives back toward cooperation*, not to maximize short-term relative advantage.

---

## Pseudocode sketch

```python
# parameters: n, r, capacity
S_safe   = 0.8 * capacity
S_danger = 0.5 * capacity

punish_timer = 0  # internal state
history_actions = []  # list of list: actions[t][player]

def decide(t, S_t, S_prev, history_actions):
    global punish_timer

    if t == 1:
        return "C"

    # Observe last round cooperation count
    last = history_actions[t-1]
    k_last = count_C(last)

    # Rolling defection rates
    W = min(5, t-1)
    persistent_defector = False
    for j in opponents:
        d_j = count_D_over_last_W(j, history_actions, W)
        if d_j / W >= 0.6:
            persistent_defector = True
            break

    # If currently punishing, continue
    if punish_timer > 0:
        punish_timer -= 1
        return "D"

    # Rule 1: resource protection
    if S_t <= S_danger or S_t < 0.1 * capacity:
        return "C"

    # Rule 2: punish multi-defection
    if k_last <= n - 2:
        punish_timer = 2 if S_t >= S_safe else 1
        punish_timer -= 1
        return "D"

    # Rule 3: persistent defector
    if persistent_defector and S_t >= S_safe:
        return "D"

    # Rule 4: forgiveness / recovery
    # (If we reached here, default cooperate)
    return "C"

def last_round_adjustment(t, r, base_action, k_last, punish_timer):
    if t != r:
        return base_action
    if punish_timer > 0 or k_last <= n - 2:
        return "D"
    return "C"
```

---

### Why this is robust in tournaments
- Works with unconditional cooperators (stays cooperative; preserves stock).
- Doesn’t get endlessly exploited by frequent defectors (punishes when exploitation is evident).
- Avoids “mutual defection traps” by capping punishment and forgiving when conditions improve.
- Reacts to the ecological state (stock), not only to actions—important because the state mediates long-run payoffs.

If you want, I can also provide a variant tuned to be *more* exploit-resistant (harsher punishment) or *more* cooperation-seeking (higher forgiveness), depending on what kinds of opponents you expect in the tournament.
'''

description_COLLECTIVE_97 = '''
## Strategy: **Stock-Guardian with Graduated Retaliation (SGGR)**  
Goal: keep the common stock near *capacity* (where everyone can earn high payoffs every round), while staying hard to exploit by short-term defectors. The strategy uses only parameters `(n, r, capacity)`, current `stock S`, and full history of observed actions.

Key idea:  
- **Cooperate by default** when the stock is healthy and others are not over-consuming.  
- **Punish** (defect) when over-consumption threatens the resource, but **forgive quickly** once behavior improves.  
- Maintain a **stock safety floor** and an **accounting of “excess take”** by others relative to a cooperative baseline.

---

# 1) Decision rules (C vs D)

### Definitions (computed each round before choosing action)
Let current stock be `S` (start-of-round).  
Per-round consumption levels:
- If you play `C`: you take `S/(2n)`
- If you play `D`: you take `S/n`

**Cooperative baseline total consumption** (if all played C):  
- `Cons_C_all = S/2`

**Maximum sustainable target:** keep stock high. From the growth function, stock replenishes strongly when remaining stock is around half capacity, but you also want *high per-round payoffs*, which scale with `S`. The sweet spot is: **don’t let S crash**, and push it back up to near `capacity`.

### Track opponent “excess take” (history-based)
For each past round `t`, you can compute actual total consumption from observed actions:
- If `k_t` players defected in round `t` (including you), then  
  `TotalCons_t = (n-k_t)*S_t/(2n) + k_t*S_t/n = S_t/2 + (k_t * S_t)/(2n)`

So **excess consumption beyond full cooperation** is:
- `Excess_t = TotalCons_t - S_t/2 = (k_t * S_t)/(2n)`

You don’t need to attribute perfectly by player; you just need an aggregate “pressure” signal. Maintain an exponentially decayed score:

- `Pressure ← λ*Pressure + (k_last / n)` where `λ ∈ [0.6, 0.9]` (use `λ=0.8`)

Interpretation: `Pressure≈0` means near-full cooperation recently; `Pressure≈1` means near-all defection recently.

---

## Action rule (core)
Use **two triggers**: (A) stock safety, (B) exploitation pressure.

### A) Stock safety trigger (resource protection)
Define a stock floor:
- `S_low = capacity * 0.35`
- `S_high = capacity * 0.80`

Rules:
- If `S ≤ S_low`: **play C** (protect/restore stock; defecting here accelerates collapse and reduces future payoffs dramatically).
- If `S ≥ S_high`: rely more on pressure trigger (below).

Why cooperate even when low? Because defection when low tends to push stock toward zero (catastrophic). Cooperation at low stock sacrifices some immediate payoff but preserves the possibility of recovery and future gains.

### B) Pressure trigger (anti-exploitation)
Let:
- `p = Pressure` (in [0,1] roughly)
- Set thresholds that scale with `n`:
  - `p_forgive = 0.15`
  - `p_punish  = 0.35`

Rules when `S_low < S < S_high` or `S ≥ S_high`:
- If `p ≤ p_forgive`: **play C**
- If `p ≥ p_punish`: **play D**
- If `p_forgive < p < p_punish`: **mix based on stock**:
  - If `S ≥ 0.6*capacity`: **play D** (stronger stance; you can afford punishment while stock is ample)
  - Else: **play C** (prioritize rebuilding stock)

This makes you:
- Cooperative with mostly cooperative groups.
- Tough with frequent defectors.
- Adaptive in mixed environments without a brittle fixed pattern.

---

# 2) Edge cases

### Round 1 (no history)
- **Play C**.
Rationale: With stock initially at `capacity`, mutual C sustains max stock and sets a cooperative baseline. Starting with D can trigger mutual collapse spirals against conditional cooperators.

Initialize:
- `Pressure = 0`

### Last round (round r)
Classic backward induction would suggest defection, but tournament opponents may use reciprocity rules and punish late defection in earlier rounds if they anticipate it. Since you **cannot coordinate on endgame**, use this rule:

- If `S ≤ S_low`: **play C** (avoid final-round resource crash is irrelevant, but this also avoids “panic D” spirals that reduce your *current* payoff if others respond earlier; here it’s last round though—still C is fine because when S is low, D vs C doesn’t change S’s effect on your immediate payoff except via your own multiplier, but you’re already in low stock and prior rules matter).
- Else (S > S_low):
  - If `Pressure ≤ 0.25` (cooperative environment): **play C**
  - Else: **play D**

So: you don’t automatically defect at the end; you condition on whether others have been cooperative. This is robust against “grim-trigger” and similar strategies that punish endgame opportunism earlier.

### Stock extremely low (`S` near 0)
- Always **C** (there’s almost nothing to gain by defecting anyway; both C and D yield tiny payoffs, but D increases the chance stock hits 0 and never recovers).

### Stock at capacity with persistent defectors
- Your pressure trigger will shift to **D**. This prevents being the “sucker” forever. With enough defectors, the stock falls, and once it approaches `S_low`, you return to **C** to prevent irreversible collapse. This “punish-while-safe, rebuild-when-dangerous” pattern is the core robustness feature.

---

# 3) Collective mindset (why this is collective and robust)

**Collective intent:** keep stock high so the group earns high payoffs repeatedly.  
- Full cooperation at high stock can keep stock at capacity (as in your example), maximizing long-run total payoff.

**Robustness:** does not assume shared norms.  
- Against cooperators: quickly converges to all-C and stays there.  
- Against occasional defectors: punishes proportionally, then forgives when behavior improves.  
- Against persistent defectors: defects when stock is safe to avoid being exploited, but switches back to cooperation when the resource is threatened to maintain future value.

**Not brittle:** no fixed schedule, no “if round is even do X”. It reacts to observed defection frequency and the ecological state.

---

# Pseudocode (implementable)

```python
# Parameters
S_low  = 0.35 * capacity
S_high = 0.80 * capacity
lambda_ = 0.8
p_forgive = 0.15
p_punish  = 0.35

# State variable stored by the strategy
Pressure = 0.0

def choose_action(round_t, S, history_defectors_last_round_count):
    global Pressure

    # Update pressure from last round (skip if t==1)
    if round_t > 1:
        k_last = history_defectors_last_round_count  # number of D observed last round
        Pressure = lambda_ * Pressure + (k_last / n)

    # Round 1
    if round_t == 1:
        return "C"

    # Stock safety rule
    if S <= S_low:
        return "C"

    # Pressure-based rule
    p = Pressure
    if p <= p_forgive:
        return "C"
    if p >= p_punish:
        # last-round refinement handled below; otherwise punish
        action = "D"
    else:
        # intermediate: trade off stock vs exploitation
        if S >= 0.60 * capacity:
            action = "D"
        else:
            action = "C"

    # Last round refinement
    if round_t == r:
        if S <= S_low:
            return "C"
        if Pressure <= 0.25:
            return "C"
        return "D"

    return action
```

---

If you want, I can tune the numeric thresholds (`0.35, 0.80, 0.15, 0.35, λ=0.8`) analytically for specific `(n, capacity, r)` regimes (e.g., small n vs large n), but the above is a solid general-purpose tournament policy.
'''

description_COLLECTIVE_98 = '''
## Strategy: **Stock-Guard Trigger (SGT)**  
A collective-minded strategy that (i) keeps the resource at/near capacity when others are willing, (ii) applies fast, unmistakable punishment when others over-extract, and (iii) recovers back to cooperation as soon as it is safe—without requiring coordination, signaling, or prearranged schedules.

Key idea: because payoffs scale with current stock \(S\), the group benefits most by keeping \(S\) high. But unilateral defection gives a one-round gain and can crash the stock. So we:  
- **Cooperate by default** when the group seems safe.  
- **Defect as a punishment/containment** when extraction is too high (to avoid being a sucker and to discipline defectors).  
- **Return to cooperation** after a short, clearly-defined “probation” period once behavior improves.

---

# 1) Decision rules (C vs D)

### Observables each round \(t\)
- Current stock \(S_t\).
- Last round actions of all players \(\{a_{j,t-1}\}\) (perfect monitoring).
- From actions, infer last round’s number of defectors:  
  \[
  k_{t-1}=\#\{j: a_{j,t-1}=D\}
  \]

### Derived “safe-to-cooperate” thresholds
Total consumption fraction depends only on \(k\):  
- Cooperator consumes \(S/(2n)\), defector consumes \(S/n\).  
- Total consumption = \( (n-k)\cdot S/(2n) + k\cdot S/n = \frac{n+k}{2n}S \)  
- Remaining stock after consumption:
  \[
  S^{rem} = S\left(1-\frac{n+k}{2n}\right)=S\cdot\frac{n-k}{2n}
  \]
Let \(x = S^{rem}/capacity\). Growth is logistic: \(2S^{rem}(1-x)\). This regrows strongly when \(x\) is around 0.5 and collapses when \(S^{rem}\) is near 0.

**Practical implication:**  
- If **everyone cooperates** (\(k=0\)), stock returns to capacity in one step from capacity (as in your example).  
- If **everyone defects** (\(k=n\)), remaining is 0 ⇒ irreversible collapse.  
- If many defect, remaining becomes small, growth weakens, and stock can spiral down.

So we treat “too many defectors” as an emergency and punish.

---

## Core rule set

### Rule A — First-round stance (optimistic collective start)
- **Round 1: play C.**  
Rationale: establishes the high-stock trajectory if others are even moderately cooperative, and costs little if they are not (we can punish quickly).

---

### Rule B — Stock emergency protection
If the stock is already low, prioritize immediate containment/punishment:

- Define a **stock floor**:
  \[
  S_{\text{low}} = 0.35 \cdot capacity
  \]
- If \(S_t \le S_{\text{low}}\): **play D**.

Rationale: when stock is low, we treat the situation as a crisis: we stop “being nice” and apply strong pressure. Also, if others are defecting, cooperating just accelerates depletion.

---

### Rule C — Defection tolerance based on recent behavior (collective but not naive)
Outside emergency low-stock:

- Compute \(k_{t-1}\) = # defectors last round.
- Use a **tolerance threshold**:
  \[
  k_{\text{tol}} = \max\left(1,\left\lfloor 0.2n \right\rfloor\right)
  \]
(At least 1, about 20% of the group.)

Decision:
- If \(k_{t-1} \le k_{\text{tol}}\): **play C** (keep the commons healthy; don’t overreact to one-off noise).
- If \(k_{t-1} > k_{\text{tol}}\): **enter punishment mode** (Rule D).

Rationale: Collective mindset means you don’t collapse cooperation because of a single “mistake,” but you also don’t tolerate a large coalition exploiting cooperators.

---

### Rule D — Punishment mode (clear, finite, and resettable)
When triggered (too many defectors, or low stock), we punish for a fixed number of rounds, then test for recovery.

- Punishment length:
  \[
  L = 2 \;+\; \left\lceil \log_2(n)\right\rceil
  \]
Maintain an internal counter `punish_remaining`.

Behavior:
- While `punish_remaining > 0`: **play D**, decrement each round.
- After punishment ends: go to **probation** (Rule E).

Rationale: finite punishment prevents permanent deadlock, but long enough to make defection unprofitable in repeated play and to deter “bursty” exploiters.

---

### Rule E — Probation / recovery test (return to collective play fast)
After punishment ends, we don’t immediately trust the group; we test:

- For the next \(P=2\) rounds (probation window):
  - If in each probation round, observed \(k_{t-1} \le k_{\text{tol}}\) **and** \(S_t > S_{\text{low}}\): **play C**.
  - If a probation round fails (too many defectors or low stock): re-enter punishment mode (Rule D).

Rationale: This is “forgiving” but only when the environment supports rebuilding the stock.

---

# 2) Edge cases

### Last round (round \(r\))
In a known finite horizon, pure game theory predicts end-game unraveling. But in tournaments, many strategies still cooperate if you don’t “announce” the final defection too early.

**Last-round rule:**
- If the immediately previous round had \(k_{r-1} \le k_{\text{tol}}\) and \(S_r > S_{\text{low}}\): **play C**.
- Otherwise: **play D**.

Rationale: maintain collective behavior against cooperative populations; protect yourself if the group has already broken down.

---

### Near-end (rounds close to \(r\))
Do **not** automatically defect in the final few rounds (that invites others to do the same and reduces your own payoffs via lower stock). The above rules already adapt to breakdowns.

---

### If the stock hits zero
If \(S_t = 0\), both actions yield 0 that round. Still:
- Keep following the rules (typically D due to low stock), since cooperation cannot regenerate stock unless some stock remains after consumption. If it’s exactly zero, nothing helps; but consistent punishment prevents being exploited if stock becomes positive later (e.g., if rules/params differ across matches).

---

### If others alternate / “chisel” (occasional defection)
This is why \(k_{\text{tol}}\) is nonzero and punishment is triggered only when defection is widespread. One or two defectors in a large group won’t collapse stock immediately; we maintain cooperation to preserve the high-stock path.

---

# 3) “Collective mindset” alignment (why this is collective)
- **Default is cooperation** to keep stock near capacity, maximizing long-run total surplus.
- **Punishment is state- and history-based**, not spite: it is triggered when extraction threatens the commons (many defectors or low stock).
- **Forgiveness is built in**: after a finite punishment, the strategy actively tests whether cooperation is viable and returns to C quickly.
- **No reliance on coordination**: it uses only observable actions/stock and simple thresholds.

---

# Pseudocode (implementation-ready outline)

```python
# Parameters: n, r, capacity
k_tol = max(1, int(0.2 * n))                  # tolerance
S_low = 0.35 * capacity                       # emergency floor
L = 2 + ceil(log2(n))                         # punishment length
P = 2                                         # probation length

punish_remaining = 0
probation_remaining = 0

def choose_action(t, S_t, last_actions):  # last_actions is list of n actions from t-1, or None if t==1
    global punish_remaining, probation_remaining

    if t == 1:
        return "C"

    k_last = count_D(last_actions)

    # Emergency: low stock
    if S_t <= S_low:
        punish_remaining = max(punish_remaining, L)  # ensure punishment engaged
        probation_remaining = 0

    # If currently punishing
    if punish_remaining > 0 reminder:
        punish_remaining -= 1
        if punish_remaining == 0:
            probation_remaining = P
        return "D"

    # If in probation (testing recovery)
    if probation_remaining > 0:
        if (k_last <= k_tol) and (S_t > S_low):
            probation_remaining -= 1
            return "C"
        else:
            punish_remaining = L
            probation_remaining = 0
            punish_remaining -= 1
            if punish_remaining == 0:
                probation_remaining = P
            return "D"

    # Normal mode
    if k_last <= k_tol and S_t > S_low:
        # Last round special-case: keep cooperative if group cooperative, else protect self
        if t == r:
            return "C"
        return "C"
    else:
        punish_remaining = L
        punish_remaining -= 1
        if punish_remaining == 0:
            probation_remaining = P
        return "D"
```

---

If you tell me typical tournament settings (ranges for \(n\), \(r\), and capacity), I can tune the constants (0.35, 0.2, punishment length) for better performance under those distributions.
'''

description_COLLECTIVE_99 = '''
## Collective, Adaptive, Robust Strategy: **Stock-Guard with Graduated Reciprocity (SGGR)**

Goal: sustain the common stock near its efficient region (high stock implies high per-round payoffs for everyone) while being robust to exploitation. The strategy cooperates by default, escalates quickly when others over-consume, and forgives when behavior improves and the stock is healthy again.

Key idea: treat “defection” as *excess extraction relative to the collective-sustainable target*. Because actions are only {C,D}, we detect over-extraction via observed actions and/or realized stock change, then respond with **graduated punishment** and **stock-based emergency rules**.

---

# 1) Decision rules (when to cooperate vs defect)

### Definitions (known each round \(t\))
- Parameters: \(n, r, capacity\)
- Observed state at start of round: \(S_t\)
- Observed history: actions in all prior rounds (who played C/D), and stocks if available.
- Let \(D_{t-1}\) = number of opponents (not you) who defected last round.
- Let \(\text{DefRate}_{t-1} = D_{t-1}/(n-1)\)

### Stock zones
We use three stock zones based on what’s “safe” vs “at risk”:

- **Healthy:** \(S_t \ge 0.75 \cdot capacity\)  
- **Caution:** \(0.40 \cdot capacity \le S_t < 0.75 \cdot capacity\)  
- **Critical:** \(S_t < 0.40 \cdot capacity\)

(These thresholds are intentionally simple and robust across \(n\) and capacities.)

### Core cooperation logic
You choose **C** unless one of the following triggers indicates that (a) you’re being exploited or (b) the group is heading toward collapse and you need to protect yourself.

#### Trigger A — Emergency self-protection (Critical stock)
If **Critical** stock: play **D**.

Rationale: when stock is low, the marginal risk of collapse is high and unilateral cooperation may just subsidize others. Also, the system’s logistic growth is weakest near 0 and strongest around capacity/2; if you’re already below 0.4 capacity, you need strong deterrence to stop further drain.

#### Trigger B — Graduated reciprocity to observed overuse (Healthy/Caution stock)
If stock is not Critical, respond to the recent defection level with a **defection probability** (or deterministic threshold if you want no randomness):

- If **Healthy**:
  - Cooperate unless \(\text{DefRate}_{t-1} \ge 0.50\).  
  - If \(\text{DefRate}_{t-1} \ge 0.50\): play **D** for punishment.
- If **Caution**:
  - Cooperate unless \(\text{DefRate}_{t-1} \ge 0.25\).  
  - If \(\text{DefRate}_{t-1} \ge 0.25\): play **D**.

Rationale: in Caution, even a minority of defectors can push the stock downward; so the strategy becomes stricter.

#### Trigger C — “Personal exploitation” guardrail
Even if group defection is low, if the *same opponent(s)* defect repeatedly, punish more. Track each opponent’s defection streak length \(streak_j\). Let:
- \(MaxStreak_{t-1} = \max_j streak_j\)

If \(MaxStreak_{t-1} \ge 2\) and stock is not Critical, play **D** this round.

Rationale: prevents being farmed by a small set of persistent defectors.

---

# 2) Edge cases (first round, last round, transitions)

### Round 1
Play **C**.

Rationale: establishes cooperative baseline and maximizes chance of reaching a high-payoff path when others are also conditional cooperators. The stock starts at capacity (best possible), so there’s no immediate emergency.

### Last round (round r)
Play **D** unless *both* conditions hold:
1. Stock is **Healthy**, and  
2. \(\text{DefRate}_{r-1} = 0\) (everyone cooperated last round)

Otherwise play **D**.

Rationale: classic endgame problem—others may defect in the last round. This rule still allows “full collective finish” if the group has proven fully cooperative right before the end.

### Forgiveness / returning to cooperation
After you defect (punishment), you return to **C** when:
- Stock is **Healthy**, and
- \(\text{DefRate}_{t-1} = 0\)

If stock is **Caution**, require two consecutive rounds of \(\text{DefRate}=0\) before returning to C.

Rationale: “forgive, but only after credible improvement,” stricter when the resource is fragile.

---

# 3) Clearly collective mindset (what the strategy is optimizing)

The strategy is explicitly designed to:
- **Maintain stock near capacity** (high shared surplus, stable growth).
- **Deter over-consumption** via rapid, proportional retaliation.
- **Allow recovery** by forgiving once cooperation resumes—so the group can return to the efficient path.
- **Avoid unilateral sacrifice** when the resource is near collapse or when exploitation is detected.

It does *not* attempt to win a one-shot payoff at the expense of the stock unless (i) it is the final round, or (ii) the group is already acting in ways that threaten collective sustainability.

---

# Pseudocode (implementable)

```pseudo
Input each round t: S_t, history of actions, r, n, capacity

If t == 1:
    return C

Compute DefRate_prev = (# opponents who played D in round t-1) / (n-1)
Compute MaxStreak_prev = max over opponents of consecutive D up to round t-1

Healthy = (S_t >= 0.75 * capacity)
Caution = (0.40 * capacity <= S_t < 0.75 * capacity)
Critical = (S_t < 0.40 * capacity)

# Last round rule
If t == r:
    If Healthy and DefRate_prev == 0:
        return C
    else:
        return D

# Emergency rule
If Critical:
    return D

# Exploitation guard
If MaxStreak_prev >= 2:
    return D

# Graduated reciprocity by stock zone
If Healthy:
    If DefRate_prev >= 0.50:
        return D
    else:
        return C

If Caution:
    If DefRate_prev >= 0.25:
        return D
    else:
        # extra forgiveness requirement: if you defected recently, wait for stability
        If (you played D in round t-1) and (DefRate_prev > 0):
            return D
        else:
            return C
```

---

## Why this performs well in a tournament
- Against cooperators/conditional cooperators: quickly converges to all-C with stock near capacity (max long-run payoff).
- Against noisy strategies: doesn’t overreact to a single defection when stock is Healthy; stricter when stock is vulnerable.
- Against persistent defectors: escalates punishment quickly (streak rule) to avoid being exploited.
- Against collapse dynamics: Critical-stock rule prioritizes stopping further losses and discourages “race to the bottom.”
- Endgame robustness: last-round defection is protected, but full cooperation is still rewarded if the group stays perfectly cooperative.

If you want, I can also provide an alternative variant that uses the *observed stock transition* (expected vs actual) to infer hidden over-consumption/implementation noise, but with your stated perfect observability of actions, the above is usually the most stable and simple.
'''

description_COLLECTIVE_100 = '''
## Strategy: **Stock-Guarded, Forgiving Trigger (SGFT)**  
Collective intent: keep the stock near its sustainable region (close to `capacity`) while resisting exploitation. Default to cooperation when the group is behaving; switch to defection quickly when others over-consume, but return to cooperation once the stock and behavior recover.

This is essentially **“cooperate unless (a) the resource is in danger, or (b) others are persistently taking more than their fair share)”** with a short, state-dependent punishment.

---

# 1) Decision rules (C vs D)

### Key observation the strategy uses
Given stock `S_t` at start of round `t`:

- If everyone plays **C**: total consumption = `S_t/2`, remaining = `S_t/2`, growth pushes back toward `capacity`. This is sustainable and often returns stock near capacity.
- If too many play **D**, remaining stock can crash toward 0 and growth can’t recover quickly.

So the strategy tries to keep the system near the “all-C” basin, and punish deviations enough to make defection unattractive.

---

## Variables computed from history
At the start of round `t`, you know:
- `S_t`: current stock
- From last round’s action profile you can infer `kD_{t-1}` = number of defectors last round (because actions are observed).
- Maintain a simple “temperature” that summarizes recent overuse:
  - `badness` (nonnegative integer)

### Parameters (depend only on n, r, capacity)
- **Safe stock threshold:**  
  `S_safe = 0.6 * capacity`  
  (Above this, the system has buffer; below this, prioritize survival.)
- **Critical stock threshold:**  
  `S_crit = 0.3 * capacity`  
  (Below this, assume emergency.)
- **Defection tolerance (how many Ds we forgive without retaliation):**  
  `D_tol = floor(n/4)`  
  (Up to ~25% defectors can happen by noise/experimentation; don’t instantly collapse cooperation.)
- **Punishment length base:**  
  `P_base = 1`  
- **Punishment length scale:**  
  `P_scale = 1 + floor(n/3)`  
- **Recovery requirement (good rounds needed to reset):**  
  `G = 2` consecutive “good” rounds

You also maintain:
- `punish_timer` (integer, starts 0)
- `good_streak` (integer, starts 0)

---

## Round-by-round decision logic

### Rule A — Emergency stock protection (state-based)
If the stock is getting dangerously low, cooperate becomes less valuable long-run, but full defection can finish the collapse. We use a *protective stance*:

- If `S_t <= S_crit`: **Play C**  
  Rationale: at very low stock, the best collective action is to reduce extraction. Defecting here is individually tempting but destroys any chance of recovery.

- Else if `S_crit < S_t <= S_safe`:  
  **Play C unless you are currently punishing** (see Rule C).  
  Rationale: in the vulnerable zone, prioritize rebuilding and only punish if needed.

### Rule B — Normal zone (behavior-based cooperation)
If `S_t > S_safe` and not punishing: **Play C**, unless recent behavior shows systematic over-consumption.

Define last round as “good” if `kD_{t-1} <= D_tol`. Otherwise “bad”.

Update:
- If last round was good: `good_streak += 1`, and reduce `badness = max(0, badness - 1)`
- If last round was bad: `good_streak = 0`, and increase `badness += (kD_{t-1} - D_tol)`

If not currently punishing and `badness > 0`, enter punishment (Rule C).

### Rule C — Punishment (short, proportional, and escapable)
When punishment is triggered, set:
- `punish_timer = P_base + min(P_scale, badness)`  

During punishment:
- If `S_t <= S_crit`: **override and play C** (don’t burn the resource down)
- Else: **Play D** while `punish_timer > 0`, decrement each round.

Exit punishment when `punish_timer == 0`.

### Rule D — Forgiveness / return to cooperation
After punishment ends:
- Require `good_streak >= G` *or* stock has recovered: `S_t >= 0.9*capacity`
- Then reset `badness = 0` and continue cooperating.

This prevents endless vendettas and lets the population return to a cooperative attractor once behavior improves.

---

# 2) Edge cases

### First round (t = 1)
- **Play C.**  
Rationale: creates maximum chance of coordination on the cooperative equilibrium, and with full stock it is also collectively optimal.

Initialize:  
`punish_timer = 0`, `badness = 0`, `good_streak = 0`.

### Last round (t = r)
You might think “always defect” in the last round, but if everyone reasons that way it back-propagates and collapses early. Tournament performance usually rewards sustaining the resource.

So:
- **If `S_r > S_safe` and history is mostly cooperative (badness == 0 and punish_timer == 0): play C.**
- **Otherwise (resource vulnerable or opponents exploitative): play D** unless `S_r <= S_crit` (then play C to avoid total collapse, which can still matter if scoring includes state or if implementation errors exist).

This keeps the strategy collectively oriented but not naive.

### If everyone defects early and stock hits ~0
When `S_t` is very low:
- Always **C** (Rule A).  
If others keep defecting, you can’t fix it alone, but cooperating is the only action that doesn’t actively worsen recovery potential (and it avoids wasting punishment cycles when the system is already broken).

### If opponents alternate / try to exploit forgiveness
The badness accumulator + proportional punishment handles periodic exploitation: repeated “bad” rounds keep `badness` elevated, so punishment re-triggers quickly and for longer, reducing the exploiter’s advantage.

---

# 3) Why this is “collective” and robust
- **Collective-first default:** cooperates whenever the group is not clearly over-consuming and stock is healthy.
- **State-aware:** protects the common pool when stock is low (won’t “revenge defect” into collapse).
- **Robust to defectors:** punishes in a way that makes sustained defection less profitable, but doesn’t permanently lock into mutual defection.
- **Forgiving:** returns to cooperation after a short demonstration of restraint or after the stock recovers.
- **No coordination assumptions:** uses only observed actions and the public stock.

---

# Pseudocode (implementable)

```python
# parameters
S_safe = 0.6 * capacity
S_crit = 0.3 * capacity
D_tol  = n // 4
P_base = 1
P_scale = 1 + (n // 3)
G = 2

# stateful memory
punish_timer = 0
badness = 0
good_streak = 0

def act(t, S_t, last_actions):  # last_actions None if t==1
    global punish_timer, badness, good_streak

    # --- update from last round history ---
    if t > 1:
        kD = sum(1 for a in last_actions if a == 'D')
        if kD <= D_tol:
            good_streak += 1
            badness = max(0, badness - 1)
        else:
            good_streak = 0
            badness += (kD - D_tol)

        # trigger punishment if not currently punishing
        if punish_timer == 0 and badness > 0 and S_t > S_crit:
            punish_timer = P_base + min(P_scale, badness)

    # --- emergency override ---
    if S_t <= S_crit:
        return 'C'

    # --- if punishing ---
    if punish_timer > 0:
        punish_timer -= 1
        return 'D'

    # --- normal cooperation unless still clearly unsafe and exploited ---
    if S_t <= S_safe:
        return 'C'

    # --- forgiveness condition ---
    if good_streak >= G or S_t >= 0.9 * capacity:
        badness = 0

    # last-round nuance
    if t == r:
        if badness == 0 and S_t > S_safe:
            return 'C'
        else:
            return 'D'

    return 'C'
```

This policy is simple, collective, adaptive to the stock dynamics, and behaves well across a wide variety of opponent types (always-defect, mostly-cooperate, noisy, grim-trigger, opportunistic, alternating, etc.).
'''

description_COLLECTIVE_101 = '''
### Strategy: **Stock-Guardian with Graduated Sanctions (SGGS)**  
Goal: keep the stock near the high-yield “safe” region (near capacity) by **cooperating by default**, but **punishing over-consumption enough to make further defection unprofitable**, then **forgiving quickly** once others return to restraint. The strategy is **state-based** (depends on current stock) and **history-based** (depends on recent defections).

Key intuition:
- If everyone plays **C**, stock regenerates strongly and stays high; long-run total payoffs are maximized.
- A defector gets an immediate gain, but reduces future stock. We respond with **targeted punishment** (temporary defection) when it matters, especially when stock is fragile.
- Because opponents may be arbitrary, we **don’t** assume coordination schedules. We use only observed actions and stock.

---

## 1) Decision Rules: when to Cooperate vs Defect

We track two things from history:
- `D_last`: number of players who defected last round (0…n)
- `streak`: how many consecutive rounds *someone* defected (or alternatively, a rolling count of defections in last W rounds)

We also compute a **stock safety level**:
- Let `S` be current stock at start of the round.
- Define `S_high = 0.8 * capacity`
- Define `S_low  = 0.5 * capacity`
- Define `S_crit = 0.25 * capacity`

These thresholds make the strategy robust across capacities because they scale with `capacity`.

### Core policy (overview)
1. **If stock is healthy (S ≥ S_high):** cooperate unless defection becomes persistent.
2. **If stock is moderate (S_low ≤ S < S_high):** cooperate if others were cooperative; punish if recent defections occurred.
3. **If stock is low (S_crit ≤ S < S_low):** punish more readily (defect) to deter further damage, but forgive as soon as compliance returns.
4. **If stock is critical (S < S_crit):** defect (a “protective retaliation” mode) until others stop defecting, then revert to cooperation. Rationale: when near collapse, you must strongly disincentivize continued defection, or the resource never recovers.

### Graduated punishment (how hard to punish)
Let `p = D_last / n` be last-round defection rate.

We compute a **punishment intensity** (how many rounds to retaliate) that increases with (a) how many defected, (b) how low the stock is:

- Base retaliation length:
  - `L_base = ceil(2 * p * n)`  (≈ proportional to number of defectors)
- Stock multiplier:
  - If `S < S_low`, add +1
  - If `S < S_crit`, add +2 more
- Total:
  - `L = clamp(L_base + stock_add, 0, L_max)`
  - Choose `L_max = 4` (keeps you from spiraling into endless mutual defection)

We maintain an internal counter `punish_remaining`. If it’s > 0, we defect and decrement it.

### Forgiveness rule
If **no one defected** last round (`D_last == 0`), then:
- Set `punish_remaining = 0` immediately (fast forgiveness)
- Cooperate (unless last round / endgame special rule says otherwise)

This keeps the strategy from getting stuck punishing after cooperation resumes.

### Exploitation guard (anti-sucker)
If exactly **one player defects repeatedly** while others cooperate, naive forgiveness can be exploited. So we add:

- Keep `same_pattern_count`: number of times in last `W=5` rounds where `D_last == 1`.
- If `same_pattern_count ≥ 3` and `S < S_high`, treat it as “persistent exploitation” and set `punish_remaining = max(punish_remaining, 2)`.

This makes “lone wolf” defection costly without overreacting to one-off noise.

---

## 2) Edge Cases

### First round
- **Play C**.
Reason: With no history, cooperation maximizes the chance to establish a high-stock path; also reveals opponent tendencies at low cost because initial stock is high.

### Last round (round r)
- **If stock is high (S ≥ S_high):** play D (endgame harvest).
- **Otherwise:** play C **unless** you are in active punishment (`punish_remaining > 0`), in which case play D.

Rationale: In the final round there is no future stock to protect, so harvesting can be individually rational. But if stock is already low, defecting yields little anyway and can be dominated by keeping consistent incentives if others are still reacting (some strategies punish last-round defection in their own internal scoring even if it doesn’t matter materially; staying calm can avoid “meta” retaliation in tournaments that include quirks).

### Second-to-last round (round r-1)
- If `S ≥ S_high` and recent defection is nonzero, **punish once** (D) only if `D_last` was substantial (e.g., `D_last ≥ n/2`). Otherwise cooperate.
This avoids triggering endgame cascades while still deterring blatant last-minute raids.

### Stock at (near) zero
If `S` is extremely small, the immediate payoff difference between C and D is also small. Still:
- If `D_last > 0`, defect (signal punishment).
- If `D_last == 0`, cooperate (help reset to stable mutual cooperation if others are trying).

---

## 3) “Collective mindset” alignment

This strategy is explicitly collective because:
- **Default is cooperation** to sustain the pool at high stock where everyone’s per-round payoffs are largest over time.
- **Punishment is temporary and proportional**, aimed at restoring cooperation, not maximizing short-term extraction.
- **State sensitivity** protects the commons more aggressively when it’s most vulnerable (low stock), matching the collective objective of avoiding collapse.
- **Quick forgiveness** re-establishes the cooperative equilibrium as soon as possible, preventing long mutually destructive punishment cycles.

---

## Pseudocode (implementable)

```python
# Parameters: n, r, capacity
S_high = 0.8 * capacity
S_low  = 0.5 * capacity
S_crit = 0.25 * capacity
L_max  = 4
W = 5

punish_remaining = 0
history_D_last = []   # store D_last values for last W rounds

def decide_action(t, S, D_last):
    global punish_remaining, history_D_last

    # Update rolling history
    history_D_last.append(D_last)
    if len(history_D_last) > W:
        history_D_last.pop(0)

    # Fast forgiveness
    if D_last == 0:
        punish_remaining = 0

    # If currently punishing, continue
    if punish_remaining > 0:
        punish_remaining -= 1
        return "D"

    # Endgame
    if t == r:
        if S >= S_high:
            return "D"
        else:
            return "C"

    # Exploitation guard
    same_pattern_count = sum(1 for x in history_D_last if x == 1)
    if same_pattern_count >= 3 and S < S_high:
        punish_remaining = max(punish_remaining, 2)
        punish_remaining -= 1
        return "D"

    # If someone defected last round, set graduated punishment depending on stock
    if D_last > 0:
        p = D_last / n
        L_base = math.ceil(2 * p * n)  # ~ 2*D_last
        stock_add = 0
        if S < S_low:  stock_add += 1
        if S < S_crit: stock_add += 2
        L = min(max(L_base + stock_add, 1), L_max)  # at least 1
        punish_remaining = L - 1
        return "D"

    # Otherwise cooperate by default
    return "C"
```

---

### Why this should do well in a tournament
- Against cooperators: quickly converges to all-C (high long-run payoffs).
- Against occasional/noisy defectors: proportional punishment stabilizes cooperation without overreacting.
- Against persistent defectors: doesn’t stay a sucker; escalates to frequent D, limiting losses.
- Across capacities and n: stock thresholds scale with capacity; punishment scales with number of defectors.

If you want, I can also provide a variant that is more “collective-pure” (never defects except as retaliation) or more “tournament-hard” (more aggressive endgame and exploitation detection), depending on expected opponent mix.
'''

description_COLLECTIVE_102 = '''
## Strategy: **Stock-Guarded, Forgiving Reciprocity (SGFR)**  
Goal: keep the resource near the regenerative sweet spot (high stock), while being hard to exploit by persistent defectors. The strategy is *collective by default* (cooperate when the group seems sustainable), but switches to *resource protection* (defect) when others over-consume or the stock becomes endangered.

Key idea: use the observed history to infer how many players defected last round, and respond with a **forgiving but firm** rule that (a) returns to cooperation quickly after accidents, (b) escalates against repeated over-consumption, and (c) prioritizes saving the stock when it is low.

---

# 1) Decision rules: when to cooperate vs defect

### Definitions (computed each round before acting)
Let:
- `S` = current stock at start of the round.
- From last round’s public actions, let `k` = number of defectors (players who played D) in the previous round.  
  (If first round, `k` undefined.)
- `S_safe = capacity / 2` (high regeneration region).
- `S_low = capacity / 4` (danger zone; recovery is slower if people keep over-consuming).
- `K_allow = floor((n-1)/2)` (tolerate up to about half defectors before punishing).
- Maintain an internal counter `streak_bad` = number of **consecutive** rounds (immediately preceding the current round) where `k > K_allow` or stock was in danger (`S < S_safe`).

### Core rule (cooperative baseline, conditional punishment)
At round `t`:

**A. Stock-protection override (resource first):**
- If `S <= S_low`: **Play D.**  
  Rationale: when stock is dangerously low, unilateral cooperation can be exploited and does not prevent collapse if others defect. Defecting here both deters exploitation and can shorten the “time to discipline” persistent defectors (so the group either reforms or the game ends quickly rather than slow-draining).

**B. Normal region (`S > S_low`): choose based on last round’s behavior**
- If `t == 1`: **Play C** (see edge cases below).
- Else (have `k` from last round):
  1. **If `k == 0` and `S >= S_safe`:** Play **C**.  
     (All cooperated and stock is healthy—stay collective.)
  2. **If `k <= K_allow` and `S >= S_safe`:** Play **C**.  
     (Forgive minority defection when stock can handle it.)
  3. **If `k > K_allow` or `S < S_safe`:** Play **D** for a “punishment burst” whose length grows with repeated bad behavior:
     - Compute `punish_len = 1 + min(2, streak_bad)` (so 1–3 rounds max).
     - If you are still inside an active punishment burst: **D**, otherwise return to **C** once conditions improve.

### How `streak_bad` and punishment bursts work (firm but not grim)
- After each round ends (observing actions and new stock):
  - If (`k > K_allow`) OR (`S_next < S_safe`): `streak_bad += 1`
  - Else: `streak_bad = max(streak_bad - 1, 0)` (gradual forgiveness)
- When you enter punishment mode, you defect for `punish_len` rounds **unless** stock becomes very healthy *and* defections drop to zero, in which case you stop early (forgiving reset).

This creates an adaptive cycle:
- Mostly cooperate when the group is sustainable.
- If too many defect, you defect briefly to remove the incentive to exploit.
- If they come back to cooperation, you quickly return to cooperation.

---

# 2) Edge cases

### First round (`t = 1`)
**Play C.**  
Reason: the stock starts at capacity, cooperation is collectively optimal, and you gain information about the population. Starting with D makes you an early exploiter and can trigger retaliation spirals from reciprocal strategies.

### Last round (`t = r`)
Still follow the same rule (no “final-round defection” by default).  
Reason: your tournament opponents may use reciprocity based on last actions. An unconditional last-round D invites preemptive endgame defection dynamics and can reduce total payoff even within the final few rounds if others anticipate it. If stock is critically low (`S <= S_low`), the override already defects.

### If history is noisy / missing
If you cannot reliably observe actions for some reason (shouldn’t happen per spec), fall back to stock-only:
- If `S >= S_safe`: C
- Else if `S > S_low`: mix C and D with probability leaning to C (e.g., C with 0.7)
- If `S <= S_low`: D

### If stock hits 0
You get 0 payoff regardless; growth is also 0. Continue to play D (doesn’t matter), but the strategy will already do so due to `S <= S_low`.

---

# 3) Collective mindset: why this is “collective” yet robust
- **Collective by default:** It cooperates whenever the stock is in a healthy region and defections are limited—this sustains high future payoffs for everyone.
- **Protects the commons:** Uses stock thresholds (`capacity/2`, `capacity/4`) to avoid sliding into regimes where collapse becomes likely under mixed play.
- **Reciprocal and deterrent:** If a majority defects, it punishes quickly so defecting is not a stable exploit.
- **Forgiving:** It returns to cooperation after short punishment bursts; a single bad round doesn’t trigger permanent collapse.
- **No coordination assumptions:** It requires only observed past actions and stock; no schedules, signaling, or shared norms.

---

## Pseudocode (implementation-ready outline)

```python
# Parameters: n, r, capacity
S_safe = capacity / 2
S_low  = capacity / 4
K_allow = (n - 1) // 2

streak_bad = 0
punish_remaining = 0

def act(t, S, last_actions):
    global punish_remaining

    # Stock-protection override
    if S <= S_low:
        return "D"

    # First round
    if t == 1 or last_actions is None:
        return "C"

    k = count_defectors(last_actions)  # number of Ds last round

    # If in a punishment burst, continue
    if punish_remaining > 0:
        punish_remaining -= 1
        return "D"

    # Cooperative region
    if S >= S_safe and k <= K_allow:
        return "C"

    # Otherwise start punishment burst (length depends on repeated issues)
    punish_len = 1 + min(2, streak_bad)  # 1..3
    punish_remaining = punish_len - 1
    return "D"

def update_after_round(S_next, last_actions):
    global streak_bad, punish_remaining
    k = count_defectors(last_actions)

    bad = (k > K_allow) or (S_next < S_safe)
    if bad:
        streak_bad += 1
    else:
        streak_bad = max(streak_bad - 1, 0)

    # Early forgiveness: if everything looks great, stop punishment
    if S_next >= S_safe and k == 0:
        punish_remaining = 0
        streak_bad = 0
```

This strategy is designed to score well against:
- Always-Cooperate (you mostly cooperate too, sustaining stock),
- Always-Defect (you quickly defect too; you can’t save the commons alone),
- Tit-for-tat / reciprocal variants (you align quickly after brief corrections),
- Mixed / noisy opponents (stock thresholds prevent naive exploitation).
'''

description_COLLECTIVE_103 = '''
## Strategy: **Stock-Guarded Reciprocal Cooperation (SGRC)**  
Goal: keep the stock near the sustainable “sweet spot” (high growth, high future payoffs) while punishing exploitation quickly and recovering cooperation when opponents do. The strategy is *collective*: it treats the common pool as the primary asset and uses defection mainly as a *control lever* (deterrence + emergency stabilization), not as a default.

Key ideas:
- The stock’s logistic growth is maximized at **S = capacity/2**; keeping **S high but not repeatedly driven to 0** is essential.
- If everyone cooperates, stock tends to recover (often to capacity) and total long-run payoffs are large.
- One-round defection always gives an immediate boost, so you need **reciprocity and credible punishment**.
- With finite horizon, end-game defection is tempting; we mitigate by switching to “harvest mode” near the end *only if* the stock is healthy.

---

# 1) Decision rules (when to cooperate vs defect)

### Variables tracked from history/state (public information)
At round `t` with current stock `S_t`:
- `k_{t-1}` = number of opponents who defected last round (from observed actions).
- `D_rate` = exponentially weighted moving average of opponent defection rate.  
  Example update: `D_rate ← 0.7*D_rate + 0.3*(k_{t-1}/(n-1))`
- `punish_left` = remaining rounds of a punishment phase (internal counter).
- `S_ratio = S_t / capacity`
- `is_low_stock = (S_ratio < 0.35)`  (emergency region)
- `is_mid_stock = (0.35 ≤ S_ratio < 0.70)`
- `is_high_stock = (S_ratio ≥ 0.70)`

### Core behavior
**A. Default: cooperate when the group is behaving and stock isn’t in emergency.**  
- If `punish_left == 0` and `k_{t-1} == 0` and `S_ratio ≥ 0.35`: **Play C**.

**B. Punish defections quickly, but proportionally, and stop when others stop.**  
- If any opponent defected last round (`k_{t-1} > 0`), enter a punishment phase:
  - Set `punish_left = P`, where  
    `P = min(3, 1 + floor(2 * k_{t-1} / (n-1)))`  
    (1 round punishment for a single defector; up to 3 if many defect.)
- During punishment phase:
  - If `S_ratio < 0.35` (stock emergency): **Play C** (don’t “burn the commons” further).
  - Else: **Play D** while `punish_left > 0`.
  - Decrement `punish_left` each round.
- **Forgiveness / de-escalation:** If in punishment but *no one defects* in the most recent round, shorten punishment:
  - `punish_left = min(punish_left, 1)`  
  (i.e., punish at most one more round after peace is observed).

**C. Emergency stock protection (collective priority over retaliation).**  
If `S_ratio < 0.35`, then regardless of history:
- **Play C** unless it is the very last round (see edge cases).  
Rationale: when stock is low, defection accelerates collapse; cooperation maximizes chance to regrow.

**D. Persistent exploitation response (if others keep defecting).**  
If `D_rate > 0.5` (others mostly defect) and `S_ratio ≥ 0.35`:
- **Play D** (you cannot unilaterally sustain the resource; best response is to take what you can while it lasts).

**E. Cooperation restoration / testing.**  
If `D_rate` has fallen below `0.25` and `S_ratio ≥ 0.35`, then:
- Prefer **C** (even if there was earlier conflict), unless currently in a punishment step that you still must execute.

This creates a loop: cooperate → punish if exploited → forgive if peace returns → protect stock if low.

---

# 2) Edge cases

### First round (t = 1)
- **Play C**.  
Reason: establishes cooperative baseline; with stock initially at capacity, mutual C is self-sustaining and high-payoff.

Initialize:
- `D_rate = 0`
- `punish_left = 0`

### Last round (t = r)
In a finite horizon, there is no future stock to protect. Still, behavior depends on opponents:
- If `S_ratio < 0.35`: **Play D** (salvage value; regrowth won’t matter).
- Else if opponents were mostly cooperative recently (`D_rate < 0.25` and `k_{r-1} == 0`): **Play C** *or* **D**?  
For tournament robustness, choose **D** in the last round when stock is not low. This prevents being the “sucker” to a common last-round grab.
  - So: if `S_ratio ≥ 0.35`: **Play D** in the last round.

### Second-to-last round (t = r-1)
- If `S_ratio ≥ 0.70` and `D_rate < 0.25`: **Play C** (keep cooperation one more round; avoids triggering pre-terminal unraveling).
- If opponents defected in round `r-2` or `D_rate ≥ 0.25`: follow normal rules (punish or D).

### Very small capacity / parameter corner
Given capacity ≥ 2n, the model avoids pathological “too small to sustain” cases. Still:
- When `S_ratio` low, always prioritize **C** before last round.
- If stock hits 0, you’ll receive 0 regardless; then default to **C** until last round (no harm; positions you for regrowth if others cooperate).

---

# 3) Collective mindset (what this strategy is “trying to do”)

- **Primary objective:** Maintain the common stock in a region that supports high future payoffs (avoid collapse cycles), which benefits everyone if reciprocated.
- **Reciprocity as governance:** Defection is used as a *sanction* to deter opportunism, not as the main plan.
- **Crisis protocol:** When the pool is endangered (low stock), the strategy suppresses retaliation to prevent mutually assured depletion.
- **Reintegration:** When opponents return to cooperation, the strategy quickly returns to cooperation too, enabling the group to rebuild.

---

## Pseudocode (implementable outline)

```python
# Inputs each round t: S, history of actions (all players), n, r, capacity
# Internal state: D_rate, punish_left

def choose_action(t, S, history, n, r, capacity):
    S_ratio = S / capacity

    if t == 1:
        D_rate = 0.0
        punish_left = 0
        return "C"

    # Observe defections last round among opponents
    k = count_opponent_defections(history[t-1])

    # Update D_rate (EWMA)
    obs = k / (n-1)
    D_rate = 0.7 * D_rate + 0.3 * obs

    # Last round rule
    if t == r:
        if S_ratio < 0.35:
            return "D"
        else:
            return "D"

    # Emergency stock protection (except last round handled above)
    if S_ratio < 0.35:
        punish_left = 0  # cancel punishment during emergency
        return "C"

    # Trigger punishment if any defection observed and not already punishing
    if k > 0 and punish_left == 0:
        P = min(3, 1 + int(2 * k / (n-1)))
        punish_left = P

    # If currently punishing
    if punish_left > 0:
        # de-escalate if peace observed last round
        if k == 0:
            punish_left = min(punish_left, 1)

        punish_left -= 1
        return "D"

    # Persistent exploitation response
    if D_rate > 0.5:
        return "D"

    # Near-end stability preference
    if t == r-1 and S_ratio >= 0.70 and D_rate < 0.25 and k == 0:
        return "C"

    # Default cooperative stance
    if k == 0 and D_rate < 0.25:
        return "C"
    else:
        # mild caution if there's some noise
        return "C"
```

(That final `else: return "C"` is intentional: outside punishment and outside persistent exploitation, SGRC errs toward rebuilding cooperation, because the stock dynamics make recovery valuable and because retaliation is already handled explicitly.)

---

### Why this is robust in a tournament
- Against cooperators: quickly locks into all-C most rounds, preserving high stock and high long-run payoffs.
- Against occasional defectors/noise: punishes briefly, then forgives and returns to cooperation.
- Against chronic defectors: shifts to D (won’t be exploited indefinitely).
- Against “endgame grab” strategies: protects you by defecting in the last round, while still sustaining cooperation up to that point when safe.

If you want, I can also provide a stricter variant (more punitive) and a softer variant (more forgiving) tuned to expected tournament ecology.
'''

description_COLLECTIVE_104 = '''
## Strategy: **Sustain–Reciprocate with Stock Safeguard (SRSS)**  
Goal: keep the stock near the regenerative sweet spot while discouraging exploitation. The strategy is *collective-first*: cooperate by default when the group appears sustainable, but switch to proportional punishment when others over-consume, with forgiveness when behavior improves.

---

## Key ideas (why this works)
1. **Stock has a “good zone”**: with logistic growth, the stock regenerates fastest around ~capacity/2. If play keeps the resource from collapsing, everyone can keep earning across rounds.
2. **Defection is individually tempting but collectively lethal**: one-shot incentives favor D; repeated incentives favor sustaining the stock.
3. **Robustness requires two levers**:
   - **Stock safeguard**: if stock is getting low, don’t keep cooperating blindly; choose actions that reduce expected total take.
   - **Reciprocity**: punish over-consumption quickly enough that exploitation is unattractive, but forgive to recover cooperation.

---

## Definitions from history/state (computable each round)
Let at round \(t\):
- \(S_t\) = current stock at the start of the round.
- Observe last round actions (from round \(t-1\)): count defectors \(d_{t-1}\) (players who played D).
- Define **defection rate**: \(\rho_{t-1} = d_{t-1}/n\).

Also define stock thresholds (depend only on parameters):
- **Critical stock**: \(S_{\text{crit}} = 0.25 \cdot \text{capacity}\)
- **Target stock**: \(S_{\text{tgt}} = 0.50 \cdot \text{capacity}\)
- **Safe stock**: \(S_{\text{safe}} = 0.70 \cdot \text{capacity}\)

(These are deliberately simple and robust; capacity is known.)

Maintain an internal integer **grudge level** \(G_t \ge 0\) that represents how much punishment is “owed” due to others’ recent over-consumption.

---

## 1) Decision rules: when to Cooperate vs Defect

### Rule A — Default collective stance
If the system looks healthy and opponents aren’t exploiting:
- **Play C** when:
  - \(S_t \ge S_{\text{tgt}}\), and
  - \(\rho_{t-1} = 0\) (no one defected last round), and
  - \(G_t = 0\).

This is the “we’re sustaining, keep it going” regime.

---

### Rule B — Stock safeguard (resource protection)
When stock is low, prioritize preventing collapse and creating conditions for regrowth:
- **If \(S_t \le S_{\text{crit}}\)**: **Play C** (always).

Rationale: At low stock, defecting accelerates collapse; the only collective move is to reduce extraction. This rule prevents death spirals against chaotic opponents.

---

### Rule C — Reciprocity / proportional punishment
When others defect, punish in a way that is:
- fast enough to deter,
- proportional to the degree of exploitation,
- not permanently escalatory (forgives when cooperation returns).

**Update grudge level after observing round \(t-1\)**:
- If \(t=1\): set \(G_1 = 0\).
- Else:
  - Increase grudge based on how many defected:
    - \(G_t \leftarrow \min(G_{t-1} + \lceil 3\rho_{t-1} \rceil,\; 6)\)
  - If no one defected last round (\(\rho_{t-1}=0\)), decay grudge:
    - \(G_t \leftarrow \max(G_t - 2,\; 0)\)

Interpretation:
- A few defectors: small, short punishment.
- Many defectors: stronger punishment.
- Two consecutive cooperative rounds typically resets to cooperative mode.

**Action choice with grudge (when not in critical stock)**:
- If \(G_t \ge 2\): **Play D**
- Else: **Play C**

This makes punishment “sticky” for a couple rounds after exploitation, but it fades quickly if the group returns to C.

---

### Rule D — Opportunistic recovery mode (restart cooperation)
If the stock has recovered enough, be willing to re-enter cooperation even after conflict:
- If \(S_t \ge S_{\text{safe}}\) and \(\rho_{t-1} \le 0.25\) and \(G_t \le 1\): **Play C**

This prevents over-punishing in environments with a small fraction of noisy/defecting players.

---

## 2) Edge cases

### First round (t = 1)
- **Play C**.
- Set \(G_1 = 0\).

Reason: You cannot infer opponent type yet, and starting with C is the only collective signal available without communication. It also keeps stock from instant collapse if many others also try to cooperate.

---

### Last round (t = r)
Endgame defection is tempting, but always-defect-at-end destroys the possibility of sustaining cooperation in tournaments where strategies condition on last-round play or use “endgame tests.”

So:
- If \(S_r \le S_{\text{tgt}}\): **Play C** (protect stock; also consistent).
- Else if \(G_r \ge 2\): **Play D** (don’t let last-round exploitation go unpunished).
- Else: **Play C**.

This keeps a collective orientation while still defending against chronic defectors.

---

### If stock hits (or is near) zero
- The safeguard already forces C at low stock. Continue playing C until \(S_t > S_{\text{crit}}\).
- If opponents keep defecting, stock may remain depressed; SRSS does not “rage defect” into collapse—because that is collectively worst.

---

## 3) Collective mindset (explicitly)
SRSS is collective because it:
- **Treats stock sustainability as a first-class objective**, not just immediate payoff.
- **Rewards cooperative group behavior with continued cooperation**.
- **Punishes over-consumption proportionally and temporarily**, aiming to *restore* cooperation rather than “win” a bilateral contest.
- **Never escalates when the resource is endangered** (critical-stock always cooperate).

---

## Pseudocode (implementable)
```python
# Parameters: n, r, capacity
S_crit = 0.25 * capacity
S_tgt  = 0.50 * capacity
S_safe = 0.70 * capacity

G = 0  # grudge level

def choose_action(t, S_t, last_actions):  # last_actions None if t==1
    global G

    if t == 1:
        G = 0
        return "C"

    # compute defection rate last round
    d = count_D(last_actions)
    rho = d / n

    # update grudge
    if rho > 0:
        G = min(G + ceil(3 * rho), 6)
    else:
        G = max(G - 2, 0)

    # stock safeguard
    if S_t <= S_crit:
        return "C"

    # recovery mode
    if S_t >= S_safe and rho <= 0.25 and G <= 1:
        return "C"

    # default reciprocity
    if G >= 2:
        return "D"
    else:
        return "C"
```

---

### What this strategy is robust against
- **Always-D players**: you won’t collapse the stock faster than necessary (critical-stock forces C), but you do punish when feasible, preventing easy exploitation when stock is healthy.
- **Noise / occasional defections**: proportional, forgiving response avoids permanent vendettas.
- **Conditional cooperators (Tit-for-Tat-like)**: your initial C and quick forgiveness enables stable cooperation.
- **Mixed populations**: recovery mode helps maintain cooperation even if a minority defects.

If you want, I can also provide a variant tuned for very small n (e.g., n=2 or n=3) where single-player defection has much larger stock impact, or a more “game-theoretic hardline” version that maximizes relative advantage rather than collective sustainability.
'''

description_COLLECTIVE_105 = '''
## Collective Strategy: **Sustainable Trigger with Stock-Aware Recovery (STaR)**

Goal: keep the resource near its regenerative sweet spot and deter over-consumption, while still recovering cooperation after mistakes/noise. The strategy uses only \((n,r,capacity)\), current stock \(S_t\), and full action history.

### Core idea
1. **Prefer C by default** to sustain the stock.
2. **Punish detected overuse** (many D’s) with temporary D to make defection unprofitable long-run and to prevent being exploited.
3. **Be stock-aware:** when the stock is low, prioritize recovery (more C) unless punishment is necessary.
4. **Forgive:** after punishment, attempt to re-cooperate if others stop defecting.

---

## 1) Decision rules (C vs D)

### Definitions computed each round \(t\)
Let:
- \(S_t\) = stock at start of round \(t\)
- \(d_{t-1}\) = number of defectors observed in round \(t-1\)
- \(\bar d_{t-1}\) = average defect rate over the last \(w\) rounds (window)
- Choose window \(w = \min(5, t-1)\) (use as much history as exists, up to 5)

Useful stock thresholds (fractions of capacity):
- **Low stock:** \(S_t \le 0.35\cdot capacity\)
- **Healthy stock:** \(S_t \ge 0.70\cdot capacity\)

Punishment control:
- Maintain an internal integer **punish\_timer** (starts at 0).
- When punish\_timer > 0, play D and decrement it by 1 each round.

### Trigger conditions
At the start of round \(t\ge2\), set/extend punishment if **either** is true:

**A. Major deviation (hard trigger):**
- \(d_{t-1} \ge \lceil n/2\rceil\) (a majority defected last round)

**B. Persistent deviation (soft trigger):**
- \(\bar d_{t-1} \ge 0.30\cdot n\) (at least ~30% are defecting on average recently)

If a trigger fires, set:
- **Base punishment length:** \(L = 2\)
- **Escalation:** add +1 if \(S_t \ge 0.70\,capacity\) (stock is healthy, punishment is affordable and deters opportunism)
- **De-escalation:** subtract 1 (minimum 1) if \(S_t \le 0.35\,capacity\) (stock is fragile; avoid collapsing it)

So:
- \(punish\_timer \leftarrow \max(punish\_timer,\; \max(1, L + I[S_t\ge0.70cap] - I[S_t\le0.35cap]))\)

### Action selection (main rule)
In round \(t\):

1. **If punish\_timer > 0:** play **D**.
2. **Else (not punishing):**
   - If \(S_t \le 0.35\,capacity\): play **C** (resource recovery mode).
   - Else play **C** (cooperative default).

This may look “too cooperative” outside punishment, but the deterrence comes from *credible* short punishments once defection appears, combined with fast return to C to rebuild the stock.

### Why this works strategically
- If others mostly cooperate, you cooperate and keep stock near capacity (high long-run payoffs).
- If others defect occasionally, you forgive quickly and avoid needless mutual destruction.
- If others systematically defect, you shift into repeated punish cycles (often D), which prevents being the “sucker” indefinitely.
- Stock-awareness prevents “punish until collapse” when the stock is already low.

---

## 2) Edge cases

### First round (\(t=1\))
- Play **C**.
Reason: stock is at capacity initially; cooperation sustains it and signals collective intent. Also you cannot condition on history yet.

### Last round (\(t=r\))
- If \(punish\_timer>0\): play **D** (finish punishment).
- Else:
  - If \(S_r \le 0.35\,capacity\): play **C** (avoid endgame collapse in case tournament scoring or tie-breakers value totals across players or future state—also consistent collective norm).
  - Otherwise: play **D** **only if** last round’s defect rate was high: \(d_{r-1}\ge \lceil n/2\rceil\). Else play **C**.

This keeps a limited endgame “defect back” response but avoids unconditional last-round defection that would undermine cooperation earlier (many tournament opponents anticipate endgame behavior).

### Very small stock (\(S_t\) near 0)
- If \(S_t < \epsilon\) (e.g., \(10^{-6}\)): play **C** unless you are currently punishing with timer>0.
Reason: when stock is nearly gone, D yields almost nothing anyway; best collective move is to rebuild.

### Capacity close to minimum allowed (\(capacity \approx 2n\))
- Thresholds scale with capacity, so the same logic applies. Low capacity means the system is more fragile, so stock often falls into recovery mode, which is appropriate.

---

## 3) “Collective mindset” alignment

This strategy operationalizes collective thinking in three ways:

1. **Sustainability-first default:** cooperate whenever not actively deterring exploitation, especially when the stock is low.
2. **Proportional accountability:** punish only when defection is meaningfully present (majority or persistent minority), and punish briefly—enough to change incentives, not enough to destroy the pool.
3. **Restoration focus:** after punishment, immediately return to cooperation to rebuild the common resource, maximizing long-run group surplus.

---

## Pseudocode (implementation-ready)

```pseudo
params: n, r, capacity
state vars: punish_timer = 0
history: actions[t][i], stock[t]

function decide(t, S_t, history):
    if t == 1:
        return C

    # compute last-round defection count
    d_last = count_i(actions[t-1][i] == D)

    # windowed average defection count (up to last 5 rounds)
    w = min(5, t-1)
    d_avg = average_{k=t-w..t-1}( count_i(actions[k][i] == D) )

    # triggers
    hard = (d_last >= ceil(n/2))
    soft = (d_avg >= 0.30 * n)

    if (hard or soft):
        L = 2
        esc = (S_t >= 0.70*capacity) ? 1 : 0
        deesc = (S_t <= 0.35*capacity) ? 1 : 0
        newL = max(1, L + esc - deesc)
        punish_timer = max(punish_timer, newL)

    if punish_timer > 0:
        punish_timer -= 1
        return D

    # not punishing
    if t == r:
        if (S_t > 0.35*capacity) and (d_last >= ceil(n/2)):
            return D
        else:
            return C

    if S_t <= 0.35*capacity:
        return C
    else:
        return C
```

---

If you want, I can also propose a more “self-protective” variant (higher baseline defection when the environment looks uncooperative) or a more “optimistic” variant (longer forgiveness, shorter punishments), depending on what tournament meta you expect.
'''

description_COLLECTIVE_106 = '''
## Strategy: **Stock-Guarded Reciprocal Cooperation (SGRC)**  
Collective goal: keep the resource near capacity so everyone can earn high payoffs every round, while deterring and containing exploitation. The strategy is **state-aware** (uses stock), **history-aware** (uses observed actions), and **robust** (forgives noise, but punishes persistent defection).

### Core intuition
- If stock stays high, even cooperation pays well repeatedly.
- A single-round defection gives a higher immediate payoff, but it reduces future stock and can crash the system if repeated.
- So we **cooperate by default** when the stock is healthy and others are mostly cooperating; we **defect defensively** when stock is low or opponents persistently defect, to avoid being the “last cooperator” subsidizing defectors.
- We use **graduated punishment**: quick response to defection, but return to cooperation after opponents show cooperation again, especially if stock is fragile and needs recovery.

---

## 1) Decision rules (Cooperate vs Defect)

### Observables (from history)
At round \(t\) with current stock \(S_t\):
- Let \(D_{t-1}\) = number of opponents who defected last round.
- Let \(d\_rate\) = fraction of defections in the last \(W\) rounds among all opponents:
  \[
  d\_rate = \frac{\sum_{k=t-W}^{t-1} D_k}{(n-1)\cdot W}
  \]
- Let **consecutive_bad** = number of consecutive previous rounds where \(D_{k} > 0\) (opponents showed any defection).

Use a short memory window, e.g. \(W=3\) (robust to one-off noise, responsive to trends).

### Stock zones
Define stock thresholds relative to capacity (so it scales across games):

- **High stock**: \(S_t \ge 0.8\cdot capacity\)
- **Mid stock**: \(0.4\cdot capacity \le S_t < 0.8\cdot capacity\)
- **Low stock**: \(S_t < 0.4\cdot capacity\)

(You can adjust the constants slightly, but keep the three-zone structure.)

### Rule set
**Rule A — Recovery priority when stock is low:**  
If \(S_t < 0.4\cdot capacity\):  
- **Cooperate**, unless opponents are currently in heavy defection (see Rule C).  
Reason: with low stock, defecting accelerates collapse; cooperation preserves growth potential.

**Rule B — Cooperative default when stock is healthy and opponents mostly cooperate:**  
If \(S_t \ge 0.4\cdot capacity\) and \(d\_rate \le 0.2\) and \(D_{t-1}=0\):  
- **Cooperate**.  
Reason: sustain near-capacity dynamics; maximize long-run group payoff.

**Rule C — Defensive mode against exploitation:**  
Enter “defensive mode” if **either**:
- \(D_{t-1} \ge 1\) **and** \(S_t \ge 0.4\cdot capacity\) (someone defected while stock is not yet critical), **or**
- \(d\_rate > 0.35\) (defection is trending), **or**
- consecutive_bad ≥ 2 (repeated disturbances).

In defensive mode:
- **Defect** if \(S_t \ge 0.6\cdot capacity\).  
- **Cooperate** if \(S_t < 0.6\cdot capacity\).  

Reason:  
- When stock is still high, defecting is a credible deterrent and prevents being exploited repeatedly.  
- When stock is fragile, prioritizing recovery dominates punishment (punishment that crashes stock harms the collective and yourself).

**Rule D — Exit defensive mode (forgiveness):**  
If in the last round \(D_{t-1}=0\) and \(d\_rate \le 0.2\):  
- Return to **Cooperate** (unless last round, see endgame rules).  
Reason: makes cooperation a stable attractor; avoids endless retaliation cycles.

---

## 2) Edge cases (first round, last round, etc.)

### First round (no history)
- **Cooperate**.  
Rationale: start by trying to establish the high-stock cooperative basin; you lose little and gain the chance of sustained high payoffs. Also makes your behavior “legible” to cooperative strategies.

### Last round (finite-horizon endgame)
Because the game has a known final round, many strategies will defect at the end. SGRC uses a **conditional last-round policy** to remain robust:

In round \(t=r\):
- If \(S_r < 0.6\cdot capacity\): **Cooperate** (stock is already damaged; defecting yields a bit more now but is typically a sign you’re in a bad pool; cooperate avoids making collapse worse during fragile recovery attempts by others—but since it’s last round, this mainly preserves reciprocity incentives earlier by not being purely endgame-defect).
- Else if \(d\_rate \le 0.2\) and \(D_{r-1}=0\): **Cooperate** (reward a cooperative group; helps maintain cooperation incentives in earlier rounds for strategies that anticipate “no endgame betrayal” types).
- Else: **Defect** (don’t be the only cooperator feeding defectors in the terminal round).

This makes you harder to exploit by “cooperate then last-round defect” opponents, but still cooperative in genuinely cooperative groups.

### Second-to-last round (\(t=r-1\))
Slightly tighten defensiveness because endgame defection becomes more likely:
- Treat \(d\_rate\) threshold as 0.15 instead of 0.2 for triggering defensive mode.
- Otherwise follow standard rules.

### Very small capacity / parameter extremes
You’re given capacity ≥ 2n; still, if capacity is only modestly above 2n, the stock can be more sensitive. The stock-zone thresholds are proportional to capacity, so the strategy remains stable.

---

## 3) “Collective mindset” commitments (what this strategy optimizes for)
SGRC is collective in three concrete ways:

1. **Stock-first cooperation:** it cooperates whenever stock is low-to-mid unless opponents are persistently exploitative, because preserving the resource benefits everyone’s future payoff stream.
2. **Graduated deterrence:** it punishes defection when stock is healthy (where punishment is least damaging), to protect cooperators from being milked.
3. **Forgiveness:** it quickly returns to cooperation after opponents stop defecting, preventing permanent collapse into mutual defection.

---

## Pseudocode (implementable)
```python
# parameters
W = 3  # history window
HIGH = 0.8
MID  = 0.4
DEF_PUNISH_STOCK = 0.6

def decide(t, r, S, history_actions, n):
    # history_actions[k] = list of all players' actions at round k (1-indexed),
    # including ours; assume we can count opponents' Ds.

    if t == 1:
        return "C"

    # compute D_{t-1}, d_rate, consecutive_bad
    D_last = count_opponent_defections(history_actions[t-1])
    # window rounds: max(1, t-W) ... t-1
    start = max(1, t-W)
    total_def = 0
    rounds = 0
    consecutive_bad = 0
    for k in range(t-1, 0, -1):
        if count_opponent_defections(history_actions[k]) > 0:
            consecutive_bad += 1
        else:
            break

    for k in range(start, t):
        total_def += count_opponent_defections(history_actions[k])
        rounds += 1
    d_rate = total_def / ((n-1) * rounds)

    # endgame tightening
    d_thresh = 0.2
    if t == r-1:
        d_thresh = 0.15

    # stock zones
    if S < MID * capacity:
        # low stock: prioritize recovery, unless opponents heavily defect
        if d_rate > 0.5 and S >= DEF_PUNISH_STOCK * capacity:
            return "D"
        return "C"

    # defensive mode trigger
    defensive = False
    if (D_last >= 1 and S >= MID * capacity) or (d_rate > 0.35) or (consecutive_bad >= 2):
        defensive = True

    # last round policy
    if t == r:
        if S < DEF_PUNISH_STOCK * capacity:
            return "C"
        if d_rate <= d_thresh and D_last == 0:
            return "C"
        return "D"

    # normal play
    if not defensive and d_rate <= d_thresh and D_last == 0:
        return "C"

    # defensive mode action depends on stock
    if S >= DEF_PUNISH_STOCK * capacity:
        return "D"
    else:
        return "C"
```

---

### Why this will do well in a mixed tournament
- Against cooperators: quickly converges to stable all-C with near-capacity stock, yielding high cumulative payoffs.
- Against occasional/noisy defectors: punishes but forgives, avoiding long mutual-defection spirals.
- Against persistent defectors: shifts to defensive defection when it matters (stock high), limiting exploitation; shifts back to cooperation when stock becomes endangered to avoid total collapse that reduces even your own payoffs.
- Against endgame defectors: doesn’t blindly cooperate on the last round unless the group is strongly cooperative.

If you want, I can also provide a tighter “one-page” version of the rules or suggest parameter values (thresholds/window) optimized for specific \(n, r, capacity\) regimes.
'''

description_COLLECTIVE_107 = '''
## Strategy: **Stock-Guarded Generous Grim (SGGG)**  
Collective goal: keep the stock near a “safe high” region where everyone can earn large payoffs every round (because payoffs scale with current stock), while still having a credible, fast response that prevents exploitation and stops stock collapse.

Key idea:  
- **Cooperate by default** when the group appears to be sustaining the resource.  
- **Defect as a corrective action** when the stock trajectory indicates over-extraction (whether intentional or not).  
- **Forgive quickly** once the system returns to a healthy state, to recover collective gains.

This is designed to be robust against: always-defectors, mixed populations, noise-like fluctuations, and “one-shot endgame defection” incentives.

---

# 1) Decision rules (C vs D)

### Quantities computed from history (common to all players)
At the start of round *t*, observe current stock \(S_t\) and last round actions.

Let:
- \(k_{t-1}\) = number of defectors in round \(t-1\) (from observed actions).
- \(c_C(S) = S/(2n)\), \(c_D(S) = S/n\)
- Total consumption last round:
  \[
  \text{Cons}_{t-1} = (n-k_{t-1})\cdot c_C(S_{t-1}) + k_{t-1}\cdot c_D(S_{t-1})
  \]
- Remaining stock after consumption:
  \[
  R_{t-1} = S_{t-1} - \text{Cons}_{t-1}
  \]
- Predicted next stock (per the game rule):
  \[
  \hat S_t = \min\Big(R_{t-1} + 2R_{t-1}\big(1 - R_{t-1}/\text{capacity}\big),\ \text{capacity}\Big)
  \]
- Realized stock change signal:
  \[
  \Delta_t = S_t - S_{t-1}
  \]

### Define “health zones” of the resource
Use thresholds based only on parameters:

- **Critical zone**: \(S_t \le 2n\)  
  (close to the minimum meaningful scale; risk of getting stuck low)

- **Caution zone**: \(2n < S_t < 0.6\cdot \text{capacity}\)

- **Healthy zone**: \(S_t \ge 0.6\cdot \text{capacity}\)

(You can adjust 0.6 to 0.7; 0.6 is chosen to be forgiving and to promote recovery.)

---

## Core policy
### A) In Healthy zone (\(S_t \ge 0.6\cdot capacity\))
**Play C** unless there is clear evidence of exploitation.

Evidence of exploitation is defined as either:
1) **Many defectors recently**: \(k_{t-1} \ge \lceil n/3 \rceil\)  
or  
2) **Stock is trending downward despite being high**: \(\Delta_t < 0\) and \(k_{t-1} > 0\)

If evidence triggers: **Play D for one round** (a “warning shot”), then reassess next round.

Rationale: When stock is high, cooperation is socially optimal and stable if most cooperate. But if defection appears, you briefly defect to reduce unilateral disadvantage and signal that exploitation won’t be tolerated.

---

### B) In Caution zone (\(2n < S_t < 0.6\cdot capacity\))
Here the priority is *rebuilding stock* while not being a sucker.

Compute the defection pressure:
- If \(k_{t-1} = 0\): **Play C** (best for recovery).
- If \(1 \le k_{t-1} < \lceil n/3 \rceil\): **Play C** (be generous—small defection can be noise/experimentation; keep recovery going).
- If \(\lceil n/3 \rceil \le k_{t-1} < \lceil 2n/3 \rceil\): **Play D** (defection is becoming systemic; protect yourself).
- If \(k_{t-1} \ge \lceil 2n/3 \rceil\): **Play D** (treat as hostile environment).

Rationale: In mid-stock ranges, the growth function is powerful if remaining stock isn’t annihilated; broad cooperation can restore health quickly. But once defection is common, pure cooperation just subsidizes defectors and may still crash the stock.

---

### C) In Critical zone (\(S_t \le 2n\))
**Play D** until the stock exits the critical zone *and* defection is not rampant.

Exit condition to return to cooperation:
- If \(S_t > 2n\) and \(k_{t-1} < \lceil n/3 \rceil\), then switch back to **C**.

Rationale: In critical scarcity, the marginal benefit of defection is high and the system is fragile; you need a “protective” stance to avoid being exploited and to push the game toward a regime where cooperation can again be self-supporting.

---

## “Forgiveness / reset” rule (important)
Even after defecting, return to cooperation quickly when conditions improve:

- If \(S_t \ge 0.6\cdot capacity\) and \(k_{t-1} \le 1\), then **Play C** regardless of earlier conflicts.

This prevents endless retaliation cycles and helps the group re-coordinate on high-stock cooperation.

---

# 2) Edge cases

### First round (t = 1)
**Play C.**  
Reason: With stock initially at capacity, mutual cooperation yields a sustainable high-payoff steady state (as in your example). Starting with D accelerates distrust and collapse.

### Last round (t = r)
Default is **C**, *unless* there is active exploitation:
- If \(k_{r-1} \ge \lceil n/3 \rceil\) or \(S_r \le 0.6\cdot capacity\), play **D**; otherwise play **C**.

Reason: Endgame incentives push some strategies to defect on the last round. This rule avoids being an easy target while still keeping cooperative norms when the group has been cooperative.

### Round r−1 (penultimate round)
Same as normal rules. Do **not** preemptively defect just because the end is near; that invites collapse and often reduces your own total payoff because payoffs scale with stock and there is still one more round.

### If stock hits zero
If \(S_t = 0\), payoffs are zero regardless. Continue with the rule: it will prescribe **D** in critical zone. (It doesn’t matter immediately, but it is consistent.)

---

# 3) Why this is “collective” and tournament-robust

### Collective alignment
- When conditions support it, the strategy strongly prefers **C**, because keeping stock high maximizes everyone’s per-round returns.
- It uses **D** primarily as a *containment tool* against exploitation or impending collapse, not as a default profit grab.
- It includes a **fast forgiveness/reset** mechanism to restore cooperation after temporary disruptions.

### Robustness against opponent types
- **Always defectors**: You shift to D in response; you won’t keep feeding them C-payoffs while they drain stock.
- **Conditional cooperators**: You coordinate easily because you start with C and maintain C in healthy conditions.
- **Noisy or exploratory players**: The “generous in caution zone for small k” rule prevents overreacting to one-off defections.
- **Endgame defectors**: The last-round safeguard reduces being exploited while still cooperating when the group has been cooperative.

---

# Pseudocode (implementation-ready logic)

```pseudo
input: n, r, capacity
state each round t: current stock S_t
history: actions in round t-1 (if t>1), past stocks

function threshold1(n): return ceil(n/3)
function threshold2(n): return ceil(2*n/3)

for t in 1..r:
  if t == 1:
     play C
     continue

  k = number_of_defectors_in_round(t-1)
  T1 = threshold1(n)
  T2 = threshold2(n)

  healthy = (S_t >= 0.6 * capacity)
  critical = (S_t <= 2*n)

  # Last-round safeguard
  if t == r:
     if k >= T1 or S_t <= 0.6*capacity:
        play D
     else:
        play C
     continue

  # Forgiveness/reset
  if healthy and k <= 1:
     play C
     continue

  if critical:
     # protective stance
     if S_t > 2*n and k < T1:
        play C
     else:
        play D
     continue

  # Caution zone (between critical and healthy)
  if not healthy:
     if k == 0:
        play C
     else if k < T1:
        play C
     else if k < T2:
        play D
     else:
        play D
     continue

  # Healthy zone default
  if k >= T1:
     play D      # warning shot
  else if k > 0 and (S_t - S_{t-1} < 0):
     play D      # stock trending down + some defection
  else:
     play C
```

---

If you want, I can also provide:
- a more “mathy” version that uses predicted stock \( \hat S_{t+1} \) directly (trigger D when predicted next stock falls below a target), or
- an explicitly symmetric “collective trigger” rule that tries to stabilize a target stock level (e.g., \(0.8\cdot capacity\)).
'''

description_COLLECTIVE_108 = '''
## Collective, adaptive strategy: **Sustain–Reciprocate–Recover (SRR)**

Goal: keep the stock near its sustainable “high-growth” region (so everyone can keep earning), while deterring persistent over-consumption using simple, history-based reciprocity.

Key idea:  
- When the resource is healthy and others are not exploiting, **cooperate (C)** to sustain the stock at/near capacity (which is feasible when many cooperate).  
- If others defect, **punish (defect)** enough to make defection unprofitable long-run, but **forgive quickly** once behavior improves.  
- When stock becomes low, switch to **recovery mode** (cooperate to regrow) unless opponents are clearly still exploiting.

---

## 1) Decision rules (when to cooperate vs defect)

### Definitions observed each round \(t\)
- \(S_t\): stock at start of round \(t\)
- Let \(d_{t-1}\): number of opponents who defected in the previous round (you can observe actions).
- Let \(\hat{p}_{t-1} = d_{t-1}/(n-1)\): observed defection rate among opponents last round.
- Maintain a **trust score** \(T_t \in [0,1]\) updated from history (EWMA of opponent cooperation):
  - Let \(c_{t-1} = (n-1 - d_{t-1})/(n-1)\) be opponent cooperation rate last round.
  - Update: \(T_t = (1-\alpha)T_{t-1} + \alpha c_{t-1}\), with \(\alpha=0.3\).
  - Initialize \(T_1 = 1\) (optimistic start).

### Stock zones
Use thresholds based on capacity (robust across parameter values):
- **Recovery zone:** \(S_t \le 0.35 \cdot capacity\)
- **Caution zone:** \(0.35\cdot capacity < S_t < 0.7\cdot capacity\)
- **Safe zone:** \(S_t \ge 0.7 \cdot capacity\)

(These are not magic numbers; they just separate “low/medium/high” stock so the policy adapts.)

### Core action policy

**A. If in Recovery zone (low stock):**  
- **Play C**, *unless* opponents are highly exploitative.
- Exception (anti-exploitation): if \(\hat{p}_{t-1} \ge 0.5\) (at least half of opponents defected last round), then **play D**.
  - Rationale: if you cooperate while many defect at low stock, you are donating your share while stock may not recover anyway.

**B. If in Caution zone (medium stock):**  
- Default: **play C** if opponents are mostly cooperating.
- Specifically:
  - If \(T_t \ge 0.7\) and \(\hat{p}_{t-1} \le 0.25\), **play C**.
  - Else **play D**.
  - Rationale: medium stock is fragile; a modest amount of defection can push it down. You require decent recent cooperation to keep cooperating.

**C. If in Safe zone (high stock):**  
- Be generous but reciprocal:
  - If \(\hat{p}_{t-1} = 0\), **play C**.
  - If \(\hat{p}_{t-1} > 0\), **play D** for *one round* (a “warning shot”), then reassess next round.
  - Rationale: in high stock, cooperation sustains near-capacity outcomes; but even small defection should be met quickly so exploitation doesn’t become a stable pattern.

### Forgiveness / return-to-cooperation rule
After you defect as punishment, you return to **C** as soon as:
- Opponent defection rate last round is low: \(\hat{p}_{t-1} \le 0.25\), **and**
- Stock is not in free-fall: \(S_t \ge 0.35\cdot capacity\) (not in deep recovery)

This makes the strategy forgiving (important in noisy populations and for re-establishing cooperation with conditional cooperators).

---

## 2) Edge cases (first round, last round, etc.)

### Round 1 (no history)
- **Play C**.
  - Reason: with stock initially at capacity, mutual cooperation can maintain capacity; starting with D risks immediate collapse if others also defect.

### Last round (round r)
There is a classic end-game temptation to defect. But in tournaments, you often face strategies that punish end-game defection or condition on late behavior.

Use a **conditional last-round rule**:
- If \(T_r \ge 0.8\) and \(S_r \ge 0.7\cdot capacity\): **play C** (honor cooperation if the group has been cooperative and the resource is healthy).
- Otherwise: **play D**.
  - This avoids being a “sucker” in populations that exploit the end-game while still allowing cooperative equilibria to persist among reciprocators.

### Very small capacity / unusual parameter regimes
Given capacity ≥ 2n, the zones still work. If capacity is close to 2n (tight system), the stock will be more sensitive:
- The policy already tightens cooperation in the Caution zone and pushes Recovery cooperation unless exploitation is severe.

### If stock hits (or is near) zero
- If \(S_t\) is extremely low (e.g., \(S_t \le 0.05\cdot capacity\)): **play C** unless \(\hat{p}_{t-1}\ge 0.5\).  
This maximizes the chance of regrowth when possible, but stops donating to clear exploiters.

---

## 3) Collective mindset (how it aligns with “we”)

SRR is collective because:
- It prioritizes keeping the stock in a region where **future payoffs for everyone** remain high (sustainability first).
- It uses **minimal necessary punishment** (often one-round) to deter exploitation without triggering endless retaliation cycles that destroy the resource.
- It **forgives quickly** to rebuild cooperation, which is essential in repeated, stateful common-pool environments.

---

## Pseudocode (implementable)

```python
# Parameters: n, r, capacity
alpha = 0.3
T = 1.0  # trust score

def stock_zone(S):
    if S <= 0.35 * capacity: return "RECOVERY"
    if S < 0.70 * capacity:  return "CAUTION"
    return "SAFE"

def decide(t, S, last_actions):  # last_actions: list of opponent actions at t-1, or None for t=1
    global T

    if t == 1:
        return "C"

    # Compute opponent defection rate
    d = sum(1 for a in last_actions if a == "D")
    p_hat = d / (n - 1)
    c_rate = 1 - p_hat

    # Update trust
    T = (1 - alpha) * T + alpha * c_rate

    zone = stock_zone(S)

    # Last round rule
    if t == r:
        if T >= 0.8 and S >= 0.70 * capacity:
            return "C"
        else:
            return "D"

    if zone == "RECOVERY":
        if p_hat >= 0.5:
            return "D"
        else:
            return "C"

    if zone == "CAUTION":
        if T >= 0.7 and p_hat <= 0.25:
            return "C"
        else:
            return "D"

    # SAFE zone
    if p_hat == 0:
        return "C"
    else:
        return "D"  # one-round punishment; reassess next round naturally
```

---

### Why this is robust in a tournament
- Against always-cooperate: stays mostly C → high stock, high group payoff.
- Against always-defect: quickly switches to D; avoids being exploited.
- Against tit-for-tat / grim-like reciprocators: converges to cooperation, because it punishes briefly and forgives when behavior improves.
- Against mixed/learning strategies: trust score + stock zones provide adaptive stability (not overreacting to one defection when the stock is healthy, but tightening when stock is fragile).

If you want, I can also provide a variant tuned to be *more cooperative* (higher welfare but more risk) or *more defensive* (lower exploitation risk but more punishment cycles).
'''

description_COLLECTIVE_109 = '''
## Collective strategy: **StockGuard with Graduated Sanctions (SGGS)**

Goal: keep the common stock near a *safe operating zone* (high enough to regenerate back to capacity), while still being resilient to exploiters. The strategy is collective because it defaults to cooperation, only escalates when others threaten the resource, and de-escalates quickly when the group returns to sustainable behavior.

Key idea: treat defection primarily as a *signal of unsustainable pressure* on the stock. Punish only as much as needed to stop collapse, and return to cooperation as soon as feasible.

---

## 1) Decision rules (when to cooperate vs defect)

### Notation (at round t)
- `S`: current stock before consumption.
- `H`: history of past rounds (actions of all players, stocks).
- `n, r, capacity` are known.

Define:

**A. Safe-stock threshold**
- `S_safe = capacity / 2`  
Reason: under the given logistic growth, if post-consumption stock is at least `capacity/2`, it regrows strongly (max growth occurs at `capacity/2`) and can recover toward capacity in one step if exactly `capacity/2`. This is a natural sustainability anchor.

**B. Observed defection rate last round**
- `d_{t-1} = (# of opponents who played D in round t-1) / (n-1)` (for t>1)

**C. “Pressure score” (how threatened the resource is)**
Use two triggers:
1) **Stock is low**: `S < S_safe`
2) **Others are defecting a lot**: `d_{t-1}` is high

We implement this as a simple state machine with three modes:
- **Mode GREEN (default cooperative)**  
- **Mode YELLOW (warning / selective punishment)**  
- **Mode RED (resource emergency / protect-yourself)**  

### Mode definitions and actions
**GREEN (Cooperate):**
- Play **C** if:
  - `S >= S_safe` **and**
  - recent defection isn’t severe: `d_{t-1} <= 1/3` (or t=1)

**YELLOW (Graduated sanction):**
- Play **D** if:
  - `S >= S_safe` **and**
  - `1/3 < d_{t-1} <= 2/3`
- Otherwise play **C** (if stock is fine but mild noise, we don’t overreact)

Interpretation: if a sizable minority defects, we don’t keep being the “sucker” indefinitely. A single round of D is a credible sanction because it reduces the advantage of defectors and signals we won’t be exploited.

**RED (Emergency):**
- Play **D** if:
  - `S < S_safe` **or**
  - `d_{t-1} > 2/3`
- Stay in RED until stock recovers and opponents calm down (rules below).

Interpretation: if stock is below safe level, cooperation (lower take) is good for the pool, but **only** if others also restrain. When stock is low, *any* group-level overconsumption can push it toward collapse; if opponents are not showing restraint, you must defect to avoid being exploited and to “force” a new equilibrium (since your unilateral cooperation cannot prevent collapse if others are consuming hard).

### De-escalation / forgiveness
We don’t want permanent retaliation (that often locks in mutual destruction). So we use short memory with quick forgiveness:

- If in **YELLOW**:
  - Return to GREEN after **one** round in which `d_{t} <= 1/3` and `S_next >= S_safe`.

- If in **RED**:
  - Return to YELLOW if `S >= S_safe` but `d_{t-1}` still moderate (`>1/3`)
  - Return to GREEN if `S >= S_safe` and `d_{t-1} <= 1/3`

This makes the strategy robust to:
- accidental defection/noise (forgives quickly),
- opportunists (punishes enough to remove unilateral advantage),
- collapse dynamics (protects itself and tries to halt depletion).

---

## 2) Edge cases

### First round (t = 1)
- Play **C**.
Reason: creates the best chance of reaching/maintaining the high-stock cooperative attractor (often capacity). There is no evidence yet of exploitation.

### Last round (t = r)
Standard backward induction would suggest defection, but in tournaments that reward cumulative payoffs across many matches/opponents, “always defect in last round” harms your reputation-like dynamics within a match (it invites endgame defection spirals and earlier preemption by others).

Rule:
- If `S >= S_safe` and `d_{r-1} <= 1/3`: play **C** (finish cooperatively).
- Otherwise: play **D**.

This is collective but not naïve: cooperate when it’s actually safe and reciprocated; otherwise protect yourself.

### Very low stock
If `S` is extremely low (e.g., `S <= capacity/(4)`), then regeneration is weaker and the system is fragile. In that case:
- Force **RED** regardless of recent defection rate (play D) until `S` recovers above `S_safe`.

Yes, D takes more in the current round, which can seem anti-conservation, but in this game if others are already over-consuming, unilateral C is dominated and does not rescue the pool. The emergency rule is about not being the only restraint in a failing group.

### Near-capacity stock
If `S` is very high (e.g., `S >= 0.9*capacity`), be extra tolerant:
- Treat `d_{t-1} <= 1/2` as acceptable for staying in GREEN.
Reason: high stock can absorb some pressure without falling into the low-stock trap; over-punishing can unnecessarily drive the system away from the high-stock equilibrium.

---

## 3) “Collective mindset” alignment

This strategy is collective in three explicit ways:

1) **Starts and prefers cooperation**: it tries to hold the system in the regenerative sweet spot (around `capacity/2` to `capacity`), maximizing long-run total welfare.

2) **Punishes proportionally**: it escalates only when defection becomes common or when stock becomes unsafe, and it escalates just one level at a time (GREEN → YELLOW → RED).

3) **Forgives quickly**: the moment others return to restraint and the stock is safe, it de-escalates back to cooperation. This avoids endless vendettas and supports re-coordination without communication.

---

## Pseudocode (implementable)

```python
# Parameters: n, r, capacity
S_safe = capacity / 2

mode = "GREEN"  # initialize

def choose_action(t, S, history):
    global mode

    if t == 1:
        return "C"

    # compute last round defection rate among opponents
    last_actions = history[t-1]["actions"]     # dict: player -> "C"/"D"
    opp_defects = sum(1 for p,a in last_actions.items() if p != me and a=="D")
    d = opp_defects / (n-1)

    # tolerance adjustment near capacity
    if S >= 0.9 * capacity:
        green_thresh = 0.5
    else:
        green_thresh = 1/3

    # emergency fragility
    if S <= capacity / 4:
        mode = "RED"

    # update mode based on stock + defection
    if S < S_safe or d > 2/3:
        mode = "RED"
    elif d > green_thresh:
        mode = "YELLOW"
    else:
        mode = "GREEN"

    # last round handling
    if t == r:
        if S >= S_safe and d <= green_thresh:
            return "C"
        else:
            return "D"

    # action selection by mode
    if mode == "GREEN":
        return "C"
    elif mode == "YELLOW":
        return "D"
    else:  # RED
        return "D"
```

---

### What this tends to achieve
- With cooperative or mildly noisy opponents: stabilizes at high stock (often returning to capacity) and high long-run payoffs for everyone.
- Against exploiters: quickly removes their advantage by matching defection when necessary.
- Against chaotic/mixed populations: avoids being a perpetual cooperator in a defect-heavy environment, while still offering a clear path back to cooperation when behavior improves.

If you want, I can also provide a variant that uses *multi-round “defection budgets”* tied to observed overconsumption to make punishment even more proportional and less trigger-happy.
'''

description_COLLECTIVE_110 = '''
## Collective Strategy: **StockGuard (forgiving, state-based, retaliation with recovery)**

Goal: keep the stock near its sustainable high level (≈ capacity) to maximize long-run total payoffs, while protecting the group from persistent over-consumption. The strategy is **collective** because it treats cooperation as the default, uses **minimal necessary punishment** to deter defectors, and returns to cooperation as soon as the system is safe again.

Key idea: In this game, if too many players defect in a round, stock collapses and everyone’s future payoffs crater. So we:
- **Cooperate by default** when the group’s recent behavior is compatible with sustainability.
- **Defect temporarily** only to (a) avoid being exploited by many defectors, and (b) create a credible deterrent.
- **Recover quickly** once others stop over-consuming.

---

# 1) Decision rules (C vs D)

### Quantities you can compute from public history
In round \(t\), before choosing action, you know the current stock \(S_t\) and last round’s actions.

Let:
- \(k_{t-1}\) = number of players who defected in round \(t-1\).
- Define a **sustainable-defection threshold** based on how much consumption the stock can tolerate *while still regrowing strongly*.

Per-round total consumption if \(k\) players defect and \(n-k\) cooperate:
\[
\text{consumption}(k) = k\cdot \frac{S}{n} + (n-k)\cdot \frac{S}{2n} = \frac{S}{2n}(n+k)
\]
Remaining stock:
\[
S_{\text{rem}}(k)=S-\frac{S}{2n}(n+k)=S\left(1-\frac{n+k}{2n}\right)=S\cdot\frac{n-k}{2n}
\]

To keep the resource healthy, you want \(S_{\text{rem}}\) not too small. A natural “safe” target is **at least half of current stock** (and ideally near \( \frac{\text{capacity}}{2} \) or more), because the logistic growth term is strongest around capacity/2 and the example shows all-C returns to full capacity.

A simple, parameter-only, history-dependent rule is:

### **Rule A — “Green zone”: cooperate**
Cooperate if:
1) Stock is healthy: \(S_t \ge 0.6 \cdot \text{capacity}\), **and**
2) Defection is not spreading: \(k_{t-1} \le k_{\text{safe}}\)

Where:
\[
k_{\text{safe}} = \left\lfloor 0.2n \right\rfloor
\]
(Meaning: tolerate up to ~20% defectors without escalating. This makes the strategy robust to noise/occasional selfish types, but responds if defection becomes common.)

### **Rule B — “Yellow zone”: conditional cooperation**
If stock is moderate: \(0.3\cdot \text{capacity} \le S_t < 0.6\cdot \text{capacity}\)

- Cooperate **only if** last round was relatively cooperative:
  \[
  k_{t-1} \le k_{\text{safe}}
  \]
- Otherwise defect (to avoid being the “sucker” when the stock is already at risk).

### **Rule C — “Red zone”: protect the resource / prevent exploitation**
If stock is low: \(S_t < 0.3\cdot \text{capacity}\)

- **Cooperate** if and only if last round had *very low* defection:
  \[
  k_{t-1} = 0
  \]
- Otherwise **defect**.

Rationale: when stock is low, any significant over-consumption can prevent recovery. You only “trust” full cooperation to rebuild.

---

## Retaliation and forgiveness mechanism (core robustness)
We add a lightweight state variable: a **punishment counter** \(P\).

- Start with \(P=0\).
- After observing round \(t-1\):
  - If \(k_{t-1} > k_{\text{safe}}\), set:
    \[
    P \leftarrow \min(P_{\max},\; P + 1)
    \]
  - Else (cooperative round), reduce:
    \[
    P \leftarrow \max(0,\; P - 1)
    \]
Where \(P_{\max}=3\). (Short memory; avoids endless feuds.)

### **Rule D — During punishment, defect**
If \(P>0\): **Defect**, except if stock is extremely high and has been cooperative recently (see “recovery override” below).

### Recovery override (to restore collective optimum quickly)
If both conditions hold:
- \(S_t \ge 0.8\cdot \text{capacity}\), and
- \(k_{t-1} \le k_{\text{safe}}\)

Then **cooperate even if \(P>0\)** (i.e., forgive quickly when the system is back in a safe regime). This makes the strategy “collective-first” rather than purely retaliatory.

---

# 2) Edge cases

### First round (no history)
**Cooperate (C)**.
Reason: at full stock, cooperation is collectively optimal and also reveals who defects early.

### Last round (endgame)
Unlike standard repeated PD, the state carries within the horizon but not beyond; in the final round there is no future to protect. Purely selfish play would defect. However, in a tournament setting you’re playing against many strategies that condition on last-round behavior, and “always defect last round” can trigger earlier preemptive defection by sophisticated opponents.

So:
- If \(r\) is known and \(t=r\) (final round):
  - **Defect only if** either stock is already low \(S_t < 0.5\cdot \text{capacity}\) **or** last round had significant defection \(k_{t-1} > k_{\text{safe}}\).
  - Otherwise **Cooperate**.

This preserves collective performance against cooperative types while not sacrificing too much when the group has already broken down.

### Stock at/near zero
If \(S_t\) is tiny, both C and D payoffs are tiny. Still, if others are defecting, cooperating is wasted. Follow the Red zone rules: defect unless last round had \(k_{t-1}=0\).

### Everyone defects for many rounds
The punishment counter will keep you defecting; you won’t be exploited. If others switch back, the counter decays and you return to cooperation once the stock and behavior are safe.

---

# 3) Collective framing (why this is “collective”)
- **Default cooperative** when the system is healthy.
- **Tolerance** for a minority of defectors (doesn’t overreact to one-off defection).
- **Escalates only when needed** (when defection becomes common or stock becomes threatened).
- **Forgives quickly** and actively returns to the collectively optimal regime once conditions allow.
- **State-aware**: prioritizes preserving/rebuilding the shared stock rather than mindlessly mirroring actions.

---

# Pseudocode (implementable)

```python
# Parameters: n, r, capacity
k_safe = floor(0.2 * n)
P_max = 3
P = 0

def action(t, S_t, last_actions):  # last_actions is list of C/D from t-1, None if t=1
    global P

    if t == 1:
        return "C"

    k_last = count_D(last_actions)

    # Update punishment counter based on last round
    if k_last > k_safe:
        P = min(P_max, P + 1)
    else:
        P = max(0, P - 1)

    # Final-round rule
    if t == r:
        if S_t < 0.5 * capacity or k_last > k_safe:
            return "D"
        else:
            return "C"

    # Recovery override (forgiveness when safe)
    if S_t >= 0.8 * capacity and k_last <= k_safe:
        return "C"

    # Punishment mode
    if P > 0:
        return "D"

    # Stock zones
    if S_t >= 0.6 * capacity:  # Green
        return "C" if k_last <= k_safe else "D"
    elif S_t >= 0.3 * capacity:  # Yellow
        return "C" if k_last <= k_safe else "D"
    else:  # Red
        return "C" if k_last == 0 else "D"
```

---

## Notes on robustness vs opponent types
- **Against always-cooperate**: stays cooperating nearly all game; high total payoff.
- **Against occasional defectors**: tolerates them unless they become frequent; avoids needless collapse.
- **Against always-defect**: quickly shifts to defecting; minimizes exploitation.
- **Against “grim trigger” or strict reciprocators**: avoids last-round betrayal unless already in breakdown, improving tournament compatibility.

If you want, I can also provide a stricter (more deterrent) variant and a more generous (more cooperative) variant, depending on whether the tournament ecology is expected to be harsher or more cooperative.
'''

description_COLLECTIVE_111 = '''
## Collective, adaptive strategy: **StockGuard (forgiving, state-aware reciprocity)**

Goal: keep the stock near the regenerative sweet spot while resisting exploitation. The strategy is “collective” because it treats cooperation as the default to sustain the resource, but uses measured retaliation when others over-extract and relaxes punishment once behavior improves.

### Key idea (what we’re protecting)
Let current stock be \(S\). If everyone **Cooperates**, total consumption is \(S/2\), leaving \(S/2\). With your growth rule, that returns to capacity when \(S= \text{capacity}\) (and tends to recover strongly when stock is moderate). If too many **Defect**, the remaining stock can collapse toward 0 and never recover.

So we:
1) **Cooperate by default**, especially when stock is healthy.
2) **Punish over-extraction** when it’s clearly happening.
3) **Become more conservative when stock is low** (defection becomes catastrophic).
4) **Forgive** once others stop over-extracting (to re-enable recovery and collective gains).

---

# 1) Decision rules (C vs D)

### Quantities computed each round \(t\)
From history of last round \(t-1\):
- Let \(k_{t-1}\) = number of players who defected last round.
- Compute the **expected remaining stock after consumption** given \(S_{t-1}\) and \(k_{t-1}\):

Each cooperator consumes \(S/(2n)\), each defector consumes \(S/n\).  
Total consumption \(= (n-k)\cdot S/(2n) + k\cdot S/n = S\left(\frac{1}{2} + \frac{k}{2n}\right)\).  
Remaining fraction \(= 1 - \left(\frac{1}{2} + \frac{k}{2n}\right) = \frac{1}{2}\left(1 - \frac{k}{n}\right)\).  
So:
\[
S^{rem}(S,k) = S \cdot \frac{1}{2}\left(1 - \frac{k}{n}\right)
\]

Also define:
- **Stock health ratio** \(h = S / \text{capacity}\).
- **Danger threshold**: when \(S\) is low, any defection is very damaging. Use two thresholds:
  - `LOW = 0.35 * capacity`
  - `HIGH = 0.70 * capacity`

These are parameter-only (depend only on `capacity`), so implementable.

---

## Core rule (two-mode: “collective” vs “enforcement”)

### Mode A: **Collective rebuilding (stock is low)**
If \(S \le LOW\):  
- **Play C always**, unless *extreme* exploitation persists.

Exception (extreme exploitation):
- If in each of the last 2 rounds, at least half the group defected (\(k \ge \lceil n/2 \rceil\)), then **play D** (you are likely being farmed, and pure C may be dominated for you individually).
- Otherwise stay at **C**.

Rationale: when stock is low, defecting accelerates collapse; cooperation is collectively optimal and also often individually better in future rounds because it allows recovery.

---

### Mode B: **Normal stock management (stock is moderate/high)**
If \(S > LOW\): use **reciprocal enforcement** based on recent defection rate.

Define the **defection pressure**:
- \(p = k_{t-1}/n\) (fraction who defected last round)

Decision:
- If \(p = 0\): **C** (full cooperation observed)
- If \(0 < p < 1/2\): **C** (forgive minority deviations; keep resource stable)
- If \(1/2 \le p < 1\): **D** (enforcement: match the coalition of defectors)
- If \(p = 1\): **C** if \(S \le HIGH\), else **D**  
  (when everyone defects and stock is still high, D prevents being the lone sucker; but if stock is only moderate, choosing C can help re-start recovery and signal willingness to rebuild)

This “majority threshold” makes the strategy robust: it doesn’t overreact to one-off defections, but it won’t be exploited by a sizable defecting bloc.

---

## Additional safeguard: “Stock collapse prevention”
Even if the rule above says “D”, override to **C** if the projected remaining stock would be dangerously small.

Compute projected remaining if the same defection count repeats:
\[
S^{rem} = S \cdot \frac{1}{2}\left(1 - \frac{k_{t-1}}{n}\right)
\]

If \(S^{rem} < 0.10 \cdot capacity\): **force C**.

Rationale: defecting when the pool is about to hit near-zero is collectively disastrous and often bad even for self-interest in a repeated game.

---

# 2) Edge cases (first round, last round, etc.)

### First round (no history)
- **Play C**.
Reason: starts in a cooperative basin; if others are cooperative, you get sustained high payoffs over \(r\) rounds. If others defect, you’ll detect it immediately and respond in round 2.

### Last round (endgame)
Finite-horizon temptation exists, but the tournament setting rewards strategies that earn high total payoff across many opponent types, including those that are contingent/cooperative.

Rule for round \(t=r\):
- If \(S \le LOW\): **C** (avoid being part of collapse; also many strategies reciprocate and may still cooperate)
- Else: follow the normal rule based on \(k_{r-1}\) (don’t unconditionally defect; only enforce if others were enforcing)

This avoids being trivially exploited by always-defect-last-round bots, while not throwing away cooperation benefits against reciprocators.

### If stock hits 0 (or extremely tiny)
- **Play C** always.  
Defection yields essentially nothing and prevents recovery if any recovery is possible (in your model, at \(S=0\) growth is 0; but if it’s tiny, cooperation helps it move upward).

---

# 3) Clearly collective mindset (what it “stands for”)
- **Default pro-social**: Cooperate whenever the group is not demonstrably over-extracting.
- **Resource-first**: When stock is low, prioritize rebuilding even if it means short-run sacrifice.
- **Fair enforcement**: If a large enough portion defects, retaliate to remove the incentive to exploit cooperators.
- **Forgiveness**: As soon as defection pressure drops below majority, return to cooperation—this prevents endless vendettas that destroy the pool.

---

## Pseudocode (implementable)
```pseudo
parameters: n, r, capacity
constants:
  LOW  = 0.35 * capacity
  HIGH = 0.70 * capacity
  CRASH = 0.10 * capacity

state each round t:
  observe current stock S
  observe last round defections k_prev (if t>1)
  observe last two rounds defections k_prev2, k_prev (if t>2)

function action(t, S, history):
  if t == 1:
    return C

  p = k_prev / n
  Srem = S * 0.5 * (1 - k_prev / n)

  # collapse-prevention override
  if Srem < CRASH:
    return C

  if S <= LOW:
    # collective rebuilding unless repeatedly farmed
    if t >= 3 and k_prev >= ceil(n/2) and k_prev2 >= ceil(n/2):
      return D
    else:
      return C

  # normal stock management
  if p == 0:
    return C
  else if p < 0.5:
    return C
  else if p < 1.0:
    return D
  else: # p == 1
    if S <= HIGH:
      return C
    else:
      return D
```

---

### Why this is robust in tournaments
- Against **cooperative/reciprocal** opponents: quickly converges to all-C, maintaining high stock and high long-run payoffs.
- Against **occasional defectors/noisy** opponents: doesn’t spiral into permanent defection; forgives minority deviations.
- Against **persistent defectors**: shifts to D when defection becomes prevalent, preventing being the lone contributor.
- Against **strategies that exploit endgame**: doesn’t auto-defect last round; it conditions on observed behavior and stock, which performs better across mixed populations.

If you want, I can tune the thresholds (LOW/HIGH/CRASH and the “2-round exploitation” trigger) for specific \(n, r, capacity\) regimes, but the above is parameter-only and general-purpose.
'''

description_COLLECTIVE_112 = '''
## Strategy: **Stock-Guarded, Forgiving Reciprocity (SGFR)**  
Goal: keep the resource near the regenerative sweet spot while being hard to exploit. Cooperate by default when the stock is healthy and others are not over-consuming; switch to defect only as a **punishment / recovery tool** when others deplete the stock, and return to cooperation quickly once behavior improves.

Key idea: With this growth rule, the pool can sustainably recover when post-consumption stock stays reasonably high. Excess defection drives the stock toward collapse; collapse makes everyone’s future payoffs small. So we (i) protect stock, (ii) reciprocate to deter persistent over-consumption, and (iii) avoid irreversible “grim” behavior.

---

# 1) Decision rules: cooperate vs defect

### Observables each round
At round \(t\), before choosing action, you know:
- current stock \(S_t\)
- full history of actions (hence how many defected last round, etc.)

Let:
- \(d_{t-1}\) = number of players who defected in round \(t-1\) (for \(t=1\), define \(d_{0}=0\))
- “defection rate” last round: \(\rho_{t-1} = d_{t-1}/n\)

### Stock zones
Define two stock thresholds from parameters (no tuning to opponents required):

- **Safe/Abundant:** \(S_t \ge 0.8 \cdot \text{capacity}\)  
- **Caution:** \(0.5 \cdot \text{capacity} \le S_t < 0.8 \cdot \text{capacity}\)
- **Critical:** \(S_t < 0.5 \cdot \text{capacity}\)

(These are simple fractions; they scale across capacities and n.)

### Core rule set
**Rule A — Default cooperative stance (collective-first):**
- If stock is **Safe/Abundant** *and* last round defection was not high:  
  **Play C** when \(\rho_{t-1} \le 1/3\).

Rationale: When the pool is healthy and most are not over-consuming, keep it stable and let growth maintain capacity.

---

**Rule B — Proportional punishment when others over-consume:**
- If stock is **Safe/Abundant** but \(\rho_{t-1} > 1/3\):  
  **Play D** for one round (a “warning shot”), then reassess next round.

Rationale: If too many defect, cooperating becomes a sucker move and also fails to deter future defection. A one-round punishment is strong but not permanently destructive.

---

**Rule C — Caution zone: prioritize deterrence + stabilization:**
- If stock is **Caution**:
  - If \(\rho_{t-1} \le 1/6\): **Play C**
  - Else: **Play D** (until defection rate drops)

Rationale: In mid stock, even moderate defection can push the system toward critical. We tighten tolerance.

---

**Rule D — Critical zone: “resource triage”**
- If stock is **Critical**: **Play C**, *unless* defection is extreme:
  - If \(\rho_{t-1} \ge 1/2\): **Play D**  
  - Else **Play C**

Rationale: When stock is low, mutual restraint (C) is the only path back. But if at least half defect, cooperating just gets exploited and may not meaningfully save the pool; defecting becomes a defensive response.

---

### Forgiveness / return-to-cooperation
To remain robust against noise and one-off deviations, SGFR is explicitly forgiving:

- After you play **D** as punishment, you return to **C** as soon as:
  - \(S_t\) is not Critical **and**
  - \(\rho_{t-1}\) is at or below the zone’s tolerance threshold (as above).

This prevents spirals and supports re-coordination.

---

# 2) Edge cases and round-specific behavior

### First round (no history)
- **Round 1:** **Play C**.

Rationale: Sets cooperative baseline; if opponents are cooperative, you lock in high long-run payoffs. If not, you have immediate data to respond in round 2.

---

### Last round (endgame risk)
Finite horizon invites endgame defection. To remain “collective” while not being naive:

- **Final round \(t=r\):**
  - If \(S_r\) is **Safe/Abundant** and \(\rho_{r-1} \le 1/3\): **Play C**
  - Otherwise: **Play D**

This is a soft endgame adjustment: you reward a cooperative group with cooperation, but you don’t donate to a collapsing or endgame-defecting population.

---

### Penultimate round (anticipating endgame)
- **Round \(r-1\):** use normal rules, but if \(\rho_{r-2} > 1/3\) (signs of endgame unraveling), treat as one zone worse (Safe→Caution, Caution→Critical) for deciding.

---

### Stock at/near zero
If \(S_t \approx 0\), payoffs are ~0 regardless. Still:
- Play **C** unless \(\rho_{t-1}\ge 1/2\) (as per Critical rule).  
The intent is to encourage any possible recovery rather than accelerate collapse.

---

# 3) “Collective mindset” features (why this is collective, not just reactive)

1. **Stock-protection priority:** thresholds explicitly guard the regenerative base rather than only chasing immediate payoff.
2. **Majority-based reciprocity:** punishment triggers only when defection is meaningfully widespread, avoiding needless retaliation against isolated defectors.
3. **Forgiveness:** quick return to C makes it possible to re-establish cooperation after perturbations.
4. **Adaptive to opponents:** works against:
   - Always-C: stays C, preserves capacity, high cumulative payoffs.
   - Always-D: shifts to D quickly, avoids chronic exploitation.
   - Tit-for-tat–like: converges to cooperation because punishment is brief and reversible.
   - Mixed/erratic: stabilizes by conditioning on both stock health and observed defection rate.

---

# Pseudocode (implementable)

```python
def SGFR_action(t, r, n, capacity, S_t, history_actions):
    # history_actions is list of lists: history_actions[t-1][i] in {"C","D"}
    if t == 1:
        return "C"

    d_prev = sum(1 for a in history_actions[t-2] if a == "D")
    rho = d_prev / n

    # stock zones
    if S_t >= 0.8 * capacity:
        zone = "SAFE"
    elif S_t >= 0.5 * capacity:
        zone = "CAUTION"
    else:
        zone = "CRITICAL"

    # endgame adjustments
    if t == r:
        if zone == "SAFE" and rho <= 1/3:
            return "C"
        else:
            return "D"

    if t == r-1 and t >= 3:
        d_prev2 = sum(1 for a in history_actions[t-3] if a == "D")
        rho2 = d_prev2 / n
        if rho2 > 1/3:
            # treat as one zone worse
            if zone == "SAFE": zone = "CAUTION"
            elif zone == "CAUTION": zone = "CRITICAL"

    # zone-specific tolerances
    if zone == "SAFE":
        return "C" if rho <= 1/3 else "D"

    if zone == "CAUTION":
        return "C" if rho <= 1/6 else "D"

    # CRITICAL
    return "D" if rho >= 1/2 else "C"
```

---

If you want, I can also provide (a) a variant that uses a rolling window of defections (more robust to noisy opponents), or (b) a version that explicitly targets a post-consumption stock band (e.g., keep expected remaining stock near capacity/2) by estimating others’ likely consumption from history.
'''

description_COLLECTIVE_113 = '''
## Strategy: **Stock-Guard Conditional Cooperation (SGCC)**  
Collective aim: keep the resource near **capacity** (high sustainable yields), while **discouraging over-consumption** by switching to defection when others over-consume and returning to cooperation once they stop. The strategy is parameterized, stateful, history-based, and does not assume coordination schedules.

---

# 1) Decision rules (C vs D)

### Key idea
- **Cooperate** when the group’s past behavior is compatible with keeping the stock high.
- **Defect** as a *sanction* when others’ behavior risks collapse or is persistently exploitative.
- Use **stock thresholds** to avoid “punishing into collapse”: when stock is low, defecting is catastrophic; when stock is high, sanctioning is affordable.

### Quantities computed from history
Let:
- `S_t` be the stock at the start of round `t`.
- In round `t-1`, let `d_{t-1}` = number of opponents (out of `n-1`) who defected (played D).
- Let `Dshare_{t-1} = d_{t-1}/(n-1)`.

Define a **running exploitation score** (EWMA) that tracks whether the environment is cooperative:
- `E_1 = 0`
- `E_t = (1-β)*E_{t-1} + β*(Dshare_{t-1})` for `t ≥ 2`, with `β = 0.3` (moderate responsiveness)

So `E_t` near 0 means mostly cooperative opponents; near 1 means mostly defectors.

### Stock zones (state-dependent behavior)
Define normalized stock `x_t = S_t / capacity`.

- **Green zone:** `x_t ≥ 0.85` (stock healthy, we can afford sanctions)
- **Yellow zone:** `0.45 ≤ x_t < 0.85` (recovering/fragile; prioritize regeneration)
- **Red zone:** `x_t < 0.45` (dangerously low; defecting accelerates collapse)

These cutoffs are chosen for robustness, not optimality per opponent.

### Core rule
At round `t`:

**A) Red zone (x_t < 0.45):**  
Always play **C**.  
Rationale: When stock is low, defection increases immediate gain but worsens the already-bad state; collective recovery dominates. Even if others defect, your defection cannot “out-punish” collapse.

**B) Yellow zone (0.45 ≤ x_t < 0.85):**  
Play **C** unless exploitation is high and recent:  
- Play **D** only if `E_t ≥ 0.55` **and** `d_{t-1} ≥ ceil((n-1)/2)`  
Otherwise **C**.  
Rationale: in the recovery region, sanction only if there is clear majority defection; otherwise contribute to rebuilding.

**C) Green zone (x_t ≥ 0.85):**  
Use conditional cooperation with fast punishment and easy forgiveness:  
- If `d_{t-1} == 0` → **C** (full cooperation)  
- Else if `d_{t-1} ≥ ceil((n-1)/3)` or `E_t ≥ 0.40` → enter/continue **punishment mode** and play **D**  
- Else (a small amount of defection) → **C** (don’t overreact)

**Punishment mode mechanics (in Green/Yellow only):**
- When triggered, defect for **P rounds**, where  
  `P = 1 + floor(2*E_t)` → typically 1–3 rounds.
- After each punishment round, if `d_{t-1} == 0`, immediately exit punishment and return to **C** (forgiveness).
- If stock falls into Red zone at any time, override punishment and play **C**.

This creates a credible deterrent in high-stock states but avoids spiraling into mutual defection when stock becomes fragile.

---

# 2) Edge cases

### First round
Round 1: play **C**.  
Reason: Starting cooperative is collectively efficient and reveals who exploits without pre-committing to being exploited indefinitely.

### Last round (round r)
Play **D** *only if the environment is already non-cooperative* and stock is not fragile:
- If `x_r ≥ 0.85` and (`E_r ≥ 0.50` or `d_{r-1} ≥ ceil((n-1)/2)`) → **D**
- Else → **C**

Reason: There is an end-game temptation to defect, but unconditional last-round defection destroys the collective norm and can reduce earlier cooperation in adaptive opponents. This “conditional end-game” keeps credibility: cooperate if cooperation is present; otherwise take the higher immediate payoff when it doesn’t threaten recovery.

### Very small n (e.g., n=2)
The rules still apply:
- `ceil((n-1)/3)` becomes 1, so any opponent defection in Green triggers punishment—appropriate in 2-player settings (Tit-for-Tat-like but stock-aware).

### Capacity vs stock bounds
If the tournament implementation ever provides stock outside expected bounds, treat:
- `x_t = clamp(S_t/capacity, 0, 1)`  
and apply the same zones.

---

# 3) Collective mindset (why this is “collective”)
This strategy explicitly:
- **Prioritizes stock sustainability** (always C in Red, mostly C in Yellow).
- **Conditions cooperation on observed restraint**, punishing only when defection is frequent enough to threaten the collective good.
- **Forgives quickly** to re-enter high-yield cooperative states as soon as others stop exploiting.
- **Avoids escalation traps** by not defecting when the resource is fragile (where punishment harms everyone more than it disciplines).

---

## Pseudocode (implementable)

```python
# Parameters: n, r, capacity
beta = 0.3

# State (persistent)
E = 0.0
punish_remaining = 0

def decide(t, S_t, history):  # history includes last round actions of others if t>1
    global E, punish_remaining
    x = max(0.0, min(1.0, S_t / capacity))

    if t == 1:
        return "C"

    # compute last round defection share among opponents
    d_last = count_opponents_played_D(history[t-1])   # 0..n-1
    Dshare = d_last / (n-1)

    # update exploitation EWMA
    E = (1 - beta)*E + beta*Dshare

    # stock zones
    RED = (x < 0.45)
    YELLOW = (0.45 <= x < 0.85)
    GREEN = (x >= 0.85)

    # Hard override: never defect in red zone
    if RED:
        punish_remaining = 0
        return "C"

    # last round special-case
    if t == r:
        if x >= 0.85 and (E >= 0.50 or d_last >= ceil((n-1)/2)):
            return "D"
        else:
            return "C"

    # If currently punishing, continue unless full cooperation observed
    if punish_remaining > 0:
        if d_last == 0:
            punish_remaining = 0
            return "C"
        punish_remaining -= 1
        return "D"

    # trigger punishment?
    if GREEN:
        if d_last >= ceil((n-1)/3) or E >= 0.40:
            punish_remaining = 1 + int(2*E)  # 1..3 typically
            return "D"
        else:
            return "C"

    # YELLOW:
    if YELLOW:
        if (E >= 0.55) and (d_last >= ceil((n-1)/2)):
            punish_remaining = 1  # short punishment in fragile zone
            return "D"
        else:
            return "C"
```

---

### Intuition check against typical opponents
- **Always-cooperate opponents:** stays in C, maintains capacity, high total payoffs.
- **Always-defect opponents:** triggers D when stock is high (deterrence), but switches to C when stock becomes low to prevent total collapse and preserve remaining long-run value.
- **Mixed/learning opponents:** sees clear correlation “defection causes punishment, cooperation restores cooperation,” encouraging them toward restraint.
- **Noisy opponents (occasional D):** doesn’t overreact unless defection frequency rises; forgiveness is fast.

If you want, I can also provide (a) a more aggressive variant (higher deterrence) and (b) a more forgiving variant (higher robustness to noise), both using the same structure.
'''

description_COLLECTIVE_114 = '''
## Strategy: **Stock-Guided, Accountability-Based Conditional Cooperation (SGA-CC)**

Core idea: keep the common pool near a “high-growth, high-yield” region by defaulting to cooperation when the stock is healthy, but switch to defection quickly when others are depleting the resource, and return to cooperation once behavior and stock recover. This is collective because it treats the stock as the primary public signal and uses punishment only to restore sustainable use, not to maximize short-run extraction.

---

# 1) Decision rules (C vs D)

### Quantities you can compute from history
At the start of round *t*, you observe current stock \(S_t\) and last round’s actions.

Let:
- \(k_{t-1}\) = number of defectors in round \(t-1\) (if \(t=1\), undefined)
- Predicted next stock if in round *t* exactly \(k\) players defect (and \(n-k\) cooperate), given current stock \(S\):

**Consumption share:**
\[
\text{total\_consumption}(k, S) = (n-k)\cdot \frac{S}{2n} + k\cdot \frac{S}{n} = S\left(\frac{1}{2}+\frac{k}{2n}\right)
\]
\[
S_{\text{rem}}(k,S)=S-\text{total\_consumption}(k,S)=S\left(\frac{1}{2}-\frac{k}{2n}\right)
\]

**Growth and next stock:**
\[
g=2S_{\text{rem}}(1-S_{\text{rem}}/\text{capacity}),\quad S'=\min(S_{\text{rem}}+g,\text{capacity})
\]

### Target principle
Maintain stock in a “safe high zone” where cooperation is self-reinforcing and the pool can recover even if a few defect.

Define two thresholds:
- **High threshold:** \(S_{\text{high}} = 0.8\cdot \text{capacity}\)
- **Low threshold:** \(S_{\text{low}} = 0.4\cdot \text{capacity}\)

(These are parameter-only, do not require knowing opponents.)

### Behavioral state
Maintain an internal integer **punish_timer ≥ 0**.

- **punish_timer = 0** means “normal cooperative mode”
- **punish_timer > 0** means “temporary defection mode” to deter/contain exploitation

### Main action rule (per round t)

**Rule A — Endgame protection (final round):**
- If \(t = r\): **Play D**.
  - Rationale: no future to protect, and others may endgame-defect. This avoids being the “sucker” in the last round.

**Rule B — Resource emergency (stock critically low):**
- If \(S_t \le S_{\text{low}}\): **Play C** unless in explicit punishment (below).
  - Rationale: with low stock, collective survival dominates; cooperation reduces consumption and lets growth work.

**Rule C — Punishment mode:**
- If **punish_timer > 0**: **Play D**, then decrement punish_timer by 1.
  - Rationale: short, sharp punishment makes defection unprofitable as a repeated pattern, but time-limited to allow re-cooperation.

**Rule D — Trigger punishment when exploitation is detected:**
If not in punishment (punish_timer = 0) and \(t>1\), trigger punishment if **either** is true:

1) **Too many defectors last round**:
- If \(k_{t-1} \ge \lceil n/3 \rceil\), set:
  \[
  \text{punish\_timer} = 2
  \]
  and **Play D** this round.

2) **Stock drop indicates unsustainable extraction**:
- Compute observed stock change last round: \(\Delta S = S_t - S_{t-1}\) (you can track prior stock).
- If \(S_t < S_{t-1}\) **and** \(S_{t-1} \ge S_{\text{high}}\), set punish_timer = 1 and **Play D**.
  - Rationale: when starting from high stock, cooperation should typically keep stock high; a drop is a strong signal of excessive defection.

**Rule E — Default cooperation in healthy conditions:**
- Otherwise (no endgame, not low-stock emergency, not punishment, no trigger): **Play C**.

### Recovery / forgiveness
Punishment is finite and automatically ends. After punish_timer reaches 0:
- Return to **C** if \(S_t > S_{\text{low}}\).
- If \(S_t \le S_{\text{low}}\), stay **C** (resource emergency rule).

This ensures the strategy is not “grim trigger”; it can restore cooperation after temporary discipline.

---

# 2) Edge cases

### First round (t = 1)
- **Play C**.
  - Rationale: starts collectively, tests whether others exploit, and—given the logistic growth—full cooperation at high stock is sustainable and yields high long-run payoffs.

### Last round (t = r)
- **Play D** (Rule A).
  - Rationale: prevents endgame exploitation; consistent with tournament robustness.

### Near last rounds (t = r-1)
- No special casing beyond the normal rules.
  - If others begin endgame defection in r-1, the defector-count trigger (Rule D) will likely activate.

### Very low stock (near collapse)
- If \(S_t\) is low, the strategy primarily **cooperates** to enable regrowth, except during a short punishment that may already be in progress. (If you want an even more conservationist variant, you can override punishment when \(S_t\) is extremely low, e.g., \(S_t \le 0.2\cdot \text{capacity}\), and force C.)

### Capacity values and constraints
- Uses only fractions of capacity; works for any capacity ≥ 2n as given.

---

# 3) Why this is “collective” and robust

**Collective alignment**
- Defaults to C to keep stock high (the public good).
- Uses the stock level as the central coordination device: when stock is healthy, cooperate; when threatened, either conserve (C) or punish exploiters (temporary D) to restore sustainable norms.

**Robustness to opponent types**
- **Always-cooperators:** you mostly cooperate, preserving stock; only defect on the last round.
- **Always-defectors:** you quickly enter punishment and stop being exploited; your payoffs won’t be maximal, but you avoid being consistently the lowest earner.
- **Noisy / erratic players:** short punishments avoid permanent breakdown; forgiveness allows recovery.
- **Conditional cooperators / reciprocity-based strategies:** your behavior is legible—cooperate when things are good, punish when defection is common—so mutual cooperation is likely.
- **Sophisticated exploiters:** the defector-count trigger plus stock-drop trigger makes “sneaky” partial defection harder to sustain without consequences.

---

## Pseudocode (implementation-ready)

```python
# Parameters: n, r, capacity
S_high = 0.8 * capacity
S_low  = 0.4 * capacity

punish_timer = 0
prev_stock = None

def action(t, S_t, history_actions, history_stocks):
    global punish_timer, prev_stock

    # Last round: endgame
    if t == r:
        return "D"

    # Emergency conservation (unless you choose to override punishment)
    if S_t <= S_low and punish_timer == 0:
        return "C"

    # Punishment mode
    if punish_timer > 0:
        punish_timer -= 1
        return "D"

    # First round
    if t == 1:
        prev_stock = S_t
        return "C"

    # Compute last round defectors
    last_actions = history_actions[-1]  # list length n
    k_last = sum(1 for a in last_actions if a == "D")

    # Trigger punishment on widespread defection
    if k_last >= math.ceil(n/3):
        punish_timer = 2
        return "D"

    # Trigger punishment if stock fell from a high state
    S_prev = history_stocks[-2]  # stock at start of round t-1
    if S_prev >= S_high and S_t < S_prev:
        punish_timer = 1
        return "D"

    # Default: cooperate
    return "C"
```

---

If you want, I can also provide a variant that uses a **model-based “sustainable defector threshold”** computed from the logistic update (instead of fixed 0.8/0.4 capacity cutoffs), which can be even more adaptive across parameter regimes.
'''

description_COLLECTIVE_115 = '''
## Strategy: **StockGuard (forgiving grim + stock stabilization)**  
Goal: keep the resource near a *high-growth, high-yield* region by cooperating by default, but apply **fast, proportional retaliation** when opponents over-consume, and **recover cooperation** once behavior improves. The strategy uses only parameters, current stock, and full history.

Key idea: In any round, your action changes (i) your immediate payoff and (ii) next round’s stock via total consumption. Because defection can crash stock quickly, we make cooperation the default but **punish detected over-consumption enough to make continued defection unattractive**, while avoiding irreversible collapse when cooperation could still restore stock.

---

# 1) Decision rules (C vs D)

### Definitions (computed each round t before choosing action)
Let:
- `S` = current stock at start of round t  
- `cap` = capacity  
- `n` = number of players  
- `H` = history of all past actions (everyone observable)

For each player j, define last-round action indicator:
- `a_j(t-1) ∈ {C, D}` (if t=1, undefined)

Compute last-round defection rate:
- `d_last = (# of players who played D in round t-1) / n`  (if t=1, treat as 0)

Compute your rolling estimate of “hostility” (exponential moving average of defection rate):
- `h_t = α * d_last + (1-α) * h_{t-1}`, with `h_1 = 0`, `α = 0.5`  
  (fast adaptation without being too jittery)

Compute a **stock safety threshold**:
- `S_safe = cap/2`  
Reason: logistic growth is strong around cap/2; above it, the system recovers well from cooperative use.

Compute a **critical stock threshold** below which unilateral cooperation is usually exploited and risks collapse:
- `S_crit = cap/(2n)` (small but scales with n)

---

## Core rule set

### Rule A — Start cooperative when stock is healthy
If `t == 1` and `S >= S_safe`: **Play C**.  
Rationale: establishes a pro-social baseline and maximizes long-run yield if others are even slightly cooperative.

### Rule B — Stock emergency brake
If `S <= S_crit`: **Play D**.  
Rationale: when stock is extremely low, growth is tiny; you cannot “invest” meaningfully. Take the larger immediate share (D) because cooperation is unlikely to restore stock fast, and you must protect yourself against opportunists.

### Rule C — Proportional retaliation when opponents defect
If `S > S_crit`, decide based on hostility `h_t`:

- If `h_t <= 0.15`: **Play C** (broadly cooperative population)
- If `0.15 < h_t <= 0.45`: **Play C** *unless* you were personally targeted by persistent defectors (see Rule D)
- If `h_t > 0.45`: **Play D** (population mostly defecting; avoid being the sucker)

This makes punishment kick in only when defection is meaningfully present, but not for one-off noise.

### Rule D — Identify and punish persistent defectors (targeted discipline)
Maintain for each opponent j a “defection streak”:
- `streak_j = consecutive rounds up to t-1 where j played D`

Let:
- `P = (# of opponents with streak_j >= 2) / (n-1)` = fraction of *persistent* defectors

If `P >= 0.25` and `S > S_crit`: **Play D**  
Else follow Rules A–C.

Rationale: A few “always-D” types can destabilize cooperation even if the average defection rate isn’t huge. This rule retaliates against entrenched exploitation.

### Rule E — Forgiveness / re-cooperation trigger
If you played D in the previous round, you return to C when BOTH:
- `d_last <= 1/n` (at most one defector last round), and
- `S >= S_safe` (system is back in a good recovery region)

Then **Play C**.

Rationale: prevents endless feuds; cooperation resumes quickly once the environment and behavior look safe.

---

# 2) Edge cases

### First round
- If `S >= S_safe`: **C**
- Else if stock already low (unusual but possible): follow Rule B (likely D)

### Last round (t = r)
Classic endgame pressure exists, but full defection can also crater the stock earlier if others anticipate it. Use a *tempered* last-round adjustment:

- If `h_t > 0.45` or `S <= S_crit`: **D**
- Else: **C**

Rationale: if the group stayed cooperative, keep C to avoid needlessly rewarding late defectors (you still get half-share, and you don’t signal earlier defection in r-1). If the group is already hostile, take D.

### Near-last rounds (t = r-1)
Do **not** automatically defect. Keep the same rules.  
Rationale: your best defense against “unraveling” is to condition on observed behavior, not on time alone; many tournament agents won’t backward induct perfectly, and conditional cooperation can keep payoffs high.

### Capacity extremes / parameter robustness
- If `cap` is very large relative to n, `S_safe = cap/2` still targets the high-growth region.
- If `cap` is only slightly above `2n`, the thresholds still scale; the emergency brake (Rule B) prevents repeated sucker cooperation at tiny stock.

---

# 3) Collective alignment (why this is “collective”)
- **Default is C** when the stock can sustain and regrow, because mutual C keeps the resource at/near capacity and maximizes long-run total payoff.
- **Punishment is contingent and proportional**, intended to *change incentives* for defectors and protect cooperators, not to maximize short-run gain.
- **Forgiveness is explicit**, so the group can return to high-yield cooperation after brief shocks or exploration.
- **Stock-aware control** treats the pool as a shared asset: actions adapt not only to opponents but also to ecological state.

---

# Pseudocode (implementable)

```python
# Parameters: n, r, cap
alpha = 0.5
S_safe = cap / 2
S_crit = cap / (2*n)

h = 0.0
streak = {j: 0 for j in opponents}

def action(t, S, last_actions):  # last_actions: dict player->C/D for t-1, empty if t=1
    global h, streak

    if t == 1:
        return "C" if S >= S_safe else ("D" if S <= S_crit else "C")

    # update streaks and hostility estimate
    d_last = sum(1 for j,a in last_actions.items() if a == "D") / n
    h = alpha*d_last + (1-alpha)*h

    for j in opponents:
        if last_actions[j] == "D":
            streak[j] += 1
        else:
            streak[j] = 0

    P = sum(1 for j in opponents if streak[j] >= 2) / (n-1)

    # Emergency brake
    if S <= S_crit:
        return "D"

    # Forgiveness trigger (if we defected last round is known in state of our own history)
    if my_last_action == "D" and d_last <= 1/n and S >= S_safe:
        return "C"

    # Target persistent defectors
    if P >= 0.25:
        return "D"

    # Population-level proportional response
    if h <= 0.15:
        a = "C"
    elif h <= 0.45:
        a = "C"
    else:
        a = "D"

    # Last round tempered adjustment
    if t == r:
        if h > 0.45:
            return "D"
        else:
            return a

    return a
```

---

## Intuition in one line
**Cooperate to keep stock high and growth strong; defect only when the group shows sustained exploitation or the stock is too low to justify “investing,” and forgive quickly once cooperation becomes safe again.**
'''

description_COLLECTIVE_116 = '''
## Strategy: **Stock-Guarded Reciprocal Sustainability (SGRS)**  
Goal: keep the resource near **capacity** (where growth is strong and stable) while **rewarding cooperation**, **punishing over-extraction**, and **surviving against defect-heavy opponents**. The strategy uses only parameters *(n, r, capacity)* plus observed history and current stock.

---

# 1) Decision rules (C vs D)

### Key idea
Each round you decide between:
- **C** to sustain the stock and signal/maintain cooperation,
- **D** to (i) punish exploitation, (ii) prevent being a persistent sucker, and (iii) “salvage” value when the stock is already collapsing.

We compute two things each round:
1) **Stock regime**: Is the stock healthy or endangered?  
2) **Opponents’ recent extraction level**: Are others behaving sustainably?

### A. Stock regime thresholds
Let current stock be `S`.

Define normalized stock `x = S / capacity`.

Use these regimes (robust across capacities and n):
- **Healthy**: `x ≥ 0.75`
- **Caution**: `0.40 ≤ x < 0.75`
- **Danger**: `0.15 ≤ x < 0.40`
- **Collapse**: `x < 0.15`

Intuition:  
- Above ~0.75, the resource is abundant; cooperation is cheap and growth can restore losses.  
- Below ~0.40, the system is at real risk; you must prevent free-riding from pushing it into collapse.  
- Below ~0.15, growth is weak in absolute terms and any consumption is destructive; you mainly switch to self-protection.

### B. Estimate opponent “defection pressure”
From last round actions (perfectly observed), compute:
- `d = (# of opponents who played D last round) / (n-1)`  in `[0,1]`

Also track a short memory to avoid overreacting to noise:
- `d̄ = average of d over last m rounds`, with `m = 3` (or fewer if early).

### C. Core action rule
**Rule 1 (Default cooperation when healthy and others not too exploitative):**
- If `x ≥ 0.75` and `d̄ ≤ 0.30` → play **C**.

**Rule 2 (Reciprocal punishment when exploitation appears):**
- If `x ≥ 0.75` and `d̄ > 0.30` → play **D** with probability `p = min(1, (d̄ - 0.30)/0.50)`  
  (i.e., gradual ramp-up; at `d̄=0.80`, you punish with `p=1`).

**Rule 3 (Caution zone: cooperate only if group seems mostly cooperative):**
- If `0.40 ≤ x < 0.75`:
  - If `d̄ ≤ 0.15` → **C**
  - Else → **D**

**Rule 4 (Danger zone: prioritize deterrence):**
- If `0.15 ≤ x < 0.40`:
  - If `d̄ == 0` (everyone cooperated recently) → **C**  
  - Else → **D**  
Rationale: when stock is low, a single defector meaningfully accelerates collapse; you must punish quickly.

**Rule 5 (Collapse zone: salvage/self-protection):**
- If `x < 0.15` → **D**  
Rationale: at very low stock, cooperation mostly donates value to others’ potential defection and cannot rebuild fast enough within finite rounds.

---

# 2) Edge cases

### First round
Play **C**.  
Reason: With stock initially at capacity, mutual cooperation is Pareto-superior long-run, and starting with C creates a chance to coordinate without communication.

### Last round (round r)
Play **D**.  
Reason: With a known final period, cooperation has no future leverage. Defection strictly dominates per-round payoff given the same `S`. (This is also robust against unknown opponents.)

### Second-to-last round (round r-1)
Use the normal rule, **but** tighten punishment:
- treat `d̄` as `max(d̄, d_last)` (i.e., if anyone defected last round, respond more strongly).
Rationale: Endgame incentives to defect rise; you need faster deterrence.

### Forgiveness / re-entry to cooperation
This strategy is not permanently grim. It re-enters cooperation when:
- stock is **Healthy** (`x ≥ 0.75`) **and**
- recent defection pressure is low (`d̄ ≤ 0.30`).

This ensures you don’t get stuck in mutual defection when others return to C.

### Handling “always defect” opponents
Against persistent defectors, `d̄` rises quickly, pushing you to **D** most rounds (especially once stock leaves Healthy). You won’t keep donating.

### Handling “mostly cooperate but occasional mistakes”
Single-round noise won’t flip you permanently because:
- you use `d̄` (3-round average),
- punishment is gradual in Healthy regime (probabilistic escalation),
- and you forgive when cooperation resumes.

---

# 3) Collective mindset (what this strategy is optimizing)

This is explicitly a **collective-first** strategy under uncertainty:

- **When the stock is healthy**, it tries to establish a *cooperative basin* by playing C unless there is clear evidence of exploitation. This supports the socially optimal cycle (keeping stock near capacity where logistic growth can replenish after sustainable consumption).
- **When exploitation appears**, it applies *measured punishment* to make defection unprofitable in expectation for opponents who are responsive.
- **When the stock becomes endangered**, it shifts to *strict deterrence* because the collective outcome becomes fragile: one defector can tip the system toward collapse.
- **When collapse is imminent**, it stops sacrificing: cooperation cannot reliably rebuild in finite time against strategic opponents, so it protects its own payoff.

---

# Pseudocode (implementable)

```python
# Inputs each round t:
# n, r, capacity
# S = current stock
# history: list of past rounds with all players' actions (perfectly observed)

def SGRS_decision(t, S, history, n, r, capacity):
    x = S / capacity

    # Last round defection share among opponents
    if t == 1:
        return "C"   # first round

    if t == r:
        return "D"   # last round

    # compute d values for last up-to-3 rounds
    m = 3
    ds = []
    for k in range(max(1, t-m), t):  # rounds are 1-indexed
        opp_def = count_opponents_defected(history[k])  # exclude self
        ds.append(opp_def / (n-1))
    dbar = sum(ds) / len(ds)
    d_last = ds[-1]

    # endgame tightening at t=r-1
    if t == r-1:
        dbar = max(dbar, d_last)

    # Stock-regime rules
    if x >= 0.75:
        if dbar <= 0.30:
            return "C"
        else:
            p = min(1.0, (dbar - 0.30) / 0.50)  # ramps from 0 to 1
            return "D" if random() < p else "C"

    elif x >= 0.40:
        return "C" if dbar <= 0.15 else "D"

    elif x >= 0.15:
        return "C" if dbar == 0 else "D"

    else:
        return "D"
```

---

## Why this should perform well in a tournament
- **Finds cooperation quickly** with cooperative/reciprocal opponents (starts C; stays C when stock is healthy and defections are rare).
- **Resists exploitation** by switching to D when defection pressure rises, with stricter behavior as the stock becomes more fragile.
- **Avoids unnecessary endless conflict** by forgiving once opponents return to cooperation and stock is healthy.
- **Endgame-safe** by defecting in the final round and tightening in r-1.

If you want, I can also provide a variant tuned to be *more forgiving* (higher long-run social welfare but slightly more exploitable) or *more punitive* (better against defectors but harder to sustain cooperation).
'''

description_COLLECTIVE_117 = '''
## Strategy: **Stock-Sustaining, Forgiving Trigger (SSFT)**  
Goal: keep the resource near a “safe” high-stock region so everyone can earn large per-round payoffs, while still being able to punish sustained over-consumption quickly enough that defect-heavy opponents don’t farm you.

Key idea:  
- When stock is healthy, cooperation (C) is collectively optimal because it preserves the stock and allows repeated high payouts.  
- When others over-consume, the stock drops; at that point you must defect (D) to (i) avoid being the only cooperator, and (ii) apply pressure so defectors don’t strictly benefit from deviating.  
- Because the system has strong logistic regrowth when stock is mid-range, a “repair mode” can restore the stock if the group returns to C.

This strategy uses **only** parameters (n, r, capacity), current **stock**, and full **history of actions**.

---

# 1) Decision rules (C vs D)

### Definitions computed each round *t* before choosing action
Let:
- `S` = current stock at start of round t.
- `m_{t-1}` = number of players who defected in the previous round (for t=1, define `m_0 = 0`).
- “Recent defection rate” over a short window `W`:
  - Let `W = min(5, t-1)` (at most last 5 rounds that exist).
  - `avgD = (total number of D-actions by all players over last W rounds) / (n*W)`  
  (for t=1, set `avgD = 0`)

### Stock zones (thresholds depend on capacity, but also respect feasible range)
We use 3 zones:
- **Green (healthy):** `S >= 0.8*capacity`
- **Yellow (caution):** `0.5*capacity <= S < 0.8*capacity`
- **Red (critical):** `S < 0.5*capacity`

(These cutoffs are chosen because in your dynamics, high stock is valuable and stable under mutual C; mid-stock regrows fast; low stock is fragile and easily collapses under D.)

### Core action policy
**A. First round (t = 1):**  
- Play **C**.  
Rationale: You create the possibility of a cooperative path immediately; if others defect, you’ll detect it and respond.

**B. Green zone (S >= 0.8*capacity): “Cooperate unless clear evidence of exploitation.”**  
Play **C** if *either* of these holds:
1) `m_{t-1} == 0` (no one defected last round), **or**
2) `avgD <= 0.15` (defection is rare), **or**
3) “forgiveness condition”: last round had defectors but they seem to be stopping, i.e. `m_{t-1} <= 1` and `avgD` is decreasing vs previous window (optional tie-break if you implement trend).

Otherwise play **D**.

Intuition: In a healthy stock state, a single accidental or exploratory defection shouldn’t permanently collapse cooperation. But if defection is frequent, you switch to punishment.

**C. Yellow zone (0.5*capacity <= S < 0.8*capacity): “Stabilize; punish more readily.”**  
Play **C** only if:
- `m_{t-1} == 0` **and** `avgD <= 0.10`

Else play **D**.

Intuition: When stock is lower, even moderate defection can push it into a dangerous trajectory; you require stronger evidence of cooperation before contributing.

**D. Red zone (S < 0.5*capacity): “Emergency mode.”**  
Play **D**, *unless* there is strong evidence the group has coordinated on recovery:
- If `m_{t-1} == 0` for **two consecutive rounds** (i.e., last two rounds had zero defectors), then play **C** to help rebuild.

Intuition: In red, cooperating while others defect is extremely costly and can lead to collapse. But if the group is already cooperating, C helps recovery.

---

# 2) Edge cases / endgame handling

### Last round (t = r)
- If `S` is in **Green** and `m_{t-1} == 0` and `avgD` is very low: play **C**.
- Otherwise: play **D**.

Reasoning: With no future, the “punishment leverage” is gone, so you take the safe best response unless the group has shown strong, stable cooperation and stock is high (in which case C is only half the immediate payoff of D, so you need strong confidence to sacrifice).

A simple implementable version:
- In the last round, play **D** unless `m_{t-1}==0` and `avgD <= 0.05` and `S >= 0.9*capacity`.

### Second-to-last round (t = r-1)
- Use the normal rules, but slightly stricter in Green/Yellow (because cooperation has only one future round to pay back). For example, reduce the `avgD` tolerance by 0.05.

---

# 3) Collective mindset alignment

This is a **collective strategy** in three ways:

1) **Stock-first objective:** It explicitly uses the common stock as the primary signal and aims to keep it high (Green) where total surplus over time is maximized.

2) **Forgiving but not naive:** It starts with cooperation and tolerates rare “noise” or experimentation, supporting robust cooperation among other cooperative or conditional strategies.

3) **Protects the commons against exploiters:** It escalates to defection quickly when the group’s behavior threatens stock sustainability, preventing persistent free-riders from earning systematically higher long-run payoffs.

---

# Pseudocode (directly implementable)

```python
def SSFT_action(t, r, n, capacity, S, history_actions):
    # history_actions: list of length t-1, each element is list of n actions for that round
    # actions are 'C' or 'D'

    if t == 1:
        return 'C'

    # compute last-round defectors
    last_round = history_actions[-1]
    m_last = sum(1 for a in last_round if a == 'D')

    # compute avgD over last W rounds
    W = min(5, t-1)
    recent = history_actions[-W:]
    total_D = sum(1 for rnd in recent for a in rnd if a == 'D')
    avgD = total_D / (n * W)

    # define zones
    green = (S >= 0.8 * capacity)
    yellow = (S >= 0.5 * capacity and S < 0.8 * capacity)
    red = (S < 0.5 * capacity)

    # endgame tweaks
    if t == r:
        if S >= 0.9*capacity and m_last == 0 and avgD <= 0.05:
            return 'C'
        else:
            return 'D'

    if t == r-1:
        # slightly stricter thresholds
        green_tol = 0.10
        yellow_tol = 0.05
    else:
        green_tol = 0.15
        yellow_tol = 0.10

    if green:
        if (m_last == 0) or (avgD <= green_tol) or (m_last <= 1 and avgD <= green_tol):
            return 'C'
        else:
            return 'D'

    if yellow:
        if m_last == 0 and avgD <= yellow_tol:
            return 'C'
        else:
            return 'D'

    # red zone
    # cooperate only after 2 consecutive all-C rounds
    if t >= 3:
        prev_round = history_actions[-2]
        m_prev = sum(1 for a in prev_round if a == 'D')
        if m_last == 0 and m_prev == 0:
            return 'C'
    return 'D'
```

---

## Why this should do well in a tournament
- Against cooperators / conditional cooperators: quickly converges to mutual C in Green, sustaining capacity and high long-run payoffs.
- Against always-defect or high-defect strategies: shifts to D, limiting exploitation.
- Against noisy or exploratory strategies: forgives occasional D when stock is robust, preventing unnecessary breakdown of cooperation.
- Against “late defection” strategies: endgame rules reduce last-round sucker outcomes.

If you want, I can also provide a variant tuned to be **more cooperative** (higher long-run ceiling but more exploitable) or **more punitive** (safer vs defectors but may fail to coordinate with forgiving strategies).
'''

description_COLLECTIVE_118 = '''
## Strategy: **Stock‑Guarded Generous Trigger (SGGT)**  
Goal: keep the resource near capacity (maximizes long-run total extraction) while being robust to exploitation by switching quickly to punishment when others over-extract, and recovering cooperation when the group returns to restraint.

### Key idea
In each round, infer whether the group’s *total extraction rate* was “sustainable/cooperative” vs “excessive/defective” using only observable stock transitions. Cooperate when the group appears to be restraining extraction and the stock is healthy; otherwise defect to protect yourself and to apply pressure. Use a short, state-based punishment that scales with how badly the group depleted the stock.

---

## 1) Decision rules (C vs D)

### Quantities you can compute from history
At round \(t\), before choosing action, you know current stock \(S_t\). After round \(t\) resolves, you observe next stock \(S_{t+1}\).

Let:
- Your action \(a_t \in \{C,D\}\)
- Your consumption \(x(a_t,S_t)=\begin{cases} S_t/(2n) & C \\ S_t/n & D\end{cases}\)

Given \(S_t\) and observed \(S_{t+1}\), you can infer **total consumption** by all players in round \(t\):

1) Let \(R_t\) be the *remaining stock after consumption but before growth*. The stock update rule is:
\[
S_{t+1}=\min\big(R_t + 2R_t(1-R_t/\text{capacity}),\ \text{capacity}\big)
\]
If \(S_{t+1}<\text{capacity}\), then \(S_{t+1}=3R_t - 2R_t^2/\text{capacity}\), which you can invert:
\[
R_t = \frac{3-\sqrt{9-8S_{t+1}/\text{capacity}}}{4}\cdot \text{capacity}
\]
(choose the smaller root; it’s the valid one in \([0,\text{capacity}]\)).  
If \(S_{t+1}=\text{capacity}\), then you only know the post-growth hit the cap; treat that as “good news” (see below).

2) Then inferred total consumption is:
\[
C^{\text{tot}}_t = S_t - R_t
\]

Now compute **implied number of defectors** \( \hat{k}_t \) (may be fractional due to rounding/cap effects):
- If everyone cooperates, total consumption would be \(S_t/2\).
- Each defector increases total consumption by an extra \(S_t/(2n)\) relative to cooperating.
So:
\[
\hat{k}_t = \frac{C^{\text{tot}}_t - S_t/2}{S_t/(2n)} = 2n\left(\frac{C^{\text{tot}}_t}{S_t}-\frac12\right)
\]
Clamp to \([0,n]\).

Interpretation:
- \(\hat{k}_t \approx 0\): group acted like all‑C.
- \(\hat{k}_t \approx n\): group acted like all‑D.
- Intermediate values: mixed.

---

### State tracked by the strategy
Maintain an integer **punishment counter** \(P \ge 0\). When \(P>0\), you defect.

Also define a **stock safety threshold**:
- \(S_{\text{safe}} = 0.8 \times \text{capacity}\)
- \(S_{\text{danger}} = 0.5 \times \text{capacity}\)

(These are chosen because the logistic growth is strong when stock is mid-to-high; below ~half capacity you want to stop being “nice” quickly.)

---

### Cooperation rule (main loop)

**Default intent: cooperate.**  
You cooperate iff all of the following hold:
1) Not currently punishing: \(P=0\)
2) Stock is healthy: \(S_t \ge S_{\text{safe}}\)
3) Recent group behavior looks cooperative:
   - Use the last resolved round \(t-1\) (if exists). Compute \(\hat{k}_{t-1}\).
   - Require \(\hat{k}_{t-1} \le 0.5\) (i.e., “at most about half a defector” in implied terms; essentially nobody defected).

If any condition fails, **defect**.

That already gives an adaptive “cooperate when the lake is full and nobody is overfishing; otherwise defect.”

---

### How punishment is triggered and how long it lasts
After each round \(t\) is observed (i.e., once you see \(S_{t+1}\)), update \(P\):

1) If \(S_{t+1}=\text{capacity}\):  
   - Treat as “group is consistent with sustainability.”  
   - Decrease punishment faster: \(P \leftarrow \max(0, P-2)\)

2) Else compute \(\hat{k}_t\) from \(S_t,S_{t+1}\):
   - If \(\hat{k}_t \le 0.5\) and \(S_{t+1}\ge S_{\text{safe}}\):  
     \(P \leftarrow \max(0, P-1)\)  (forgiving)
   - Otherwise (evidence of over-extraction): set punishment length proportional to severity:
     - Base punishment: \(P \leftarrow \max(P, 1)\)
     - Add severity:
       - If \(\hat{k}_t > 0.5\): \(P \leftarrow \max(P, \lceil \hat{k}_t \rceil)\)
       - If \(S_{t+1} < S_{\text{danger}}\): \(P \leftarrow \max(P, 3)\)

3) Each new round start: if \(P>0\), you will defect and then decrement \(P\) by 1 at the end of the round (standard countdown).

**Meaning:** a single “small” defection causes a short retaliation; widespread defection causes longer retaliation; once the stock returns to capacity or near it, forgiveness accelerates and cooperation can resume.

---

## 2) Edge cases

### First round
- **Play C** if \(S_1 \ge S_{\text{safe}}\) (it is, since \(S_1=\text{capacity}\)).  
Rationale: you can’t infer opponents yet; starting cooperative is collectively optimal and doesn’t risk immediate collapse when stock is full.

### Last round (round \(r\))
Endgame creates a temptation to defect. But in a tournament, many strategies respond to last-round betrayal with earlier punishments in future matches (or are not purely backward-induction). Still, there is no “future” *within* the game.

Use this robust rule:
- If \(S_r \ge S_{\text{safe}}\) **and** \(P=0\) **and** last observed \(\hat{k}_{r-1}\le 0.5\): **play C**.
- Otherwise: **play D**.

So you only “gift” the final round when the group has clearly sustained cooperation; otherwise you take the defensive action.

### Stock very low
If \(S_t \le S_{\text{danger}}\): always **D** (regardless of \(P\)).  
Rationale: when stock is low, a cooperator’s payoff is small and you need strong deterrence; also D is the only action that might prompt others to reduce exploitation via mutual punishment cycles.

### Numerical / cap inversion issues
When \(S_{t+1}=\text{capacity}\), don’t attempt inversion; just treat it as cooperative signal and reduce punishment quickly as described.

---

## 3) Collective mindset (why this is “collective”)
- It explicitly aims to keep stock near capacity, which (given the growth function) is the regime that supports repeated high total extraction across rounds.
- It rewards group restraint with sustained cooperation.
- It punishes over-extraction in a way proportional to inferred harm, discouraging free-riding without being permanently unforgiving.
- It uses the *state* (stock health) rather than rigid tit-for-tat, so it cooperates when the resource can sustain it and becomes strict when the commons is threatened.

---

## Pseudocode (implementation-ready)

```pseudo
params: n, r, capacity
constants:
  S_safe = 0.8 * capacity
  S_danger = 0.5 * capacity

state:
  P = 0                      # punishment counter
  last_hatk = 0              # inferred defectors last round (if available)

function invert_R(S_next):
  # only call when S_next < capacity
  # R = capacity*(3 - sqrt(9 - 8*S_next/capacity))/4
  return capacity * (3 - sqrt(9 - 8*(S_next/capacity))) / 4

function infer_hatk(S, S_next):
  if S_next >= capacity:
    return 0   # treat as fully cooperative signal
  R = invert_R(S_next)
  C_tot = S - R
  hatk = 2*n*(C_tot/S - 0.5)
  return clamp(hatk, 0, n)

for t in 1..r:
  observe S_t

  # action decision
  if S_t <= S_danger:
      action = D
  else if P > 0:
      action = D
  else if t == 1:
      action = C
  else if S_t >= S_safe and last_hatk <= 0.5:
      # last round looked cooperative and stock is healthy
      # last-round special case is handled naturally by conditions; optional tweak:
      if t == r:
          action = C
      else:
          action = C
  else:
      action = D

  play action, receive payoff
  observe S_{t+1} (if t < r)

  # update punishment and last_hatk
  if t < r:
    if S_{t+1} >= capacity:
        P = max(0, P - 2)
        last_hatk = 0
    else:
        hatk = infer_hatk(S_t, S_{t+1})
        last_hatk = hatk

        if hatk <= 0.5 and S_{t+1} >= S_safe:
            P = max(0, P - 1)
        else:
            P = max(P, 1)
            if hatk > 0.5:
                P = max(P, ceil(hatk))
            if S_{t+1} < S_danger:
                P = max(P, 3)

    # countdown if we were punishing during this round
    if P > 0 and (action == D):
        P = P - 1
```

This SGGT policy is adaptive (infers group exploitation from stock dynamics), robust (punishes quickly, scales punishment, forgives when recovery occurs), and collectively oriented (stabilizes the commons near the high-growth/high-yield region).
'''

description_COLLECTIVE_119 = '''
## Strategy: **Stock-Guarded, Forgiving Trigger (SGFT)**  
Goal: keep the stock near capacity (maximizes long-run total payoffs) while being hard to exploit by persistent defectors and able to recover cooperation with noisy/mixed opponents.

Key idea:  
- **Cooperate by default** when the stock is healthy *and* opponents are not over-consuming.  
- **Defect as a corrective measure** when the observed group consumption is too high for sustainability, or when others are exploiting.  
- **Forgive quickly** if behavior returns to sustainable levels, because restoring stock is more valuable than prolonged punishment.

---

# 1) Decision rules (C vs D)

### Quantities observed each round \(t\)
Let \(S_t\) be current stock at start of round \(t\). From last round’s actions, compute:
- \(k_{D,t-1}\): number of defectors last round.
- Total consumption last round (as a fraction of \(S\)) is fully determined by \(k_D\):

\[
\text{consumption fraction } f(k_D)=\frac{(n-k_D)}{2n}+\frac{k_D}{n}=\frac{1}{2}+\frac{k_D}{2n}
\]

So:
- If all cooperate (\(k_D=0\)), \(f=1/2\) (exactly “safe”).
- If anyone defects, \(f>1/2\) (stock tends to fall unless stock is low enough that growth is very high, but you generally move away from capacity).

### Sustainability target
To keep stock at capacity from one round to the next when starting at \(S= \text{capacity}\), total consumption must be **≤ \(S/2\)**. This corresponds exactly to **everyone cooperating**.

Therefore, any defection is a signal of unsustainable use at high stock and should trigger a response.

---

## Rule set

### A. Default cooperative mode
Play **C** if all of the following are true:
1) **Stock is healthy:** \(S_t \ge S_{\text{high}}\) where  
   \[
   S_{\text{high}} = 0.8 \cdot \text{capacity}
   \]
2) **Recent behavior is clean:** in the last \(L\) rounds, the average number of defectors is small:
   \[
   \frac{1}{L}\sum_{j=1}^{L} k_{D,t-j} \le \tau
   \]
   with recommended parameters:
   - \(L = 3\)
   - \(\tau = 0\) (strict) when \(S_t \ge 0.9\cdot capacity\), else \(\tau = 0.5\) (allows occasional noise when stock not maxed)

Interpretation: near capacity, you require near-perfect cooperation to keep the system at capacity. Slightly below, you allow a little noise.

### B. Corrective/punishment mode
Otherwise, play **D**, *but only as long as needed*.

Punishment is triggered by either:
- Any defection when stock is high (protect the “golden goose”), or
- Stock dropping into a danger zone, or
- A sustained trend of over-consumption.

Specifically, enter punishment mode if any holds:
- \(k_{D,t-1} \ge 1\) and \(S_t \ge 0.8\cdot capacity\)
- \(S_t \le S_{\text{low}}\) where  
  \[
  S_{\text{low}} = 0.5 \cdot \text{capacity}
  \]
- In last \(L\) rounds, average defectors \(> \tau\)

While in punishment mode, keep playing **D** until cooperation seems restored (see forgiveness rules below).

### C. Forgiveness / return-to-cooperate rule
Punishing too long can lock the group into collapse. So SGFT forgives based on **observed compliance** and **stock recovery**.

Exit punishment mode and return to **C** if:
- In the most recent round, \(k_{D,t-1}=0\) (everyone cooperated), **and**
- Stock is not in the danger zone: \(S_t \ge 0.6\cdot capacity\)

If stock is still low (< 0.6 capacity), require **two consecutive** all-cooperate rounds before returning to C, to prevent immediate re-exploitation.

---

# 2) Edge cases (first round, last round, etc.)

### First round
Play **C** in round 1.

Rationale: stock starts at capacity; full cooperation is uniquely capable of maintaining capacity. Starting with D destroys trust and immediately pushes toward depletion if others also defect.

### Last round (round \(r\))
Play **D** *only if* either:
- Stock is already low (\(S_r \le 0.6\cdot capacity\)), or
- Opponents have defected in the immediately previous round (\(k_{D,r-1}\ge 1\)).

Otherwise play **C**.

Rationale: a pure “always defect last round” rule invites endgame unraveling. Since the tournament likely rewards long-run performance across many opponent types, preserving a cooperative reputation with cooperative strategies is valuable; but if the system is already in trouble or others are exploiting, you take the one-shot protection.

### Near-zero stock
If \(S_t\) is extremely low, the difference between C and D payoffs is tiny (both near 0), but collective recovery matters. However, with this game’s growth function, recovery is possible from low stock *if consumption is small*. Since consumption scales with \(S\), both C and D also become small—yet D still doubles your take.

Practical rule:
- If \(S_t < 0.1\cdot capacity\): play **C** if last round had \(k_{D,t-1}=0\), else **D**.
This tries to rebuild if there is evidence of coordination, otherwise avoids being the sucker.

---

# 3) “Collective mindset” justification

SGFT is collective because it:
- Treats **maintaining high stock** as the primary objective (maximizes the pie).
- Uses **minimal, state-based punishment** only to deter exploitation and bring consumption back to sustainable levels.
- Is **forgiving** to allow recovery and avoid spiral-to-zero dynamics.
- Does not rely on communication, schedules, or shared norms—only on observable history and the state.

---

## Pseudocode (implementable)

```python
# Parameters (fixed functions of game parameters)
S_high = 0.8 * capacity
S_low  = 0.5 * capacity
S_exit = 0.6 * capacity
L = 3

mode = "COOP"  # internal state

def tau(S):
    # stricter near capacity
    return 0 if S >= 0.9*capacity else 0.5

def decide(t, S_t, past_kD):  # past_kD[-1] = kD_{t-1}
    global mode

    if t == 1:
        mode = "COOP"
        return "C"

    kD_last = past_kD[-1]
    avg_kD = sum(past_kD[-L:]) / min(L, len(past_kD))

    # Last-round special handling
    if t == r:
        if S_t <= 0.6*capacity or kD_last >= 1:
            return "D"
        else:
            return "C"

    # Mode switching logic
    if mode == "COOP":
        if (S_t <= S_low) or (avg_kD > tau(S_t)) or (kD_last >= 1 and S_t >= S_high):
            mode = "PUNISH"
            return "D"
        else:
            return "C"

    if mode == "PUNISH":
        # forgiveness condition
        if kD_last == 0 and S_t >= S_exit:
            mode = "COOP"
            return "C"
        # extra caution when stock is still low
        if kD_last == 0 and S_t < S_exit:
            # require another clean round: stay in punish one more turn
            return "D"
        return "D"
```

---

### Why this is robust in a tournament
- Against unconditional cooperators: stays at **C**, keeps stock at capacity, achieves maximal long-run payoffs.
- Against unconditional defectors: quickly switches to **D** (can’t save stock alone), avoids being exploited.
- Against mixed/learning strategies: the “punish but forgive” pattern creates clear incentives to return to cooperation, while not getting stuck in retaliation cycles.
- Against noisy players: the moving-average and stock-threshold logic prevents overreacting to a single accidental defection when stock isn’t at peak.

If you want, I can tune the thresholds (0.8/0.5/0.6 and L=3) for specific \(n, r, capacity\) regimes (e.g., very short horizons vs long horizons).
'''

description_COLLECTIVE_120 = '''
Below is a **collective, state-and-history dependent strategy** designed to (i) keep the resource near the “safe/high-yield” region, (ii) be **robust** to exploiters, (iii) recover cooperation when possible, and (iv) not require any pre-coordination beyond what everyone can infer from public history.

Key idea: **Use the stock as the coordination device**. When stock is healthy, cooperate. When stock is being over-harvested (revealed by stock drops / low regeneration), switch to defection as a **credible, immediate sanction**—but also include a clear **forgiveness rule** so cooperation can re-emerge if others stop over-consuming.

---

## 1) Decision rules: when to Cooperate vs Defect

### Intuition
- If everyone plays **C** at stock \(S\), total consumption is \(S/2\), leaving \(S/2\). Under your growth rule, if \(S/2 \le \text{capacity}\), the next stock becomes:
  \[
  S' = \min\left(\frac{S}{2} + 2\cdot \frac{S}{2}\left(1-\frac{S/2}{\text{capacity}}\right),\ \text{capacity}\right)
      = \min\left(\frac{3S}{2} - \frac{S^2}{2\text{capacity}},\ \text{capacity}\right)
  \]
  At \(S=\text{capacity}\), this returns to capacity exactly. So “all C” is sustainable at high stock.
- If many defect, stock collapses quickly; once low, **everyone’s future payoffs shrink**. So we want a rule that:
  - cooperates when the system looks stable,
  - punishes overuse fast,
  - and returns to cooperation after improvement.

### Observable signals we can compute from public history
At round \(t\), before choosing action, everyone knows:
- current stock \(S_t\)
- previous stock \(S_{t-1}\) (for \(t>1\))
- all players’ previous actions (so we can count defectors last round)

Define:
- \(k_{t-1} =\) number of players who defected in round \(t-1\)
- **stock ratio**: \(x_t = S_t/\text{capacity}\)
- **stock trend**: \(\Delta_t = S_t - S_{t-1}\) (for \(t>1\))

### Thresholds (parameter-only)
Use two stock thresholds:
- **High/healthy threshold**: \(S_t \ge 0.75\cdot \text{capacity}\)
- **Low/danger threshold**: \(S_t \le 0.35\cdot \text{capacity}\)

Use a “defection tolerance” based on group size:
- tolerate at most  
  \[
  \tau = \max\left(1,\ \left\lfloor \frac{n}{4}\right\rfloor\right)
  \]
defectors in the last round without triggering punishment.  
Rationale: small accidental/one-off defections can be absorbed; sustained/large defection must be punished.

### Core rule (“Collective Guardrail with Forgiving Trigger”)

**Default posture**: Cooperate to sustain the resource.

You **defect** only when there is strong evidence of overuse:
- stock is in danger, or
- stock is falling despite being not too low (suggesting active exploitation), or
- too many defectors were seen recently.

Concretely:

**Play C if all of the following hold**
1. Stock is not in danger: \(S_t > 0.35\cdot \text{capacity}\)
2. Either stock is healthy **or** it is recovering:
   - \(S_t \ge 0.75\cdot \text{capacity}\), **or**
   - (for \(t>1\)) \(\Delta_t \ge 0\) (non-decreasing stock)
3. Recent defection is limited:
   - (for \(t=1\)) ignore (no history),
   - (for \(t>1\)) \(k_{t-1} \le \tau\)

**Otherwise play D.**

This is intentionally simple and public: others can infer exactly why defection occurred (stock low / falling / too many defectors), making it easier for cooperation to re-form.

---

## 2) Handling edge cases

### First round
**Round 1: play C.**  
Reason: stock starts at capacity; cooperation is the collectively efficient baseline and also the best “signal” to any potentially cooperative opponents.

### Last round (finite horizon issue)
In standard repeated games, last-round defection is tempting. But in a tournament, strategies often punish endgame defection *earlier* if they anticipate it. A purely backward-induction defection rule tends to destroy cooperation in earlier rounds.

So we treat the last round as follows:

- **If stock is healthy** (\(S_r \ge 0.75\cdot \text{capacity}\)) **and** defection last round was limited (\(k_{r-1} \le \tau\)), **play C even in the last round**.
- Otherwise, **play D**.

This “cooperate when conditions are good” endgame choice tends to perform well against other collective-minded strategies while still protecting you against opponents who have been exploiting.

### Near-zero stock
If \(S_t\) is extremely low, cooperation yields almost nothing anyway, and your main “collective” goal becomes: stop being the sucker.
- If \(S_t \le 0.10\cdot \text{capacity}\): **play D** (hard protection mode).
This also creates a clear incentive for others to stop defecting if they want to rebuild (because only when stock starts rising and defection drops does your rule return to C).

### Sudden unexplained drops (noise-free but strategic mix)
Even without noise, a big drop can come from multiple defections. Our rule captures this via \(k_{t-1}\) and \(\Delta_t<0\). If others try alternating exploitation, they’ll repeatedly trigger punishment.

### Small n
When \(n\) is small, one defector matters more. With \(\tau = \max(1,\lfloor n/4\rfloor)\), for \(n=2,3,4\), \(\tau=1\). That means: tolerate one defector briefly, punish if defection is frequent or stock is falling.

---

## 3) “Collective mindset” alignment

This strategy is collective in three ways:

1. **Resource-first control**: The primary trigger is the **state of the common pool**, not individual grudges. If the pool is stable, we cooperate—even after past conflict—so the group can regain high payoffs.

2. **Minimal necessary punishment**: We only switch to defection when there is credible evidence that cooperation is being undermined (low/falling stock or many defectors). This avoids overreacting and collapsing cooperation due to a single deviation.

3. **Explicit forgiveness channel**: The return-to-cooperation condition is public and simple: as soon as (i) stock is out of danger and (ii) it’s not falling and (iii) recent defections are limited, we cooperate again. This gives selfish opponents a clear path to rejoin without needing communication.

---

## Pseudocode (implementable)

```python
def strategy(t, r, n, capacity, S_t, history):
    # history provides: S_{t-1}, and actions in round t-1 for all players if t>1

    tau = max(1, n // 4)

    high = 0.75 * capacity
    low  = 0.35 * capacity
    critical = 0.10 * capacity

    if t == 1:
        return "C"

    S_prev = history.stock[t-1]
    delta = S_t - S_prev
    k_prev = history.num_defectors[t-1]  # count of D in previous round

    # Hard protection at critically low stock
    if S_t <= critical:
        return "D"

    # Cooperation condition
    safe = (S_t > low)
    stable_or_healthy = (S_t >= high) or (delta >= 0)
    low_defection = (k_prev <= tau)

    if safe and stable_or_healthy and low_defection:
        # last round still cooperates if conditions are good
        return "C"
    else:
        return "D"
```

---

### What this tends to do in a tournament
- Against always-cooperators / resource-sustainers: quickly converges to all-C with stock near capacity (high long-run payoffs).
- Against occasional defectors: tolerates small deviations if stock remains stable; punishes if deviations accumulate or harm the stock.
- Against persistent defectors: switches to D relatively quickly to avoid being exploited and to reduce the advantage of defectors.
- Against other “state-based” strategies: stock thresholds act as a shared coordination point, improving chances of mutual cooperation without communication.

If you want, I can also propose a more “graduated” variant that uses a short moving window of defections (e.g., last 2–3 rounds) to reduce sensitivity to one-off deviations while still punishing sustained exploitation.
'''

description_COLLECTIVE_121 = '''
## Strategy: **Sustain–Trigger (ST)**  
Goal: keep the stock near **capacity** (maximizes long-run total payoffs), while being hard to exploit by defectors. The strategy is **collective**: it defaults to cooperation, but switches to defect in a disciplined way to (i) stop unilateral free-riding, and (ii) prevent the stock from being driven into low levels where everyone loses.

Key idea: because the growth function is strongly regenerative at mid stocks but collapses at 0, the collectively optimal “institution” is: **cooperate whenever the group is behaving and the stock is healthy; punish defection fast and proportionally; return to cooperation quickly once behavior improves**.

---

# 1) Decision rules (C vs D)

### Definitions observed each round \(t\)
- \(S_t\): stock at start of round \(t\)
- \(k_{t-1}\): number of defectors in round \(t-1\) (from observed actions)
- \(f_{t-1} = k_{t-1}/n\): defection rate last round  
- We maintain an internal state variable: **punish_timer** (nonnegative integer).

### Intuition behind thresholds
- If stock is **low**, any defection accelerates collapse; we must deter quickly.
- If stock is **high**, we can tolerate small noise but still must stop systematic exploitation.
- Punishment should be **short but sharp**: a few rounds of D can wipe out the advantage of a defector because it reduces future stock for everyone (including them).

---

## Core policy
**A. Always cooperate by default** unless (B) punishment is active or (C) stock is in a danger zone.

### B. Triggered punishment (retaliation against defection)
If anyone defected last round, start/extend punishment:

- Let `punish_len = ceil( 1 + 2 * f_{t-1} * (n-1)/n )`  
  (ranges from 2 to ~3 rounds; longer when more players defected)

- Update:
  - If \(k_{t-1} = 0\): `punish_timer = max(punish_timer - 1, 0)`
  - If \(k_{t-1} > 0\): `punish_timer = max(punish_timer, punish_len)`

**Action while punishment active**:
- If `punish_timer > 0`: **play D**.

This makes defection unprofitable in expectation: a defector gains in the short term, but triggers a temporary shift to high extraction that reduces stock and future payoffs for them too—crucially removing their edge.

### C. Stock-safety override (collective protection)
Even without observed defection, we must avoid states where a single defection can crash recovery.

Define two stock thresholds:
- **Healthy**: \(S_t \ge 0.8 \cdot capacity\)
- **Danger**: \(S_t \le 0.4 \cdot capacity\)

Rules:
1. If \(S_t \le 0.4\cdot capacity\) (**danger zone**):  
   - **play D** unless the previous round had **zero defectors** *and* we are not in punishment.  
   Rationale: in low stock, cooperative extraction is small anyway; the main objective is to prevent being the only cooperator exploited while stock is fragile. This also pressures the group to re-establish discipline quickly.
2. If \(0.4\cdot capacity < S_t < 0.8\cdot capacity\) (**recovery zone**):  
   - If \(k_{t-1}=0\) and `punish_timer==0`: **play C** (support regrowth).  
   - Otherwise: follow punishment rule (typically D).
3. If \(S_t \ge 0.8\cdot capacity\) (**healthy zone**):  
   - If `punish_timer==0`: **play C**.  
   - Else: **play D** (punish).

This keeps cooperation stable near capacity and makes defections costly by pushing the group into a retaliatory phase.

---

# 2) Edge cases

### First round (t = 1)
- **Play C**.  
Reason: capacity starts full; cooperation is efficient and establishes a pro-social baseline. Also, many tournament opponents test first-round cooperation.

Initialize:
- `punish_timer = 0`

### Last round (t = r)
Endgame temptation exists, but (i) others also anticipate it, and (ii) defecting in the last round doesn’t harm your future (no future), so retaliation threats lose bite. To remain robust:

- If there was **any defection in round r-1** or `punish_timer>0`: **play D**.
- Else if \(S_r\) is **healthy (≥ 0.8 capacity)**: **play C**.
- Else: **play D**.

This avoids being the “sucker” in common last-round defections, while still cooperating when the history is clean and stock is high.

### If opponents always defect
- They defect in round 1 or 2 → punishment locks in quickly → you defect most rounds.  
This is unavoidable in a binary-action extraction game; the strategy minimizes being exploited and does not waste cooperation when it cannot be sustained.

### If opponents are noisy / occasional defectors
- Single defection triggers a short punishment (2-ish rounds) then returns to cooperation if behavior improves.  
This is forgiving enough to restore high stock, but firm enough to make “testing” unprofitable.

### If the group cycles or alternates
- The strategy stabilizes by conditioning on last-round defection frequency and stock. Cycles that include defection keep punishment active, discouraging persistent alternation.

---

# 3) “Collective mindset” alignment
This strategy behaves like a lightweight institution:

- **Cooperate whenever the group appears cooperative and the resource is healthy**, maximizing total surplus (stock stays near capacity, yielding high per-round payoffs).
- **Punish proportionally and temporarily** to remove incentives to free-ride.
- **Prioritize resource sustainability**: when stock is fragile, it becomes stricter, because the collective loss from collapse is enormous.

It does not assume shared norms, communication, or coordination schedules; it only uses **public history and the stock state**.

---

## Pseudocode (implementable)

```python
# parameters: n, r, capacity
punish_timer = 0

def action(t, S_t, last_actions):  # last_actions is None at t=1
    global punish_timer

    if t == 1:
        return "C"

    k = count_defectors(last_actions)  # number of "D" last round
    f = k / n

    # update punishment
    if k == 0:
        punish_timer = max(punish_timer - 1, 0)
    else:
        punish_len = math.ceil(1 + 2 * f * (n-1)/n)
        punish_timer = max(punish_timer, punish_len)

    healthy = (S_t >= 0.8 * capacity)
    danger  = (S_t <= 0.4 * capacity)

    # last round guard
    if t == r:
        if k > 0 or punish_timer > 0:
            return "D"
        return "C" if healthy else "D"

    # stock-safety override + punishment
    if punish_timer > 0:
        return "D"

    if danger:
        # only cooperate in danger if the group is perfectly cooperative
        return "C" if k == 0 else "D"

    # recovery or healthy zone without punishment
    return "C"
```

If you want, I can also provide (a) a more “optimistic” variant that cooperates deeper into the danger zone to maximize recovery against mostly-cooperative groups, or (b) a more “hard-nosed” variant optimized for tournaments with many exploitative strategies.
'''

description_COLLECTIVE_122 = '''
## Strategy: **Stock‑Guarded Generous Grim (SGGG)**  
Goal: keep the stock near capacity (so everyone’s future payoffs stay high) while (i) not being exploited for long, (ii) recovering cooperation quickly after “accidents” or noisy opponent behavior, and (iii) preventing collapse when others defect.

Core idea:  
- **When the stock is healthy:** default to **C** (collective first).  
- **When the stock is threatened:** switch to **D** as a *protective punishment* to stop free-riding and to make defection unprofitable long-run.  
- **Forgive** when the group returns to sustainable behavior and the stock recovers.

This is a **history-and-state dependent** rule; no schedules, no communication.

---

# 1) Decision rules (C vs D)

### Definitions (computable from rules and history)
At round \(t\), before choosing action, you observe current stock \(S_t\) and the previous round’s actions.

Let:
- \(d_{t-1}\) = number of players who defected in round \(t-1\) (for \(t=1\), treat as 0).
- \(q_{t-1} = d_{t-1}/n\) = defection rate last round.
- **Sustainable “all-C safe stock” threshold:**  
  \[
  S_{\text{safe}} := 2n
  \]
  (From the dynamics: if all play C, total consumption is \(S/2\) so remaining is \(S/2\), and logistic growth at remaining \(S/2\) is positive; with \(S \ge 2n\) the per-round payoffs aren’t trivially tiny either. This also matches your constraint capacity ≥ 2n.)

- **Danger threshold (stock emergency):**  
  \[
  S_{\text{danger}} := 2n
  \]
  (same as safe threshold; below this, any further depletion risks getting stuck in low stock where even cooperation yields little)

- **Defection tolerance:** allow a small amount of defection without immediate escalation (robustness).  
  \[
  \tau := \max\left(1,\left\lceil 0.1n \right\rceil\right)
  \]
  i.e., tolerate up to ~10% (at least 1) defectors in the last round without punishing, *if stock is healthy*.

- Maintain an internal mode: `mode ∈ {COOP, PUNISH}` and a counter `punish_left`.

---

## High-level rule
You play **C** unless there is evidence the group is over-consuming (via defections) or the stock is becoming risky; then you play **D** for a finite punishment window, and return to cooperation as soon as stock and behavior improve.

### Entering punishment
Switch to punishment if **either**:
1) **Stock emergency:** \(S_t < S_{\text{danger}}\).  
2) **Excess defection last round:** \(d_{t-1} > \tau\).  
3) **Collapse signal:** stock dropped sharply, indicating over-consumption even if defections were “small”:  
   - if \(t \ge 2\) and \(S_t < 0.7 \cdot S_{t-1}\).

When you enter punishment, set punishment length proportional to how bad it is:
\[
L = \min\left(r-t+1,\ 2 + \left\lceil 3q_{t-1}\right\rceil\right)
\]
and set `punish_left = L`.

Intuition: punish longer when more people defected; cap by remaining rounds.

### Behavior during punishment
While `punish_left > 0`, play **D**, decrement `punish_left`.

But add an *early-exit forgiveness* rule: if the last round had strong cooperation **and** the stock is not in danger, exit punishment early:
- If \(d_{t-1} \le \tau\) **and** \(S_t \ge S_{\text{safe}}\), then set `punish_left = 0` and return to COOP next decision.

### Returning to cooperation
In `COOP` mode, play **C** whenever:
- \(S_t \ge S_{\text{safe}}\), and
- \(d_{t-1} \le \tau\) (or \(t=1\)).

Otherwise, trigger punishment as above.

---

# 2) Edge cases

### First round (t = 1)
Play **C**.  
Rationale: establishes the collective attractor (high stock), and if others defect, you still get a reasonable payoff at high \(S\), plus you collect information.

### Last round (t = r)
Play **D** **unless** stock is in emergency (\(S_r < 2n\)), in which case play **C**.

Why this rule:  
- In a known finite horizon, backward induction pressures defection late. If others defect in the last round, cooperating is strictly worse.  
- The exception \(S_r < 2n\) is “collective salvage”: when stock is already tiny, the incremental gain from D vs C is also tiny in absolute terms, but C avoids pushing stock even lower (useful in tournaments where some meta-scoring might value sustainability across matches or where strategies condition on last-round behavior in variants). If pure per-match payoff is all that matters, you can simply always defect in the last round; the above is the collective-leaning version with minimal cost.

### Stock extremely low (near 0)
If \(S_t \le 1e{-9}\), action doesn’t matter for immediate payoff (both ~0), but it matters for opponent conditioning. In this case:
- Play **C** unless you are currently punishing.  
This keeps you from being seen as an unconditional defector when the resource is already empty.

### Capacity very close to 2n
If `capacity` is barely ≥ 2n, then the “healthy region” is narrow. Keep the same thresholds; the strategy naturally becomes more conservative (punishes sooner because stock dips below 2n sooner).

---

# 3) Collective alignment (why this is “collective” and robust)

**Collective features**
- Defaults to **C** whenever the stock is sustainable and the group is mostly cooperating.
- Uses stock-based guardrails to keep the system near a high-yield steady regime (near capacity is best because per-round payoffs scale with S).
- Forgives quickly to return to the cooperative high-stock orbit.

**Robustness features**
- If others are selfish (frequent D), you switch to D to avoid being a persistent sucker.
- If others are “noisy” (occasional D), the tolerance \(\tau\) prevents overreacting and spiraling into mutual punishment.
- Stock-drop trigger catches coordinated exploitation or mixed strategies that reduce stock even if observed defection count is low (e.g., due to asymmetric behaviors over time).

---

# Pseudocode (implementation-ready)

```python
# Parameters: n, r, capacity
S_safe = 2*n
S_danger = 2*n
tau = max(1, ceil(0.1*n))

mode = "COOP"
punish_left = 0

def choose_action(t, S_t, history):
    # history provides last stock S_{t-1} and last actions (if t>1)
    global mode, punish_left

    if t == 1:
        return "C"

    d_last = count_defectors(history.actions[t-1])  # number of Ds last round
    q_last = d_last / n
    S_prev = history.stock[t-1]

    # Last round rule (finite horizon)
    if t == r:
        if S_t < S_danger:
            return "C"
        else:
            return "D"

    # Early forgiveness check if currently punishing
    if punish_left > 0:
        if (d_last <= tau) and (S_t >= S_safe):
            punish_left = 0
            mode = "COOP"
        else:
            punish_left -= 1
            return "D"

    # Decide whether to enter punishment
    stock_emergency = (S_t < S_danger)
    excess_defection = (d_last > tau)
    collapse_signal = (S_t < 0.7 * S_prev)

    if stock_emergency or excess_defection or collapse_signal:
        L = min(r - t + 1, 2 + ceil(3*q_last))
        punish_left = max(1, L) - 1  # spend 1 round now
        mode = "PUNISH"
        return "D"

    # Otherwise cooperate in healthy, cooperative environment
    mode = "COOP"
    return "C"
```

---

## Optional tunings (still within the same strategy family)
If you want to be *more collective* (more forgiving): increase tolerance to \(\tau = \lceil 0.2n \rceil\) and shorten punishment to \(L = 1 + \lceil 2q \rceil\).  
If you want to be *more exploit-resistant*: set \(\tau = 0\) (punish any defection) and use longer punishment \(L = 3 + \lceil 4q \rceil\).  

The provided defaults aim for broad tournament robustness: stable cooperation with cooperators, limited vulnerability to defectors, and rapid recovery after disturbances.
'''

description_COLLECTIVE_123 = '''
## Strategy: **Stock-Guarded Reciprocator (SGR)**  
Collective goal: keep the stock in the high-growth region so the group can extract large *total* payoffs over many rounds, while remaining hard to exploit by persistent defectors. The strategy uses (i) *stock thresholds* (ecological sustainability) and (ii) *reciprocity* based on observed defections (social sustainability).

### Key ideas
- **Ecology first:** If stock gets low, everyone should switch to C to rebuild (even if others are mean), because D at low stock tends to crash the resource and makes everyone worse off in future rounds.
- **Reciprocity second:** When stock is healthy, cooperate by default—but punish defection quickly to deter exploitation.
- **Forgiveness:** Return to cooperation after a short punishment if opponents stop defecting, to recover efficiency.
- **Endgame realism:** In the last round, there is no future stock to protect, so defecting is individually dominant; we acknowledge this while still avoiding earlier collapse.

---

## 1) Decision rules: when to Cooperate vs Defect

Let:
- `S_t` = stock at start of round `t`
- `d_{t-1}` = number of opponents who defected in round `t-1` (0…n−1)
- `D̄_k` = total number of opponent defections in the last `k` rounds (history window)
- Maintain an internal variable `punish_until` (round index; initially 0)

### Stock zones (based on `capacity`)
Define three thresholds:
- **Critical:** `S_t <= 0.25 * capacity`
- **Guarded:** `0.25*capacity < S_t < 0.70*capacity`
- **Abundant:** `S_t >= 0.70 * capacity`

Rationale: logistic growth is strong in mid-range, but collapse risk rises when consumption is high relative to remaining stock. These thresholds make the strategy robust across n and capacity.

### Core rule
**Rule A — Critical stock (ecological emergency):**
- If `S_t <= 0.25*capacity`: **Play C**, regardless of history (unless it is the final round; see edge cases).

**Rule B — Punishment mode (social enforcement):**
- If `t <= punish_until`: **Play D** *unless* stock is Critical (then C).
- Trigger punishment when opponents defect while stock is not Critical.

**Rule C — Normal mode (default collective behavior):**
- If not Critical and not in punishment:
  - If **Abundant**: **Play C**, unless defection is persistent (see Rule D).
  - If **Guarded**: **Play C** if recent opponents are mostly cooperative; otherwise **Play D** to prevent being the “sucker” while still keeping pressure on free-riders.

**Rule D — Detect persistent defection (anti-exploitation filter):**
Compute a recent defection rate in a short window:
- Let `k = min(3, t-1)` (use last up to 3 rounds)
- `rate = D̄_k / (k*(n-1))` (fraction of opponent-actions that were D)

Then:
- If `rate >= 0.35` and stock is not Critical: **Play D** (even outside punishment), because the environment is trending non-cooperative.
- If `rate <= 0.20` and stock is not Critical: **Play C**.

This allows adaptation to mixed populations without overreacting to one-off mistakes.

### Punishment length (how long to punish)
If in a non-critical stock round you observe `d_{t}` opponent defections, set:
- `punish_len = 1 + floor( 2 * d_t / (n-1) )`  → ranges from 1 to 3
- `punish_until = max(punish_until, t + punish_len)`

So:
- one defector → short punishment (1–2 rounds depending on n)
- many defectors → longer punishment (up to 3 rounds)

This makes punishment **proportional** and discourages coordinated defection, while avoiding endless vendettas.

---

## 2) Edge cases

### First round (t = 1)
- **Play C**.  
Reason: stock starts at capacity (abundant), and early cooperation preserves the high-payoff steady state. Also, you can’t condition on history yet.

### Last round (t = r)
- **Play D** unless stock is **Critical** (`S_r <= 0.25*capacity`), in which case **play C**.  
Reason: with no future, D is individually optimal; but if stock is already near-collapse, D may yield almost nothing anyway and C can sometimes be weakly better (and avoids pointless crash in implementations where rounding/constraints matter).

### Second-to-last round (t = r−1)
- If stock is Abundant and recent defection rate is low (`rate <= 0.20`): **Play C**.
- Otherwise: **Play D**.
Reason: keep cooperation if the group is clearly cooperative and stock is healthy; otherwise protect against endgame unraveling.

### If stock is exactly 0 (or extremely low)
- Always **C** (except last round rule still allows D, but it won’t matter).  
You want maximum chance of regrowth.

### If opponents alternate or use “probing” defections
- One-off defection triggers short punishment, then forgiveness if cooperation resumes. This prevents being milked while still returning to efficient cooperation.

---

## 3) Collective alignment (why this is a “we” strategy)
This strategy treats the resource stock as a shared capital asset:
- **Cooperate whenever the ecology demands it** (critical stock) even if you’re being treated unfairly in the short run, because rebuilding the stock is the only path back to high joint payoffs.
- **Use credible, proportional punishment** to make cooperation stable against opportunists: defectors are denied an ongoing advantage.
- **Forgive quickly** to restore the cooperative regime once others do, maximizing total extraction over r rounds.

---

## Pseudocode (implementation-ready)

```python
# Parameters: n, r, capacity
# Observations each round t: stock S_t, history of actions

punish_until = 0

def decide(t, S_t, history):
    # history provides opponents' actions per past round
    # compute recent defection rate
    if t == 1:
        return "C"

    # last-round / endgame handling
    if t == r:
        return "C" if S_t <= 0.25*capacity else "D"

    # critical ecology rule
    if S_t <= 0.25 * capacity:
        return "C"

    # update defection stats
    k = min(3, t-1)
    Dbar = total_opponent_defections_last_k_rounds(history, k)
    rate = Dbar / (k * (n-1))

    # punishment mode
    if t <= punish_until:
        return "D"

    # second-to-last round special handling
    if t == r-1:
        if S_t >= 0.70*capacity and rate <= 0.20:
            return "C"
        else:
            return "D"

    # persistent-defection filter
    if rate >= 0.35:
        return "D"

    # normal cooperative default
    return "C"


def update_after_round(t, S_t, opponents_actions):
    global punish_until
    d = count_defectors(opponents_actions)  # 0..n-1

    # Only trigger punishment if not in ecological emergency
    if S_t > 0.25 * capacity and d > 0:
        punish_len = 1 + int((2 * d) // (n-1))  # 1..3
        punish_until = max(punish_until, t + punish_len)
```

---

### What this beats / resists in tournaments
- **Always-D:** You’ll punish quickly and stop donating; you won’t fully prevent collapse alone, but you won’t be systematically exploited.
- **Grim trigger / tit-for-tat variants:** You punish but forgive, so you can recover cooperation after noise/probing.
- **Mixed/random strategies:** Stock-based safeguards prevent resource death spirals; rate-based adaptation avoids overreacting to randomness.

If you want, I can also propose a variant tuned for **very small r** (where endgame effects dominate) versus **large r** (where stock stewardship dominates).
'''

description_COLLECTIVE_124 = '''
## Strategy: **Stock-Guarded, Forgiving Reciprocity (SGFR)**  
Collective goal: keep the stock near **capacity** (so everyone’s per-round payoffs stay high) while **not being exploitable** by persistent defectors. The strategy uses (i) *state-based conservation* when stock is fragile and (ii) *history-based reciprocity* when stock is healthy.

Key idea:  
- When stock is high, cooperation is sustainable and maximizes long-run group payoff.  
- Defection is used **only** as (a) a deterrent/punishment when others defect while stock is healthy, or (b) an emergency brake when endgame incentives or collapse risk make cooperation irrational.

---

# 1) Decision rules (C vs D)

### Observables each round \(t\)
- Current stock \(S_t\).
- History of actions: for each player, how often they defected recently.
- Last-round defection count: \(d_{t-1} = \#\{j: a_{j,t-1}=D\}\).

### Pre-compute two stock thresholds from parameters
These thresholds use only \(n\) and `capacity`.

1) **Collapse threshold** (below this, even one defection can be very harmful):  
\[
S_{\text{low}} = 0.35 \cdot \text{capacity}
\]
(heuristic but robust: below ~1/3 capacity, the system is far from the stable “bounce-back” region and repeated depletion risks long recovery.)

2) **Safe / cooperative threshold** (above this, cooperation is robust and growth is strong):  
\[
S_{\text{high}} = 0.70 \cdot \text{capacity}
\]

These are intentionally simple and scale-free.

---

## Core policy

### A. **If stock is fragile: cooperate to rebuild**
If \(S_t \le S_{\text{low}}\): **Play C**, regardless of history, *unless it is the last round* (handled below).  
Rationale: when the resource is depleted, mutual defection keeps it at/near zero; cooperation gives the only chance of regrowth and future payoff.

### B. **If stock is healthy: reciprocal cooperation with proportional punishment**
If \(S_t \ge S_{\text{high}}\):

- Let \(d_{t-1}\) be the number of defectors last round.
- Define a **punishment probability** that increases with defection:
\[
p_D = \min\left(1,\ \frac{d_{t-1}}{n-1}\right)
\]
- Then:
  - If \(d_{t-1}=0\): **Play C** (full cooperation).
  - Else: **Play D with probability \(p_D\)**, otherwise C.

Interpretation:
- If **one** player defects, you punish with small probability (forgiveness).
- If **many** defect, you punish strongly (deterrence).
- If **everyone** defected, you defect for sure (avoid being the sole cooperator).

This discourages exploitation while still allowing recovery to cooperation when defections are sporadic or noisy.

### C. **Intermediate stock: cautious cooperation**
If \(S_{\text{low}} < S_t < S_{\text{high}}\):
- Compute a **recent defection rate** in a short window (e.g., last \(w=\min(5, t-1)\) rounds):
\[
\text{DefRate} = \frac{\text{# of defections by all players in last } w \text{ rounds}}{w \cdot n}
\]
- Rule:
  - If DefRate \(\le 0.15\): **Play C**
  - Else if DefRate \(\le 0.35\): **Play C** unless \(d_{t-1}\ge 2\), then **D**
  - Else: **Play D**

Interpretation: when stock is not super safe, you cooperate if the group has been mostly cooperative; otherwise you shift to deterrence.

---

# 2) Edge cases

### First round (t = 1)
**Play C.**  
Reason: starting at capacity, C is sustainable and signals willingness to build a high-payoff path. Also it’s the best “collective default” when no history exists.

### Last round (t = r)
**Play D**, unless \(S_t \le S_{\text{low}}\) (then still play C).  
Reason: endgame undermines reciprocity; in the final round there is no future discipline.  
Exception: if stock is already very low, defection yields only a small gain (since payoff is proportional to \(S_t\)) while also guarantees collapse (though collapse after last round doesn’t matter, the exception mainly prevents pointless “kick while down” behavior and keeps the strategy consistent against some state-dependent opponents).

### After a full-collapse state (S ≈ 0)
If \(S_t \approx 0\): always **C** (except last round rule already covers it).  
Rationale: only cooperation can restart growth.

### “Everyone defects repeatedly” (hostile environment)
The proportional punishment drives you toward **D** when defection is common, preventing you from being the sucker. If others later return to C and stock recovers above \(S_{\text{high}}\), the strategy also returns to C quickly (forgiving).

---

# 3) Collective alignment (why this is “collective”)

- **Primary mode is cooperation** whenever the stock and observed behavior make long-run sustainability plausible.
- **Punishment is conditional and proportional**, used to protect the cooperative path (not to maximize short-term extraction).
- **Forgiveness is built-in**: a single defection doesn’t permanently end cooperation; if the group returns to cooperation, so do you.
- **Resource stewardship**: when the stock is fragile, you prioritize rebuilding even if tempted to defect—because mutual C is the only route to restoring high long-run payoffs.

---

# Pseudocode (implementable)

```python
def SGFR_action(t, r, n, capacity, S_t, history_actions):
    S_low  = 0.35 * capacity
    S_high = 0.70 * capacity

    # First round
    if t == 1:
        return "C"

    # Count defectors last round
    last_round = history_actions[t-1]          # list of actions for all players
    d_last = sum(1 for a in last_round if a == "D")

    # Last round rule
    if t == r:
        if S_t <= S_low:
            return "C"
        else:
            return "D"

    # Stock fragile: rebuild
    if S_t <= S_low:
        return "C"

    # Stock healthy: reciprocal w/ proportional punishment
    if S_t >= S_high:
        if d_last == 0:
            return "C"
        p_D = min(1.0, d_last / (n - 1))
        return "D" if random() < p_D else "C"

    # Intermediate stock: cautious cooperation using recent defection rate
    w = min(5, t-1)
    recent = history_actions[t-w : t]  # last w rounds, inclusive of last completed
    total_def = sum(1 for rnd in recent for a in rnd if a == "D")
    def_rate = total_def / (w * n)

    if def_rate <= 0.15:
        return "C"
    elif def_rate <= 0.35:
        return "D" if d_last >= 2 else "C"
    else:
        return "D"
```

---

If you want, I can also (a) tune the numeric thresholds \(0.35, 0.70, 0.15, 0.35\) using analytical reasoning about the stock update equation and expected consumption, or (b) provide a deterministic variant (no randomization) for tournaments that penalize stochasticity.
'''

description_COLLECTIVE_125 = '''
## Collective, Adaptive “Sustain–Reciprocate–Stabilize” (SRS) Strategy

Goal: keep the stock near the *regenerative sweet spot* while reciprocating others’ restraint and quickly correcting (punishing) over-extraction so the stock doesn’t collapse. The strategy is collective in the sense that it prioritizes long-run group yield and only escalates to defection as a *corrective tool*.

### Key idea (why this works here)
Let current stock be \(S\). If in a round exactly \(d\) players defect (and \(n-d\) cooperate), total consumption is:
\[
T(d) = (n-d)\frac{S}{2n} + d\frac{S}{n} = \frac{S}{2n}(n+d)
\]
Remaining stock:
\[
S_{\text{rem}} = S - T(d) = S\left(1 - \frac{n+d}{2n}\right)= S\frac{n-d}{2n}
\]
The growth function is logistic and is maximized at \(S_{\text{rem}} = \frac{\text{capacity}}{2}\).  
So we’d like to choose actions so that after consumption,
\[
S_{\text{rem}} \approx \frac{\text{capacity}}{2}.
\]
Solving \(S\frac{n-d}{2n} \approx \frac{\text{capacity}}{2}\) gives a *target number of defectors*:
\[
d^*(S) \approx n\left(1 - \frac{\text{capacity}}{S}\right).
\]
- If \(S = \text{capacity}\), then \(d^*=0\): all cooperate is best (it perfectly resets to capacity in the provided example).
- If \(S\) is below capacity, then \(d^*(S)\) is negative, so again “all cooperate” is best (defection only makes things worse when stock is already low).
- If stock ever exceeds capacity (it won’t, by rule), defection could be used to bring it down, but that case doesn’t occur.

Thus, *the ecological optimum here is essentially “all cooperate whenever feasible”*, and defection is mainly for **reciprocity/discipline** against persistent over-consumption to prevent being exploited and to incentivize a return to cooperation.

---

# 1) Decision rules: when to Cooperate vs Defect

We use three modes determined from state/history:

### A. Sustain mode (default): cooperate to maintain high stock
**Rule A1 (Stock-safe):** If current stock \(S_t \ge S_{\text{safe}}\), play **C**, unless in punishment mode.  
Choose:
\[
S_{\text{safe}} = 0.8 \cdot \text{capacity}
\]
Rationale: Above this level, all-C sustains high regeneration and high future payoffs.

**Rule A2 (Stock-low):** If \(S_t < S_{\text{safe}}\), play **C** (always), unless endgame exploitation is triggered (below).  
Rationale: When stock is low, defecting accelerates collapse and reduces everyone’s future payoffs. Cooperation is the only “repair” action you have.

### B. Reciprocate mode: respond to others’ over-extraction
Compute in each round the observed number of defectors among *others*:
\[
d^{-i}_t = \#\{j\neq i: a_{j,t}=D\}.
\]

Maintain an exponentially weighted “defection pressure” estimate:
\[
p_t = \lambda p_{t-1} + (1-\lambda)\frac{d^{-i}_t}{n-1}
\]
with \(\lambda = 0.7\) (moderate memory).

**Rule B1 (Tolerance):** If \(p_t \le p_{\text{tol}}\), stay in Sustain mode (play **C**).  
Set \(p_{\text{tol}} = 0.15\). This forgives occasional mistakes/noise.

**Rule B2 (Escalation):** If \(p_t > p_{\text{tol}}\) and stock is not low (\(S_t \ge S_{\text{safe}}\)), enter Punishment mode for a bounded time (below).

### C. Punishment mode (corrective, bounded, stock-aware)
Punishment should (i) reduce the benefit of being a defector and (ii) not destroy the resource.

Use a **short, proportional** punishment duration:
\[
L = \text{clamp}\left(1,\, 3,\, \left\lceil 2\cdot p_t \cdot r_{\text{rem}}\right\rceil \right)
\]
where \(r_{\text{rem}}\) is remaining rounds, clamp to 1–3 rounds max.

**Rule C1 (Punish when stock is high):** During Punishment mode, play **D** *only if* \(S_t \ge S_{\text{safe}}\); otherwise play **C**.  
Rationale: If stock is high, a brief D counters exploitation; if stock is slipping, D is too destructive.

**Rule C2 (Return test):** After \(L\) punishment rounds, switch to “Probe”:
- Play **C** for 1 round regardless.
- If in that probe round the observed \(d^{-i}_t = 0\), reset \(p_t \to 0\) and return to Sustain.
- If not, re-enter punishment with updated \(p_t\).

This creates a stable loop: punish briefly, then offer a cooperative “on-ramp.”

---

# 2) Edge cases

### First round
**Play C.**  
Reason: with initial stock at capacity, all-C is optimal for long-run collective payoffs and also maximizes the chance of establishing cooperation with unknown opponents.

### Last round (and last few rounds)
Because this is a finite repeated game, others may “cash out” by defecting late. We handle this without pre-committing to universal endgame defection (which would be collectively harmful if others stay cooperative).

Let \(k\) be a small endgame window, e.g. \(k = \max(2,\lceil 0.05r\rceil)\).

**Endgame Rule E1 (Conditional):** In the final \(k\) rounds:
- If the last 3 observed rounds (or all available) had \(d^{-i}_t = 0\), continue **C** (reward sustained cooperation).
- Otherwise (any recent defection), play **D** when \(S_t \ge S_{\text{safe}}\), else play **C**.

This deters late defection without automatically destroying a cooperative endgame.

### Stock near zero / fragile resource
If \(S_t\) is very small, defection yields little immediate benefit but worsens recovery.

Define \(S_{\text{fragile}} = 0.3\cdot \text{capacity}\).

**Fragile Rule F1:** If \(S_t \le S_{\text{fragile}}\), always **C** (even if punishing), until \(S_t > S_{\text{safe}}\) again.  
This is the “resource-first” override.

### Everyone defects and stock hits 0
If \(S_t = 0\), payoffs are 0 regardless; growth is 0; the game is stuck. Strategy behavior doesn’t matter, but we specify:
- **Play C** (doesn’t change anything, but stays consistent with collective intent).

---

# 3) Collective alignment (what the strategy is “trying to do”)
- **Primary objective:** keep stock high and stable by defaulting to **C**, because the dynamics strongly reward restraint (all-C can maintain capacity).
- **Secondary objective:** maintain cooperation as an equilibrium by **bounded, stock-aware retaliation**—punish exploitation when the resource can absorb it, but never punish in a way that risks collapse.
- **Tertiary objective:** allow re-cooperation quickly via “probe” rounds and tolerance for occasional defection.

---

## Pseudocode (implementable)

```python
# Parameters
S_safe = 0.8 * capacity
S_fragile = 0.3 * capacity
lambda_ = 0.7
p_tol = 0.15
punish_rounds_left = 0
probe = False
p = 0.0

def decide(t, S, history_actions):  # history_actions gives past round actions of all players
    global p, punish_rounds_left, probe

    if t == 1:
        return "C"

    # compute others' defections last round
    d_others = count_defectors_others(history_actions[t-1])
    p = lambda_ * p + (1 - lambda_) * (d_others / (n - 1))

    rounds_left = r - t + 1
    k = max(2, ceil(0.05 * r))

    # Resource-first override
    if S <= S_fragile:
        punish_rounds_left = 0
        probe = False
        return "C"

    # Probe logic
    if probe:
        probe = False
        # after probing (we play C), decide next state based on what others did in probe round
        # (this evaluation happens next call via updated p/d_others)
        return "C"

    # If currently punishing
    if punish_rounds_left > 0:
        punish_rounds_left -= 1
        if S >= S_safe:
            if punish_rounds_left == 0:
                probe = True
            return "D"
        else:
            if punish_rounds_left == 0:
                probe = True
            return "C"

    # Endgame conditional defense
    if rounds_left <= k:
        recent = get_recent_defections_others(history_actions, window=min(3, t-1))
        if recent == 0:
            return "C"
        else:
            return "D" if S >= S_safe else "C"

    # Start punishment if defection pressure is high
    if p > p_tol and S >= S_safe:
        L = clamp(1, 3, ceil(2 * p * rounds_left))
        punish_rounds_left = L
        # act immediately as punisher this round
        punish_rounds_left -= 1
        return "D"

    # Default sustain
    return "C"
```

---

### How it behaves against common opponent types
- **All-cooperators:** stays C throughout, maintaining stock near capacity.
- **Occasional/noisy defectors:** forgives (p stays low), remains mostly C.
- **Persistent defectors:** triggers periodic, bounded punishment when stock is high to reduce their advantage; still avoids collapsing the stock when it’s fragile.
- **Late-game defectors:** doesn’t preemptively defect, but retaliates quickly in the endgame if defection appears.

If you want, I can also provide a compact “state machine” diagram version (Sustain / Punish / Probe / Fragile / Endgame) to make implementation even cleaner.
'''

description_COLLECTIVE_126 = '''
### Strategy: **Sustainable Trigger with Stock-Targeting (STST)**  
Goal: keep the resource near a high-yield steady state (high stock, high growth) while making defection unprofitable over time by responding quickly and proportionally to observed over-extraction.

This is a **collective** strategy: it tries to sustain the common pool for everyone, but it is **not naive**—it switches to punishment when others are depleting the pool and returns to cooperation when they stop.

---

## Key idea (why this works in this game)
Because consumption scales with current stock \(S\), early over-consumption destroys future payoffs. The logistic growth term restores stock only if the remaining stock isn’t too low. So the “collective optimum” is to **keep stock high** by making total consumption moderate.

Given actions:
- If a player cooperates: takes \(S/(2n)\)
- If defects: takes \(S/n\) (twice as much)

Total consumption depends only on **how many defectors** there were. Let \(k\) = # defectors that round. Then:
\[
\text{Total consumption fraction of stock} = \frac{(n-k)}{2n} + \frac{k}{n} = \frac{1}{2} + \frac{k}{2n}
\]
So remaining fraction is:
\[
\frac{S_{\text{rem}}}{S} = 1 - \left(\frac{1}{2} + \frac{k}{2n}\right) = \frac{n-k}{2n}
\]
More defectors → much lower remaining stock → growth collapses → everyone loses.

---

# 1) Decision rules: when to cooperate vs defect

### State you track each round
From public history you can compute:
- Current stock \(S_t\)
- Previous round’s number of defectors \(k_{t-1}\) (you can observe actions)
- A short “cooperation climate” estimate:
  - \( \bar{k} \) = average defectors over last \(w\) rounds (use \(w = \min(5, t-1)\))

### Core policy
You choose **C by default** when the group is mostly cooperating and stock is healthy. You choose **D** as a defensive/punishment action when (a) others are defecting enough to threaten sustainability, or (b) stock is low enough that immediate deterrence is needed.

#### Thresholds (parameter-only, no coordination assumptions)
Define:
- “Healthy stock” threshold:  
  \[
  S_t \ge 0.8 \cdot \text{capacity}
  \]
- “Danger stock” threshold:  
  \[
  S_t \le 0.5 \cdot \text{capacity}
  \]
- “Defection tolerance” (how many defectors you tolerate before punishing):  
  \[
  k_{\text{tol}} = \max(1, \lceil 0.2n \rceil)
  \]
- “Severe defection” threshold:  
  \[
  k_{\text{sev}} = \lceil 0.5n \rceil
  \]

#### Decision rule (natural language)
- **Cooperate (C)** if:
  1) Stock is healthy **and** recent defection is low: \(\bar{k} \le k_{\text{tol}}\), and  
  2) Last round wasn’t severely exploitative: \(k_{t-1} < k_{\text{sev}}\).
- **Defect (D)** otherwise, *until conditions improve* (see forgiveness rule below).

This makes you a “conditional cooperator”: generous when the group is cooperative, firm when the group isn’t.

---

## Punishment + forgiveness (robustness)
Pure tit-for-tat can fail in multi-player settings because one defector doesn’t map cleanly to individual blame. Instead:

### Punishment mode
Enter punishment mode if either:
- \(k_{t-1} > k_{\text{tol}}\) (too many defectors recently), or
- \(S_t \le 0.5\cdot \text{capacity}\) (stock is in danger), or
- \(k_{t-1} \ge k_{\text{sev}}\) (systemic defection)

**In punishment mode:** play **D**.

### Forgiveness / return-to-cooperation rule
Exit punishment mode (return to C) only after you observe:
- Two consecutive rounds with low defection: \(k_{t-1} \le k_{\text{tol}}\) and \(k_{t-2} \le k_{\text{tol}}\), **and**
- Stock is recovering: \(S_t \ge 0.7\cdot \text{capacity}\)

This prevents being exploited by oscillating opponents who defect whenever you cooperate.

---

# 2) Edge cases (first round, last round, etc.)

### Round 1
Play **C**.
- Rationale: establishes a cooperative baseline and maximizes stock preservation; if others defect, you immediately have evidence and can punish next round.

### Last round (round r)
Play **D** unless stock is already dangerously low.
- Specifically:
  - If \(S_r \ge 0.6\cdot \text{capacity}\): play **D** (endgame has no future to protect, so take the higher payoff).
  - If \(S_r < 0.6\cdot \text{capacity}\): play **C** (avoid total collapse in case stock is very low; also avoids catastrophic “everyone defects” outcomes when low stock still matters to your last-round payoff because it scales with \(S_r\)).

This gives a controlled endgame advantage without accelerating collapse when the pool is already depleted.

### Very low stock (near collapse)
If \(S_t \le 0.2\cdot \text{capacity}\): play **C** regardless of others.
- Reason: when stock is very low, defecting further reduces the chance of recovery; also the difference between \(S/(2n)\) and \(S/n\) is small in absolute terms, while preserving growth potential can matter if there are still rounds left.

### If capacity is barely above \(2n\) (small pool)
The same thresholds work because they’re proportional to capacity; the logic remains: protect stock first, punish over-extraction.

---

# 3) Collective alignment (what this strategy “stands for”)
- **Primary objective:** maintain a high stock regime that yields high repeated payoffs for all players (collective sustainability).
- **Secondary objective:** enforce norms by making persistent defection unattractive (collective stability).
- **Tertiary objective:** avoid endless retaliation spirals by forgiving only when cooperation is stable and stock is recovering.

This is not “be nice”; it’s “be sustainable, and enforce sustainability.”

---

## Pseudocode (implementation-ready)
```python
# Parameters: n, r, capacity
# State each round t: stock S_t, history of actions to compute k_{t-1}, k_{t-2}, etc.

k_tol = max(1, ceil(0.2 * n))
k_sev = ceil(0.5 * n)

def healthy(S): return S >= 0.8 * capacity
def recovering(S): return S >= 0.7 * capacity
def danger(S): return S <= 0.5 * capacity
def critical(S): return S <= 0.2 * capacity

punish_mode = False

for t in 1..r:
    if t == 1:
        action = "C"
    else:
        # compute last defection counts
        k1 = num_defectors(t-1)
        k2 = num_defectors(t-2) if t >= 3 else None
        w = min(5, t-1)
        kbar = avg_num_defectors(last w rounds)

        # endgame rule
        if t == r:
            if S_t >= 0.6 * capacity:
                action = "D"
            else:
                action = "C"

        # critical stock override
        elif critical(S_t):
            action = "C"
            punish_mode = False  # prioritize recovery

        else:
            # update punishment mode
            if (k1 > k_tol) or danger(S_t) or (k1 >= k_sev) or (kbar > k_tol):
                punish_mode = True

            # forgiveness condition
            if punish_mode and (t >= 3) and (k1 <= k_tol) and (k2 <= k_tol) and recovering(S_t):
                punish_mode = False

            action = "D" if punish_mode else "C"

    play(action)
```

---

### What opponents this is robust against
- **Always-defectors:** you switch to D quickly and stop being the “sucker.”
- **Occasional defectors / noisy strategies:** you tolerate small amounts, punish only when it becomes systemic, and forgive after stability returns.
- **Grim-trigger types:** you cooperate by default and don’t initiate punishment unless there’s clear over-extraction.
- **Opportunists exploiting endgame:** you defect in the last round when stock is healthy, preventing being exploited at the finish.

If you tell me typical tournament settings (common values of \(n, r, capacity\)), I can tune the thresholds (0.8/0.7/0.5, 20% tolerance, etc.) to better fit expected dynamics.
'''

description_COLLECTIVE_127 = '''
## Strategy: **Stock‑Sustaining Reciprocity (SSR)**  
Goal: keep the common pool near a self-renewing “sweet spot” while using measured reciprocity to deter persistent defection. The strategy is **collective-first** (tries to sustain high long-run total payoffs), but **not naive** (escalates when the group persistently over-extracts).

### Key idea
Because consumption is proportional to current stock, a group that cooperates tends to keep stock high (often returning to capacity), which maximizes everyone’s future payoffs. Defection is individually tempting in a round, but it can crash the stock and destroy future value. SSR therefore:
1) **Cooperates by default** when the stock is healthy,  
2) **Punishes** over-extraction when evidence suggests others are defecting,  
3) **Protects the resource** when the stock is low (even if punishment would suggest defection), since further depletion is collectively disastrous.

---

## Quantities to compute from history/state
At round \(t\), before acting, you know current stock \(S_t\) and past actions.

- Let \(d_{t-1}\) = number of players who defected in the previous round (if \(t=1\), undefined).
- Let **stock health ratio**:  
  \[
  h_t = S_t / \text{capacity}
  \]
- Define “low stock” threshold:  
  \[
  h_t < 0.35 \quad(\text{resource is fragile})
  \]
- Define “high stock” threshold:  
  \[
  h_t > 0.75 \quad(\text{resource robust})
  \]

These constants are deliberately simple and parameter-only (they do not assume knowing others’ strategies).

---

## 1) Decision rules (C vs D)

### Rule A — Resource protection comes first (collective safeguard)
If the stock is **low**, always **Cooperate**:
- **If** \(h_t < 0.35\) **then play C**.

Rationale: When stock is low, defection consumes a larger fraction of what remains and risks pushing the system into collapse; cooperating reduces draw and helps recovery.

---

### Rule B — Default cooperation when stock is healthy
If stock is high and there is no strong evidence of ongoing defection, cooperate:
- **If** \(h_t > 0.75\) and (last round had **at most 1 defector**) then **play C**.

Rationale: With mostly cooperative behavior, staying cooperative keeps the pool near capacity, maximizing long-run payoffs.

---

### Rule C — Reciprocity / deterrence when over-extraction is detected
When stock is not fragile but defection appears significant, respond proportionally:

- Compute last-round defection rate:
  \[
  q = d_{t-1}/n
  \]
- Define a “tolerate small noise” band: if \(q \le 1/n\) treat it as noise and continue C (already covered above).
- Otherwise, **punish with controlled defection** using a probability that increases with the defection rate and with the urgency (later rounds):

**Punishment probability**
\[
p_D = \text{clip}\Big( 0,\ 1,\ \underbrace{\alpha (q - 1/n)}_{\text{how many defected}} + \underbrace{\beta \cdot (t-1)/(r-1)}_{\text{less time left}} \Big)
\]
Use constants:
- \(\alpha = 1.6\)
- \(\beta = 0.4\)

Then:
- **If** \(0.35 \le h_t \le 0.75\) **and** \(q > 1/n\): play **D with probability \(p_D\)**, otherwise **C**.

Rationale:  
- Proportional retaliation discourages strategies that profit by defecting while others cooperate.  
- The time factor makes forgiveness easier early (more value in restoring cooperation) and tougher late (less time to recover losses).

---

### Rule D — Recovery / forgiveness trigger
If the group returns to cooperation, immediately de-escalate:

- If in the previous round \(d_{t-1} = 0\), then **play C** (unless Rule A already applies, which also yields C).

Rationale: quickly restores a cooperative basin once others stop defecting.

---

## 2) Edge cases

### First round (t = 1)
- **Play C**.

Reason: establishes the cooperative baseline and keeps stock high; also reveals who defects without prematurely degrading stock.

---

### Last round (t = r)
Classic backward-induction would suggest defection, but in tournaments you face non-equilibrium opponents; moreover the last-round stock still depends on earlier behavior, so reputation effects matter until the end. SSR uses a tempered endgame:

- If \(h_r < 0.35\): **C** (protect resource even at the end; also avoids enabling “crash-and-grab” dynamics).
- Else if in round \(r-1\), \(d_{r-1} \le 1\): **C** (reward near-cooperation).
- Else: **D** with probability \(0.75\) (firm response if others are already exploiting).

This avoids being a predictable “always defect last round” type, while still not being exploited in late-stage collapses.

---

### Very small capacity relative to n (given capacity ≥ 2n but could still be tight)
The thresholds are in **ratios** \(S/capacity\), so the strategy scales automatically. Rule A (protect when low) becomes more important in tight environments.

---

### Persistent chaos / oscillations
If opponents are erratic, SSR tends to:
- keep cooperating when the pool is fragile (prevent collapse),
- otherwise mix in defection in proportion to observed defection, avoiding being a permanent sucker while not guaranteeing collapse.

---

## 3) Collective mindset (what it’s trying to achieve)
SSR’s “collective” logic is:

1) **Sustainability first**: never accelerate collapse when the resource is already fragile.  
2) **Cooperation is the default**: when the group is mostly cooperative and the pool is healthy, keep it that way.  
3) **Reciprocal deterrence**: if others exploit, respond enough to make exploitation unattractive, but with forgiveness so cooperation can re-emerge.  
4) **Adaptive to population behavior**: reacts to *measured* defection rates rather than assuming any fixed norm, schedule, or communication.

---

## Pseudocode (implementation-ready)
```python
def SSR_action(t, r, n, capacity, S_t, history_actions):
    h = S_t / capacity

    # Round 1
    if t == 1:
        return "C"

    # Count defectors last round
    last = history_actions[t-1]  # list of "C"/"D" length n
    d = sum(1 for a in last if a == "D")
    q = d / n

    # Rule A: protect fragile stock
    if h < 0.35:
        return "C"

    # Rule D: immediate forgiveness if all cooperated last round
    if d == 0:
        return "C"

    # Last round special handling
    if t == r:
        if d <= 1 and h >= 0.35:
            return "C"
        else:
            return "D" if random() < 0.75 else "C"

    # Rule B: default cooperate when healthy and only minor noise
    if h > 0.75 and d <= 1:
        return "C"

    # Rule C: proportional retaliation (mixed)
    if q > 1/n:
        alpha = 1.6
        beta  = 0.4
        p_D = alpha * (q - 1/n) + beta * ((t-1)/(r-1))
        p_D = max(0.0, min(1.0, p_D))
        return "D" if random() < p_D else "C"

    return "C"
```

This strategy is simple enough to be robust, parameter-only, history- and state-dependent, sustainability-preserving, and hard to exploit systematically across a wide range of opponent behaviors.
'''

description_COLLECTIVE_128 = '''
## Strategy: **Stock-Guarded Reciprocity (SGR)**  
Goal: keep the stock near the regenerative “sweet spot” while staying hard to exploit. The core idea is:

- **Default to cooperation** when the resource is healthy and opponents are not persistently over-consuming.
- **Punish defections quickly and predictably** (short, state-dependent punishments) to make exploitation unprofitable.
- **Recover to cooperation** as soon as the stock and behavior indicate it’s safe, to avoid mutually destructive spirals.
- **Endgame-aware**: tighten if there’s no future to protect.

This is a *collective* strategy: it treats cooperation as the baseline and uses punishment only to protect the common pool and deter free-riding.

---

# 1) Decision rules: when to cooperate vs defect

### Key signals computed each round
Let:
- `S_t` = stock at start of round `t`
- `capacity` given
- `n` players
- `D_{t-1}` = number of players who defected in round `t-1` (observed)
- `D_rate_{t-1} = D_{t-1}/n`

Define stock zones (fractions of capacity):
- **Green**: `S_t >= 0.80 * capacity` (very healthy)
- **Yellow**: `0.50 * capacity <= S_t < 0.80 * capacity` (healthy but watch)
- **Orange**: `0.25 * capacity <= S_t < 0.50 * capacity` (at risk)
- **Red**: `S_t < 0.25 * capacity` (critical)

Maintain an internal integer state:
- `punish_timer` (starts at 0): how many future rounds we will defect as punishment.

### Core behavioral rules

#### A. Stock protection (ecological trigger)
If stock is low, prioritize preventing collapse:
- **If Red** (`S_t < 0.25 cap`): **Defect (D)**  
  Rationale: when the pool is near collapse, “being nice” doesn’t save it; the marginal personal incentive dominates and you must avoid being the only cooperator feeding defectors. This also makes the strategy resistant to exploitation in critical states.

- **If Orange** (`0.25 cap <= S_t < 0.50 cap`):
  - If `D_rate_{t-1} >= 0.25` (at least a quarter defected last round): **Defect (D)**
  - Else: **Cooperate (C)**  
  Rationale: if others are mostly cooperating, keep the pool alive; if notable defection exists, switch to deterrence.

#### B. Reciprocity / deterrence (behavioral trigger)
If stock is not critical (Yellow/Green), react to defection:
- If `punish_timer > 0`: **Defect (D)** and decrement `punish_timer`.
- Else (not currently punishing):
  - If `D_{t-1} == 0`: **Cooperate (C)** (reward full cooperation)
  - If `D_{t-1} > 0`: start punishment:
    - Set `punish_timer = P(S_t, D_{t-1})`
    - **Defect (D)** this round

Where punishment length is short but stronger when defection is larger or stock is weaker:

**Punishment function**
```
P(S_t, D_{t-1}) =
    base = 1
    severity = 1 if D_{t-1} <= n/3 else 2
    fragility = 1 if S_t < 0.70*capacity else 0
    return base + severity + fragility
```
So punish for **2–4 rounds**, typically:
- 2 rounds for small defection with strong stock,
- 3–4 rounds if many defect or stock is slipping.

#### C. Forgiveness / return-to-cooperate
After punishment ends (`punish_timer == 0`), don’t hold grudges:
- If the last observed round had `D_{t-1} == 0` and stock is **Yellow/Green**, **Cooperate (C)**.
- If defections persist, re-enter punishment immediately.

This creates a **clear on-ramp back to cooperation**: “Stop defecting and we cooperate again.”

---

# 2) Edge cases

### First round (no history)
Round `t=1`: **Cooperate (C)** *unless stock is already Orange/Red*.
- Since the game starts at `capacity`, this means **C in round 1**.
- Collective intent: offer cooperation to establish a cooperative path when it’s most sustainable.

### Last round (finite-horizon endgame)
In the last round, deterrence value is reduced. Use a state-and-history-dependent endgame rule:

At round `t = r`:
- If `S_t >= 0.80 cap` **and** `D_{r-1} == 0`: **Cooperate (C)** (take the collective-friendly finish)
- Else: **Defect (D)** (avoid being exploited at the end)

At round `t = r-1` (penultimate):
- If `D_{r-2} > 0` or `S_t < 0.70 cap`: lean defensive → **Defect (D)**
- Else: **Cooperate (C)**

This prevents “endgame sucker” outcomes while still finishing cooperatively when the group has proven cooperative.

### Stock at (or near) zero
If `S_t == 0`: payoffs are zero regardless; choose **Defect (D)** to remain consistent with the red-zone rule.

### Everyone is defecting persistently
If you observe `D_rate` high (e.g., `>= 0.5`) for 2 consecutive rounds, switch into **Containment Mode** for the remainder:
- In Containment Mode: **Defect (D)** unless `D_{t-1} == 0` for **two consecutive rounds** and `S_t >= 0.70 cap`, in which case reset and cooperate.
Rationale: avoid endless cycles of trying to “restart” cooperation against highly exploitative populations.

---

# 3) Why this is “collective” and robust

### Collective alignment
- **Starts cooperative** and **returns to cooperation quickly** when others do.
- Uses punishment **only as a tool to enforce a cooperative norm** and protect the common pool.
- Explicitly accounts for the **resource state**; it does not blindly punish or blindly forgive.

### Robustness to opponent types
- **Against unconditional cooperators:** stays mostly cooperative (high joint payoffs).
- **Against unconditional defectors:** shifts to defection quickly; avoids being exploited repeatedly.
- **Against noisy strategies (occasional defection):** short punishments + forgiveness prevent permanent breakdown.
- **Against grim-trigger types:** avoids gratuitous defections when stock is healthy and history is clean; but will still defend itself if attacked.
- **Against opportunists who defect when stock is high:** immediate punishment makes “defect-when-rich” less profitable long-run.

---

# Pseudocode (implementation-oriented)

```python
punish_timer = 0
containment = False
last_two_defection_rates = []  # keep last 2

def stock_zone(S, cap):
    if S < 0.25*cap: return "red"
    if S < 0.50*cap: return "orange"
    if S < 0.80*cap: return "yellow"
    return "green"

def punishment_length(S, cap, D_count, n):
    base = 1
    severity = 1 if D_count <= n/3 else 2
    fragility = 1 if S < 0.70*cap else 0
    return base + severity + fragility  # 2..4

def decide(t, r, S, cap, n, D_prev, D_prevprev):
    global punish_timer, containment, last_two_defection_rates

    zone = stock_zone(S, cap)

    # Update containment trigger
    if D_prev is not None:
        last_two_defection_rates.append(D_prev/n)
        last_two_defection_rates = last_two_defection_rates[-2:]
        if len(last_two_defection_rates) == 2 and all(x >= 0.5 for x in last_two_defection_rates):
            containment = True

    # First round
    if t == 1:
        return "C" if zone in ["green","yellow"] else "D"

    # Endgame
    if t == r:
        if S >= 0.80*cap and D_prev == 0:
            return "C"
        return "D"
    if t == r-1:
        if (D_prevprev is not None and D_prevprev > 0) or S < 0.70*cap:
            return "D"

    # Containment mode
    if containment:
        # require two clean rounds + decent stock to reset
        if D_prev == 0 and D_prevprev == 0 and S >= 0.70*cap:
            containment = False
            punish_timer = 0
            return "C"
        return "D"

    # Ecological trigger
    if zone == "red":
        return "D"
    if zone == "orange":
        if D_prev/n >= 0.25:
            return "D"
        # else continue to reciprocity logic below

    # Punishment phase
    if punish_timer > 0:
        punish_timer -= 1
        return "D"

    # Reciprocity trigger
    if D_prev == 0:
        return "C"
    else:
        punish_timer = punishment_length(S, cap, D_prev, n) - 1  # -1 because we defect now
        return "D"
```

---

If you tell me typical tournament settings (common `n`, `r`, and `capacity` ranges), I can tune the thresholds (0.25/0.50/0.80, defection-rate cutoffs, and punishment lengths) to better match the ecology implied by the logistic growth and consumption structure.
'''

description_EXPLOITATIVE_1 = '''
## Exploitative strategy: **Probe–Tax–Harvest (PTH)**

Mindset: treat the stock as a renewable “capital base” you want others to help recapitalize. You **(a)** probe who is willing/able to cooperate, **(b)** “tax” them by defecting when the stock is high, and **(c)** only cooperate when defection would crash the stock and kill future rents. You also **punish hard** when others defect too much, not to be fair, but to (i) stop being suckered and (ii) shift the game into a fast endgame where you at least take what you can.

This strategy uses only parameters, current stock, and history.

---

# Key quantities you track each round

Let:
- `S_t` = current stock at start of round t.
- `k_{t-1}` = number of defectors observed in round t−1 (from actions history).
- `p_{t-1} = k_{t-1}/n` = observed defection rate.
- `k_hat` = exponentially smoothed expected number of defectors next round:
  - `k_hat ← (1-α)*k_hat + α*k_{t-1}` with α≈0.4, initialized to n/2.

Also compute a **safety threshold** stock below which defection is likely to drive the resource toward collapse even if some cooperate:

- If you defect and expect `k_hat` total defectors (including you) and `n-k_hat` cooperators, expected remaining stock after consumption is:
  - `S_rem = S_t * [1 - ( (n-k_hat)/(2n) + (k_hat)/n ) ]`
  - Simplifies to `S_rem = S_t * (n - k_hat)/(2n)`
- Logistic growth is positive if `S_rem > 0` and is strongest near `capacity/2`. But if `S_rem` is tiny, growth won’t rebuild quickly and you risk hitting ~0 if defection increases.

Define:
- `S_safe(k_hat) = capacity * 0.25 * (2n)/(n - k_hat + 1e-9)` (clipped to [0,capacity])
  - Interpretation: keep expected post-consumption stock around ≥ capacity/4. This is a conservative “don’t crash the bank” rule.
  - If `k_hat` is high, `S_safe` rises (need more stock to safely defect).

You don’t need the exact constant 0.25; it’s a tunable safety margin. The point is: **defect when S is comfortably high given expected defection; cooperate to recapitalize when it’s not.**

---

# 1) Decision rules (C vs D)

### Rule A — Endgame harvest
If `t == r` (last round): **Defect (D)** always.  
No future stock to protect; pure one-shot incentive.

### Rule B — If stock is “flush,” tax the pool
If `S_t >= max(0.6*capacity, S_safe(k_hat))`: **Defect (D)**.  
Rationale: when stock is high, your defection is least likely to permanently harm future earnings, and you get double the per-round payoff.

### Rule C — If stock is “fragile,” recapitalize unless opponents are already too greedy
If `S_t <= 0.35*capacity`:
- If `p_{t-1} <= 0.4` (others mostly cooperating): **Cooperate (C)** to rebuild stock so you can exploit later.
- Else (others are already defect-heavy): **Defect (D)** (don’t be the only one paying to rebuild).

### Rule D — Default: conditional exploitation (“cooperate just enough”)
Otherwise (mid stock):
- If `p_{t-1} <= 0.25`: **Defect (D)** (they’re cooperative → exploit).
- If `0.25 < p_{t-1} <= 0.6`: **Cooperate (C)** (keep stock from decaying under mixed play).
- If `p_{t-1} > 0.6`: **Defect (D)** (pool is in a defection regime; take what you can).

### Rule E — Retaliation trigger (anti-sucker)
Maintain a counter `bad_streak`:
- Increment if `k_{t-1} >= ceil(n/2)` (majority defected).
- Reset to 0 otherwise.

If `bad_streak >= 2` and `t <= r-1`: **Defect (D)** until either:
- stock hits very low (`S_t <= 0.25*capacity`) *and* defection rate drops (`p_{t-1} <= 0.35`), then return to Rule C/D.
This prevents being dragged into repeatedly “rebuilding for free” while others cash out.

---

# 2) Edge cases (first round, last rounds, etc.)

### First round (t=1)
You have no history. Use a parameter-based probe that’s exploit-friendly:

- If `r <= 3`: **Defect (D)** immediately (short horizon → harvest).
- Else (r >= 4):
  - If `capacity` is large relative to n (it is, since capacity ≥ 2n): **Defect (D)** in round 1.
    - Reason: when starting at capacity, one round of defection is maximally profitable and reveals opponent type quickly.
  - (Optional safer variant if you expect many “grim trigger” bots in tournaments): cooperate only if you want to try to keep them cooperative. But exploitative stance says: take the first-round rent.

### Last two rounds
- Round `r`: always D.
- Round `r-1`: D unless `S_t` is so low that you’d get almost nothing and you believe a cooperative round could rebuild enough to make round r more lucrative.
  - Practical rule: if `S_t < 0.2*capacity` and `p_{t-1} <= 0.3`, play **C** in `r-1`; else **D**.
This is purely instrumental: “invest” one round only if you can harvest next round.

### Stock near zero
If `S_t` is extremely small (`S_t <= 0.05*capacity`):
- If opponents are cooperating a lot (`p_{t-1} <= 0.25`) and `t < r-1`: **C** (rebuild to exploit later).
- Else: **D** (no point being the sole restorer).

### Everyone always defects
You will quickly enter retaliation trigger and then just **D always** (except possibly a brief rebuild attempt if defection rate drops).

---

# 3) Why this is exploitative and robust

**Exploitative:**
- When others cooperate (low `p`), you default to **D** to extract roughly double payoff while they sustain the stock.
- You only cooperate to *protect your future ability to defect profitably*, not to be fair.
- You use endgame defection and “taxing” whenever stock is high.

**Robust:**
- If the table turns defect-heavy, you stop subsidizing and defect too.
- Uses smoothing (`k_hat`) so it doesn’t overreact to noise or occasional exploration by others.
- Uses state (`S_t`) so it doesn’t blindly defect into collapse—protects long-run earnings against self-defeating greed.

---

# Pseudocode (implementable)

```pseudo
init:
  k_hat = n/2
  bad_streak = 0
  α = 0.4

for t in 1..r:
  observe S_t

  if t == r:
    play D
    continue

  if t > 1:
    k_prev = number_of_defectors_in_round(t-1)
    p_prev = k_prev / n
    k_hat = (1-α)*k_hat + α*k_prev

    if k_prev >= ceil(n/2): bad_streak += 1
    else: bad_streak = 0
  else:
    p_prev = 0.5   # neutral prior

  # safety threshold
  S_safe = capacity * 0.25 * (2*n) / max(1e-9, (n - k_hat))
  S_safe = clamp(S_safe, 0, capacity)

  # retaliation mode
  if bad_streak >= 2:
    if (S_t <= 0.25*capacity) and (t > 1) and (p_prev <= 0.35):
      # allow rebuild exit
      # fall through to normal rules
      pass
    else:
      play D
      continue

  # first round special
  if t == 1:
    if r <= 3: play D
    else: play D
    continue

  # penultimate round special
  if t == r-1:
    if (S_t < 0.2*capacity) and (p_prev <= 0.3):
      play C
    else:
      play D
    continue

  # main rules
  if S_t >= max(0.6*capacity, S_safe):
    play D
  else if S_t <= 0.35*capacity:
    if p_prev <= 0.4: play C
    else: play D
  else:
    if p_prev <= 0.25: play D
    else if p_prev <= 0.6: play C
    else: play D
```

---

If you tell me typical tournament ranges for `(n, r, capacity)` (e.g., n=4..10, r=10..100), I can tune the constants (0.6, 0.35, 0.25, streak length, etc.) to maximize exploitability without inducing frequent stock crashes.
'''

description_EXPLOITATIVE_2 = '''
Below is an **exploitative, state-aware “Harvest–Threat–Recover (HTR)”** strategy. It treats cooperation as an *investment to keep stock high* and defection as *harvesting* when others are likely to sustain the resource for you. It is adaptive: it estimates whether opponents are “supporting” the stock (cooperating enough) and then defects as much as it can without collapsing the stock below a safe band.

---

## Key idea (what you’re exploiting)

- Your **one-round gain from D vs C is +S/(2n)** at stock \(S\).
- But too many D’s drive \(S\) down and ruin future payoffs.
- So you:
  1. **Probe** whether the group tends to cooperate.
  2. If yes, **free-ride** (defect) to harvest higher payoffs.
  3. If stock falls toward a danger zone, you **temporarily cooperate** to rebuild (because the logistic growth is strong at mid stock).
  4. You **punish** by defecting when others defect a lot (don’t subsidize them).
  5. Near the end, you **harvest** (more defection), because future value matters less.

This is not “nice.” It’s designed to take extra payoff whenever the environment allows it.

---

## Observables you can compute each round

At round \(t\), before choosing an action, you know current stock \(S_t\) and full past actions. Let:
- \(k_{t-1}\) = number of opponents who defected last round (out of \(n-1\)).
- \(d_{t-1} = k_{t-1}/(n-1)\) = opponent defection rate last round.
- \(\bar d_{t-1}\) = smoothed defection rate, e.g. exponential moving average:
  \[
  \bar d_t = \lambda \bar d_{t-1} + (1-\lambda)d_t,\quad \lambda \in [0.6,0.85]
  \]
- \(S_t/capacity\) = stock health.

---

## Stock thresholds (parameter-only)

Define safe bands relative to capacity:

- **Danger zone**: \(S_t \le S_{\text{low}} = 0.25 \cdot capacity\)  
  (below this, growth may be slower and collapse risk rises if others defect)
- **Harvest zone**: \(S_t \ge S_{\text{high}} = 0.70 \cdot capacity\)  
  (resource is abundant; defection payoff is large)
- **Recovery target**: \(S_{\text{rec}} = 0.60 \cdot capacity\)

These are intentionally conservative: they keep the game alive while still enabling frequent harvesting.

---

## Decision rules (cooperate vs defect)

### Rule 0: Last round = harvest
If \(t = r\): **Play D**.

Reason: no future to protect; exploit immediate payoff.

---

### Rule 1: First round = probe for “suckers”
If \(t = 1\):
- If \(r\) is small (e.g., \(r \le 3\)): **D** (short horizon → harvest immediately).
- Else: **C** (cheap probe: keeps stock high and reveals who defects).

---

### Rule 2: Don’t subsidize defect-heavy groups
If smoothed opponent defection is high:
- If \(\bar d_{t-1} \ge 0.5\): **D** regardless of stock, except when stock is extremely low (see Rule 4).

Interpretation: if at least about half the opponents are typically defecting, any cooperation you do mostly becomes a transfer to them. So you defect too.

---

### Rule 3: Free-ride when others are cooperating and stock is healthy
If opponents are mostly cooperating and stock is good:
- If \(\bar d_{t-1} \le 0.25\) **and** \(S_t \ge S_{\text{high}}\): **D**

Interpretation: the table is set; take the larger share.

---

### Rule 4: Controlled recovery when stock is in danger (but only if it’s worth saving)
If \(S_t \le S_{\text{low}}\):
- If \(t \le r-2\) (at least 2 future rounds remain) **and** \(\bar d_{t-1} \le 0.35\): **C**
- Else: **D**

Interpretation: you only “invest” to rebuild stock if (a) there’s time to benefit and (b) opponents aren’t too defect-happy (otherwise your cooperation won’t rescue it).

---

### Rule 5: Default “exploit with guardrails”
When none of the above triggers, use a simple exploit/recover toggle:

- If \(S_t \ge S_{\text{rec}}\):
  - **D** if \(\bar d_{t-1} \le 0.40\) (group can likely sustain)
  - else **C** (rare: stabilize if group is drifting defect-heavy but not hopeless)
- If \(S_t < S_{\text{rec}}\):
  - **C** if \(\bar d_{t-1} \le 0.30\)
  - else **D**

This makes you:
- defect a lot against cooperative or mixed opponents (exploitation),
- stop cooperating when it’s futile (avoid being the “resource maintainer” for defectors),
- cooperate just enough to keep the stock from collapsing when you can later cash in.

---

## Edge cases

1. **Very short games** (\(r \le 3\)):  
   Always **D** except possibly \(t=1\) if you want a probe, but exploitatively you should just D.

2. **Stock already at/near 0**:  
   Cooperation yields ~0 now. If opponents are defectors, rebuilding is unlikely; **D** (Rule 4).  
   If opponents are cooperative and time remains, **C** to reboot growth.

3. **Capacity barely satisfies constraint (capacity ≈ 2n)**:  
   Stock levels are small and volatility is high; tighten recovery:
   - raise \(S_{\text{low}}\) to 0.35 capacity
   - lower \(S_{\text{high}}\) to 0.65 capacity  
   (same logic, just more cautious to prevent collapse).

4. **Sudden opponent shift to defection**:  
   The moving average \(\bar d\) reacts; once it crosses 0.5 you stop cooperating (Rule 2). You don’t get trapped “being nice” after they turn predatory.

---

## Pseudocode

```python
def action(t, r, n, capacity, S, opp_defections_last, dbar_prev):
    # parameters
    lam = 0.75
    d_last = opp_defections_last / (n-1)
    dbar = lam*dbar_prev + (1-lam)*d_last

    Slow  = 0.25 * capacity
    Shigh = 0.70 * capacity
    Srec  = 0.60 * capacity

    # Rule 0: last round harvest
    if t == r:
        return "D", dbar

    # Rule 1: first round probe or harvest if short horizon
    if t == 1:
        if r <= 3:
            return "D", dbar
        else:
            return "C", dbar

    # Rule 2: don't subsidize defect-heavy groups
    if dbar >= 0.50:
        if S <= Slow and t <= r-2 and dbar <= 0.35:
            return "C", dbar  # practically never true when dbar>=0.5
        return "D", dbar

    # Rule 3: free-ride when stock is high and others cooperate
    if dbar <= 0.25 and S >= Shigh:
        return "D", dbar

    # Rule 4: controlled recovery
    if S <= Slow:
        if t <= r-2 and dbar <= 0.35:
            return "C", dbar
        return "D", dbar

    # Rule 5: default exploit-with-guardrails
    if S >= Srec:
        return ("D" if dbar <= 0.40 else "C"), dbar
    else:
        return ("C" if dbar <= 0.30 else "D"), dbar
```

---

## Why this is exploitative (and robust)

- **Exploitative:** It defects whenever opponents appear to maintain the resource (low \(\bar d\), high \(S\)), extracting higher per-round payoff.
- **Not a pure defector:** It uses cooperation tactically to keep stock in a profitable regime, then harvests.
- **Robust:** Against defect-heavy populations it stops “funding” them (switches to D). Against cooperators it free-rides. Against mixed/unstable groups it uses stock thresholds to avoid catastrophic collapse when salvageable.

If you want it *even more exploitative*, you can lower the “defect-heavy cutoff” from 0.50 to 0.40 and lower \(S_{\text{low}}\) to 0.20 capacity—this increases short-run gains but raises collapse risk.
'''

description_EXPLOITATIVE_3 = '''
### Strategy: **Regenerative Extortion (REX)**  
Exploit others by (i) keeping the resource in the high-growth region when it benefits you, (ii) taking the larger share whenever opponents appear “safe” or “forgiving,” and (iii) immediately switching to harsh punishment when your longer-run take is threatened.

This strategy is **stateful** (uses stock), **history-based** (uses observed action counts), **adaptive** (learns opponents’ cooperativeness), and **exploitative** (defaults to defection unless it’s profitable to “farm” cooperators).

---

## Key ideas (why this exploits well)

- **Defection pays double in the current round**: \(D\) yields \(S/n\) vs \(C\) yields \(S/(2n)\).
- **But defection can kill the stock**, eliminating all future payoffs (including yours). So the exploit is to:
  - **Maintain stock** in a range where growth is strong (roughly mid-capacity), *but only by cooperating as little as needed*.
  - **Defect whenever opponents keep stock alive for you** (they cooperate enough, or they’re “nice” after you defect).
- Use **credible punishments**: if others start defecting enough to endanger the stock (or to reduce your future extraction), you switch to full defection to deny them long-run gains (“if I can’t profitably farm, I burn the field”).

---

## Useful quantities each round \(t\)

Let:
- \(S_t\): current stock at start of round \(t\).
- From history at \(t-1\): \(k_{t-1}\) = number of opponents who played \(C\) last round. (So total cooperators last round is \(k_{t-1} + \mathbb{1}[\text{you played C}]\).)

### Stock-safe region target
You want to avoid \(S\) collapsing to ~0, but you also don’t need it at capacity. Logistic growth is strong when \(S\) is not too close to 0 or capacity.

Define two thresholds (parameter-only):
- **Critical floor:**  
  \[
  S_{\text{crit}} = 0.25 \cdot \text{capacity}
  \]
  Below this, stock is fragile; prioritize survival/farming over immediate extortion.
- **Harvest region:**  
  \[
  S_{\text{harv}} = 0.6 \cdot \text{capacity}
  \]
  Above this, stock is abundant; you can defect aggressively and still often remain sustainable if others cooperate.

(These constants are tunable but work as simple robust heuristics across capacities.)

---

## 1) Decision rules: when to Cooperate vs Defect

### Rule A — Last-round logic (backward induction)
- **Round \(t = r\) (last round): Always D.**  
  No future to protect; take the full extraction.

### Rule B — Stock emergency (prevent total collapse if it helps you)
- If \(S_t \le S_{\text{crit}}\): **Play C** *unless* you are already in “scorched-earth mode” (defined below).  
  Rationale: when stock is low, defecting often drives it to ~0, destroying your remaining rounds’ earnings. Cooperating here is an investment to restore a farmable stock.

### Rule C — Scorched-earth trigger (when farming is no longer profitable)
Enter **Scorched-Earth Mode** (SEM) if either condition holds:
1. **Opponent defection pressure is high**: in the previous round, at least half of opponents defected:  
   \[
   k_{t-1} \le \left\lfloor \frac{n-1}{2} \right\rfloor
   \]
2. **Stock is already in collapse** and opponents are not helping:  
   \(S_t \le S_{\text{crit}}\) **and** \(k_{t-1} < n-1\) (someone defected while it was fragile).

**In SEM: Always D for the rest of the game** (except you can optionally exit if you see full cooperation for 2 consecutive rounds; see “robustness” below).  
Exploitative logic: if others won’t sustain the pool, you deny them any advantage from your restraint.

### Rule D — Default extortion (farm cooperators)
If not in SEM and not last round:

1) **If stock is abundant (\(S_t \ge S_{\text{harv}}\)): Play D.**  
You extract maximum now; stock is high and growth can refill if others cooperate at all.

2) **If stock is moderate (\(S_{\text{crit}} < S_t < S_{\text{harv}}\)): condition on how cooperative others are**:
- If last round opponents were very cooperative:  
  \[
  k_{t-1} \ge \left\lceil 0.7 (n-1) \right\rceil
  \]
  then **Play D** (they’re sustaining the pool; exploit).
- Otherwise **Play C** (you need to stabilize the pool to keep future extraction viable).

This gives you a simple “extortion gate”: you defect whenever opponents demonstrate willingness to carry the sustainability burden; you cooperate only when necessary to prevent killing your future revenue.

---

## 2) Edge cases & special handling

### First round \(t=1\)
You have no history. Use stock-only logic:
- If \(r \ge 3\): **Play D** (probe for punishers/forgivers; big immediate gain; you can still recover later if needed).
- If \(r=2\): **Play D** (still best; next is last round anyway).
This is intentionally exploitative: you start by taking more and see who tolerates it.

### Last two rounds
- \(t=r\): always D.
- \(t=r-1\): **Usually D**, *unless* \(S_{r-1} \le S_{\text{crit}}\) and you’re not in SEM; then play **C** to avoid getting near-zero in the last round (this can increase the final-round \(S_r\) and thus your last-round D payoff).

### Handling “all-cooperate” opponents
If everyone else keeps cooperating, you will:
- Defect most rounds (Rule D), extracting double each time.
- Only cooperate if stock drifts into the moderate/low region due to too many defections (yours and potential mutants), to restore the farm.

### Handling “grim trigger / retaliators”
Against strategies that punish defection by switching to D:
- Your initial D may trigger them; then \(k\) drops and SEM will likely activate, pushing you to permanent D (mutual ruin).
- This is acceptable in an exploitative mindset: if they won’t be farmed, you deny them gains too rather than subsidize them. (Also, sometimes stock dynamics will still allow positive payoffs even under heavy D early on.)

### Handling noisy / mixed populations
The \(k_{t-1}\) thresholds make you robust:
- If enough others cooperate, you farm (D).
- If cooperation falls, you stabilize (C) until farmable again—or switch to SEM if opponents are too destructive.

---

## 3) Clear exploitative alignment (what you’re optimizing)

Your policy is designed so that:

- **You defect whenever opponents demonstrate they’ll sustain the resource**, capturing higher immediate payoff while they bear sustainability costs.
- **You cooperate only as an investment** to keep future stock high enough for *your* later defection profits.
- **If opponents won’t support your exploitation**, you switch to a punishment regime that avoids being the “sucker” and reduces their ability to profit.

---

## Pseudocode (implementable)

```pseudo
parameters:
  Scrit = 0.25 * capacity
  Sharv = 0.60 * capacity
  coop_high = ceil(0.7 * (n-1))
  defection_majority = floor((n-1)/2)

state:
  SEM = false
  fullcoop_streak = 0

for each round t = 1..r:
  observe current stock S_t

  if t == r:
     play D
     continue

  if t > 1:
     k = #opponents who played C in round t-1

     if k == n-1:
        fullcoop_streak += 1
     else:
        fullcoop_streak = 0

     # enter scorched-earth
     if (k <= defection_majority) or (S_t <= Scrit and k < n-1):
        SEM = true

     # optional exit rule (keeps robustness vs temporary shocks)
     if SEM and fullcoop_streak >= 2 and S_t > Scrit:
        SEM = false

  # first round: no history
  if t == 1:
     play D
     continue

  if SEM:
     play D
     continue

  # stock emergency
  if S_t <= Scrit:
     play C
     continue

  # abundant stock: harvest
  if S_t >= Sharv:
     play D
     continue

  # moderate stock: farm only if others carry sustainability
  if k >= coop_high:
     play D
  else:
     play C
```

---

### Notes on why this should perform well in a tournament
- Beats “always cooperate” and many forgiving/reactive cooperators by defecting most of the time while still maintaining stock via occasional corrective cooperation.
- Avoids being exploited by always-defectors: SEM quickly locks into D so you’re not the only cooperator propping up others.
- Uses stock thresholds so it doesn’t blindly defect into zero (a common failure mode of purely myopic exploiters).

If you want, I can also provide a tighter version that computes the **minimum cooperation needed** (based on estimated number of cooperators) to keep expected post-growth stock above a chosen floor, making the extortion even more surgical.
'''

description_EXPLOITATIVE_4 = '''
## Strategy: **Reserve‑Guard Extortion (RGE)**  
Goal: **take D whenever it’s safe**, but **keep the resource from collapsing** by switching to C only when the stock is in a danger zone. This exploits (i) short-horizon/greedy opponents by harvesting high immediate payoffs, and (ii) conditional cooperators by staying just “cooperative enough” to preserve a high stock while still defecting more often than they do.

Key idea: treat the stock as an **asset** you sometimes invest in (C) to prevent ruin, but otherwise **extract maximum** (D). Use history to detect whether others are stabilizing the stock for you; if yes, defect more aggressively.

---

# 1) Decision rules (when to C vs D)

### Notation observed at start of round *t*
- `S` = current stock.
- `capacity` = carrying capacity.
- `n` = number of players.
- From last round: number of defectors `k_last` (count of players who played D), and whether stock rose/fell.

### Useful stock thresholds (parameterized)
Define three zones:
- **Safe zone:** `S ≥ 0.70 * capacity`
- **Caution zone:** `0.40 * capacity ≤ S < 0.70 * capacity`
- **Danger zone:** `S < 0.40 * capacity`

Rationale: with logistic growth `2*S_rem*(1 - S_rem/capacity)`, the system is most resilient when remaining stock after consumption stays around `capacity/2`. Below ~0.4 capacity, a couple of D-heavy rounds can push it toward collapse; above ~0.7 you can usually extract hard.

### Opponent “stewardship” estimate
Track over a rolling window (e.g., last `W = min(10, t-1)` rounds):
- `D_rate_others` = average fraction of other players choosing D.
- `ΔS_avg` = average change in stock (new stock − old stock).

Interpretation:
- If `ΔS_avg ≥ 0` while `D_rate_others` is not too high, opponents are keeping the resource healthy (intentionally or not). You can exploit by defecting more.

### Core policy
**Rule A — Danger guard (preserve the commons only when necessary):**
- If `S < 0.40*capacity`: **play C**.
  - Exception (rare): if it’s the last round, defect (see endgame rules).

**Rule B — Safe extraction (default exploitation):**
- If `S ≥ 0.70*capacity`: **play D**, unless you are trying to “buy” cooperation (see Rule D).

**Rule C — Caution zone (adaptive extortion):**
If `0.40*capacity ≤ S < 0.70*capacity`:
- If others are mostly cooperating (low D-rate) *or* stock has been stable/increasing:
  - **play D** (let them do the replenishing).
- If others are defecting heavily *and* stock has been falling:
  - **play C** to prevent collapse (you’re not being nice; you’re protecting future extraction).

Concretely:
- Compute:
  - `others_steward = (ΔS_avg >= 0) or (D_rate_others <= 0.35)`
  - `collapse_risk = (ΔS_avg < 0) and (D_rate_others >= 0.50)`
- In caution zone:
  - If `others_steward`: **D**
  - Else if `collapse_risk`: **C**
  - Else: **D** (lean exploitative by default)

**Rule D — “Bait then squeeze” against conditional cooperators**
Some strategies respond to recent cooperation by cooperating. To exploit them:
- If in the last `m=2` rounds you played **C both times** and stock is now in **safe zone**, switch to **D**.
- If after you switch to D, the majority of others keep cooperating (observed via `k_last` staying low), **keep defecting** until stock re-enters caution/danger.

This creates a pattern: *invest briefly → trigger/maintain others’ cooperation → harvest via sustained defection*.

---

# 2) Edge cases (first round, last round, etc.)

### First round (no history)
- **Play D** if `capacity` is full (it is initially) and `r > 1`.
Reason: immediate gain is double; many opponents will open with C or reciprocal schemes; you exploit while stock is abundant.

### Last round (endgame)
- **Always play D** in the final round.
There is no future stock to protect; pure extraction dominates.

### Second-to-last round (penultimate)
- If stock is very low (`S < 0.25*capacity`), still **play D** (you’re near the end; the investment won’t pay back enough).
- Otherwise follow normal rules; typically you’ll defect unless in deep danger.

### Very small capacity edge case
You specified `capacity ≥ 2n`, but still:
- If `capacity` is only slightly above `2n`, the system is more fragile. Tighten danger threshold:
  - Use `danger = 0.50*capacity`, `safe = 0.75*capacity` for `capacity < 4n`.
This makes you more conservative only when the environment cannot sustain repeated D.

### If the stock hits (or nears) zero
- If `S <= stock_epsilon` (e.g., `1e-9`): actions are payoff-irrelevant (`~0`), but growth from zero is zero, so the game is dead.
- **Play D** (doesn’t matter), and accept collapse—no one can restore it.

---

# 3) Why this is exploitative (explicit mindset)

1. **Defaults to D whenever the resource can bear it.**  
   You only cooperate as an *investment* to keep future extraction possible.

2. **Free-rides on stewards.**  
   If others’ behavior keeps stock stable/high, you defect systematically and let them “pay” to maintain the commons.

3. **Weaponizes conditional cooperation.**  
   The “bait then squeeze” rule uses short cooperative streaks to elicit cooperation from reciprocity-based opponents, then converts that into extended defection while stock stays high.

4. **Endgame extraction.**  
   Always defects in the final round (and usually near the end), capturing the classic finite-horizon advantage.

---

## Pseudocode (implementable)

```python
def choose_action(t, r, S, capacity, n, history):
    # history contains past actions of all players, past stocks
    if t == r:
        return "D"

    # Parameter tweaks for fragile environments
    if capacity < 4*n:
        SAFE = 0.75 * capacity
        DANGER = 0.50 * capacity
    else:
        SAFE = 0.70 * capacity
        DANGER = 0.40 * capacity

    CAUTION_LOW = DANGER
    CAUTION_HIGH = SAFE

    # First round
    if t == 1:
        return "D"

    # Rolling stats
    W = min(10, t-1)
    D_rate_others = avg_over_last_W(rounds=W, value=fraction_of_others_playing_D)
    dS_avg = avg_over_last_W(rounds=W, value=stock_change)

    others_steward = (dS_avg >= 0) or (D_rate_others <= 0.35)
    collapse_risk = (dS_avg < 0) and (D_rate_others >= 0.50)

    # Penultimate round tweak
    if t == r-1 and S < 0.25*capacity:
        return "D"

    # Zone rules
    if S < DANGER:
        return "C"   # protect future extraction (unless last round handled above)

    if S >= SAFE:
        # bait-then-squeeze trigger
        if played_C_in_both_last_two_rounds(history) and S >= SAFE:
            return "D"
        return "D"

    # Caution zone
    if others_steward:
        return "D"
    if collapse_risk:
        return "C"
    return "D"
```

---

If you want, I can also provide:
- a version that uses a **one-step stock forecast** to choose C only when it prevents entering the danger zone next round, or
- a more explicitly “extortionate” variant that sets a target stock band (e.g., 55–75% capacity) and maximizes your D frequency subject to staying in-band.
'''

description_EXPLOITATIVE_5 = '''
### Strategy: **Predatory Harvest with Stock-Aware Extortion (PHSE)**  
Goal: **earn more than others whenever they permit it**, while **not being the one who collapses the stock unless collapse is already inevitable or endgame makes it profitable**. The strategy tries to (i) keep the resource near the “high-yield” region, (ii) **punish** any opponent who defects by switching to a regime where they do worse long-run, and (iii) **take the bigger cut (D)** whenever the group is sufficiently cooperative or whenever short-run advantage dominates.

Key facts exploited from the rules:
- In any round at stock \(S\): \(D\) yields **2×** the per-round payoff of \(C\) (since \(S/n\) vs \(S/(2n)\)).
- But \(D\) also withdraws **double** the stock share, risking future payoffs.
- The growth function is logistic; with your consumption included, you want to keep \(S\) in a region that regrows well **and** allows repeated harvesting.
- You can’t coordinate, so you must treat cooperation as something to **induce by threat**, not assume.

---

## 1. Decision Rules (Cooperate vs Defect)

We use **two modes**:  
- **Exploit mode (E):** defect to extract surplus when others are “safe”.  
- **Discipline mode (P):** cooperate to preserve stock **only** when (a) stock is at risk, or (b) you’re running a punishment plan that makes defectors worse off over time.

We infer opponents’ behavior from history:

### Definitions computed each round \(t\)
Let:
- \(S_t\) = current stock at start of round \(t\).
- \(d_{t-1}\) = number of opponents who defected in previous round (from observed actions).
- \(\hat{d}\) = exponentially-smoothed defection rate among opponents:
  \[
  \hat{d}_t = \lambda \hat{d}_{t-1} + (1-\lambda)\frac{d_{t-1}}{n-1}
  \]
  with \(\lambda=0.7\) (stable but responsive).
- “Stock safety band”:
  - **Critical:** \(S_t \le 2n\) (near the minimum scale of the action magnitudes)
  - **Low:** \(S_t \le 0.35\cdot capacity\)
  - **Healthy:** \(S_t \ge 0.6\cdot capacity\)

Maintain a punishment counter `punish_until` (round index).  

---

### Core rule
At round \(t\), choose action:

**Rule A — Endgame grab (exploitative by construction):**
- If \(t = r\): **Play D**. (No future stock to protect.)

**Rule B — If punishment is active:**
- If \(t \le punish\_until\):
  - If \(S_t \le 0.35\cdot capacity\): **Play C** (don’t crash the pool; crashing helps defectors too by ending future yields).
  - Else: **Play D** (extract while you’re “teaching” that defection triggers a harsh environment).

**Rule C — Trigger punishment when others defect:**
- If in the previous round \(d_{t-1} \ge 1\) and \(t < r\): activate punishment:
  - Set
    \[
    punish\_until = \min\left(r-1,\ t + L\right)
    \]
    where \(L = 2 + \lceil 3\hat{d}_t \rceil\).  
    (More persistent opponents ⇒ longer punishment.)

**Rule D — Normal play when not punishing:**
- If \(S_t \le 0.35\cdot capacity\): **Play C** (rebuild stock; it’s future money).
- Else if \(S_t \ge 0.6\cdot capacity\) and \(\hat{d}_t \le 0.25\): **Play D** (others are cooperative enough; take the bigger slice).
- Else if \(\hat{d}_t \ge 0.5\): **Play D** (environment is already exploitative; don’t be the sucker).
- Else: **Play C** (probe for cooperation and keep the pool productive).

This creates a system where:
- If others are mostly cooperating and stock is high, you **defect to outperform**.
- If others defect, you **immediately switch** to a regime that removes any benefit of them being the “only defector” later.
- If stock is low, you cooperate regardless of others to keep the game from becoming worthless.

---

## 2. Edge Cases

### First round (t = 1)
You don’t yet know opponents. Start with a **calibrated test for exploitable fields**:

- If \(r \ge 3\): **Play D** in round 1.  
  Rationale: if opponents are naive cooperators, you immediately gain; if they’re harsh reciprocators, you’ll see it and can shift into punishment/stock-preservation. With \(r>1\), learning has value.
- Exception: if \(capacity\) is only slightly above \(2n\) (fragile system), be more cautious:
  - If \(capacity \le 3n\): **Play C** in round 1 to avoid rapid collapse from mutual D.

### Last two rounds (t = r-1 and t = r)
- \(t=r\): always **D**.
- \(t=r-1\): almost always **D** unless stock is extremely low and you believe one round of C yields a higher \(S_r\) that you can harvest with D. Use this simple check:
  - If \(S_{r-1} \le 0.2\cdot capacity\): play **C** at \(r-1\) (try to regrow so that final-round D is worth more).
  - Else: **D**.

### Stock near zero / critical region
If \(S_t\) is very small, D and C both yield tiny payoffs, but D can prevent regrowth by keeping \(S\) too low. So:
- If \(S_t \le 2n\): **Play C** unless it’s the final round.

This is exploitative in a longer-horizon sense: you’re maximizing harvestable future stock, not “being nice.”

### Highly defecting populations
If \(\hat{d}\) stays high (e.g., >0.7) for several rounds, the resource tends to collapse anyway. Then:
- Default to **D** except when \(S_t\) is in the low/critical region (where C can “resuscitate” future extraction).

---

## 3. Why this is exploitative (explicit mindset)

1. **You defect whenever it is safe and profitable** (high stock + cooperative environment), taking **double** the per-round payoff of cooperators.
2. **You do not reward cooperation with cooperation; you reward it with exploitation**—but only when the stock can sustain it.
3. **You punish any detected defection** so opponents cannot reliably get ahead by unilateral D. This discourages “smart” opponents from trying to pick off cooperators.
4. **You cooperate mainly as an investment** to keep the pool in a state where you can continue extracting high payoffs later (and to avoid mutually assured collapse that reduces your own total winnings).

---

## Pseudocode (implementation-ready)

```python
# Parameters: n, r, capacity
lambda_ = 0.7
d_hat = 0.0
punish_until = 0

def action(t, S_t, last_actions):  # last_actions is list of opponent actions from t-1 (empty if t==1)
    global d_hat, punish_until

    # thresholds
    LOW = 0.35 * capacity
    HEALTHY = 0.60 * capacity
    CRIT = 2 * n

    # last round
    if t == r:
        return "D"

    # update defection estimate and trigger punishment (except t==1)
    if t > 1:
        d_prev = sum(1 for a in last_actions if a == "D")
        d_hat = lambda_ * d_hat + (1 - lambda_) * (d_prev / (n-1))

        if d_prev >= 1:
            L = 2 + math.ceil(3 * d_hat)
            punish_until = min(r-1, t + L)

    # first-round choice
    if t == 1:
        if capacity <= 3*n:
            return "C"
        else:
            return "D"

    # critical stock safeguard (except final round handled above)
    if S_t <= CRIT:
        return "C"

    # last-two-round logic
    if t == r-1:
        if S_t <= 0.20 * capacity:
            return "C"
        else:
            return "D"

    # punishment mode
    if t <= punish_until:
        if S_t <= LOW:
            return "C"
        else:
            return "D"

    # normal mode
    if S_t <= LOW:
        return "C"
    elif S_t >= HEALTHY and d_hat <= 0.25:
        return "D"
    elif d_hat >= 0.50:
        return "D"
    else:
        return "C"
```

---

If you want it even more exploitative (higher variance but higher upside), you can tighten the “Healthy” threshold (defect at lower \(S\)) and lengthen punishment \(L\); if you want it more robust to collapse, raise the LOW threshold (cooperate earlier) and shorten punishment to avoid starvation cycles.
'''

description_EXPLOITATIVE_6 = '''
## Strategy: **Regime-Switching Harvester (RSH)**  
Exploit cooperators by taking **D** whenever the stock is safely renewable and opponents appear non-punishing; switch to **C** only when needed to (a) keep the resource from collapsing and (b) avoid triggering/continuing punishment cycles. Near the end, cash out.

This is intentionally opportunistic: it **free-rides whenever feasible**, but “nurses” the stock just enough to keep future extraction profitable.

---

# Key idea: track two things from history
1. **Stock level trend**: are we heading toward collapse (low stock) or stable regeneration?
2. **Opponents’ responsiveness (punishment likelihood)**: do they reduce defection after we defect (they “tolerate”), or do they start defecting more (they “punish”)?

We don’t need to identify individual opponents; we only need aggregate behavior.

---

# Notation
- \(S_t\): stock at start of round \(t\)
- Let \(k_t\) = number of opponents who defected in round \(t-1\) (observable from actions)
- Let \(d_{t-1}\in\{0,1\}\): whether *we* defected in round \(t-1\)
- Let \(\Delta k_t = k_t - k_{t-1}\): change in opponent defection count (how they react over time)

---

# Decision rules (high-level)
We operate in one of two modes:

## Mode A — **Harvest (Exploit)**
Default mode. Defect to gain double per-round payoff compared to C.

We stay in Harvest as long as stock is not in the danger zone **and** opponents are not clearly punishing us for defection.

## Mode B — **Repair (De-escalate / Maintain)**
Cooperate temporarily to stabilize stock and/or coax cooperative types back, so future Harvest remains profitable.

We enter Repair if:
- stock is getting dangerously low, or
- opponents escalate defection after we defect (punishment signal), risking a collapse spiral.

---

# Concrete thresholds
These are parameter-based and scale with capacity:

- **Danger stock threshold**:  
  \[
  S_t \le S_{\text{low}} := 0.35 \cdot \text{capacity}
  \]
- **Comfort stock threshold** (safe to exploit):  
  \[
  S_t \ge S_{\text{high}} := 0.60 \cdot \text{capacity}
  \]

- **Punishment detection**: after we defect, if opponents’ total defection increases noticeably:
  - “punishing” if within the next round,
    \[
    \Delta k_{t+1} \ge \lceil (n-1)/3 \rceil
    \]
  i.e., at least about a third of opponents shifted toward D.

- **Lenient / exploitable** if after our defection, opponents don’t increase defection:
  \[
  \Delta k_{t+1} \le 0
  \]

---

# Full policy (with edge cases)

## Round 1 (probe-and-take)
**Play D.**  
Rationale: you immediately earn the higher payoff and you test whether the population punishes defection. There is no prior reputation to protect, and some strategies cooperate early; exploit them.

## Middle rounds (2 … r-1)
Maintain a mode variable `mode ∈ {HARVEST, REPAIR}`.

### Enter REPAIR if any of the following hold:
1. **Stock danger**: \(S_t \le S_{\text{low}}\).  
2. **Collapse momentum**: stock has dropped two rounds in a row and is below comfort:  
   \(S_t < S_{t-1} < S_{t-2}\) and \(S_t < S_{\text{high}}\).
3. **Punishment response**: If we defected last round and observed punishment:  
   \(d_{t-1}=1\) and \(\Delta k_t \ge \lceil (n-1)/3 \rceil\).

### In REPAIR mode, play C until one of these is true:
- Stock recovered to comfort: \(S_t \ge S_{\text{high}}\), **and**
- Opponent defection is not extreme: \(k_t \le \lceil (n-1)/2 \rceil\)

Once both conditions hold, switch back to HARVEST next round.

### In HARVEST mode, play D unless:
- Stock is near danger: \(S_t \le S_{\text{low}}\) ⇒ play C (don’t kill the goose).
- Opponents are already mostly defecting: if \(k_{t-1} \ge \lceil 2(n-1)/3 \rceil\) **and** stock is not high (\(S_t < S_{\text{high}}\)), then play C (minimize collapse, try to induce any conditional cooperators back).

Otherwise: **play D**.

## Last round (r)
**Play D always.**  
Rationale: no future to protect; cooperation only reduces your payoff.

---

# Pseudocode (implementable)

```python
def action(t, r, n, capacity, S_t, history):
    # history provides: our past actions, opponents' past actions, past stocks
    if t == 1:
        return "D"
    if t == r:
        return "D"

    S_low  = 0.35 * capacity
    S_high = 0.60 * capacity

    # Compute opponent defections last round
    k_prev = count_opponent_defections(history.actions[t-1])  # among n-1 opponents
    k_prev2 = count_opponent_defections(history.actions[t-2]) if t >= 3 else None

    we_prev_defected = (history.our_action[t-1] == "D")

    # punishment signal: jump in defections after our defection
    punished = False
    if t >= 3 and we_prev_defected:
        delta_k = k_prev - k_prev2
        punished = (delta_k >= ceil((n-1)/3))

    # stock momentum
    falling_two = False
    if t >= 3:
        falling_two = (S_t < history.stock[t-1] < history.stock[t-2])

    # determine mode transitions (mode stored in state; init HARVEST)
    mode = history.mode  # persisted
    if (S_t <= S_low) or (falling_two and S_t < S_high) or punished:
        mode = "REPAIR"

    if mode == "REPAIR":
        # exit repair only when stock recovered and defections not too high
        if (S_t >= S_high) and (k_prev <= ceil((n-1)/2)):
            mode = "HARVEST"
            history.mode = mode
            return "D"
        else:
            history.mode = mode
            return "C"

    # HARVEST mode
    if S_t <= S_low:
        history.mode = "REPAIR"
        return "C"

    if (k_prev >= ceil(2*(n-1)/3)) and (S_t < S_high):
        # others are stripping it; try to slow collapse to preserve future value
        return "C"

    return "D"
```

---

# Why this is exploitative (and robust)
- **Exploitative by default**: D is the baseline; C is only “maintenance” or “reputation repair.”
- **Punishment-aware**: If the population retaliates against defection, we temporarily cooperate to stop hemorrhaging future stock and to re-enable future exploitation.
- **Stock-aware**: It avoids self-defeating greed that drives stock to 0 (where D yields 0 forever).
- **Endgame cash-out**: Defects in the final round regardless of history.

---

# Edge cases & behavior against common opponent types
- **Always-Cooperate opponents**: you mostly play D; stock stays high because their C reduces total extraction; you harvest consistently.
- **Grim/trigger punishers**: first-round D may trigger retaliation; you detect the spike in defections and switch into REPAIR to limit collapse. You won’t fully “win” versus grim types, but you avoid the worst-case stock death spiral.
- **Always-Defect population**: you’ll often end up cooperating when stock is low to keep any chance of positive future payoffs; still defect on last round and when stock is comfortably high.
- **Mixed adaptive learners**: the probe + regime switching tends to find a profitable equilibrium: defect whenever tolerated, cooperate only enough to keep the resource productive.

If you want an even more exploitative variant, you can raise `S_low` (cooperate later) and tighten punishment detection (repair less often), at the cost of more frequent collapses against punitive fields.
'''

description_EXPLOITATIVE_7 = '''
Below is an exploitative “harvest–threat–recover” strategy designed specifically for this common-pool dynamic: it tries to (i) extract extra payoff whenever others are conservative, (ii) punish defect-heavy environments by switching to full defection (since the resource collapses anyway), and (iii) rebuild the stock only when doing so is privately profitable in expected future rounds.

---

## Intuition (why this can exploit)
- **Defection is always locally better** in a given round: D gives you \(S/n\) vs \(S/(2n)\) for C.
- The only reason to ever cooperate is **to maintain stock** so future rounds are valuable.
- Many opponents will attempt “sustainability” via cooperation. You can **free-ride** on that by defecting more often, but you must avoid triggering collapse that ruins your own future profits.
- This strategy therefore:
  1) **Defects by default** when the pool is healthy (harvest),
  2) **Cooperates just enough** to keep the pool from spiraling down (recover),
  3) **Goes full D** when others are defecting enough that recovery is unlikely (give up and extract what remains),
  4) Uses **simple, observable thresholds** based on stock and observed defection rate.

---

## Key quantities computed each round \(t\)
Let:
- \(S_t\) = current stock at start of round \(t\).
- \(d_{t-1}\) = number of opponents who defected in round \(t-1\) (observable).
- \(\hat{q}_{t-1} = d_{t-1}/(n-1)\) = last-round opponent defection rate.
- \(\bar{q}_t\) = smoothed opponent defection rate (EWMA):
  \[
  \bar{q}_t = \lambda \bar{q}_{t-1} + (1-\lambda)\hat{q}_{t-1}, \quad \lambda \in [0.6,0.8] \text{ (e.g., }0.7\text{)}
  \]

Also define stock regions (parameter-only):
- **High stock**: \(S_t \ge 0.8\cdot capacity\)
- **Mid stock**: \(0.4\cdot capacity \le S_t < 0.8\cdot capacity\)
- **Low stock**: \(S_t < 0.4\cdot capacity\)

And a “defection-heavy” threshold:
- **Defection-heavy environment** if \(\bar{q}_t \ge 0.5\) (at least half of opponents typically defect).

These are deliberately coarse and robust.

---

## Strategy: “Exploitative Adaptive Harvester (EAH)”

### 1) Decision rules (C vs D)

#### Rule A — Last round: always Defect
- If \(t = r\): play **D**.
Reason: no future to protect; D strictly dominates C in the stage payoff.

#### Rule B — If the environment is defect-heavy, defect always (strip-mine)
- If \(\bar{q}_t \ge 0.5\): play **D** regardless of stock.
Reason: recovery is unlikely if many others defect; cooperating just reduces your current payoff and doesn’t buy a sustainable future.

#### Rule C — If stock is high and environment not defect-heavy: defect to exploit
- If \(S_t \ge 0.8\cdot capacity\) and \(\bar{q}_t < 0.5\): play **D**.
Reason: you can safely take the larger share while others likely keep the pool from collapsing.

#### Rule D — If stock is low and environment not defect-heavy: cooperate to rebuild (but only as a “maintenance investment”)
- If \(S_t < 0.4\cdot capacity\) and \(\bar{q}_t < 0.5\): play **C**.
Reason: when stock is low, further depletion is dangerous; if others are relatively cooperative, rebuilding makes future exploitation possible.

#### Rule E — Mid stock: conditional “test-and-exploit”
When \(0.4\cdot capacity \le S_t < 0.8\cdot capacity\) and \(\bar{q}_t < 0.5\):
- If last round opponents were very cooperative: \(\hat{q}_{t-1} \le 0.25\), play **D** (free-ride).
- If last round opponents showed meaningful defection: \(\hat{q}_{t-1} > 0.25\), play **C** (stabilize).

This mid-region rule is where the strategy adapts most: it defects when opponents appear “safe” and cooperates when the pool risks sliding.

---

## 2) Edge cases

### First round (t = 1)
No history exists. Use an exploitative “probe”:
- If \(r \ge 3\): play **D** in round 1.
- If \(r = 2\): still play **D** (there’s almost no future to protect).
Rationale: You learn whether others will tolerate exploitation and how fast stock drops. Starting with C gives up guaranteed payoff with little informational advantage.

Initialize \(\bar{q}_1 = 0.5\) (neutral prior) so Rule B doesn’t automatically trigger; round 1 is handled explicitly.

### “Crash detected” failsafe
If the stock ever becomes extremely low, e.g. \(S_t \le 0.1\cdot capacity\):
- If \(t < r\) and \(\bar{q}_t < 0.5\): play **C** (attempt salvage).
- Else: play **D** (take what you can).
Reason: only attempt recovery if opponents are plausibly cooperative; otherwise salvage is wasted.

### Endgame (last few rounds)
Even before the last round, the value of investing in stock declines. Add a simple horizon rule:
- If \(r - t \le 1\) (i.e., last 2 rounds): play **D** unless \(S_t < 0.2\cdot capacity\) *and* \(\bar{q}_t < 0.3\) (rare case where one cooperation could preserve a meaningful last-round stock).
This keeps it exploitative near the end.

---

## 3) Why this is “exploitative” in mindset
- **Default posture is D** whenever it’s safe or profitable (high stock; cooperative opponents; endgame).
- **Cooperation is purely instrumental**: it’s used as a temporary investment to restore the resource so you can defect later at higher \(S\).
- **No “fairness” targeting**: you do not reciprocate cooperation with cooperation except when needed to keep the pool valuable for you.
- **Abandons sinking ships quickly**: if opponents defect a lot, you stop subsidizing and strip-mine.

---

## Pseudocode (implementable)

```python
# Parameters
HIGH = 0.8 * capacity
LOW  = 0.4 * capacity
CRASH = 0.1 * capacity
LAMBDA = 0.7

# State maintained by strategy
q_bar = 0.5  # smoothed opponent defection rate prior
last_qhat = None

def action(t, S_t, history):
    global q_bar, last_qhat

    # Last round: defect
    if t == r:
        return "D"

    # Update beliefs from history (from round t-1 outcomes)
    if t > 1:
        d_last = number_of_opponents_defected_in_round(t-1, history)
        qhat = d_last / (n-1)
        last_qhat = qhat
        q_bar = LAMBDA*q_bar + (1-LAMBDA)*qhat

    # First round probe
    if t == 1:
        return "D"

    # Endgame bias (last 2 rounds)
    if r - t <= 1:
        if S_t < 0.2*capacity and q_bar < 0.3:
            return "C"
        return "D"

    # Crash failsafe
    if S_t <= CRASH:
        if q_bar < 0.5:
            return "C"
        return "D"

    # If opponents defect a lot, never invest
    if q_bar >= 0.5:
        return "D"

    # Stock-based rules when environment is not defect-heavy
    if S_t >= HIGH:
        return "D"
    if S_t < LOW:
        return "C"

    # Mid stock: test-and-exploit
    if last_qhat is not None and last_qhat <= 0.25:
        return "D"
    else:
        return "C"
```

---

If you want, I can also provide: (a) a more “mathematical” version that estimates next-round stock under hypothetical C vs D to choose the better long-run action, or (b) a more aggressive variant that tries to *induce* others into cooperating by occasionally cooperating after punishment.
'''

description_EXPLOITATIVE_8 = '''
## Strategy: **State-Triggered Extortion (STE)**  
Goal: extract higher per-round payoffs than “cooperative” opponents while avoiding self-destruction against defectors by switching quickly to harsh punishment, then reopening cooperation only when it is profitable again.

Key idea:  
- When the stock is healthy, **defect** to take the larger share.  
- If opponents’ behavior (or the stock trajectory) threatens collapse, **punish** by defecting hard (you don’t sacrifice for them), but **use a state-based “safe zone”** where you sometimes cooperate to keep the resource regenerating—only enough to keep the game exploitable.

This is not “nice”: cooperation is used as a *resource management tool* to maintain a stock level that you can later harvest by defecting.

---

# 1) Decision rules (C vs D)

### Notation from history (round t-1 observed)
Let:
- \(S_t\) be current stock at start of round t.
- \(k_{t-1}\) = number of opponents who defected last round (you observe all actions).
- Defection rate last round among opponents:  
  \[
  q_{t-1} = \frac{k_{t-1}}{n-1}
  \]
- “Danger stock” threshold (state-based):  
  \[
  S_{\text{low}} = 0.35 \cdot \text{capacity}
  \]
- “Comfort stock” threshold:  
  \[
  S_{\text{high}} = 0.75 \cdot \text{capacity}
  \]

(These constants are tunable; they’re chosen to be robust across capacities and n because the growth term is strongest at mid stock and collapses near zero.)

---

## Rule A — Last round (t = r): **Always Defect**
In the final round there is no future to protect; take the maximum immediate payoff.

---

## Rule B — If stock is in danger: **Stabilize (conditional C)**
If \(S_t \le S_{\text{low}}\), you are near the region where bad play can lock the game at low stock.

- If opponents were mostly cooperating last round (meaning the stock can recover if you don’t overharvest):
  - If \(q_{t-1} \le 0.25\) (≤ 25% of opponents defected): **Cooperate (C)**.
- Otherwise (many defectors or unclear): **Defect (D)**.

Rationale: You only “help” replenish when others already show restraint, because then your cooperation is leveraged into future stock that you can later exploit. If others are defect-heavy, cooperating is just donating stock to them.

---

## Rule C — If stock is comfortable or high: **Exploit**
If \(S_t \ge S_{\text{high}}\): **Defect (D)**.

Rationale: growth is capped at capacity; when stock is high, it’s a good time to harvest aggressively. If others cooperate, you free-ride. If others defect too, the stock will crash—then you switch to Rule B stabilization only if it benefits you.

---

## Rule D — Mid-stock region: **Extort with a “one-way” trigger**
If \(S_{\text{low}} < S_t < S_{\text{high}}\), you apply a simple extortionate trigger:

- If opponents show low defection: \(q_{t-1} \le 0.10\): **Defect (D)** (milk them).
- If moderate defection: \(0.10 < q_{t-1} \le 0.40\): **Defect (D)** (don’t yield; punish by refusing to be the sucker).
- If high defection: \(q_{t-1} > 0.40\): **Defect (D)**.

So in mid region, you essentially defect unless the stock is low enough to require stabilization *and* opponents are mostly cooperating.

That may sound “too defect-heavy,” but the only times you cooperate are exactly when:
1) stock is threatened **and**
2) others are already making it recoverable.

Those are the only conditions under which cooperation buys you future exploitable surplus.

---

# 2) Edge cases

### Round 1 (no history)
Start with **Defect (D)** unless capacity is barely above the minimum sustainable bound.

Concretely:
- If \(\text{capacity} \ge 4n\): **D** (resource is big; early exploitation is safe).
- Else: **C** for round 1 (small capacity makes early collapse easier; you want to test if others cooperate while keeping stock off the floor).

### After a “collapse” (stock near zero)
If \(S_t < 0.10 \cdot \text{capacity}\):
- **Defect (D)** unless last round opponents were extremely cooperative: \(q_{t-1} = 0\), then **C**.
Reason: if it’s near dead, your cooperation only matters if everyone else is already not defecting; otherwise recovery fails and you wasted payoff.

### “Forgiveness” / re-opening after punishment
There is no apology-based forgiveness. Re-opening is purely **state-based**:
- Once \(S_t \le S_{\text{low}}\) and opponents show restraint (\(q_{t-1} \le 0.25\)), you cooperate to rebuild.
- As soon as \(S_t\) rises above \(S_{\text{low}}\), you revert to exploitation (defect), especially if it reaches \(S_{\text{high}}\).

This makes you hard to manipulate with temporary cooperation: opponents must keep cooperating while stock is low to get you to cooperate, but once the stock is healthy you harvest.

---

# 3) Why this is exploitative (and robust)

### Exploitative against cooperators / conditional cooperators
- When others play C frequently, stock tends to be maintained high or recover quickly.
- You mostly play D in high and mid stock, so you take **double** their per-round payoff whenever they cooperate (since D gives \(S/n\) vs C gives \(S/(2n)\)).
- If they are “nice” strategies (Tit-for-Tat-like), they may respond to your D by switching to D, causing collapse; your strategy then only cooperates when it is *profitable and likely to work* (low stock + mostly cooperative opponents). Many conditional cooperators will eventually resume C to rebuild, letting you exploit again.

### Robust against defect-heavy opponents
- You don’t keep cooperating into a defector field (you defect too), avoiding being the sucker.
- You rely on the stock dynamics to punish everyone—if they defect, the stock collapses and everyone’s future payoffs die. You accept that outcome rather than subsidize them.

### Robust against mixed / adaptive opponents
- The decision depends on observable defection rate and stock thresholds, not on predicting a specific opponent type.
- Opponents trying to “trick” you with occasional cooperation only get you to cooperate when stock is low and they are already cooperating a lot; the moment the resource becomes plentiful, you revert to D and extract rents.

---

# Pseudocode (implementable)

```python
def action(t, r, n, capacity, S_t, opp_actions_prev):
    # Edge: last round
    if t == r:
        return "D"

    # Round 1 (no history)
    if t == 1 or opp_actions_prev is None:
        if capacity >= 4*n:
            return "D"
        else:
            return "C"

    # Compute opponent defection rate last round
    k = sum(1 for a in opp_actions_prev if a == "D")
    q = k / (n - 1)

    S_low  = 0.35 * capacity
    S_high = 0.75 * capacity

    # Collapse zone
    if S_t < 0.10 * capacity:
        return "C" if q == 0 else "D"

    # Danger zone: only stabilize if others already cooperate a lot
    if S_t <= S_low:
        return "C" if q <= 0.25 else "D"

    # Comfortable/high: harvest
    if S_t >= S_high:
        return "D"

    # Mid zone: extort (default D)
    return "D"
```

---

If you want a slightly “more sophisticated” variant for tournaments (still exploitative) I can add a small amount of probabilistic cooperation in the danger zone calibrated to the observed defection rate, to better herd borderline strategies into keeping the stock alive—without giving up the exploitative advantage.
'''

description_EXPLOITATIVE_9 = '''
## Exploitative strategy: **State‑Gated Grim Extractor (SGGE)**

**Intent:** Harvest aggressively whenever it’s safe or opponents look exploitable; otherwise do the minimum needed to keep the resource productive. The core lever is that the stock regrows strongly when the *post-consumption* remainder stays near **capacity/2** (logistic peak). So we (i) **milk** near that sweet spot, (ii) **punish** hard when others over-extract, and (iii) **exploit** cooperative/forgiving populations by defecting more often than they do while keeping the stock from collapsing.

---

# 1) Decision rules: when to Cooperate vs Defect

### Key quantities computed each round \(t\)
Let:
- \(S_t\) = current stock at start of round \(t\)
- From last round’s observed actions, let \(d_{t-1}\) = number of opponents who defected (ignore us), and \(q_{t-1} = d_{t-1}/(n-1)\).
- Define a **defection pressure estimate** \( \hat q_t \) as an exponentially weighted average:
  \[
  \hat q_t = \lambda \hat q_{t-1} + (1-\lambda) q_{t-1},\quad \lambda\in[0,1)
  \]
  Use \(\lambda=0.7\) (fairly sticky).
- Map that into an **expected total consumption fraction** of stock this round if we cooperate/defect. Each cooperator consumes \(S/(2n)\), each defector \(S/n\).
  - Expected opponent consumption multiplier per opponent:
    \[
    \mathbb{E}[\text{opp fraction of }S] = (1-\hat q_t)\frac{1}{2n} + \hat q_t \frac{1}{n} = \frac{1+\hat q_t}{2n}
    \]
  - Expected opponents’ total fraction:
    \[
    F_{\text{opp}} = (n-1)\frac{1+\hat q_t}{2n}
    \]
  - Our fraction if we play C: \(F_C = \frac{1}{2n}\); if D: \(F_D = \frac{1}{n}\)

So expected post-consumption remaining stock:
\[
R_C = S_t \left(1 - (F_{\text{opp}} + F_C)\right),\quad
R_D = S_t \left(1 - (F_{\text{opp}} + F_D)\right)
\]

### Strategic thresholds
- **Growth-optimal remainder:** \(R^\* = \frac{\text{capacity}}{2}\) (maximizes \(2R(1-R/\text{capacity})\))
- **Safety floor:** keep the pool out of the “collapse zone”
  \[
  R_{\min} = \max\left(2n,\;0.15\cdot \text{capacity}\right)
  \]
  (uses the game’s given “meaningful stock range” up to \(2n\), and adds a % floor for larger capacities.)

### Rule summary (high level)
1. **If last round showed substantial cooperation, exploit it**: defect unless doing so risks pushing expected remainder below \(R_{\min}\).
2. **If the population is defect-heavy, conserve to keep the pool alive**, but only enough to maintain future extraction opportunities.
3. **If we detect a cooperator majority and stock is healthy, bias hard toward D** (one-step advantage each round).
4. **If stock is in danger, play C** (even if others defect) because preserving stock is the only way to keep future payoffs nonzero.

### Concrete decision rule
At round \(t\) (with \(S_t\), \(\hat q_t\)):

**A. Emergency preservation**
- If \(S_t \le R_{\min}\): play **C**.
  - Rationale: at low stock, even D yields tiny immediate gain and increases chance of hitting 0; C is the best shot at regrowth.

**B. Otherwise, choose the more exploitative action subject to sustainability**
- If \(R_D \ge R_{\min}\): play **D**.  
  (Defect whenever it is not expected to push the system into the danger zone.)
- Else: play **C**.

**C. Extra exploitation when opponents are cooperative and stock is high**
If \(S_t \ge 0.6\cdot \text{capacity}\) and \(\hat q_t \le 0.35\), then even stronger:
- Play **D** (unless \(R_D < R_{\min}\), in which case C).

This makes you “free-ride” when it’s most profitable and least risky.

---

# 2) Edge cases and round-specific handling

### First round (no history)
Assume opponents are more cooperative than not, but don’t risk immediate collapse.
- Initialize \(\hat q_1 = 0.25\).
- Apply the main rule. With \(S_1=\text{capacity}\), this almost always yields **D** (because \(R_D\) will remain comfortably above \(R_{\min}\) unless \(n\) is very small and opponents are expected to all defect).

### Last round
There is no future to protect.
- If \(t=r\): play **D** always.
  - Only exception: none. Even if it collapses, who cares.

### Last two rounds (optional but exploitative)
- If \(t=r-1\): play **D** unless \(S_t\) is already ~0 (doesn’t matter) or you want to eke a tiny bit more in final round by avoiding collapse. For exploitative stance: still **D** (simple and mean).

### After a collapse (stock hits 0)
- If \(S_t = 0\): action doesn’t change payoff that round (both give 0). Choose **C** to maximize chance others also restrain in the first regrowth-possible cycle (though growth at 0 is 0; you need a positive remainder, so the key is preventing future total consumption when stock becomes positive again). Practically:
  - If \(S_t\) is very small (\(\le R_{\min}\)): **C** per emergency rule.

---

# 3) Why this is exploitative and robust

### Exploitative features
- **Defect-by-default subject to a sustainability constraint:** You take the larger share whenever it won’t likely kill the goose.
- **Targets cooperators:** When opponents are cooperative (\(\hat q\) low) and stock is healthy, you defect more, extracting roughly **2×** the per-round payoff of a cooperator at the same stock.
- **No “fairness” reciprocity:** You do not match cooperation; you only cooperate instrumentally to keep the pool productive.

### Robustness features
- **Adaptive to opponent mix:** \(\hat q_t\) tracks whether the environment is cooperative or defect-heavy.
- **State-aware:** Decisions are driven by stock and predicted remainder, not fragile pattern-matching.
- **Fails gracefully in all-D worlds:** If everyone defects, the pool collapses; SGGE’s emergency C can’t fully stop it alone, but it avoids making things worse when stock is low and maximizes any regrowth chances.
- **Avoids self-sabotage in mixed worlds:** The \(R_{\min}\) guardrail prevents over-extraction when the pool is near a tipping point.

---

## Pseudocode (implementation-ready)

```pseudo
params: n, r, capacity
constants:
  lambda = 0.7
  Rmin = max(2*n, 0.15*capacity)

state:
  qhat = 0.25   # initial belief about opponent defection rate

for t in 1..r:
  observe current stock S

  if t == r:
     action = D
     play(action)
     continue

  if t > 1:
     q_last = (#opponents who played D last round) / (n-1)
     qhat = lambda*qhat + (1-lambda)*q_last

  # expected opponent consumption fraction of S:
  Fopp = (n-1) * (1 + qhat) / (2*n)
  FC = 1/(2*n)
  FD = 1/n

  RC = S * (1 - (Fopp + FC))
  RD = S * (1 - (Fopp + FD))

  if S <= Rmin:
     action = C
  else if RD >= Rmin:
     action = D
  else:
     action = C

  # extra exploit bias (mostly redundant but clarifies intent):
  if S >= 0.6*capacity and qhat <= 0.35 and RD >= Rmin and t < r:
     action = D

  play(action)
```

---

If you want to make it *even more exploitative*, you can lower \(R_{\min}\) (e.g., to \(0.10\cdot \text{capacity}\)) to defect closer to the cliff; if you want more long-run extraction stability, raise it (e.g., \(0.20\cdot \text{capacity}\)).
'''

description_EXPLOITATIVE_10 = '''
## Strategy: **Stock-Leash Exploiter (SLE)**  
Core idea: keep the resource in a **high-stock “sweet spot”** (near capacity) because your *absolute* gains scale with current stock. Use cooperation as an *investment* to keep stock high when others are mostly cooperative; switch to defection to **harvest extra payoff** whenever opponents can sustain stock (or whenever you can safely grab before endgame). If opponents are destructive, stop investing and defect (or defect until collapse, then take whatever remains).

This is exploitative because it:
- **Free-rides** on cooperative groups by defecting when the stock can tolerate it.
- **Punishes** defect-heavy groups by refusing to subsidize them with cooperation.
- **End-games** aggressively (defect) because future stock is irrelevant.

---

# 1) Decision rules (C vs D)

### Quantities you track each round
At start of round *t*, you observe current stock `S_t`.

From last round’s observed actions, compute:
- `k_{t-1}` = number of defectors among the *other* `n-1` players last round.
- `dRate_{t-1} = k_{t-1} / (n-1)` (0 to 1)

Also compute two important stock thresholds (depend only on parameters and current S):

**A. “Collapse-if-I-defect” safety threshold given others’ expected defections**  
If in round t you defect, total consumption fraction of stock is:
- each cooperator consumes `S/(2n)`
- each defector consumes `S/n`

If you expect `k` other defectors this round, then:
- total consumption = `S * [ (n-(k+1))*(1/(2n)) + (k+1)*(1/n) ]`
- remaining stock after consumption:
  \[
  S_{\text{rem}} = S \cdot \left(1 - \frac{n-(k+1)}{2n} - \frac{k+1}{n}\right)
               = S \cdot \frac{n-(k+1)}{2n}
  \]
So if `k = n-1` (everyone defects), `S_rem = 0` (immediate collapse).

We’ll use this to decide whether defecting is “safe” (keeps some stock alive) or is just a final grab.

**B. “Target stock zone”**  
With logistic growth `2*S_rem*(1 - S_rem/capacity)`, growth is strong when `S_rem` is around `capacity/2`, and it restores to capacity when `S_rem = capacity/2`.  
So we want to keep post-consumption `S_rem` not too low—ideally **≥ capacity/2** when feasible, or at least not near 0.

---

## Main policy (high-level)
### Rule 0: Last-round rule (pure exploitation)
- **If `t == r`: play D.**  
No future to protect.

### Rule 1: First round probing (identify whether there’s “profit to exploit”)
- **If `t == 1`: play D.**  
Rationale: (i) you immediately get double the cooperative payoff at maximum stock; (ii) you learn whether the field collapses stock or sustains it.

### Rule 2: Maintain a “leash” on stock using a cooperation trigger
After round 1, do this each round `t < r`:

Let `k = k_{t-1}` (others’ defect count last round; use as prediction).
Compute predicted remaining stock if you defect now:
\[
S_{\text{rem}}^{D} = S_t \cdot \frac{n-(k+1)}{2n}
\]
Compute predicted remaining stock if you cooperate now (then expected defectors are just `k`):
\[
S_{\text{rem}}^{C} = S_t \cdot \frac{n-k}{2n}
\]

Now choose action:

### **Play D (exploit) if all are true:**
1. **Opponents are not mostly defecting:** `dRate_{t-1} ≤ 0.5`  
   (At least half of opponents cooperated last round; there’s something to free-ride on.)
2. **Stock is high enough to safely harvest:** `S_t ≥ 0.6 * capacity`  
   (High stock makes defection especially lucrative and less risky.)
3. **Defection doesn’t predict near-collapse:** `S_rem^D ≥ 0.25 * capacity`  
   (If your defection would drive remaining stock too low, you refrain unless near end.)

If these hold, **defect** to take the larger share while others sustain the pool.

### **Otherwise play C (invest/restore) if both are true:**
1. **There is evidence cooperation can work:** `dRate_{t-1} < 1.0`  
   (If literally everyone else defects, your cooperation is wasted.)
2. **Stock is in the danger zone:** `S_t < 0.6 * capacity` **or** `S_rem^D < 0.25*capacity`  
   (You cooperate to rebuild stock so you can exploit later.)

### **Otherwise (hopeless environment): play D**
If opponents are highly defecting (`dRate` close to 1) or the stock is already headed down and others aren’t helping, **defect** and take what you can.

---

# 2) Edge cases & special handling

### Endgame escalation (strong exploitation near the end)
Even before the last round, future matters less as you approach round r.

Define `H = 2` (horizon).  
- **If `t >= r - H`: play D unless stock is extremely low and you observed substantial cooperation** (e.g., `S_t < 0.3*capacity` and `dRate_{t-1} ≤ 0.25`), in which case play C once to prop up stock for a final defection.  
This is a “pump-and-dump” endgame: one possible repair round, then harvest.

### If stock hits (or nearly hits) zero
- **If `S_t <= ε` (tiny): action is irrelevant; play D**.  
No stock to protect; also signals unwillingness to subsidize recovery.

### If capacity is very large relative to 2n
Doesn’t change the logic; all thresholds are expressed as fractions of capacity, so it scales.

### If opponents are chaotic (flip-flopping)
The “use last-round defect count as prediction” naturally adapts; additionally, you can smooth it:
- Track `avgDefectRate` over last 3 rounds; use that instead of `dRate_{t-1}` if you want more robustness.

---

# 3) Why this is exploitative (and robust)

### Exploitative against cooperators / conditional cooperators
- When others mostly cooperate and stock is high, you **defect repeatedly** because:
  - Your payoff is always `S/n` instead of `S/(2n)`—a strict per-round advantage.
  - The pool often remains recoverable due to logistic growth and others’ restraint.
- You only cooperate when stock drops enough that continued exploitation would kill the golden goose.

### Not easily suckered by defectors
- If others defect heavily, SLE stops “investing” and **defects too**, avoiding being the lone cooperator propping up the pool.
- This prevents persistent exploitation *of you*.

### Adaptive to mixed populations
- In many tournaments, you’ll face a mix of types. SLE uses stock + observed defection rate to decide when to harvest vs rebuild, which works without assuming norms, communication, or stable patterns.

---

# Pseudocode (implementable)

```python
def choose_action(t, r, n, capacity, S_t, history_actions):
    # history_actions[t-1] gives list of all players actions last round (including you)
    # Assume we can count opponents' defectors last round.
    if t == r:
        return "D"

    if t == 1:
        return "D"

    # Count opponent defectors last round
    last = history_actions[t-1]
    k = count_opponent_defectors(last)   # 0..(n-1)
    dRate = k / (n-1)

    # Predict remaining stock after consumption if we choose D or C
    Srem_D = S_t * (n - (k + 1)) / (2 * n)
    Srem_C = S_t * (n - k) / (2 * n)

    high_stock = (S_t >= 0.6 * capacity)
    safe_if_defect = (Srem_D >= 0.25 * capacity)
    opponents_mostly_coop = (dRate <= 0.5)

    # Endgame escalation: last 2 rounds before final
    if t >= r - 2:
        if S_t < 0.3 * capacity and dRate <= 0.25:
            return "C"  # one repair/pump round
        return "D"

    # Main logic
    if opponents_mostly_coop and high_stock and safe_if_defect:
        return "D"  # exploit

    # If environment still salvageable and stock is getting risky, invest
    if dRate < 1.0 and (not high_stock or not safe_if_defect):
        return "C"

    # Otherwise, don't subsidize a bad group
    return "D"
```

---

If you want this to be even more exploitative, you can lower the “opponents mostly coop” threshold (e.g., defect when `dRate ≤ 0.7`) and lower the safety threshold slightly—this increases short-run gains but raises the chance of collapsing the pool (which can reduce total gains over many rounds).
'''

description_EXPLOITATIVE_11 = '''
Below is an **exploitative, stateful “harvest–test–punish” strategy**. It tries to (i) keep the stock high enough to sustain repeated extraction, (ii) **take the bigger share whenever opponents allow it**, and (iii) **never be the sucker** against defect-heavy opponents. It uses only parameters, current stock, and full history.

---

## Intuition (what we’re exploiting)

- If enough players cooperate, the stock can rebound toward `capacity`, creating a renewable stream of value.
- Defection gives **2×** the per-round payoff of cooperation at the same stock (`S/n` vs `S/(2n)`).
- So the best exploit is: **keep the resource alive primarily using others’ restraint, then defect to harvest more**, while switching to defection immediately if opponents won’t sustain the resource.

The strategy therefore:
1. **Probes** whether the population will sustain the stock.
2. If they will, it **defects most of the time** (harvesting).
3. If they won’t, it **defects always** (salvage mode).
4. Uses **sharp punishment** to deter “taking too much when the stock is fragile,” but returns quickly to harvesting once the system is stable again.

---

## Key computed signals from history

Let round `t` have starting stock `S_t`.

For each opponent `j`, define:
- `a_{j,t} ∈ {C,D}`
- **Recent defection rate** over a window `W` (e.g., `W=5` or `min(5, t-1)`):  
  `dr_j = (# of D by j in last W rounds) / W`

Define:
- `Dcount_t = number of opponents who played D in round t`
- `Davg = average Dcount over last W rounds`
- `S_trend = S_t - S_{t-1}` (if `t>1`)
- `S_low = capacity * 0.35`  (resource is “fragile”)
- `S_high = capacity * 0.75` (resource is “healthy”)

Also compute a simple “sustainability” estimate:
- Let total consumption in round t be:  
  `cons_t = S_t * ( (#C_t)/(2n) + (#D_t)/n )`  
  where `#C_t + #D_t = n`.  
- Remaining stock: `R_t = S_t - cons_t`
- Growth: `g(R_t)=2*R_t*(1 - R_t/capacity)`
- Next stock predicted: `Ŝ_{t+1} = min(R_t + g(R_t), capacity)`
- Define “group sustains” if `Ŝ_{t+1} ≥ S_t` (non-declining).

You can compute this from observed actions.

---

## Strategy: “Exploit-Until-Fragile (EUF)”

### Parameters (fixed from game parameters)
- `W = min(5, r)` (history window)
- Thresholds:  
  `S_low = 0.35*capacity`  
  `S_high = 0.75*capacity`
- “Defection tolerance” (how many defectors we can tolerate while still trying to keep stock alive):  
  `D_tol = floor((n-1)/3)`  
  (if more than ~1/3 of others defect persistently, assume cooperation is not sustainable)

---

## 1) Decision rules (C vs D)

### Rule A — Last round: always defect
- If `t == r`: play **D**.
Rationale: no future to protect; pure exploitation.

---

### Rule B — Collapse / salvage mode: if stock is very low, defect
- If `S_t ≤ S_low`: play **D**.
Rationale: at low stock, cooperation yields little and can be exploited; also your single C rarely rescues the system if others are defecting.

(If you want an even harder exploit: also play D whenever `S_t < S_low` regardless of anything else.)

---

### Rule C — Early probe (round 1–2): cooperate once, then harvest if safe
- If `t == 1`: play **C**.  
- If `t == 2`:
  - If `Dcount_1 ≤ D_tol` **and** `S_2 ≥ S_1` (stock didn’t drop): play **D** (begin harvesting).
  - Else: play **D** (salvage; opponents not cooperative enough anyway).

Why cooperate at `t=1` at all? It’s a cheap test: you learn who defects, and if opponents are the type to sustain the pool, you can start exploiting them from round 2 onward.

---

### Rule D — Main phase (t = 3 … r-1): “Harvest when healthy, punish when fragile”
For `t ∈ [3, r-1]`:

1. **Detect an unsustainable environment**  
   If either is true, switch to **Always D** for the rest of the game (irreversible):
   - `Davg > D_tol`  (too many defectors recently), OR
   - Stock is trending down while not low: `S_t < S_{t-1}` and `S_t < S_high` for 2 consecutive rounds.

   **Action:** play **D** and set `mode = SALVAGE` (always D thereafter).

2. **If not salvage: choose between exploit and brief “resource maintenance”**
   - If `S_t ≥ S_high` and `Davg ≤ D_tol`: play **D** (harvest).
   - Else (stock is mid-range or fragile but not collapsed):
     - If last round had “too much defection” (e.g., `Dcount_{t-1} > D_tol`): play **D** (punish; don’t pay to fix what others broke).
     - Otherwise: play **C** (maintenance) **only until stock returns to healthy**, then resume harvesting.

In short:
- **Healthy stock + sufficiently cooperative group → defect (exploit).**
- **Mid stock + group mostly cooperative → cooperate just enough to keep it from slipping.**
- **Any sign of too many defectors or persistent decline → defect (punish/salvage).**

---

## 2) Edge cases

### First round
- Play **C** (probe).

### Second round
- Usually shift to **D** unless the environment is clearly hostile (in which case also D). Net effect: you almost always start exploiting by round 2.

### Last round
- Always **D**.

### Very small `r`
- If `r == 2`: play `C` then `D`.  
- If `r == 3`: play `C`, then likely `D`, and `D` last round.

### If `capacity` is barely above `2n`
- The stock thresholds still scale with `capacity`. This tends to make `S_low` and `S_high` smaller in absolute terms, but the rules still behave: harvest when high, salvage when low.

---

## 3) Why this is exploitative (explicitly)

- **It defects whenever it can do so without triggering collapse**, extracting 2× the per-round payoff of cooperators at the same stock.
- It uses cooperation **instrumentally**:
  - only as a **probe** (round 1), and
  - as minimal **maintenance** to keep the resource renewable *when others are mostly cooperating* (so you can keep exploiting later).
- It **refuses to subsidize** defect-heavy groups: if others defect too much, you immediately go to **permanent defection** (salvage), preventing opponents from gaining by alternating or by dragging you into a “repair” role.
- The “punish when fragile” behavior ensures that if opponents try to increase their defection while the stock is at risk, they get met with defection rather than forgiveness—reducing their ability to profit from short-run grabs.

---

## Pseudocode sketch

```pseudo
mode = "NORMAL"
W = min(5, r)
S_low  = 0.35 * capacity
S_high = 0.75 * capacity
D_tol = floor((n-1)/3)

function decide(t, S_t, history):
    if t == r:
        return D

    if mode == "SALVAGE":
        return D

    if S_t <= S_low:
        return D

    if t == 1:
        return C

    # compute recent stats
    Davg = avg_{k=t-W .. t-1}(Dcount_k)   # from observed actions
    # optional: detect persistent decline
    decline2 = (t>=3 and S_t < S_{t-1} and S_{t-1} < S_{t-2} and S_t < S_high)

    if (Davg > D_tol) or decline2:
        mode = "SALVAGE"
        return D

    # NORMAL mode
    if S_t >= S_high and Davg <= D_tol:
        return D  # harvest

    # mid stock: maintenance only if others are behaving
    if Dcount_{t-1} > D_tol:
        return D  # punish
    else:
        return C  # minimal maintenance
```

---

If you want, I can also provide:
- a more “mathematically tuned” version that computes the **exact maximum defection frequency** you can sustain given observed opponent behavior (instead of using `S_low/S_high` heuristics), or
- a variant that targets and exploits a **single most-cooperative opponent profile** (useful if some strategies condition on your behavior).
'''

description_EXPLOITATIVE_12 = '''
Below is an **exploitative, stateful “harvest–discipline” strategy**. It tries to (i) **take D whenever it expects the stock will stay high anyway** (because others are conserving), (ii) **punish/deny profitability** when others defect (so they can’t keep profiting from you), and (iii) **avoid being the sucker** in the last part of the horizon. It adapts using only parameters, the current stock, and the full history.

---

## Core idea (why this exploits)
- When stock is high, your per-round gain from D is exactly **2×** your gain from C (since \(S/n\) vs \(S/(2n)\)).  
- But repeated D by many players can crash the stock to 0, killing future payoffs.  
- So the exploitative posture is:
  1. **Free-ride with D** when it looks like others are keeping the resource healthy.
  2. **Switch to C (or keep stock alive)** only when needed to preserve future extraction value.
  3. **Retaliate hard** against defectors so they do not get an easy “defect-while-you-cooperate” rent.

This is not “nice”; it is **conditional conservation** with **aggressive extraction** when safe.

---

## Observable quantities to compute each round
At round \(t\) with current stock \(S_t\), from last round actions:

- \(k_{t-1}\): number of defectors last round (from history).
- **Defection rate**: \(d_{t-1} = k_{t-1}/n\).
- Maintain an **exponentially weighted moving average (EWMA)** of defection:
  \[
  \bar d_t = \lambda \bar d_{t-1} + (1-\lambda)d_{t-1}, \quad \lambda \in [0.6,0.9]
  \]
  (Interpretation: “how defect-y the population seems lately.”)

Also define a **critical stock floor** to avoid collapse:
- \(S_{\text{floor}} = 2n\).  
  (Given your constraint that capacity ≥ 2n and stock is bounded, keeping above this floor is a conservative “don’t flirt with zero” buffer.)

And a **late-game window**:
- Let \(L = \max(2, \lceil r/5 \rceil)\).  
  Final \(L\) rounds are “endgame” where conserving for the future matters less.

---

## Strategy overview
The strategy has three modes:

1. **Probe/Exploit mode**: default. Try to defect if others look cooperative and stock is healthy.
2. **Discipline mode**: if defection becomes common, do not “feed” defectors—also defect (deny them the advantage of your C), and allow stock to drop if necessary.
3. **Conservation mode**: if stock gets dangerously low, cooperate to rebuild *only when it benefits you* (i.e., when there’s enough horizon left to re-harvest).

It transitions based on stock and the estimated defection climate.

---

## Decision rules (C vs D)

### Rule 0: First round (no history)
- **Play D** in round 1.
  - Exploitative rationale: you lose nothing reputationally (no communication), and you immediately test whether the room collapses stock or supports replenishment.

### Rule 1: Last-round logic (pure endgame extraction)
- If \(t = r\): **Play D**.
  - No future to protect.

### Rule 2: Late-game window (final L rounds)
- If \(t > r-L\):  
  - If stock is not near-collapse: **Play D**.  
  - Only play C if stock is extremely low and you think C yields more immediate expected value due to keeping stock nonzero next round—but since you won’t see “next round” near the end, in practice:
    - If \(t=r\): D (already handled)
    - If \(t=r-1\): usually still **D** unless your implementation simulates that choosing C now materially increases \(S_{r}\) enough to outweigh the factor-2 immediate gain from D. (Most of the time, still D.)

**Simplified tournament-ready late-game rule**:
- For all \(t \ge r-L+1\): **D**.

### Rule 3: Stock safety override (avoid accidental total crash when it still matters)
- If \(S_t \le S_{\text{floor}}\) and \(t \le r-L\): **Play C**.
  - Rationale: if stock is very low and there’s still runway, you want it to regrow so you can later defect-profit. This is “invest-to-exploit,” not altruism.

### Rule 4: Exploit when others are cooperative (free-ride)
- If \(S_t > S_{\text{floor}}\) and \(t \le r-L\) and \(\bar d_t < \theta_{\text{low}}\): **Play D**  
  where \(\theta_{\text{low}}\) is small, e.g. 0.25.
  - Meaning: if fewer than ~25% of actions are defection on average, the group is conserving enough that you can harvest aggressively.

### Rule 5: Discipline when defection is common (deny sucker payoffs)
- If \(S_t > S_{\text{floor}}\) and \(t \le r-L\) and \(\bar d_t > \theta_{\text{high}}\): **Play D**  
  where \(\theta_{\text{high}}\) e.g. 0.45–0.55.
  - Rationale: when many defect, cooperating just hands them extra payoff while still risking collapse. So you defect too and accept the tragedy-of-the-commons outcome rather than being exploited.

### Rule 6: The “middle band” (strategic conservation to keep the resource harvestable)
When \(\theta_{\text{low}} \le \bar d_t \le \theta_{\text{high}}\) and \(t \le r-L\):
- Use a **stock-dependent mixed trigger**:
  - If \(S_t \ge \alpha \cdot \text{capacity}\): **Play D**
  - Else: **Play C**
  with \(\alpha\) around 0.6–0.75.

Interpretation:  
- If stock is still high, keep extracting (D).  
- If stock has slipped below a healthy fraction of capacity, switch to C to rebuild so you can later return to D.

---

## Pseudocode (implementation-friendly)

```pseudo
params: n, r, capacity
constants:
  S_floor = 2*n
  L = max(2, ceil(r/5))
  lambda = 0.75
  theta_low = 0.25
  theta_high = 0.50
  alpha = 0.70

state variables:
  d_bar = 0.0   // EWMA defection rate, initialized pessimistically or neutral

function act(t, S_t, history):
  if t == 1:
    return D

  // update d_bar from last round
  k = number_of_defectors_in_round(t-1, history)
  d = k / n
  d_bar = lambda*d_bar + (1-lambda)*d

  // Endgame extraction
  if t >= r - L + 1:
    return D
  if t == r:
    return D

  // Safety: rebuild if dangerously low stock (only when future exists)
  if S_t <= S_floor:
    return C

  // Exploit cooperative populations
  if d_bar < theta_low:
    return D

  // Discipline defect-heavy populations
  if d_bar > theta_high:
    return D

  // Middle band: manage stock to keep future D profitable
  if S_t >= alpha * capacity:
    return D
  else:
    return C
```

---

## Edge cases & robustness notes
- **If others always cooperate**: you mostly defect, extracting 2× each round while stock often returns toward capacity due to logistic growth. This is exactly the exploit.
- **If others always defect**: you defect too, preventing being the lone cooperator funding their higher payoffs. Stock collapses, but you avoid relative exploitation.
- **If others use conditional cooperation/punishment (e.g., Tit-for-Tat-like)**:  
  - Your EWMA thresholds make you defect early, but if that causes widespread defection and stock drops, the safety override (C when \(S\) low and horizon remains) can “reset” the resource so you can again profit later.  
  - Against harsh punishers, you will still often end up defecting (since \(\bar d\) rises), but you won’t keep donating.
- **Small capacity / tight dynamics**: the explicit stock floor \(2n\) prevents you from mindlessly defecting into immediate zero when there’s still time value in recovery.
- **Very short games**: the endgame window \(L\) scales with r; for small r you still default to D quickly, matching the exploitative stance.

---

## Exploitative alignment (explicit)
- The default bias is **D** whenever it’s plausibly sustainable or whenever others are defecting (so you aren’t the sucker).
- **C is only chosen instrumentally**: as a temporary investment to rebuild stock so you can defect-profit later, and only when there’s enough remaining horizon to recoup that investment.
- In the final portion of the game, the strategy **shifts to pure extraction** (D), because future stock has little/no value.

If you want, I can also provide a more aggressive variant that uses a **one-step lookahead simulation** (using the known growth equation) to choose C vs D by maximizing estimated remaining-game value given inferred opponent defection rate. That typically improves exploitation in mixed populations.
'''

description_EXPLOITATIVE_13 = '''
## Strategy: **Regenerative Grim-Trigger with Opportunistic Harvest (RGTOH)**  
Exploit the fact that (i) defecting always gives you 2× the per-round payoff of cooperating at the same stock, and (ii) the stock has strong logistic regrowth when the *post-consumption remaining stock* is near `capacity/2`. So you want to:  
- **Induce/maintain high stock** by cooperating when the group is “not too extractive.”  
- **Harvest (defect) when others keep stock high anyway** (free-ride).  
- **Punish extraction hard** to prevent being milked while you cooperate.  
- **Always defect near the end** (finite horizon).

This is an exploitative, state-aware “cooperate to farm, defect to harvest” policy with a credible punishment regime.

---

## Key quantities computed from history/state
Let in round `t` the observed stock be `S_t`.

From the previous round’s action profile (after it resolves), compute:
- `kD_{t-1}` = number of opponents who defected in round `t-1` (you observe actions).
- `D_rate_{t-1} = kD_{t-1} / (n-1)`.

Also define a **stock region** (using only parameters and current state):
- `S_high = 0.75 * capacity`
- `S_mid  = 0.50 * capacity`
- `S_low  = 0.25 * capacity`

These thresholds are robust across capacities and n.

---

## Decision rules (cooperate vs defect)

### Phase variable
Maintain an internal mode:
- `mode ∈ {FARM, HARVEST, PUNISH}`
- Also maintain `punish_remaining` (integer countdown).

### Baseline idea
- **FARM**: cooperate to keep stock high (so future harvest is valuable).
- **HARVEST**: defect to extract extra payoff while stock remains high.
- **PUNISH**: defect for multiple rounds to make exploitation unprofitable / avoid being the “sucker.”

### Rule 0: Last-round and endgame
- If `t == r`: **Defect (D)**.
- If `t == r-1` and `S_t >= S_mid`: **Defect (D)** (penultimate-round harvest).
- If `t >= r-2` and `S_t < S_mid`: still **Defect (D)** (nothing left worth farming).

Reason: with no future beyond the horizon, there is no value in sustaining stock.

---

## Rule 1: Round 1 (cold start)
Start in `FARM`, but **probe**:
- If `r >= 4`: play **C** in round 1.
- If `r == 2 or r == 3`: play **D** in round 1 (short horizon → immediate extraction dominates).

Rationale: In longer games you want to discover whether opponents will keep the pool viable. In very short games, exploit immediately.

---

## Rule 2: Trigger to punishment (anti-exploitation)
After observing round `t-1`:

Enter `PUNISH` if **either**:
1) Opponent defection is “meaningful”:
   - `D_rate_{t-1} >= 0.5`  (at least half of opponents defected), **or**
2) Stock is being driven down:
   - `S_t <= S_low` **and** `D_rate_{t-1} > 0`.

When triggered:
- Set `punish_remaining = 2 + ceil((r - t)/4)`  
  (a punishment that’s longer earlier in the game, shorter later)
- Set `mode = PUNISH`

**Action in PUNISH:** always **D** while `punish_remaining > 0`.

Why this is exploitative: if others defect while you cooperate, you stop subsidizing them immediately and you also push the game toward the low-stock path where their future gains vanish.

---

## Rule 3: Exiting punishment (conditional forgiveness)
While in `PUNISH`:
- Decrement `punish_remaining` each round.
- When `punish_remaining == 0`:
  - If last observed `D_rate_{t-1} <= 0.25` (most opponents cooperated recently), switch to `FARM`.
  - Else stay in `PUNISH` with `punish_remaining = 1` (keep defecting until they back off).

This makes you hard to exploit but not permanently locked if opponents shift.

---

## Rule 4: Farming vs harvesting when not punishing
When `mode ∈ {FARM, HARVEST}` and not in endgame:

### 4A) If stock is low or fragile, farm
- If `S_t < S_mid`: play **C** and set `mode = FARM`.

Reason: regrowth is maximized around `capacity/2`, but if you’re below mid, extra extraction risks spiraling toward zero.

### 4B) If opponents are mostly cooperating, harvest
- If `S_t >= S_high` **and** `D_rate_{t-1} <= 0.25`: play **D** and set `mode = HARVEST`.

Exploit: you defect when the pool is healthy and opponents are “providing” restraint, so you take the larger slice without collapsing the system immediately.

### 4C) If opponents are mixed/uncertain, farm (don’t be the only cooperator)
- If `S_mid <= S_t < S_high`:
  - If `D_rate_{t-1} == 0`: play **D** (safe free-ride; all others cooperated last round).
  - Else if `D_rate_{t-1} <= 0.25`: play **C** (keep system stable; avoid tipping into collapse).
  - Else: play **D** (they’re already extracting; don’t be the sucker).

---

## Summary in compact pseudocode
```pseudo
Initialize mode = FARM
punish_remaining = 0

For t = 1..r:
  observe current stock S_t

  if t == r: return D
  if t >= r-2: return D   // strong endgame harvest

  if t == 1:
     if r >= 4: return C else return D

  // compute from previous round
  D_rate = (#opponents who played D in t-1) / (n-1)

  // punishment logic
  if mode != PUNISH:
     if D_rate >= 0.5 or (S_t <= 0.25*capacity and D_rate > 0):
        mode = PUNISH
        punish_remaining = 2 + ceil((r - t)/4)

  if mode == PUNISH:
     punish_remaining -= 1
     if punish_remaining <= 0:
        if D_rate <= 0.25: mode = FARM
        else { mode = PUNISH; punish_remaining = 1 }
     return D

  // not punishing: FARM/HARVEST logic
  if S_t < 0.5*capacity:
     mode = FARM
     return C

  if S_t >= 0.75*capacity and D_rate <= 0.25:
     mode = HARVEST
     return D

  // mid region
  if D_rate == 0: return D
  if D_rate <= 0.25: return C
  return D
```

---

## Why this is exploitative and robust
- **Exploitative vs cooperators:** When others keep defection low, you defect at high stock and especially near the end, capturing 2× payoff in those rounds.
- **Not exploitable by defectors:** The moment defection becomes common, you switch to sustained defection (punish), avoiding being the lone cooperator funding others.
- **State-aware:** Uses stock thresholds so you don’t accidentally collapse the pool when it’s already fragile; farms when necessary to restore harvestable stock.
- **Works against many behavior types:**  
  - Always-defect: you quickly punish and then defect too (minimizes losses).  
  - Tit-for-tat-ish: your punishment is legible; you can return to farming once they cooperate.  
  - Random/mixed: you default to safe choices (farm when low stock; otherwise defect unless cooperation is strong).

If you want, I can also provide a more aggressive variant that defects more often in the mid-stock region (higher immediate payoff, higher collapse risk) depending on how “winner-take-most” the tournament scoring is.
'''

description_EXPLOITATIVE_14 = '''
Below is an **exploit-first, safety-second** strategy for the Common Pool Resource (CPR) game. It is designed to (i) take the high action (D) whenever it is profitable *and* not immediately self-destructive, (ii) switch into “resource management” only when needed to keep the stock in a high-yield region, and (iii) punish/coax opponents into doing the conserving for you.

---

## Core idea (what you’re exploiting)

- Your one-shot incentive is always **D dominates C** in the current round: you get twice as much from the same stock \(S\).
- The only reason to ever play **C** is **instrumental**: keeping stock from collapsing so that future rounds remain lucrative.
- If others are willing to conserve (play C), you want to **free-ride** (play D) while the stock stays healthy.
- If others over-defect, you want to **minimally cooperate** to prevent total collapse—but only when doing so yields higher total remaining payoff for you than continued defection.

So: **Defect by default; cooperate only as an investment to keep the stock near capacity and to reset the “goose that lays golden eggs.”**

---

## Key state estimate from history

In each past round \(t-1\), you observe stock \(S_{t-1}\) and the next stock \(S_t\). From that you can infer how many others defected.

Let:
- Your action \(a_{t-1} \in \{C,D\}\)
- Your consumption was \(S_{t-1}/(2n)\) if C else \(S_{t-1}/n\).
- Let \(S^{rem}_{t-1}\) be stock after total consumption, before growth.
- Growth rule: \(S_t = \min(S^{rem} + 2S^{rem}(1 - S^{rem}/capacity),\ capacity)\).

You can invert the growth step to recover \(S^{rem}\) (unique for relevant ranges). Then compute total consumption and infer the number of defectors last round.

**Practical shortcut** (robust and easy): don’t fully invert; estimate “defection pressure” directly by comparing how hard stock fell relative to what you’d expect under mostly-C. But if you can invert, do it precisely.

Define:
- \(k_{t-1}\) = estimated number of defectors among all \(n\) players last round.

This drives the policy.

---

## Strategy: **Predatory Stock Manager (PSM)**

### Parameters derived from game parameters
Let:
- **Safe stock floor**: \(S_{\text{floor}} = 0.35 \cdot capacity\)  
  (below this, collapse risk rises and future value shrinks)
- **Target stock**: \(S_{\text{target}} = 0.85 \cdot capacity\)  
  (a high-yield region; logistic growth strong but not capped too hard)
- **Panic threshold**: \(S_{\text{panic}} = \max(2n,\ 0.20\cdot capacity)\)
- **Defection tolerance**: \(k_{\text{tol}} = \lceil 0.35n \rceil\)  
  (if more than this defect, the group is extraction-heavy)

These constants are deliberately coarse; the strategy works across wide behaviors without fine-tuning.

---

## 1) Decision rules (when to cooperate vs defect)

### Rule A — First round: **Defect**
- Play **D** in round 1.
Rationale: immediate gain and information gathering; if the table is cooperative you’ll quickly see stock remain high and can continue free-riding.

---

### Rule B — Last round: **Defect**
- Play **D** in round \(r\).
Rationale: no future to protect.

---

### Rule C — Normal operation (default predation)
If \(t \notin \{1,r\}\):

1) **If stock is healthy**: \(S_t \ge S_{\text{target}}\)  
   → Play **D** (free-ride while the resource is abundant)

2) **If stock is okay but not huge**: \(S_{\text{floor}} \le S_t < S_{\text{target}}\)  
   - If estimated defectors last round are **low**: \(k_{t-1} \le k_{\text{tol}}\)  
     → Play **D** (others are managing; keep exploiting)
   - Else (many defectors): \(k_{t-1} > k_{\text{tol}}\)  
     → Play **C** (invest to prevent drift downward; you can’t free-ride a collapsing pool)

3) **If stock is low**: \(S_{\text{panic}} \le S_t < S_{\text{floor}}\)  
   → Play **C** unless you have strong evidence that others are already switching to C.
   Specifically:
   - If \(k_{t-1} \ge \lceil 0.6n \rceil\) (table still mostly defecting)  
     → Play **C** (minimal stewardship to preserve future; if everyone D’s here, it spirals)
   - Else  
     → Play **D** (they’re already repairing; resume predation)

4) **If stock is critical**: \(S_t < S_{\text{panic}}\)  
   → Play **C** for **two consecutive rounds** (a “recovery burst”), then reassess.  
Rationale: when very low, growth can be strong proportionally, but only if you don’t drain the remaining base.

This yields a “predator with a stethoscope” behavior: exploit whenever the pool is robust, but stabilize it when it becomes dangerous to your own long-run extraction.

---

## 2) Edge cases

### Round 1
- **D** always.
- Also record baseline behavior of others (via inferred \(k_1\)).

### Round 2
- If \(S_2\) stayed near capacity, continue **D**.
- If it dropped hard (sign of heavy D), switch into the Rule C logic.

### Final 2 rounds (rounds \(r-1\) and \(r\))
- Round \(r\): always **D**
- Round \(r-1\): **D unless stock is in “critical” region** \(S_{r-1} < S_{\text{panic}}\)  
  In that case play **C** in \(r-1\) to avoid a near-zero final-round payout.

### If stock hits 0
- You are forced into a dead pool (no one can gain).  
- Keep playing **D** (it does not matter), but the strategy has already failed; this is as good as anything.

### If capacity is very close to \(2n\) (minimal)
- Then the system is inherently fragile. Increase conservatism slightly:
  - Set \(S_{\text{floor}} = 0.45\cdot capacity\) and \(S_{\text{target}} = 0.90\cdot capacity\).
Still defect-first, but with earlier “maintenance” mode.

---

## 3) Why this is exploitative (not “nice”)

1) **You defect whenever the pool is healthy**, extracting double the cooperative share.
2) You only cooperate when the *marginal value of preserving future stock* exceeds the immediate defection gain.
3) When others are cooperative (low inferred \(k\)), you explicitly **free-ride**.
4) When others are defect-heavy, you do **just enough** cooperation to keep the game from becoming worthless—so you can keep exploiting later.
5) You never attempt fair splitting; the target is **maximum personal cumulative extraction**.

---

## Pseudocode (implementation-oriented)

```python
def action(t, r, n, capacity, S_t, history):
    # thresholds
    S_floor  = 0.35 * capacity
    S_target = 0.85 * capacity
    S_panic  = max(2*n, 0.20 * capacity)

    k_tol = ceil(0.35 * n)

    # edge rounds
    if t == 1:
        return "D"
    if t == r:
        return "D"

    # estimate last round's number of defectors
    k_last = estimate_defectors(history[-1], n, capacity)  # robust estimator

    # critical recovery burst memory
    if history.has_flag("recovery_burst_remaining"):
        if history.flag_value("recovery_burst_remaining") > 0:
            history.decrement_flag("recovery_burst_remaining")
            return "C"

    if S_t >= S_target:
        return "D"

    if S_floor <= S_t < S_target:
        if k_last <= k_tol:
            return "D"
        else:
            return "C"

    if S_panic <= S_t < S_floor:
        if k_last >= ceil(0.60 * n):
            return "C"
        else:
            return "D"

    # S_t < S_panic
    history.set_flag("recovery_burst_remaining", 2)
    return "C"
```

`estimate_defectors()` can be implemented by inverting the growth step to recover remaining stock and thus total consumption, then mapping consumption to number of D’s. If inversion is numerically annoying, approximate \(k\) from observed stock change patterns; the policy tolerates noise because it mostly relies on broad regions (healthy/ok/low/critical).

---

This strategy is adaptive (responds to stock and inferred defection rate), robust (works against cooperators, defectors, and mixed/reactive types), and explicitly exploitative (free-rides whenever the resource can support it, only “invests” when needed to keep future exploitation profitable).
'''

description_EXPLOITATIVE_15 = '''
### Strategy: **Harvest–Probe–Punish (HPP)**  
Exploit cooperators by taking **D** whenever it is safe (stock won’t crash), but switch to **C** to (a) keep the resource productive and (b) punish populations that would otherwise keep you from extracting high payoffs.

The key idea is: **you earn twice as much this round by defecting**, so you should defect whenever the stock is high enough that (i) it won’t hit zero and (ii) it will regrow strongly. You only cooperate when defecting would drive the system into a low-stock trap or when you need to “buy” future stock growth.

---

## Notation (observable from history)
At round \(t\) with current stock \(S_t\):

- Let \(m_{t-1}\) be the number of opponents who defected last round (you observe this).
- Let \(\hat{m}_t\) be your prediction for how many opponents will defect this round. Default: \(\hat{m}_t = m_{t-1}\) (inertia assumption).
- If no history (round 1), start with \(\hat{m}_1 = 0\) (assume cooperation to bait exploitation), then correct immediately after observing.

If **you** play:
- **C**: you consume \(S_t/(2n)\)
- **D**: you consume \(S_t/n\)

If opponents: each C consumes \(S_t/(2n)\), each D consumes \(S_t/n\).

So predicted **remaining stock after consumption** if you choose action \(a \in \{C,D\}\) is:
\[
S^{rem}(a) = S_t - S_t\Big(\frac{\#C}{2n} + \frac{\#D}{n}\Big)
\]
Given \(\hat{m}_t\) defectors among the other \(n-1\) players:

- If you play **D**: total defectors \(=\hat{m}_t+1\), cooperators \(= (n-1-\hat{m}_t)\)
- If you play **C**: total defectors \(=\hat{m}_t\), cooperators \(= (n-\hat{m}_t)\)

This simplifies nicely to a *fraction remaining*:

- If you play **D**:
\[
S^{rem}(D)= S_t \cdot \frac{n-1-\hat{m}_t}{2n}
\]
- If you play **C**:
\[
S^{rem}(C)= S_t \cdot \frac{n-\hat{m}_t}{2n}
\]

Growth is logistic:
\[
g(x)= 2x\Big(1-\frac{x}{capacity}\Big), \quad S_{t+1}=\min(x+g(x),capacity)
\]
where \(x=S^{rem}(\cdot)\).

---

## Core decision rule (cooperate vs defect)

### Step 1: compute “safety” and “productivity” thresholds
Defecting is great *unless it pushes the system into low stock*, where future payoffs collapse.

Use two thresholds:

1) **No-crash threshold**: ensure predicted remaining stock after consumption stays above a small floor:
- Define \(S_{floor} = \max\{1,\; 0.05\cdot capacity\}\).  
(Any small constant works; the point is to avoid drifting into near-zero where recovery is slow under ongoing exploitation.)

2) **Regrowth threshold**: logistic growth is strongest around \(capacity/2\). You want post-consumption stock not too far below that.
- Define \(S_{target} = 0.35\cdot capacity\).  
(If remaining is below this, you’re likely entering a low-output region unless everyone cooperates.)

### Step 2: predict next stock for each action
Compute:
- \(x_D = S^{rem}(D)\), \(x_C = S^{rem}(C)\)
- \(S'_{D} = \min(x_D + g(x_D), capacity)\)
- \(S'_{C} = \min(x_C + g(x_C), capacity)\)

### Step 3: choose action using exploitative preference
**Default: choose D** unless one of the following “resource preservation” conditions triggers:

You play **C** if **any** is true:
1. **Crash risk**: \(x_D < S_{floor}\)
2. **Low-productivity risk**: \(x_D < S_{target}\) *and* \(S'_D < S_t\) (defecting makes the stock trend down)
3. **Last-2-round preservation**: \(t \le r-2\) and \(S'_D \ll S'_C\) (cooperating now buys noticeably more future stock). Concretely:
   - if \(S'_C - S'_D > 0.15\cdot capacity\), cooperate.

Otherwise play **D**.

Interpretation: you defect whenever you can “get away with it” without driving the stock into a depleted basin. You cooperate only as an investment to keep the resource extractable.

---

## Punishment / exploitation logic (adaptive to opponents)

Opponents fall into broad types; HPP exploits each:

### A) Mostly cooperators
You will mostly defect, because \(\hat{m}_t\) is low and \(x_D\) stays healthy. You extract ~2× per-round compared to them while the stock remains viable due to their restraint.

### B) Mixed / conditional cooperators
They often respond to defection with defection. HPP avoids mutual ruin by switching to C when the stock would spiral down, but it does **not** “forgive” into equal sharing. It returns to D as soon as the stock is healthy again.

### C) Always defectors
With many defectors, \(x_D\) becomes small quickly. HPP will shift toward C earlier (sometimes even always C in late rounds) to keep the stock from going to ~0, but you still defect whenever the stock is high enough to survive. Against all-D populations, nobody can do well; HPP’s goal becomes **minimizing long-run collapse while still grabbing D whenever feasible**.

### D) Weird/chaotic strategies
The prediction \(\hat{m}_t=m_{t-1}\) is robust to inertia; add a short memory smoother:

\[
\hat{m}_t = \text{round}\Big(0.7 m_{t-1} + 0.3 m_{t-2}\Big)
\]
(if \(t\ge 3\)). This handles oscillators and noise.

---

## Edge cases

### Round 1 (no history)
**Play D** unless doing so trivially collapses the resource even under optimistic assumptions.

Given initial \(S_1=capacity\), for any \(n\ge2\), if you play D and assume others cooperate (\(\hat{m}_1=0\)):
\[
x_D = capacity\cdot\frac{n-1}{2n}\ge capacity\cdot\frac{1}{4}
\]
So it won’t crash. Therefore:

- **Round 1: play D.**  
This is maximally exploitative and also information-gathering (you learn opponent defect rate immediately).

### Last round \(t=r\)
There is no future stock value. **Always play D.**

### Second-to-last round \(t=r-1\)
Future matters only one step. Rule:
- If \(x_D < S_{floor}\) *and* \(x_C \ge S_{floor}\), play **C** to avoid a “zero payout” scenario in the very last round (if collapse would carry over).  
Otherwise **D**.

(If stock dynamics apply after r-1 into r, preserving stock for the last extraction can be worth it.)

### If stock is already near zero
If \(S_t\) is tiny, both actions pay tiny amounts, but defection may keep it tiny forever if others also defect. When \(S_t < S_{floor}\):
- **Play C** for one round to attempt recovery **unless** it’s the last round (then D).

---

## Pseudocode (implementable)

```pseudo
Input: n, r, capacity
State each round t: stock S_t, history of opponent actions

Constants:
  S_floor  = max(1, 0.05 * capacity)
  S_target = 0.35 * capacity
  BIGGAIN  = 0.15 * capacity

Function grow(x):
  return 2*x*(1 - x/capacity)

Function nextStock(x):
  return min(x + grow(x), capacity)

At round t:

if t == r:
  return D

// Predict opponent defect count
if t == 1:
  mhat = 0
else if t == 2:
  mhat = m_{t-1}
else:
  mhat = round(0.7*m_{t-1} + 0.3*m_{t-2})

// Compute remaining stocks under each action
xD = S_t * (n - 1 - mhat) / (2*n)
xC = S_t * (n - mhat)     / (2*n)

SDp = nextStock(xD)
SCp = nextStock(xC)

// Special handling near end
if t == r-1:
  if xD < S_floor and xC >= S_floor:
    return C
  else:
    return D

// Main rule (exploit unless preservation needed)
if xD < S_floor:
  return C
if xD < S_target and SDp < S_t:
  return C
if (SCp - SDp) > BIGGAIN and t <= r-2:
  return C

return D
```

---

## Why this is exploitative (explicitly)
- **Bias toward D**: D is the default in all normal conditions, including round 1 and the final round.
- **Cooperation is purely instrumental**: you cooperate only to prevent the “gold mine” (stock) from collapsing or to set up a larger stock you can later defect on.
- **It harvests cooperators**: in populations with any sustained cooperation, you systematically take the larger share each round while keeping the system productive.
- **It resists being dragged into ruin**: if others defect heavily, you selectively cooperate to keep the stock from hitting low-output levels, then immediately revert to defection when safe.

If you want, I can tune the numeric thresholds (\(0.05, 0.35, 0.15\)) based on \(n\) and the exact growth curve to maximize expected extraction under different opponent mixes.
'''

description_EXPLOITATIVE_16 = '''
Below is an **exploitative, adaptive “Harvest–Punish–Recover (HPR)” strategy**. It treats cooperation as an *investment* to keep stock high only when that investment is likely to be repaid, and otherwise defects aggressively to extract short-run payoff, while also avoiding self-defeating full collapses when continued play remains.

---

## Core idea (exploitative posture)

- **Default goal:** Get the *defector’s share* whenever others are keeping the resource alive.
- **Only cooperate** when (a) stock is in a “danger zone” where extra depletion risks killing future gains, *and* (b) enough others appear to be cooperating so that your cooperation will actually restore/maintain stock.
- **Punish quickly**: if others defect a lot, you defect (do not subsidize them).
- **Recover strategically**: if the pool is low but opponents look capable of sustaining it (many C), temporarily cooperate to rebuild, then return to harvesting (D).

This exploits cooperative or sustainability-focused opponents by free-riding on their restraint; it also avoids wasting cooperation against defect-heavy populations.

---

## Useful quantities from history

At round \(t\), before choosing action, you observe current stock \(S_t\) and history of actions.

Let:

- \(c_{t-1}\) = number of opponents who played **C** in previous round (i.e., among \(n-1\)).
- \(d_{t-1} = (n-1) - c_{t-1}\).
- \(\hat{p}_{t-1} = c_{t-1}/(n-1)\) = observed cooperation rate among opponents last round.

Also define a short memory (robustness to noise):

- \(\bar{p}_t\) = exponentially-weighted moving average of opponent cooperation:
  \[
  \bar{p}_t = \lambda \bar{p}_{t-1} + (1-\lambda)\hat{p}_{t-1}, \quad \lambda \in [0.6,0.8]
  \]
Initialize \(\bar{p}_1 = 0.5\).

---

## Stock-risk thresholds (parameter-only, no opponent assumptions)

We want to avoid being the one who “tips” the pool into a bad region, but we’re happy to run it moderately low if others can rebuild it.

Define two stock thresholds:

- **Collapse-risk threshold:**  
  \[
  S_{\text{low}} = \max(2n,\; 0.25\cdot \text{capacity})
  \]
  If stock is below this, continued heavy taking risks prolonged low payoffs (even if not literally absorbing-state 0 every time).

- **Comfort threshold:**  
  \[
  S_{\text{high}} = 0.65\cdot \text{capacity}
  \]
  If stock is above this, defecting is highly profitable and typically sustainable if enough others cooperate.

(These values are deliberately coarse; they work across capacities as long as capacity ≥ 2n.)

---

## Decision rules (when to C vs D)

### Rule 0: Last round = defect
If \(t = r\): **play D**.  
Exploit endgame: there is no future to protect.

---

### Rule 1: First round = defect (with one safety exception)
If \(t = 1\):
- If \(S_1 \ge S_{\text{high}}\): **play D** (harvest immediately).
- Else (unusual, only if capacity is small or stock not full): **play C** to avoid immediate collapse.

Rationale: in tournaments, many strategies “open cooperative.” You take the higher payoff immediately and learn how forgiving the population is.

---

### Rule 2: If stock is comfortable, harvest unless opponents are mostly defecting
If \(S_t \ge S_{\text{high}}\):
- If \(\bar{p}_t \ge 0.4\): **play D** (free-ride; enough others tend to sustain).
- Else (\(\bar{p}_t < 0.4\)): **play D** anyway.

(When stock is high, even defect-heavy groups haven’t yet hurt you much this round. Defection remains myopically dominant; you’re not “saving” anything by cooperating at high stock unless you expect your cooperation to change opponent behavior, which you cannot signal/communicate here.)

So effectively: **if high stock → D**.

---

### Rule 3: In the middle zone, condition on opponent cooperation
If \(S_{\text{low}} \le S_t < S_{\text{high}}\):

- If \(\bar{p}_t \ge 0.6\): **play D** (exploit cooperative population; they will tend to rebuild/maintain).
- If \(0.4 \le \bar{p}_t < 0.6\): **play D** unless you are close to endgame? (see Rule 5)
- If \(\bar{p}_t < 0.4\): **play D** (do not subsidize defectors).

So in the middle zone, you still mostly defect; you only start cooperating when stock is actually threatened.

---

### Rule 4: In the danger zone, “recover only if recoverable”
If \(S_t < S_{\text{low}}\):

- If \(\bar{p}_t \ge 0.55\): **play C** (rebuild with the cooperators; then harvest later).
- Else: **play D** (pool is effectively being strip-mined; take what you can).

This is the key exploit/recovery gate:
- When others are cooperative enough, your C helps lift stock and keeps the game lucrative in later rounds—then you can resume D and extract more.
- When others are not cooperative, C is wasted and just transfers value to others (since your per-round payoff is strictly lower under C).

---

### Rule 5: Endgame tightening (final 20% of rounds)
Let remaining rounds \(R = r - t + 1\).

If \(R \le \max(2, \lceil 0.2r \rceil)\) (late game):
- Always **play D**, *unless* stock is extremely low and opponents are very cooperative:
  - If \(S_t < 0.15\cdot \text{capacity}\) and \(\bar{p}_t \ge 0.75\): **play C** for exactly **one** round, then revert to **D**.

Rationale: late game, future is short so you become more purely extractive. The one-round exception prevents self-sabotage in cases where a single cooperative “patch” yields higher total in the last few rounds (because growth is strong when stock is moderate).

---

## Punishment / anti-exploitation behavior (robustness)

Some opponents use conditional cooperation and may try to punish defectors. You can’t communicate, but you can detect “they punish D.”

Add a simple retaliation detector:

- If in the last round **you played D** and the opponent cooperation rate **drops sharply**:
  \[
  \hat{p}_{t-1} \le \bar{p}_{t-1} - 0.3
  \]
  then mark a **punishment event**.

**Response to punishment events:**
- If stock is not in danger (\(S_t \ge S_{\text{low}}\)): **play C for 1 round only**, then revert to baseline rules.
- If stock is in danger (\(S_t < S_{\text{low}}\)): follow Rule 4 (likely C if recoverable).

This is exploitative “minimal appeasement”: you pay the smallest cooperation cost to re-enable opponents’ cooperation, then resume harvesting.

---

## Pseudocode summary

```pseudo
parameters:
  S_low  = max(2*n, 0.25*capacity)
  S_high = 0.65*capacity
  lambda = 0.7

state:
  pbar = 0.5
  punished_flag = false

for round t = 1..r:
  observe stock S

  if t == r:
      action = D
      play(action); update pbar; continue

  if t == 1:
      action = (S >= S_high) ? D : C
      play(action); update pbar; continue

  # update pbar from previous round opponents' actions
  phat = (#opponents_C_last_round)/(n-1)
  pbar = lambda*pbar + (1-lambda)*phat

  # detect punishment response to our previous D
  punishment_event = (my_last_action == D) and (phat <= previous_pbar - 0.3)

  R = r - t + 1
  late = (R <= max(2, ceil(0.2*r)))

  if late:
      if (S < 0.15*capacity) and (pbar >= 0.75) and (not used_late_patch):
          action = C
          used_late_patch = true
      else:
          action = D
      play(action); continue

  if punishment_event and S >= S_low:
      action = C         # 1-round appeasement
      play(action); continue

  if S < S_low:
      action = (pbar >= 0.55) ? C : D
  else if S >= S_high:
      action = D
  else:
      action = (pbar >= 0.6) ? D : D   # effectively D in mid zone

  play(action)
```

(You can simplify the “mid zone” to always D; the real switching happens only in the danger zone and in brief appeasement/late-patch situations.)

---

## Edge cases and guarantees

- **All-defect population:** You defect throughout; you maximize short-run extraction and don’t waste cooperation.
- **Mostly-cooperative population:** You defect almost always, occasionally cooperating only to prevent resource collapse that would reduce your future take; this reliably exploits altruists and sustainability bots.
- **Conditional cooperators (grim/trigger-like):** The minimal-appeasement rule gives you a chance to restore their cooperation at low cost, then you go back to D.
- **Very small capacity or stock volatility:** The danger-zone rule prevents repeatedly pushing stock into the region where everyone’s future payoffs shrink.

---

## Why this is exploitative

1. **Starts with D** to immediately capture surplus and probe the population.
2. **Free-rides on cooperation**: defects whenever stock is healthy or opponents show willingness to sustain.
3. **Only cooperates instrumentally**: to maintain a future stream of exploitable stock (or to cheaply re-enable opponents’ cooperation).
4. **Endgame defection**: converts accumulated sustainability into final extraction.

If you want, I can also provide a more “mathematical” variant that explicitly estimates whether the expected next-period stock (given last round’s C/D counts) will stay above a target, and chooses C only when it increases your expected *total remaining* payoff.
'''

description_EXPLOITATIVE_17 = '''
### Strategy: **Siphon-Then-Stabilize (STS)**  
Exploit others whenever it is safe (i.e., when the stock will recover), and only cooperate when cooperation is necessary to keep the resource from collapsing and killing your future payoffs. The core idea is: **take the larger share (D) whenever the stock is in a “regenerating zone” and opponents aren’t overwhelmingly predatory; otherwise switch to C to preserve the resource and to punish collapse-inducers by not “feeding” them a high stock next round.**

This strategy uses only: parameters `(n, r, capacity)`, current `stock S`, and full history of actions.

---

## Key observations (drives the rules)
Let `k` be the number of defectors in the current round.

- Each cooperator consumes `S/(2n)`; each defector consumes `S/n`.
- Total consumption fraction of `S` is:
  \[
  \frac{k}{n}+\frac{n-k}{2n}=\frac{1}{2}+\frac{k}{2n}
  \]
  so remaining stock after consumption is:
  \[
  S_{\text{rem}} = S\left(1-\frac{1}{2}-\frac{k}{2n}\right)=S\cdot\frac{n-k}{2n}
  \]
- Stock growth is logistic: `2 * S_rem * (1 - S_rem/capacity)`.

**Implication:** When `S_rem` stays moderate (not near 0), the pool can bounce back strongly. When `S_rem` is driven near 0 (many D), the pool collapses and stays low. So you want to **defect when the pool can still rebound**, and **cooperate when the pool is at risk**.

---

## What STS tracks from history
Maintain:
- `D_rate_others`: exponentially-weighted moving average of how many *other* players defect.
- `streak_collapse`: number of consecutive rounds where stock ended very low or fell sharply.

Concrete (can be implemented):
- Let `k_others(t)` = number of other players who defected in round `t`.
- EWMA:  
  `D_rate_others ← (1-α)*D_rate_others + α*(k_others/(n-1))` with `α ≈ 0.25`.

Also track last round’s stock `S_prev` to detect collapse trend.

---

## Decision rule (cooperate vs defect)

### Step 1: Compute a **safety forecast**
Before choosing your action in round `t`, with current stock `S`:

Define a pessimistic estimate of defectors this round:
- `k_hat = round( (n-1)*D_rate_others ) + 1`  
  (assume you defect too; this is “exploit-first” pessimism)

Compute estimated remaining stock if `k_hat` defect:
- `S_rem_hat = S * (n - k_hat) / (2n)`  (clamp to ≥ 0)

Compute estimated next stock:
- `S_next_hat = min(S_rem_hat + 2*S_rem_hat*(1 - S_rem_hat/capacity), capacity)`

Define two thresholds:
- **Danger floor**: `S_danger = 0.20 * capacity`  
- **Recovery floor**: `S_recover = 0.60 * capacity`

(These are tuned for robustness: below ~20% capacity, the game tends to become a low-stock trap; above ~60%, there’s room to exploit.)

### Step 2: Choose action with a **greedy bias**
You defect unless one of the “must-stabilize” conditions triggers.

**Play D** if all are true:
1. `t < r` (not last round), and  
2. `S_next_hat >= S_danger` (defection won’t likely push the system into the danger zone), and  
3. `D_rate_others <= 0.70` (others are not overwhelmingly defect-heavy), and  
4. `S >= 0.35*capacity` (pool is currently healthy enough to siphon).

Otherwise **play C**.

This is intentionally exploitative: it defaults to D whenever sustainability appears plausible.

---

## Edge cases and special handling

### Round 1 (no history)
- **Play D**.
Rationale: immediate 2× payoff relative to C, and you learn opponents’ types quickly. If everyone defects, the resource collapses—but in that case cooperation wouldn’t have saved you from being exploited anyway (you’d just be the sucker).

Initialize `D_rate_others = 0.5` (agnostic).

### Last round (t = r)
- **Always play D**.
No future to protect; pure one-shot incentive.

### “Collapse response” mode (protect future exploitation)
If stock is collapsing, stop feeding defectors by helping the pool recover too quickly.

Trigger collapse response if either:
- `S <= S_danger`, or
- `S < 0.7*S_prev` for 2 consecutive rounds (sharp decline trend)

**In collapse response:**
- If `t < r`: **Play C** until `S >= S_recover` *and* `D_rate_others <= 0.55`.  
- If others keep defecting heavily (`D_rate_others > 0.70`), continue playing **C** anyway (you cannot out-defect them sustainably; your best play is to preserve any future stock and reduce volatility).

This looks “nice,” but it is still exploitative: you cooperate only to rebuild the stock so you can resume siphoning later.

### “Weak-opponent exploitation” (ramp up defection)
If history indicates others cooperate a lot:
- If `D_rate_others < 0.35` and `S >= 0.50*capacity` and `t < r`:  
  **Play D with certainty** (no randomization).
You’re explicitly punishing cooperative populations by taking the larger share.

### “Predator crowd” handling (avoid being the lone cooperator)
If others are near-always defecting:
- If `D_rate_others > 0.85`:
  - If `t < r-1`: **Play D** while `S > 0.15*capacity`, else **C**.
  - Rationale: when the pool is still nontrivial, grab what you can. When it’s nearly empty, D yields almost nothing and keeps it dead; C can sometimes create a rebound if a few others aren’t perfectly rigid.

---

## Pseudocode (implementable)
```pseudo
Parameters: n, r, capacity
State each round t: stock S
Memory: D_rate_others, S_prev, decline_streak

Initialize:
  D_rate_others = 0.5
  S_prev = capacity
  decline_streak = 0

For each round t = 1..r:

  if t == 1:
     action = D
     goto END

  if t == r:
     action = D
     goto END

  # update decline streak (based on last observed transition)
  if S < 0.7 * S_prev:
     decline_streak += 1
  else:
     decline_streak = 0

  S_danger  = 0.20 * capacity
  S_recover = 0.60 * capacity

  # collapse response trigger
  collapse = (S <= S_danger) OR (decline_streak >= 2)

  if collapse:
     if (S >= S_recover) AND (D_rate_others <= 0.55):
         # leave collapse mode; resume normal rule (fall through)
     else:
         action = C
         goto END

  # pessimistic forecast assuming you defect
  k_hat = round((n-1)*D_rate_others) + 1
  k_hat = clamp(k_hat, 1, n)
  S_rem_hat = S * (n - k_hat) / (2*n)
  if S_rem_hat < 0: S_rem_hat = 0
  S_next_hat = min(S_rem_hat + 2*S_rem_hat*(1 - S_rem_hat/capacity), capacity)

  # weak-opponent exploit
  if (D_rate_others < 0.35) AND (S >= 0.50*capacity):
      action = D
      goto END

  # predator crowd
  if (D_rate_others > 0.85):
      if S > 0.15*capacity:
          action = D
      else:
          action = C
      goto END

  # main greedy rule
  if (S_next_hat >= S_danger) AND (D_rate_others <= 0.70) AND (S >= 0.35*capacity):
      action = D
  else:
      action = C

END:
  play action

  # after observing others' actions and new stock next round:
  observe k_others (defectors among others)
  D_rate_others = (1-α)*D_rate_others + α*(k_others/(n-1)) , α=0.25
  S_prev = S
```

---

## Why this is exploitative and robust
- **Exploitative by default:** It defects whenever it expects the system won’t immediately crash—capturing the 2× per-round payoff advantage over cooperators.
- **Adaptive:** Learns the population’s defection level; shifts between “siphon” and “stabilize.”
- **Robust across opponent types:**
  - Against cooperative or conditional cooperators: you harvest more by defecting while maintaining stock above danger levels.
  - Against mixed groups: the forecast-based guardrails prevent self-destructive over-defection.
  - Against defect-heavy populations: you take what’s left early (D) and only cooperate when defection is pointless (stock too low).
- **Tournament-oriented:** Doesn’t require signaling or coordination; uses only observable history and state.

If you want, I can tune the numeric thresholds (`0.20/0.35/0.60/0.70/0.85`) analytically for specific `(n, capacity)` regimes or propose a version that computes them endogenously from the growth equation instead of fixed fractions.
'''

description_EXPLOITATIVE_18 = '''
### Strategy: **FGR (Fence–Graze–Raid)**  
Exploit the stock dynamics by (i) keeping the resource near the “high-growth” region when that benefits you, (ii) free-riding on any group that sustains the stock, and (iii) switching to aggressive extraction when cooperation is absent or the endgame makes sustainability irrelevant.

Key facts this exploits:
- **Defection always doubles your per-round take vs cooperation at the same stock** (S/n vs S/(2n)).
- But too much total extraction collapses the stock and kills future payoffs.
- With logistic growth, the stock regenerates best around **S ≈ capacity/2**. If others keep stock healthy, you should defect to skim.

---

## 1) Decision rules: when to Cooperate vs Defect

Maintain two internal signals from history:

**A. “Opponent cooperation rate” (last round):**  
Let \(k_{t-1}\) = number of opponents (out of \(n-1\)) who played C last round.

**B. “Stock safety” (current state):**  
Let current stock be \(S_t\). Define thresholds (depend only on parameters):
- **Critical stock:** \(S_{\text{crit}} = 2n\)  
  (When stock is near the minimum bound, the game is on the brink; any over-extraction is catastrophic.)
- **Growth zone center:** \(S_{\text{mid}} = capacity/2\)  
- **High stock:** \(S_{\text{high}} = 0.8 \cdot capacity\)

**C. “Endgame horizon”:**  
Let remaining rounds be \(R = r - t + 1\). Define:
- **Endgame window:** last \(E\) rounds where sustainability is less valuable:  
  \(E = \max(2,\lceil r/6 \rceil)\)

---

### Core policy (per round t)

#### Rule 0 — Last-round raid (pure exploitation)
If \(R = 1\): **Play D**.  
No future to protect; take maximum.

#### Rule 1 — Endgame pressure (increasingly exploit)
If \(R \le E\):  
- If \(S_t > S_{\text{crit}}\): **Play D**  
- Else (stock already extremely low): **Play C** only to avoid immediate zeroing if others might also restrain; but if it’s already doomed (see below), still D.

Interpretation: in the endgame, defect unless the stock is so low that mutual D yields almost nothing and a small restraint could keep it nonzero for the final rounds.

#### Rule 2 — If others are sustaining the pool, free-ride
If \(k_{t-1} \ge \lceil (n-1)\cdot 0.6 \rceil\) (a strong cooperative majority last round) **and** \(S_t \ge S_{\text{mid}}\):  
→ **Play D**.

Rationale: when others are mostly cooperating and stock is in/above the growth region, you can defect for double immediate payoff while the system remains viable due to others’ restraint + growth.

#### Rule 3 — If cooperation is scarce, switch to controlled grazing (or raid if hopeless)
If \(k_{t-1} \le \lfloor (n-1)\cdot 0.3 \rfloor\): (most opponents defected last round)
- If \(S_t \ge S_{\text{high}}\): **Play D** (harvest while there’s still stock)
- Else if \(S_t \in (S_{\text{crit}}, S_{\text{high}})\): **Play C** (attempt to keep pool from collapsing; if you D too, you accelerate collapse and reduce your own future payoff)
- Else \(S_t \le S_{\text{crit}}\): **Play D** (it’s effectively a race-to-the-bottom; your C won’t save it if others keep defecting)

This is “exploit when possible, conserve only when it protects your own future intake.”

#### Rule 4 — Otherwise (mixed/uncertain environment): “Fence” around the growth zone
When opponent behavior is mixed (neither clearly cooperative nor clearly defective), use stock as the main guide:
- If \(S_t > S_{\text{high}}\): **Play D** (skim excess; growth is weaker near capacity)
- If \(S_t \in [S_{\text{mid}}, S_{\text{high}}]\): **Play D** if \(k_{t-1} \ge (n-1)/2\), else **Play C**
- If \(S_t \in (S_{\text{crit}}, S_{\text{mid}})\): **Play C** (protect the growth engine)
- If \(S_t \le S_{\text{crit}}\): **Play D** (protect yourself in the collapse regime)

---

## 2) Edge cases

### First round (no history)
Round 1: **Play D** *if and only if* capacity is comfortably high relative to group size, else **C**.

Concrete rule:
- If \(capacity \ge 6n\): **D** (there is room to skim; initial stock is high)
- Else: **C** (resource is comparatively tight; early collapse is too easy)

This makes you exploitative by default in “rich” environments, but not suicidally so in scarce ones.

### Second round
After round 1 you have \(k_1\) and \(S_2\); apply the core rules above.

### Handling “hopeless collapse”
If stock has hit 0 at any point, it stays 0 (growth is 0), so all future payoffs are 0. After observing \(S_t = 0\), action is irrelevant; play **D** by convention.

### Handling “persistent cooperators”
If opponents repeatedly cooperate (high \(k\) across rounds) and stock remains high, the strategy will defect most of the time (Rule 2 / Rule 4). It only cooperates when stock falls toward the growth-critical region.

### Handling “grim-trigger-like punishers”
If a punisher retaliates against your defection by defecting thereafter, the pool tends to degrade. The strategy responds by shifting into conservation (Rule 3/4) when that actually preserves future value, but will abandon conservation when the group is mostly defecting and the stock is low (raid mode).

---

## 3) Why it’s exploitative (explicit mindset)

- **Default is to defect whenever the environment can absorb it** (stock high, others cooperating, endgame). That captures the 2× per-round payoff advantage.
- **Cooperation is instrumental, not moral**: you cooperate only to prevent stock from entering a region where your own future earnings collapse.
- **You punish “unproductive” groups indirectly** by switching to raiding when cooperation is absent—because trying to be the sole conservationist is negative EV.
- **You also exploit naïve cooperators** by free-riding on their restraint, keeping the pool viable while you take more each round.

---

## Pseudocode (implementable)

```python
def action(n, r, capacity, t, S, opp_last_actions):
    # thresholds
    S_crit = 2*n
    S_mid  = 0.5*capacity
    S_high = 0.8*capacity
    E = max(2, math.ceil(r/6))
    R = r - t + 1

    if S <= 0:
        return "D"

    if t == 1:
        return "D" if capacity >= 6*n else "C"

    k = sum(1 for a in opp_last_actions if a == "C")  # out of n-1

    # Rule 0: last round
    if R == 1:
        return "D"

    # Rule 1: endgame window
    if R <= E:
        if S > S_crit:
            return "D"
        else:
            # very low stock: only cooperate if there's any chance others restrain
            return "C" if k >= (n-1)/2 else "D"

    # Rule 2: free-ride on strong cooperation
    if k >= math.ceil((n-1)*0.6) and S >= S_mid:
        return "D"

    # Rule 3: mostly defectors
    if k <= math.floor((n-1)*0.3):
        if S >= S_high:
            return "D"
        elif S > S_crit:
            return "C"
        else:
            return "D"

    # Rule 4: mixed
    if S > S_high:
        return "D"
    if S >= S_mid:
        return "D" if k >= (n-1)/2 else "C"
    if S > S_crit:
        return "C"
    return "D"
```

This strategy is adaptive (reacts to both stock and opponent mix), robust (doesn’t require coordination or norms), and exploitative (defects whenever it can do so without destroying its own future returns, and always defects in the endgame).
'''

description_EXPLOITATIVE_19 = '''
Below is an *exploit-first*, stateful strategy designed to (i) take the high payoff when it is safe, (ii) harvest cooperative opponents hard, (iii) avoid being the “sucker” in low-stock regimes, and (iv) keep the stock from collapsing too early if that would reduce your own future take.

I’ll call it **Harvest–Probe–Punish (HPP)**.

---

## Key idea (why this works in this game)

- In any round with stock \(S\), defecting gives **double** the immediate payoff of cooperating: \(S/n\) vs \(S/(2n)\).
- But too much defection collapses the stock, reducing future payoffs to near 0.
- So you want a policy that:
  1. **Defects by default** to exploit any cooperators.
  2. **Cooperates only when needed** to keep the stock high enough to keep extracting.
  3. Detects whether opponents are “stock-friendly” (many C) and then **leans into D**.
  4. When opponents are also D-heavy and the stock is about to die anyway, **grab what’s left** (D).

---

## Definitions computed each round

Let:
- \(S_t\) = current stock at start of round \(t\).
- From last round’s observed actions, let \(k_{t-1}\) = number of opponents (excluding you) who played **C**.
- Define **opponent cooperation rate** (smoothed):
  \[
  \hat{c}_t = \frac{\alpha \cdot \hat{c}_{t-1} + k_{t-1}/(n-1)}{\alpha + 1}
  \]
  where \(\alpha\) is a smoothing factor (e.g., \(\alpha=2\)). Initialize \(\hat{c}_1=0.5\).

Also compute a **one-step stock forecast** given a hypothetical number of cooperators:
- If in round \(t\), total number of cooperators is \(K\) (including you if you play C), then total consumption is:
  \[
  \text{cons}(K)=K\cdot \frac{S_t}{2n} + (n-K)\cdot \frac{S_t}{n} = S_t\left(1-\frac{K}{2n}\right)
  \]
  remaining:
  \[
  S' = S_t - \text{cons}(K) = S_t\cdot \frac{K}{2n}
  \]
  growth:
  \[
  g=2S'(1-S'/\text{capacity})
  \]
  next stock:
  \[
  S_{t+1}=\min(S'+g,\text{capacity})
  \]

We will use this to decide when to “pay” a cooperation move to keep \(S\) productive.

---

## Strategy overview (decision rules)

### Rule 0: Last round grab
- **If \(t=r\): play D.**
  - Pure exploitation: no future to protect.

### Rule 1: Emergency stock protection (avoid premature zero if you can still farm later)
Compute two forecasts using *expected* opponent cooperation:
- Estimate expected number of opponent cooperators:
  \[
  \mathbb{E}[k] = (n-1)\hat{c}_t
  \]
- Forecast next stock if you defect:
  - expected total cooperators \(K_D = \mathbb{E}[k]\)
- Forecast next stock if you cooperate:
  - expected total cooperators \(K_C = \mathbb{E}[k]+1\)

Let these forecasts be \(S^{(D)}_{t+1}\) and \(S^{(C)}_{t+1}\).

**If** all are true:
1. \(S_t\) is still “worth preserving” (e.g. \(S_t \ge 0.25\cdot \text{capacity}\)), and
2. \(S^{(D)}_{t+1}\) is predicted to be “low” (e.g. \(< 0.10\cdot \text{capacity}\)), and
3. Cooperating would prevent the crash materially (e.g. \(S^{(C)}_{t+1} - S^{(D)}_{t+1} \ge 0.10\cdot \text{capacity}\)),

**then play C**, otherwise proceed to Rule 2.

Interpretation: you only cooperate when it buys you a big improvement in future stock.

### Rule 2: Exploit cooperators aggressively
If opponents are sufficiently cooperative, you can defect and still have them sustain the resource.

- **If \(\hat{c}_t \ge 0.55\): play D.**

This is the core exploitation lever: once the table is mostly cooperating, you free-ride.

### Rule 3: Probe when uncertain (cheap test for “are they conditional?”)
Conditional strategies often punish defection. To detect them, do controlled probes early.

- **If \(t \in \{1,2\}\): play D.** (strong opening exploitation; also tests forgiveness)
- **If \(t=3\)** and both of these hold:
  - stock remains healthy \(S_3 \ge 0.6\cdot \text{capacity}\)
  - observed opponent cooperation so far isn’t terrible (e.g. average \(k/(n-1) \ge 0.4\))
  
  then **play C** as a *single-round probe* to see if opponents respond by increasing C later.  
  Otherwise play D.

This probe helps you distinguish:
- “always C / naive” (you defect forever),
- “grim / tit-for-tat style” (one C can restore cooperation),
- “always D” (no point cooperating).

### Rule 4: Punish non-cooperators only when it increases your future take
If opponents are mostly defecting, unilateral cooperation usually just lowers your current payoff without saving the stock enough (since others will still drain it). So:

- **If \(\hat{c}_t \le 0.35\): play D.**

This is exploitative and robust: you don’t subsidize defectors.

### Rule 5: Default
- Otherwise (mid-range \(\hat{c}_t\)), use stock condition:
  - If \(S_t \ge 0.5\cdot \text{capacity}\): **play D** (harvest while rich)
  - Else: **play C** (try to rebuild only when stock already low and future rounds remain)

But apply Rule 1 emergency check first (it can override).

---

## Edge cases

### First round
- **Round 1: D**.
  - You immediately get the higher payoff and learn whether the population collapses stock or maintains it.

### Last two rounds
- **Round r: D always**
- **Round r-1:** almost always **D**, except if Rule 1 triggers *and* you estimate that preserving stock will increase your round r payoff enough to compensate (rare). Practically:
  - If \(r-1\) and \(S^{(D)}_{r}\) would be near 0 but \(S^{(C)}_{r}\) would be high, consider **C**; otherwise **D**.

### Stock near zero
- If \(S_t\) is extremely low (e.g. \(S_t < 0.05\cdot \text{capacity}\)):
  - **play D**.  
  Reason: your action has little leverage; take what you can.

### Very high capacity / very large n
This strategy scales because all thresholds are in fractions of capacity and use \(\hat{c}_t\) rather than assuming specific opponent types.

---

## Pseudocode (implementable)

```pseudo
init c_hat = 0.5
alpha = 2

for t in 1..r:
  observe current stock S

  if t == r:
    action = D
    break

  if t > 1:
    k = number of opponents who played C last round
    c_hat = (alpha*c_hat + k/(n-1)) / (alpha+1)

  # early exploit + probing
  if t == 1 or t == 2:
    action = D
    continue
  if t == 3:
    if S >= 0.6*capacity and c_hat >= 0.4:
      action = C   # one-round probe
    else:
      action = D
    continue

  # compute emergency preservation test
  expected_k = (n-1)*c_hat
  Snext_D = forecast_next_stock(S, K = expected_k)
  Snext_C = forecast_next_stock(S, K = expected_k + 1)

  if S >= 0.25*capacity and Snext_D < 0.10*capacity and (Snext_C - Snext_D) >= 0.10*capacity:
    action = C
    continue

  # exploit cooperative tables
  if c_hat >= 0.55:
    action = D
    continue

  # don't subsidize defectors
  if c_hat <= 0.35:
    action = D
    continue

  # default stock-based
  if S >= 0.5*capacity:
    action = D
  else:
    action = C
```

`forecast_next_stock(S, K)` uses the game’s exact stock transition equations.

---

## Why this is explicitly exploitative

- **Defaults to D** in almost all “normal” situations.
- **Uses C instrumentally**, only when it is predicted to *increase your own future extraction* (prevent a stock crash that would hurt you).
- **Harvests naive cooperators**: when opponents keep \( \hat{c} \) high, you keep defecting and take 2× each round.
- **Refuses to prop up defect-heavy groups**: avoids being the lone conservationist funding others’ defection.

If you want, I can also provide:
- parameterized threshold suggestions as functions of \(r\) (becoming more D-heavy as \(t\) approaches \(r\)),
- a more “bandit-style” version that explicitly learns the marginal effect of your C on next stock in this particular pool of opponents.
'''

description_EXPLOITATIVE_20 = '''
## Exploitative strategy: **“Recover–Probe–Tax (RPT)”**

Mindset: treat the stock as a productive asset you want others to help replenish. You (i) **defect whenever the stock is high** to harvest large immediate payoffs, (ii) **only cooperate when the stock is low** (to avoid killing future value) or when you need to **incentivize** others to rebuild it, and (iii) **punish cooperative opponents by taking more (defecting) when they keep the resource healthy**, while **not wasting effort punishing defectors** in a way that only hurts you.

The strategy uses only parameters `(n, r, capacity)`, current stock `S_t`, and full history of actions.

---

# 1) Decision rules (C vs D)

### Key quantities you compute each round
- Let `S` be current stock at start of the round.
- For each opponent `j`, keep:
  - `coop_rate_j` = fraction of past rounds where `j` played C (excludes current round).
- Define:
  - `pC = average_j coop_rate_j` (how cooperative the population seems)
  - `lastC = fraction of opponents who played C last round` (if t>1 else undefined)
- Define two stock thresholds (depend on capacity):
  - **Low-stock threshold**: `S_low = 0.25 * capacity`
  - **High-stock threshold**: `S_high = 0.70 * capacity`

Intuition:
- Below `S_low`, defecting tends to drive the stock toward collapse; cooperate to “reseed.”
- Above `S_high`, the stock is plentiful; exploit by defecting unless you are actively trying to induce more cooperation for future harvest.
- In the middle region, adapt based on whether others are actually contributing.

---

## Core policy

### A. If it’s the **last round**: **Defect**
- No future value to conserve.

### B. If stock is **very low** (preservation mode): `S <= S_low`
- **Cooperate**, *unless* you detect “hopeless collapse” (everyone defects persistently), in which case defect to grab what remains.

Operationally:
- If `pC < 0.15` and (t>2) and `S` has been non-increasing for 2 rounds → **Defect** (salvage).
- Else → **Cooperate** (try to recover).

### C. If stock is **high** (harvest mode): `S >= S_high`
- Default: **Defect**.
- Exception (investment to keep the golden goose alive): if opponents are *very* cooperative and you are early enough to profit from sustained capacity, occasionally cooperate to maintain their willingness.

Operationally:
- If `pC >= 0.70` and `t <= r-2`:
  - Play **C** with small probability `q = 0.20` (otherwise D).
  - (This is not “fairness”; it’s cheap insurance to keep cooperators cooperative while you mostly harvest.)
- Else: **Defect**.

### D. If stock is **mid-range** (`S_low < S < S_high`) (steer opponents)
Here you decide based on whether cooperation is “available to exploit”:

- If `lastC >= 0.5` (many cooperated last round): **Defect**  
  Rationale: others are sustaining the stock; tax them.

- Else if `lastC <= 0.2` (almost no one cooperated): **Defect**  
  Rationale: no one is investing; don’t be the sucker unless stock is low.

- Else (mixed): choose **C** only if doing so is likely to move the group back toward high stock where you can harvest.
  - If `pC >= 0.45` and `t <= r-2`: **Cooperate** (nudge toward recovery)
  - Otherwise: **Defect**

This creates a dynamic:
- When there’s enough cooperative mass, you help just enough to rebuild stock, then harvest.
- When cooperators are already plenty, you defect to extract.
- When cooperation is absent, you defect and salvage.

---

# 2) Edge cases / special rounds

### Round 1
You don’t know types yet, but you do know `S_1 = capacity` (high).
- **Defect in round 1**.
Reason: immediate payoff is doubled vs C, and you can still switch to cooperation later if stock drops.

### Final 2 rounds (endgame ramp)
- Round `r`: **Defect**.
- Round `r-1`: almost always **Defect**, except:
  - If `S <= S_low` and `pC >= 0.6` (many cooperators you can keep from panicking) then **Cooperate** (rare insurance), otherwise **Defect**.

### “Collapse detected” override
If `S` is falling and opponents aren’t cooperating, don’t waste actions trying to save the stock.
- If for the last 2 rounds: `S_t < S_{t-1} < S_{t-2}` and `lastC <= 0.2` → **Defect** (salvage mode).

### “Overabundance” override
If `S` is essentially at capacity (e.g., `S >= 0.95*capacity`):
- **Defect** (max harvest; growth can’t exceed capacity anyway).

---

# 3) Why this is exploitative (and robust)

## Exploitative mechanics
- **Tax cooperators:** whenever others keep stock high or cooperate in the mid/high range, you defect to take the larger share (`S/n` vs `S/(2n)`).
- **Minimal investment:** you cooperate primarily when stock is low enough that continued defection threatens future harvest (or when a small “gift” may keep cooperative types from switching).
- **No costly punishment:** you don’t “punish defectors” by cooperating (which would just subsidize them). Against defect-heavy populations you defect and salvage.

## Robustness to diverse opponents
- Against **always-cooperate / generous** strategies: you mostly defect and extract; you sometimes cooperate just enough to keep the system from collapsing early.
- Against **grim trigger / reciprocal** strategies: the occasional cooperation in high/mid stock can prevent total breakdown, but you still defect frequently; you’re not trying to be loved, just to keep the resource productive.
- Against **always-defect**: you defect too; the stock collapses, but you avoid being the lone contributor.
- Against **mixed / adaptive** populations: the mid-range rules “steer” toward regimes where stock can regrow (when feasible) and then harvest.

---

# Pseudocode (implementable)

```python
def RPT_action(t, r, n, capacity, S, history_actions, history_stock):
    # history_actions: list of dicts per round: {player_id: 'C'/'D'}
    # opponents are all except self_id; assume self_id known in implementation.

    if t == r:
        return 'D'

    # compute opponent cooperation rates
    if t == 1:
        pC = None
        lastC = None
    else:
        # last round fraction cooperators
        last_round = history_actions[t-2]   # 0-index
        lastC = fraction_opponents_played_C(last_round)

        # average cooperation rate across opponents
        pC = average_over_opponents(coop_rate_over_history(opponent))

    S_low  = 0.25 * capacity
    S_high = 0.70 * capacity

    # overrides
    if S >= 0.95 * capacity:
        return 'D'

    if t >= 3:
        if (history_stock[t-1] < history_stock[t-2] < history_stock[t-3]) and (lastC is not None) and lastC <= 0.2:
            return 'D'  # collapse detected => salvage

    if t == 1:
        return 'D'  # high stock; exploit first

    # last-1 round
    if t == r-1:
        if S <= S_low and pC is not None and pC >= 0.6:
            return 'C'
        return 'D'

    # low stock region
    if S <= S_low:
        if pC is not None and pC < 0.15 and t > 2:
            return 'D'
        return 'C'

    # high stock region
    if S >= S_high:
        if pC is not None and pC >= 0.70 and t <= r-2:
            return 'C' if random() < 0.20 else 'D'
        return 'D'

    # mid stock region
    if lastC >= 0.5:
        return 'D'
    if lastC <= 0.2:
        return 'D'
    # mixed
    if pC is not None and pC >= 0.45 and t <= r-2:
        return 'C'
    return 'D'
```

---

If you want, I can also provide: (i) tuned threshold formulas as functions of `n` (since per-round total extraction depends on n), and/or (ii) a deterministic (non-random) version that still “gifts” cooperation occasionally using a state-based trigger instead of probability.
'''

description_EXPLOITATIVE_21 = '''
## Exploitative strategy: **Regrow-Then-Raid (RTR)**

**Mindset:** keep the resource productive (so there’s something to take), but capture a disproportionate share whenever opponents show willingness to sustain the stock. Punish patterns that threaten collapse only when doing so protects future extractable value; otherwise, free-ride.

The key structural fact is: when stock is healthy, your action mostly affects (a) your share **this round** and (b) whether stock stays high for future rounds. Since **D doubles your current payoff vs C at the same stock**, you want to defect whenever you expect the stock to remain high anyway (because others cooperate enough), and only cooperate when the stock is at risk of falling into a low-growth/low-payoff region.

---

# 1) Decision rules (C vs D)

### Track from history each round
Let:
- `S` = current stock at start of round.
- `kD_last` = number of opponents who defected last round (you can observe actions).
- `kC_last = (n-1) - kD_last`.
- `coop_rate` = EWMA of opponent cooperation (or simple fraction over last `w` rounds).
- `collapse_flag` = whether stock hit 0 in the recent past.

Also compute a **danger threshold** based on sustainability:
- If `m` players defect in a round (total defectors, including you), then total consumption fraction is  
  \[
  \alpha(m)=\frac{m}{n}+\frac{n-m}{2n}=\frac{n+m}{2n}
  \]
  so remaining stock is `S_remaining = S*(1 - α) = S*(n-m)/(2n)`.

If `m` is large, remaining stock becomes small and regrowth may not recover.

### Core policy (high-level)
You operate in two modes:

## Mode A — **Raid (default): defect to exploit cooperators**
Defect when stock is comfortably high *or* opponents are cooperating enough that they will maintain stock without you.

**Choose D if any of:**
1. **Stock is high:** `S >= S_high`  
2. **Opponents are cooperative:** `kC_last >= ceil((n-1)/2)` (a majority of opponents cooperated last round)
3. **Your cooperation is unlikely to change outcomes:** estimated next stock remains high even if you defect (see “stock safety check” below)

## Mode B — **Stabilize (conditional): cooperate to rebuild the resource**
Cooperate only when needed to prevent the commons from crashing, i.e., when future extraction is threatened.

**Choose C if all of:**
1. **Stock is low or falling:** `S <= S_low` OR (`S` has decreased for 2 consecutive rounds)
2. **Opponents are not sufficiently cooperative to sustain without you:** `kC_last < ceil((n-1)/2)`
3. **Your cooperation plausibly helps:** switching you from D to C increases remaining stock enough to move toward regrowth (again, “stock safety check”)

---

## Stock safety check (simple, robust heuristic)
You don’t need exact forecasting; just prevent “death spirals”.

Define thresholds (depend only on parameters):
- `S_high = 0.8 * capacity`
- `S_low  = 0.35 * capacity`
- `S_crit = 0.15 * capacity` (near-zero zone where payoffs are tiny and recovery is slow)

Heuristic:
- If `S <= S_crit`: **always C** (unless it’s the last round), because raiding yields almost nothing and risks staying near-zero.
- If `S >= S_high`: **always D** (except if you want to “seed” cooperation early; see Round 1 rule).

---

# 2) Edge cases (first round, last rounds, weird histories)

### Round 1 (bootstrapping exploitation)
You want to discover whether others will cooperate, but you also want to start extracting quickly.

**Round 1 rule:**
- If `r` is small (e.g., `r <= 3`): **D immediately** (little future value in investing).
- Otherwise: **C in round 1** to “invite” others into sustaining behavior (many adaptive strategies reciprocate), then switch to exploitation quickly.

Rationale: one early cooperative move often increases opponent cooperation in later rounds, which you then exploit by defecting while they keep stock high.

### Last round (pure raid)
**Final round:** always **D**.  
No future stock value; D strictly dominates C given same `S`.

### Last 2 rounds (endgame squeeze)
**Round r-1:**
- If `S` is high (`>= S_high`): **D**
- If `S` is very low (`<= S_crit`): still often **D** (no time to regrow meaningfully)
- Otherwise: default **D**, unless cooperating prevents immediate collapse that would drastically reduce your final-round payoff (rare; but can happen if others are cooperative and you can keep `S` from hitting ~0).

### If stock ever hits 0
If `S == 0`, payoffs are 0 regardless. Growth from 0 is 0, so it’s an absorbing state.

**If `S == 0`:** action doesn’t matter; choose **D** (tie-breaker).

### Handling noisy/mixed opponents
Use a short memory window `w` (e.g., 3–5 rounds) so you respond quickly.

- If opponents are mostly defecting recently (`coop_rate` low): stop investing; play **D** except when `S` is in the “salvageable low zone” (`S_crit < S < S_low`) where a few cooperative rounds could restore high stock and enable later raids. If too late in the game, don’t salvage.

---

# 3) Why this is exploitative (and robust)

### How you exploit
- When others cooperate enough to keep stock high, **you defect to take double** their per-round payoff.
- You only “pay” the cooperation cost when the commons is at risk, and only as much as needed to restore a high-stock environment to raid again.
- Early “C then D” specifically targets reciprocators/conditional cooperators, pulling them into a cooperative basin while you harvest.

### Why it’s robust across opponents
- Against always-cooperators / sustainability-focused bots: you mostly **D**, maintaining high stock due to them → you win.
- Against conditional cooperators: your initial C can lock them into cooperation; your later D extracts until stock threatens collapse, then you briefly stabilize and resume raiding.
- Against defectors: you don’t waste time cooperating except in narrow salvage cases; otherwise you **D** and accept the low-payoff equilibrium (best response).
- Against sophisticated punishers: since actions are simultaneous and C is costly, many punishers that respond to defection by defecting will drive stock down; RTR then switches to stabilize only if there’s enough horizon left to profit.

---

# Pseudocode (implementable)

```pseudo
initialize:
  if r <= 3: first_move = D else first_move = C
  w = 4
  S_high = 0.8 * capacity
  S_low  = 0.35 * capacity
  S_crit = 0.15 * capacity

for t in 1..r:
  observe current stock S
  if t == r: play D; continue
  if t == 1: play first_move; continue

  get kC_last from history (opponents who played C in t-1)
  compute coop_rate over last w rounds (fraction of opponent C actions)

  if S == 0: play D; continue

  if S >= S_high:
      play D; continue

  if S <= S_crit:
      if t >= r-1: play D else play C
      continue

  // mid-zone: choose mode
  if kC_last >= ceil((n-1)/2) or coop_rate >= 0.55:
      // others sustain; raid
      play D
  else:
      // risk zone; stabilize only if time to profit
      if t <= r-2 and S <= S_low:
          play C
      else:
          play D
```

---

If you want, I can also provide (a) an exact one-step stock forecast rule that compares “if I play C vs D” and chooses the action that maximizes expected **total** payoff over a short lookahead horizon, while still keeping the exploitative bias.
'''

description_EXPLOITATIVE_22 = '''
## Strategy: **Quota–Trigger Exploiter (QTE)**

Exploit the resource’s regenerative sweet spot: keep the stock high enough that *others* can keep “working” (cooperating), but take the bigger share (defect) whenever (a) you can do so without collapsing the stock, and (b) others are sufficiently cooperative that you can safely farm them. If opponents overexploit, switch immediately to punishment (defect) or “salvage mode” (cooperate) depending on whether the resource is still worth saving for your own future take.

The key is to treat each round as choosing between:
- **Harvesting** (defect) when the stock can absorb it and opponents look cooperative.
- **Tending** (cooperate) when the stock is in the vulnerable region where another heavy take would crash future value.

---

# 1) Decision rules (when to C vs D)

### Quantities computed each round \(t\)
Let:
- \(S\) = current stock at start of round
- \(h\) = number of opponents who defected last round (from history)
- \(p = h/(n-1)\) = estimated opponent defect rate (last round; you can also smooth it over a short window)

**Stock thresholds (parameter-only, simple, robust):**
- **Collapse threshold:** \(S_{\text{low}} = n\)
  - Intuition: if stock is around \(n\), one more round of heavy consumption tends to push toward very low remaining stock; recovery becomes uncertain because remaining stock after consumption can go near 0.
- **Safe-to-farm threshold:** \(S_{\text{high}} = 2n\)
  - Intuition: if \(S\) is comfortably above \(2n\), you can defect and still leave meaningful remaining stock unless everyone defects.

**Opponent cooperativeness thresholds:**
- **Cooperative field:** \(p \le 0.25\) (few opponents defect)
- **Hostile field:** \(p \ge 0.5\) (many opponents defect)

You will use these rules:

---

## Core rule set

### A. **Last round (t = r): always Defect (D)**
No future to protect; take the larger immediate payoff \(S/n\).

---

### B. **If stock is very low: “Salvage mode”**
If \(S \le S_{\text{low}} (= n)\):  
- **Play C** *unless* the table is hostile (see below).
- Exception: if \(p \ge 0.5\) (most opponents defected last round), **play D** (they’ll crash it anyway; grab what you can).

Reasoning: when stock is low, cooperating can move the system back into the high-growth region; but if others are defecting heavily, your cooperation is just donating future value you won’t receive.

---

### C. **If stock is high: “Farm mode”**
If \(S \ge S_{\text{high}} (=2n)\):  
- If opponents look cooperative (\(p \le 0.25\)), **play D**.  
- If opponents look hostile (\(p \ge 0.5\)), also **play D** (race condition; don’t be the sucker).
- Only play C in this region if you’re trying to “rebuild trust” after a punishment phase (defined below).

Reasoning: This is the main exploit: when stock is healthy and others are not over-harvesting, defecting strictly dominates cooperating *this round* and usually doesn’t immediately destroy the resource.

---

### D. **Middle stock: “Gatekeeping”**
When \(n < S < 2n\), you are in the danger zone: over-harvesting can push the remaining stock too low and reduce future total available.

Use a simple gate:

- If opponents are cooperative (\(p \le 0.25\)): **play C**  
  (tend the stock so it rebounds, then farm later)
- If opponents are mixed (0.25 < p < 0.5): **play D**  
  (they’re already taking more; take your share now)
- If opponents are hostile (\(p \ge 0.5\)): **play D**

This makes you look “conditionally responsible” only when the environment is worth saving—otherwise you pivot to extraction.

---

## Punishment / reset mechanic (to be exploitative but robust)
Track a variable `punish_timer`.

- If **stock dropped sharply** after a round where you cooperated (a signal you were exploited), or if **≥ half** the opponents defected, set:
  - `punish_timer = 2` (or 3 for larger r)
- While `punish_timer > 0`: **play D**, decrement timer each round.
- After punishment ends:
  - If \(S \le 2n\), play **C** for **1** round to attempt resource recovery (not “fairness”—just rebuilding the farm), then revert to the core rules.

**Detecting “you were exploited” (simple):**
- If you played C last round and \(S\) at start of this round is **below** what it would be under widespread cooperation (i.e., it did not rebound), treat as exploitation.
Practically: if you played C and the observed opponent defect rate last round \(p > 0.25\), trigger punishment.

---

# 2) Edge cases (first round, last round, etc.)

### Round 1 (t = 1)
Start stock is capacity (typically large, certainly ≥ 2n by parameter). You have no history.

**Play D in round 1.**
- Rationale: immediate gain, and it probes the field. Cooperative strategies often keep cooperating early; you profit. If the field is hostile, you didn’t waste a cooperation attempt.

### Last 1–2 rounds
- **t = r:** always D.
- **t = r-1:** almost always D, except:
  - If \(S \le n\) and you believe (from last-round p) the table is very cooperative (\(p \le 0.25\)), you may play **C** to raise \(S\) for the final-round defect.
  - Otherwise **D**.

This is exploitative endgame: use any remaining chance to “pump” stock only when it converts into a bigger final extraction.

### Very small r
If r is small (e.g., r=2 or r=3), there’s little time for recovery cycles.
- r=2: D then D.
- r=3: D, then use the core rule once, then D.

---

# 3) Explicit exploitative alignment

This strategy is exploitative in three ways:

1. **Default extraction:** It defects in round 1 and in the last round, and defects whenever stock is high and opponents are cooperative—systematically taking the larger share while others preserve the resource.

2. **Conditional “resource investment,” not altruism:** It cooperates only to keep the stock in a region where it can later defect for larger payouts. Cooperation is treated as capital expenditure to maintain the farm.

3. **Fast sucker-avoidance:** The moment opponents show meaningful defection (or you infer you were used), it switches into a defect punishment phase, minimizing losses to free riders and preventing being trapped as the only cooperator.

---

# Pseudocode (implementation-oriented)

```python
# Parameters: n, r, capacity
S_low  = n
S_high = 2*n

punish_timer = 0

def action(t, S, history):  # history includes last round opponent actions
    global punish_timer

    if t == r:
        return "D"

    if t == 1:
        return "D"

    # estimate opponent defect rate from last round
    opp_defects_last = count_opponent_D(history, t-1)
    p = opp_defects_last / (n-1)

    # trigger punishment if exploited / hostile
    if (my_action(history, t-1) == "C" and p > 0.25) or (p >= 0.5):
        punish_timer = max(punish_timer, 2)

    if punish_timer > 0:
        punish_timer -= 1
        return "D"

    # near-end adjustment: r-1
    if t == r-1:
        if S <= S_low and p <= 0.25:
            return "C"   # pump stock for final D
        else:
            return "D"

    # Salvage mode
    if S <= S_low:
        if p >= 0.5:
            return "D"
        else:
            return "C"

    # Farm mode
    if S >= S_high:
        # defect broadly; only cooperate if you want a one-round reset (optional)
        return "D"

    # Middle: gatekeeping
    if p <= 0.25:
        return "C"
    else:
        return "D"
```

---

If you want, I can also provide (a) a “more aggressive” variant that defects in middle stock more often, and (b) a “more patient” variant that tries harder to keep stock near a high-yield cycle when r is large.
'''

description_EXPLOITATIVE_23 = '''
Below is an explicitly exploitative, adaptive “farm-then-harvest” strategy. The core idea is:

- **Keep the stock high** when others are willing to sustain it (so the per-round pie stays large).
- **Free-ride** whenever others’ behavior implies the stock will recover anyway.
- **Switch to aggressive extraction** when cooperation is unlikely, when the stock is already sliding, or as the horizon ends.
- **Never be the sucker**: if your cooperation isn’t being “paid back” via higher future stocks, stop cooperating quickly.

---

## Key quantities you can compute from history

At round \(t\), you observe current stock \(S_t\) and previous actions.

Let:
- \(k_t\) = number of opponents who played **C** in round \(t\) (so total cooperators = \(k_t + \mathbf{1}[a_t=C]\))
- Total consumption fraction (given current stock) if you play C vs D:
  - If you play **C**: total fraction consumed = \(\frac{k_t+1}{2n} + \frac{(n-1-k_t)}{n} = \frac{2n - (k_t+1)}{2n}\)
  - If you play **D**: total fraction consumed = \(\frac{k_t}{2n} + \frac{(n-k_t)}{n} = \frac{2n - k_t}{2n}\)

Equivalently, after consumption:
- If you play **C** and total cooperators = \(K\): remaining stock \(R = S_t \cdot \frac{K}{2n}\)
- If you play **D** and total cooperators among all players = \(K\): remaining stock \(R = S_t \cdot \frac{K}{2n}\) as well, but note \(K\) differs by 1 depending on your move.

Growth function:
- \(G(R)=2R(1-R/\text{capacity})\)
- Next stock: \(S_{t+1}=\min(R+G(R),\text{capacity})\)

### A simple “stock-health” target
The growth-maximizing remainder is \(R=\text{capacity}/2\). Because \(R = S_t \cdot K/(2n)\), the **cooperator count** needed (roughly) to put remainder near \(\text{capacity}/2\) is:
\[
K^\*(S_t) \approx \frac{n\cdot \text{capacity}}{S_t}
\]
When \(S_t \approx \text{capacity}\), this is about \(n\): you’d need almost everyone cooperating to hit the peak-growth remainder. But you don’t actually need peak growth—just enough to keep the stock from collapsing.

---

## Strategy: Opportunistic Farming with Endgame Harvest (OFEH)

### Intuition
1. **Probe** early to see if opponents sustain stock.
2. **Exploit** sustainable groups by defecting most of the time while occasionally cooperating just enough to keep the stock from spiraling down (if your cooperation is pivotal).
3. **Punish / abandon** quickly if others defect a lot: defecting is then strictly better (both immediately and because stock is likely doomed anyway).
4. **Endgame**: in final rounds, shift to defection because future stock value no longer matters.

---

## Decision rules (cooperate vs defect)

We maintain two internal indicators:

- **CoopRate**: exponentially weighted moving average of opponents’ cooperation
  \[
  p_t = (1-\lambda)p_{t-1} + \lambda \cdot \frac{k_{t-1}}{n-1}, \quad \lambda \in [0.2,0.4]
  \]
  Initialize \(p_1=0.5\) (neutral).

- **StockTrend**: whether stock is recovering under current environment:
  - “Good” if \(S_t \ge S_{t-1}\) or \(S_t\) is near capacity.
  - “Bad” if \(S_t\) is falling consistently.

### Rule set
At round \(t\) with stock \(S_t\):

#### 1) Endgame harvest
- If \(t \ge r-1\) (last two rounds): **Play D**.
  - Rationale: no time to benefit from preserved stock; take maximum now.

#### 2) Collapse / low-stock regime
- If \(S_t \le S_{\text{low}}\) where \(S_{\text{low}} = \max(0.25\cdot \text{capacity},\, 2n)\): **Play D**.
  - Rationale: when stock is already low, your cooperation yields small immediate payoff and is unlikely to restore stock unless near-unanimous cooperation appears; exploit whatever remains.

#### 3) “Others are cooperative enough” → free-ride
- If \(p_t \ge p_{\text{hi}}\) (e.g. \(p_{\text{hi}}=0.65\)) **and** \(S_t \ge 0.6\cdot \text{capacity}\): **Play D** most of the time.
  - Exception: if stock has dropped for 2 consecutive rounds, temporarily switch to C for 1 round (see pivotal test below).
  - Rationale: if others keep the system healthy, defecting dominates per-round payoff.

#### 4) “Others are mostly defecting” → stop investing
- If \(p_t \le p_{\text{lo}}\) (e.g. \(p_{\text{lo}}=0.35\)): **Play D**.
  - Rationale: your cooperation won’t be rewarded; take what you can.

#### 5) Middle regime: cooperate only when your cooperation is likely pivotal
When \(p_{\text{lo}} < p_t < p_{\text{hi}}\), use a **pivotality check** based on last round’s observed cooperators \(k_{t-1}\):

- Compute expected opponents cooperators next round as \(\hat{k} = \text{round}(p_t\cdot (n-1))\).
- Compare predicted next stock if you play C vs D, assuming \(\hat{k}\) opponents cooperate.

Let:
- If you play C: \(K_C = \hat{k}+1\), remainder \(R_C = S_t \cdot K_C/(2n)\), next \(S^C_{t+1}=\min(R_C+G(R_C),cap)\)
- If you play D: \(K_D = \hat{k}\), remainder \(R_D = S_t \cdot K_D/(2n)\), next \(S^D_{t+1}=\min(R_D+G(R_D),cap)\)

Define a “future value weight” that shrinks near the end:
\[
w_t = \frac{r-t}{r}
\]
Then cooperate iff:
\[
\underbrace{\frac{S_t}{2n}}_{\text{payoff if C}} + w_t \cdot \alpha S^C_{t+1}
\;\;>\;\;
\underbrace{\frac{S_t}{n}}_{\text{payoff if D}} + w_t \cdot \alpha S^D_{t+1}
\]
Where \(\alpha\) is a scaling constant (e.g. \(\alpha=1/(2n)\)) just to put “future stock” in payoff units.

Practical simplification (works well):
- **Cooperate only if** \(S^C_{t+1} - S^D_{t+1} \ge \Delta_t\), where \(\Delta_t\) is a threshold that increases as you approach the end:
  \[
  \Delta_t = 0.1\cdot \text{capacity} \cdot \left(1 + \frac{t}{r}\right)
  \]
Otherwise **defect**.

This makes cooperation a tool you use only when it substantially prevents stock decline.

---

## Edge cases

### Round 1 (no history)
- If \(r \le 3\): **D** immediately (short horizon).
- Else:
  - If capacity is very large relative to \(n\) (e.g. \(\text{capacity} \ge 20n\)): **D** (system can tolerate more extraction; free-ride early).
  - Otherwise play **C** in round 1 as a **probe** (cheap way to test if others sustain stock), then immediately shift according to observed \(k_1\) and \(S_2\).

### Sudden regime change (opponents start defecting)
- If stock drops by more than 20% in one round (\(S_t < 0.8 S_{t-1}\)): switch to **D** for the next 2 rounds (“panic harvest”), then re-evaluate \(p_t\).
  - Rationale: don’t be the last cooperator in a collapse.

### If everyone else always cooperates
- You will mostly **D**, occasionally **C** only if the pivotality check says your defection would measurably push the system into decline. This is maximal exploitation while keeping the resource productive.

### If everyone else always defects
- You always **D**. You can’t fix it unilaterally; take what you can.

---

## Pseudocode (implementable)

```python
# parameters (tunable)
p_hi = 0.65
p_lo = 0.35
lam = 0.3

def G(R, cap):
    return 2*R*(1 - R/cap)

def next_stock(S, K, n, cap):
    R = S * (K/(2*n))
    return min(R + G(R, cap), cap)

p = 0.5
S_prev = None
drop_streak = 0
panic = 0

for t in 1..r:
    observe S_t

    if t == r or t == r-1:
        action = "D"
        play(action); continue

    if S_prev is not None:
        if S_t < 0.8*S_prev: panic = 2
        if S_t < S_prev: drop_streak += 1
        else: drop_streak = 0

    S_low = max(0.25*capacity, 2*n)
    if S_t <= S_low:
        action = "D"
        play(action); continue

    if panic > 0:
        panic -= 1
        action = "D"
        play(action); continue

    if t == 1:
        if r <= 3: action = "D"
        elif capacity >= 20*n: action = "D"
        else: action = "C"
        play(action); continue

    # update p from last round opponents' cooperation rate
    # k_last = number of opponents who played C last round (observable)
    p = (1-lam)*p + lam*(k_last/(n-1))

    if p >= p_hi and S_t >= 0.6*capacity:
        if drop_streak >= 2:
            action = "C"  # stabilize briefly if needed
        else:
            action = "D"
        play(action); continue

    if p <= p_lo:
        action = "D"
        play(action); continue

    # middle regime: pivotality test
    k_hat = round(p*(n-1))
    S_C = next_stock(S_t, K=k_hat+1, n=n, cap=capacity)
    S_D = next_stock(S_t, K=k_hat,   n=n, cap=capacity)

    Delta = 0.1*capacity*(1 + t/r)
    if (S_C - S_D) >= Delta and drop_streak >= 1:
        action = "C"
    else:
        action = "D"

    play(action)
    S_prev = S_t
```

---

## Why this is exploitative and robust

- **Exploitative:** defaults to **D** whenever it can get away with it; uses **C** only as a tool to keep the stock (and thus future exploitation opportunities) high.
- **Robust:** doesn’t assume cooperation norms; it measures actual opponent cooperation and stock response, and it “bails out” quickly during collapse.
- **Adaptive across horizons:** automatically becomes greedier as \(t\) approaches \(r\), and fully harvests in the last two rounds.
- **Handles mixed populations:** against cooperators it free-rides; against defectors it doesn’t waste effort; against conditional cooperators it does minimal “maintenance cooperation” only when it changes the state meaningfully.

If you want, I can also give a slightly more aggressive variant that explicitly tries to *induce* others to cooperate (by brief “good behavior” followed by long exploitation), but the above is usually safer in unknown tournaments with diverse AI policies.
'''

description_EXPLOITATIVE_24 = '''
Below is an exploitative, state-aware strategy that treats cooperation as an *investment* only when it is profitable to keep the stock high, and otherwise defects to extract value. It is adaptive (infers opponents’ “cooperativeness” from observed actions), robust (doesn’t require coordination or fixed schedules), and explicitly opportunistic (free-rides when others sustain the resource, but punishes/abandons quickly when they don’t).

---

## Core idea

- The stock grows logistically and is maximized when the post-consumption remaining stock is around **capacity/2**.
- Your action affects total consumption only slightly, but your payoff difference is large: **D pays 2× C** in the same round.
- Therefore:
  - **Defect whenever the stock is “safe”** (others are keeping it high).
  - **Cooperate only as much as needed** to prevent collapse *when the future is valuable* (not near the end).
  - **If opponents are depleting the stock**, switch to **strip-mining** (always defect), because your restraint won’t save the resource and just gives up payoff.

---

## State quantities computed from history

At the start of round `t`, you know current stock `S_t` and past actions.

Let:
- `k_{t-1}` = number of players who defected last round (you can observe actions).
- `p_t` = estimated defection rate among opponents (smoothed):
  - Maintain `p` initialized at 0.5.
  - After each round: `p ← 0.7*p + 0.3*( (#defectors among opponents)/ (n-1) )`.

Define a **collapse-risk indicator** from last round’s realized behavior:
- If last round consumption drove the stock low (or to 0), the system is fragile.
- Use threshold on current stock too.

Key thresholds (parameter-only; no tuning to opponents):
- `S_low = capacity / 4` (danger zone)
- `S_mid = capacity / 2` (sweet spot for growth)
- `S_high = 3*capacity / 4` (safe zone)
- “Late game” starts when `t > r - ceil(r/5)` (final 20% of rounds)

---

## Decision rules (C vs D)

### Rule 0: Last-round/last-phase greed
- **If `t == r` (final round): play D.**
  - No future to protect.

- **If `t` is in the last 20% of rounds:**
  - Play **D unless stock is in danger and opponents are mostly cooperating** (see Rule 2).

This guarantees you cash out late.

---

### Rule 1: If opponents are not sustaining, abandon (strip-mine)
If either condition holds, you assume the pool is effectively doomed and you maximize immediate payoff:

- **Condition A (high defection environment):** `p_t ≥ 0.5`  
  (At least half of opponents tend to defect.)
- **Condition B (stock already stressed):** `S_t ≤ S_low` and `p_t ≥ 0.3`

**Action:** play **D**.

Rationale: In these environments, your cooperation rarely changes the trajectory, but always halves your payoff.

---

### Rule 2: If stock is endangered but salvageable, “reluctant conservation”
If you are *not* in strip-mine mode (Rule 1 didn’t trigger) and:

- `S_t ≤ S_mid` (≤ capacity/2), **and**
- `p_t < 0.5` (opponents lean cooperative), **and**
- `t` is not late game (not in last 20%)

**Action:** play **C**.

Rationale: When others are mostly cooperating, stock can rebound strongly; cooperating here is an investment that preserves many future rounds with high S.

This is the only sustained-cooperation regime, and it’s conditional on opponents being sufficiently cooperative.

---

### Rule 3: Otherwise, free-ride
In all other cases, **play D**.

In particular:
- If `S_t` is moderate/high and opponents are cooperative: defect to exploit their restraint.
- If `S_t` is high, even if others sometimes defect: defect now, evaluate again next round.

---

## First-round behavior

**Round 1:** play **D**.

Reason:
- You start at `S_1 = capacity` (max), so there is no immediate danger.
- Defecting is the best probe: you learn how others respond while taking the higher payoff.
- If the table is cooperative, the resource may remain healthy anyway; if not, you’ve lost nothing by “being nice.”

---

## Additional edge-case safeguards

1. **If stock hits 0 at the start of your turn (`S_t = 0`)**: action irrelevant for payoff (0 either way).  
   Play **D** (default exploitative stance).

2. **If capacity is barely above `2n` (small buffer)**: the system is inherently fragile.  
   Tighten salvage: replace `S_low = capacity/3` (instead of capacity/4). This makes you cooperate slightly earlier *only when opponents are cooperative*, otherwise you strip-mine.

3. **If you observe “near-unanimous cooperation” for several rounds** (e.g., `k_{t-1} == 0` for 2 consecutive rounds):
   - Still defect unless `S_t ≤ S_mid` and it’s not late game.
   - This is the exploitative core: you do not “reward” their cooperation with your own except to prevent collapse.

---

## Pseudocode

```python
# parameters: n, r, capacity
# inputs each round t: current stock S, history of actions

p = 0.5  # opponent defection tendency (EMA)

for t in 1..r:

    if t > 1:
        opp_def_last = count_defectors_among_opponents(t-1) / (n-1)
        p = 0.7*p + 0.3*opp_def_last

    late_game = (t > r - ceil(r/5))
    S_low = capacity/4
    S_mid = capacity/2
    # optional fragility adjustment:
    if capacity <= 3*n:
        S_low = capacity/3

    # Rule 0: endgame cash-out
    if t == r:
        action = "D"
    else:
        # Rule 1: strip-mine if others won't sustain or stock is stressed under defection
        if (p >= 0.5) or (S <= S_low and p >= 0.3) or late_game:
            # late_game included here except when salvage triggers below
            action = "D"

            # allow one exception in late game only if salvage is very profitable:
            if late_game and S <= S_mid and p < 0.2:
                action = "C"  # rare: keep stock from crashing while others cooperate
        else:
            # Rule 2: reluctant conservation
            if (S <= S_mid) and (p < 0.5) and (not late_game):
                action = "C"
            else:
                # Rule 3: free-ride
                action = "D"

    play(action)
```

---

## Why this is exploitative (explicitly)

- **Baseline is defection** (Round 1 D; last round D; most states D).
- **Cooperation is only used instrumentally** as a *minimal* intervention to keep the resource from collapsing **when others are already doing most of the work** and there’s enough horizon left to benefit.
- Against cooperative groups, you **free-ride**: you defect while they stabilize the stock, earning roughly double per round.
- Against defect-heavy groups, you **do not waste payoff** trying to save an unsalvageable resource; you defect and extract whatever remains.

This tends to score high in heterogeneous tournaments because it:
- exploits unconditional or generous cooperators,
- avoids being the “sucker” in mixed/defective populations,
- still preserves long-run returns when a cooperative ecosystem exists (by cooperating only when it prevents collapse).
'''

description_EXPLOITATIVE_25 = '''
### Strategy: **Harvester–Extortion with Stock Guardrails (HESG)**  
Core idea: **Free-ride whenever opponents keep the stock healthy; punish hard (defect) when they don’t; only cooperate as an investment to restore stock when it’s profitable and when opponents show they will actually sustain it.** This is exploitative because it tries to hold the group near a “high stock” regime while you take the larger share (D) whenever possible, and it uses credible, state-based punishment to deter opponents from collapsing the resource.

---

## Key observations (driving the rules)

Let current stock be \(S\). Your one-shot gain from defecting vs cooperating is always:
- \( \pi(D) - \pi(C) = S/n - S/(2n) = S/(2n) > 0\)

So **D strictly dominates C in the stage game**, but repeated stock dynamics create an investment motive: if everyone defects, stock hits 0 and stays 0.

The stock update after total consumption depends only on the **fraction of stock remaining**:
- If \(k\) players defect and \(n-k\) cooperate, total consumption fraction is  
  \[
  \frac{k}{n} + \frac{n-k}{2n} = \frac{n+k}{2n}
  \]
  so remaining fraction is  
  \[
  x = 1 - \frac{n+k}{2n} = \frac{n-k}{2n}
  \]
- Growth is logistic and is maximized around \(x \approx 1/2\) (i.e., remaining stock around half capacity).  
- Importantly, if **all defect** (\(k=n\)), then \(x=0\) and the stock becomes 0 forever.

Thus we want to:
1) **Exploit** when others keep \(k\) small enough that stock rebounds.
2) **Punish** when others let \(k\) get large (or try to exploit you).
3) **Invest** (cooperate) only when it meaningfully increases future stock and only if opponents seem likely to sustain it.

---

## State you track from history
At end of each round \(t\), you can infer:
- \(k_t\): number of other players (excluding you) who played D.
- \(S_t\): stock at start of round \(t\) (given).
- A short “trust score” of the group: e.g., an exponentially-weighted average of defection rate:
  \[
  q_t = (1-\alpha) q_{t-1} + \alpha \cdot \frac{k_t}{n-1}
  \]
  with \(\alpha \in [0.2,0.4]\). Initialize \(q_1 = 0.5\).

Also track:
- `punish_timer`: how many rounds remain in a punishment phase.

---

## Decision rules (C vs D)

### 0) Edge rounds
- **Last round (t = r): Always D.**  
  No future to invest in.

- **First round (t = 1): Default D**, *unless* capacity is huge relative to \(2n\) and you want an “investment probe.” Since the game already starts at capacity, probing is not needed. Starting with D is maximally exploitative and tests whether others are willing to carry the stock.

### 1) Stock guardrails (prevent irreversible collapse)
There is one catastrophic region: once \(S\) is low and many defect, the system can spiral to 0 quickly.

Define a *critical stock threshold*:
- \(S_{\text{crit}} = \max\left(\frac{\text{capacity}}{4},\; 2n\right)\)

Rule:
- If \(S_t \le S_{\text{crit}}\):  
  - **Cooperate (C)** *unless* it’s the last round or you are already in “collapse acceptance” (see below).
Rationale: when stock is low, you cooperate as an *investment* to avoid hitting 0. This is still exploitative because you only do it when it protects your ability to exploit later.

### 2) Default exploitation when stock is healthy
If \(S_t > S_{\text{crit}}\) and not in punishment:
- **Defect (D)**.

This is the baseline: you take the bigger share while the pool is healthy.

### 3) Punishment: make defecting by others unprofitable (or at least painful)
Start a punishment phase when opponents’ behavior suggests they are not sustaining the resource.

Trigger punishment if **either**:
- **High current defection:** \(k_{t-1} \ge \lceil (n-1)/2 \rceil\) (a majority of others defected last round), **or**
- **Persistent moderate defection:** \(q_{t-1} \ge 0.45\)

Punishment action:
- During punishment: **Always D** for \(L\) rounds, where
  \[
  L = 1 + \left\lceil \frac{r-t}{4} \right\rceil
  \]
  (shorter punishment near endgame, longer earlier).

Exit punishment early if opponents become cooperative:
- If in the most recent round, \(k_{t-1} \le 1\) (at most one other defector), then set `punish_timer = 0` after completing the current punishment round.

Why punishment = D (not C)? Because C “rewards” defectors by increasing future stock they can steal. Defecting in response **depletes the stock** and makes their short-run exploitation less sustainable. This is harsher and more exploitative.

### 4) Controlled “rebuild” (conditional cooperation to restore a profitable stock)
After punishment or after low-stock cooperation, you want to rebuild only if others likely will.

Enter a rebuild mode when:
- \(S_t \le 0.6 \cdot \text{capacity}\) **and**
- recent defection is low: \(q_{t-1} \le 0.25\) and \(k_{t-1} \le 1\) **and**
- there are at least 2 rounds left: \(t \le r-1\)

Rebuild rule:
- Play **C** for exactly 1 round (“investment tick”), then revert to default exploitation (D) unless stock is still below \(S_{\text{crit}}\).

This is exploitative “one-step investing”: you contribute minimally to push stock upward, then harvest.

### 5) Collapse acceptance (don’t throw good effort after bad)
If the group is clearly intent on mutual destruction, stop investing.

If for the last two rounds:
- \(k_{t-1} \ge \lceil (n-1)/2 \rceil\) **and** \(k_{t-2} \ge \lceil (n-1)/2 \rceil\),
then set a flag `doomed = true`.

When `doomed = true`:
- **Always D** (even if stock is low).  
Rationale: you won’t rescue a pool that others will immediately raid; you maximize remaining extraction.

---

## Pseudocode summary

```pseudo
init:
  q = 0.5
  punish_timer = 0
  doomed = false

for t in 1..r:
  if t == r:
    play D
    continue

  Scrit = max(capacity/4, 2*n)

  if t > 1:
    observe k_prev  # number of other defectors last round
    q = (1-alpha)*q + alpha*(k_prev/(n-1))

    if t > 2 and k_prev >= ceil((n-1)/2) and k_prev2 >= ceil((n-1)/2):
      doomed = true

  if doomed:
    play D
    continue

  if punish_timer > 0:
    play D
    punish_timer -= 1
    # early exit condition handled next round via punish_timer reset logic
    continue

  # trigger punishment
  if t > 1 and (k_prev >= ceil((n-1)/2) or q >= 0.45):
    L = 1 + ceil((r - t)/4)
    punish_timer = L - 1
    play D
    continue

  # stock guardrail
  if S_t <= Scrit:
    play C
    continue

  # controlled rebuild: one-step invest if group looks cooperative and stock not high
  if S_t <= 0.6*capacity and t > 1 and q <= 0.25 and k_prev <= 1:
    play C
    continue

  # default exploitation
  play D
```

(Implementation detail: store `k_prev2` and update it each round; also, if you want the “exit punishment early” behavior, after each round in punishment, if observed `k_prev <= 1`, you can set `punish_timer = 0`.)

---

## Why this is exploitative and robust

- **Exploitative baseline**: defects whenever it’s safe/lucrative, using others’ cooperation to maintain the resource.
- **Minimal investment**: cooperates mainly as a *guardrail* (to avoid total collapse) or a *single-step rebuild* when it expects to harvest later.
- **Harsh deterrence**: responds to widespread defection with sustained defection, accelerating depletion and making “steal and run” strategies less profitable over time.
- **Adaptive to mixed populations**:  
  - Against mostly cooperators: you mostly defect and earn ~double their per-round payoff while stock stays high.  
  - Against mostly defectors: you don’t waste effort rescuing; you defect and take what remains.  
  - Against conditional cooperators/punishers: your punish/rebuild logic can stabilize the stock enough to keep extracting, while your last-round D captures endgame value.

If you want, I can also provide parameter tweaks (e.g., thresholds for \(S_{\text{crit}}\), \(q\), punishment length) optimized for different \(n, r, \text{capacity}\) regimes.
'''

description_EXPLOITATIVE_26 = '''
## Strategy: **Harvester–Extortion with Stock Guardrails (HESG)**

Goal: maximize your total payoff by (i) taking the high action **D** whenever it is safe or when others already degrade the resource, (ii) extracting extra surplus from cooperators by defecting against them, and (iii) only cooperating when it is necessary to keep the stock from collapsing or when doing so credibly “buys” future stock from mostly-cooperative opponents.

This is an exploitative, state-aware variant of “grim-with-forgiveness,” but tuned to the ecology: stock dynamics are nonlinear and collapse is irreversible if everyone defects at high stock.

---

# Key quantities you compute each round

Let current stock be `S`.

**Per-player consumption:**
- If you play `C`: `cC = S/(2n)`
- If you play `D`: `cD = S/n`

**Infer how many others defected last round (from observed actions):**
- `k = # of opponents who played D in previous round` (0…n-1)

**Predict next stock if you choose C or D given you expect opponents to repeat last round’s mix (best default when no comms):**

If `m` total defectors this round, total consumption fraction is:
- each C consumes `S/(2n)` and each D consumes `S/n = 2*S/(2n)`
- total consumption = `S/(2n) * ((n-m) + 2m) = S*(n+m)/(2n)`
- remaining stock after consumption:  
  `R(m) = S - S*(n+m)/(2n) = S*(n-m)/(2n)`

Growth is logistic:
- `G(R) = 2*R*(1 - R/capacity)`
- next stock: `Snext = min(R + G(R), capacity)`

So if opponents repeat last round:
- If you play **C**: expected defectors `mC = k`
- If you play **D**: expected defectors `mD = k+1`

Compute:
- `R_C = S*(n - k)/(2n)`
- `R_D = S*(n - (k+1))/(2n) = S*(n-k-1)/(2n)`
- Then compute `Snext_C`, `Snext_D`.

This gives a one-step ecological consequence of your action.

---

# Decision rules (cooperate vs defect)

You will use **three modes**: **Exploit**, **Guard**, **Punish**.

## 1) Exploit mode (default)
Defect whenever stock is healthy enough that you can safely take more now *without pushing the system into a low-stock trap*, and whenever opponents are cooperating enough to be worth exploiting.

**Rule E (Defect for profit):** Play **D** if all are true:
1. **Not the last round** (or if last round, see endgame below),
2. Stock is not in the danger zone: `S ≥ S_safe`
3. Your defection does not push predicted next stock below the danger zone: `Snext_D ≥ S_floor`
4. Opponents are “cooperative enough” to exploit: `k ≤ k_exploit`

Where parameters are:
- `S_safe = 0.6 * capacity`  (resource is abundant)
- `S_floor = 0.35 * capacity` (below this, recovery is slower and riskier)
- `k_exploit = floor((n-1)/3)` (if too many already defect, join punish/guard instead of “solo exploit”)

Intuition: defecting against mostly-cooperators gives you 2× the stage payoff, while stock can still rebound.

## 2) Guard mode (resource preservation to enable future exploitation)
If stock gets low or your defection would likely drive it too low, you cooperate to keep the resource productive—*not out of kindness, but to keep the asset alive for later harvesting*.

**Rule G (Cooperate to stabilize stock):** Play **C** if any are true:
- `S < S_safe` **and** (`Snext_D < S_floor` or `S < S_floor`)
- or `k` is moderate/high and stock is trending down (see trend rule below)

**Trend rule (anti-collapse):**
Maintain a short memory of stock: `ΔS = S - S_prev`.
If `ΔS < 0` for **2 consecutive rounds**, switch to Guard mode (play C) until stock recovers above `S_safe`.

This prevents getting dragged into a death spiral caused by others defecting.

## 3) Punish mode (discipline defectors; don’t subsidize them)
When many opponents defect, cooperating merely props up the stock for them to steal next round. Then you defect as well—even if it collapses—because your relative loss from “being the sucker” is worse than the ecological loss you can’t unilaterally prevent.

**Rule P (Defect when others defect):** Play **D** if:
- `k > k_exploit` (too many defectors), **unless** stock is already near-collapse (`S < S_floor`) in which case you still defect (take what’s left).

This is exploitative in the sense that you refuse to fund others’ high take rates.

---

# Edge cases and special phases

## First round
You don’t know opponents yet, but stock is at capacity, so it’s the best time to harvest.

**Round 1 action: `D`.**  
Rationale: if others cooperate, you exploit immediately; if many defect, the stock collapses anyway and you still got max payout.

## Last round (round r)
No future stock value exists, so pure myopic payoff dominates.

**Last round action: `D` always.**

## Second-to-last round (round r-1)
There is only one future round. You mainly want stock to be high at start of the last round because you will defect then.

Play **C** in round r-1 **only if** it increases expected last-round stock enough to outweigh the immediate loss from not defecting.

Operational rule:
- Compute `Snext_C` vs `Snext_D` (assuming opponents repeat last mix).
- Compare total of (round r-1 payoff + round r payoff if you defect in r):
  - If you play C now: `pay_C = S/(2n) + Snext_C/n`
  - If you play D now: `pay_D = S/n + Snext_D/n`
- Choose C in r-1 iff `pay_C > pay_D`, else D.

This is a tight exploitative endgame calculation.

---

# Robust adaptivity to opponent behaviors

## Detect “always-cooperate” / highly cooperative populations
If in the last `W=3` rounds you observe `k=0` (no opponent defects), then you are in a cooperators’ field.

**Response:** defect continuously (Exploit mode) until stock approaches guardrails:
- Keep playing D while `S ≥ S_safe` and `Snext_D ≥ S_floor`.
- If stock approaches the floor, temporarily cooperate (Guard mode) to rebuild, then resume defecting.

This yields an extortion-like cycle: you “farm” cooperators but keep the common pool productive.

## Detect “always-defect” / highly noncooperative populations
If in the last `W=3` rounds `k ≥ n-2` consistently, cooperation cannot rescue the system alone.

**Response:** defect always (Punish mode).  
Take maximum while it exists; do not waste rounds cooperating.

## Mixed/conditional opponents (Tit-for-Tat-like, grim-like, reactive)
These opponents often condition on whether they saw you defect.

The strategy’s guardrails serve two purposes:
- If your defection triggers retaliation and stock starts dropping, the **trend rule** pushes you into temporary cooperation to restore stock.
- Once stock is high again, you defect again unless retaliation persists.

This tends to produce either:
- A stable “you defect often, they sometimes cooperate” regime (good for you), or
- Mutual defection if they refuse to tolerate exploitation (you still avoid being the sole cooperator).

---

# Pseudocode (implementable)

```python
# parameters
S_safe  = 0.60 * capacity
S_floor = 0.35 * capacity
W = 3
k_exploit = (n-1)//3

# state memory
history_stock = []     # store S each round start
history_k = []         # store k each round (opponents D count)

def predict_Snext(S, m):  # m = total defectors this round
    R = S*(n - m)/(2*n)
    G = 2*R*(1 - R/capacity)
    return min(R + G, capacity)

def action(t, S, last_opponent_actions):
    # t in {1..r}
    if t == r:
        return "D"

    if t == 1:
        return "D"

    k = count_defectors(last_opponent_actions)  # among n-1 opponents
    history_k.append(k)
    history_stock.append(S)

    # trend check: two consecutive declines
    trend_down = False
    if len(history_stock) >= 3:
        if history_stock[-1] < history_stock[-2] and history_stock[-2] < history_stock[-3]:
            trend_down = True

    # endgame: round r-1 lookahead
    if t == r-1:
        Snext_C = predict_Snext(S, m=k)
        Snext_D = predict_Snext(S, m=k+1)
        pay_C = S/(2*n) + Snext_C/n
        pay_D = S/n + Snext_D/n
        return "C" if pay_C > pay_D else "D"

    # general lookahead guardrails
    Snext_D = predict_Snext(S, m=k+1)

    # Punish if too many defect
    if k > k_exploit:
        return "D"

    # Guard if stock low or defection risks dropping too low or downward trend
    if S < S_safe and (S < S_floor or Snext_D < S_floor or trend_down):
        return "C"

    # otherwise exploit
    if S >= S_safe and Snext_D >= S_floor:
        return "D"

    # fallback
    return "C"
```

---

# Why this is exploitative (explicitly)

- **Starts with D** to immediately capture surplus from naive/hopeful strategies.
- **Defects in any endgame** (last round always; r-1 unless cooperating materially increases the final harvest).
- **Uses cooperation only instrumentally** to keep the stock in a productive range (a renewable asset), not to match norms.
- **Refuses to subsidize defectors**: when many defect, you defect too (punish), avoiding the “sucker” position.
- **Adapts to the ecology** using state-based guardrails and trend detection, making it robust against both collapse-prone and cooperative populations.

If you share typical tournament ranges for `(n, r, capacity)` I can tune the `S_safe/S_floor` thresholds and `k_exploit` more aggressively for expected regimes.
'''

description_EXPLOITATIVE_27 = '''
## Strategy: **Regenerative Extortion with Grim-Drain (REGD)**  
Goal: keep the stock in a high-growth “sweet spot” so the game remains lucrative, but *systematically take the larger share* whenever others allow it; if they don’t, switch to *rapid depletion* so you don’t get exploited while waiting.

The core idea is:
- **When others are mostly cooperating**, you **defect** to harvest ~2× their per-round payoff while the resource still regenerates.
- **When others defect too much**, the stock will collapse anyway; you **defect** as well (and often accelerate collapse), because trying to “save” the stock alone is unprofitable.
- **If you can plausibly stabilize the stock**, you sometimes cooperate *only as much as needed* to keep the stock in a regenerative range.

---

# 1) Decision rules (C vs D)

### Observables each round \(t\)
- Current stock \(S_t\)
- History of actions: how many opponents cooperated last round, etc.
- Let:
  - \(k_{t-1} =\) number of opponents who played **C** last round (out of \(n-1\))
  - \(d_{t-1} = (n-1) - k_{t-1}\)
  - \(p_{t-1} = d_{t-1}/(n-1)\) = observed opponent defection rate last round

### Key stock thresholds (computed from parameters)
Let:
- **Collapse threshold**: \(S_{\text{low}} = 2n\) (near the minimum feasible / fragile region)
- **Regeneration target band**:  
  - \(S_{\text{mid}} = 0.5 \cdot \text{capacity}\) (max growth for logistic)  
  - \(S_{\text{high}} = 0.8 \cdot \text{capacity}\) (still high, but avoid needless waste via hitting the cap)

### Rule A: Endgame extraction
- **If \(t\) is the last round**: play **D**.
- **If \(t\) is the second-to-last round and stock is not critically low**: also usually **D** (details in edge cases).

Rationale: no future to protect; take maximum.

---

### Rule B: If stock is fragile, drain (don’t be the “rescuer”)
If \(S_t \le S_{\text{low}}\): play **D**.

Rationale: when stock is low, your C yields tiny payoff and others’ D will keep it low; better to secure the larger share now.

---

### Rule C: Extort cooperators (the default in healthy stock)
If \(S_t \ge S_{\text{mid}}\) **and** opponents are mostly cooperating:
- If \(p_{t-1} \le 0.25\) (≥75% of opponents cooperated last round): play **D**.

Rationale: With strong cooperation, the system regenerates; you “free-ride” with D and earn double cooperators’ payoff.

---

### Rule D: Punish meaningful defection (avoid being the sucker)
If opponents show nontrivial defection:
- If \(p_{t-1} \ge 0.35\): play **D**.

Rationale: once defection is common, cooperating is mostly wasted; defect to avoid exploitation and to race for payoff before stock collapses.

---

### Rule E: Minimal cooperation to keep the goose laying golden eggs
This is the only time you choose **C**: when (1) stock is in a “recoverable but not safe” range and (2) opponents are cooperating enough that your cooperation can keep the system productive.

Condition:
- If \(S_{\text{low}} < S_t < S_{\text{mid}}\) **and** \(p_{t-1} < 0.35\): play **C**.
- Otherwise play **D**.

Rationale: Below ~0.5 capacity, growth is strong; modestly reduced extraction can restore stock upward. You cooperate *only* when there’s evidence others will not simply defect and nullify your sacrifice.

---

## Summary decision table
Given \(S_t\), \(p_{t-1}\), and round \(t\):

1. If \(t=r\): **D**
2. Else if \(S_t \le 2n\): **D**
3. Else if \(p_{t-1} \ge 0.35\): **D**
4. Else if \(S_t \ge 0.5\,cap\) and \(p_{t-1} \le 0.25\): **D**
5. Else if \(2n < S_t < 0.5\,cap\) and \(p_{t-1} < 0.35\): **C**
6. Else: **D**

This is intentionally D-leaning: C is a *maintenance investment*, not a norm.

---

# 2) Edge cases and special handling

### First round (no history)
Default to **D**, unless the game is very long and capacity huge relative to \(n\). Concretely:

- If \(r \ge 10\) and \(\text{capacity} \ge 10n\): play **C** in round 1 **only** to “test” for cooperative populations (you still flip to D quickly if they cooperate).
- Otherwise: **D**.

Rationale: The biggest exploit opportunities come from identifying cooperative fields; a single probe C can be worth it in long games, but in shorter games you just take.

---

### Last two rounds
- Round \(r\): **D**
- Round \(r-1\): **D** unless stock is already so low that D and C are nearly identical (i.e., \(S_{r-1} \le 2n\)); then still **D** (no reason to be nice).

Rationale: backward induction pressure—no point preserving stock.

---

### “One defector” detection (avoid being the only cooperator)
If last round **you played C** and **any** opponent played D (i.e., \(p_{t-1} > 0\)):
- Switch to **D** immediately for the next round.
- Require **two consecutive rounds** of low defection (\(p \le 0.25\)) before you ever play C again.

Rationale: prevents strategies that bait you into “resource maintenance” while they free-ride.

---

### Recovery attempt cap (don’t throw good money after bad)
If stock has been trending downward for 3 consecutive rounds (estimate via observed \(S_{t}\) sequence) **and** opponents are not improving (defection rate not falling):
- Lock into **D** for the remainder of the game.

Rationale: once the population is effectively defecting, your C cannot rescue the system; shift to extraction.

---

# 3) Why this is exploitative (and robust)

### Exploit cooperative groups
When others cooperate, your D payoff is exactly double a cooperator’s:  
- Cooperator payoff: \(S/(2n)\)  
- Defector payoff: \(S/n\)

REGD defects in the “safe stock, low defection” regime, extracting maximum while the stock is still maintained by others.

### Avoid being exploited by defectors
As soon as defection becomes meaningful, REGD defects. It does not “teach cooperation”; it *protects itself* and races for remaining value.

### Only cooperate as a self-serving investment
REGD cooperates only when:
- stock is low enough that growth is valuable,
- opponents are sufficiently cooperative that your sacrifice is not simply stolen,
- and continuing a productive stock benefits you in future rounds.

This makes it adaptive across:
- Always-cooperate opponents (you free-ride)
- Always-defect opponents (you defect and drain)
- Conditional cooperators (you can sometimes keep the system alive while still defecting often)
- Noisy / mixed strategies (the thresholds and “two-round forgiveness” reduce flip-flopping)

---

# Pseudocode (implementable)

```python
def action(t, r, n, capacity, S_t, history_actions, history_stock):
    # thresholds
    S_low  = 2*n
    S_mid  = 0.5 * capacity

    def opp_defection_rate(last_round_actions):
        # last_round_actions: list of opponents' actions 'C'/'D'
        if last_round_actions is None: 
            return None
        d = sum(1 for a in last_round_actions if a == 'D')
        return d / (n-1)

    # last round => defect
    if t == r:
        return 'D'

    # first round handling
    if t == 1:
        if r >= 10 and capacity >= 10*n:
            return 'C'  # probe
        return 'D'

    last_opp = history_actions[t-1]["opponents"]  # list length n-1
    p = opp_defection_rate(last_opp)

    # if stock fragile => defect
    if S_t <= S_low:
        return 'D'

    # anti-sucker rule: if we cooperated and anyone defected => defect next
    my_last = history_actions[t-1]["me"]
    if my_last == 'C' and p > 0:
        return 'D'

    # downward trend lock-in
    if t >= 4:
        if history_stock[t-1] < history_stock[t-2] < history_stock[t-3]:
            # if opponents not getting more cooperative, give up on recovery
            # (simple proxy: p not decreasing meaningfully)
            p1 = opp_defection_rate(history_actions[t-1]["opponents"])
            p2 = opp_defection_rate(history_actions[t-2]["opponents"])
            if p1 is not None and p2 is not None and p1 >= p2 - 0.05:
                return 'D'

    # meaningful defection => defect
    if p >= 0.35:
        return 'D'

    # safe stock + cooperative opponents => exploit
    if S_t >= S_mid and p <= 0.25:
        return 'D'

    # only cooperate as investment to rebuild stock
    if (S_low < S_t < S_mid) and (p < 0.35):
        return 'C'

    return 'D'
```

---

If you share typical tournament parameter ranges (e.g., common \(n\), \(r\), and capacity), I can tune the numeric thresholds (0.25/0.35, 0.5 capacity) for higher exploitation without accidentally collapsing the stock too early.
'''

description_EXPLOITATIVE_28 = '''
Below is an explicitly **exploitative, history-based** strategy designed to (i) **harvest** cooperative opponents, (ii) **avoid being the sucker** against defectors, and (iii) **not accidentally crash the stock too early** when future exploitation value is high.

I’ll call it **Harvest–Test–Punish (HTP)**.

---

## Core idea (exploitative mindset)

- **Cooperation is an investment** only when it keeps the stock high enough to later take larger D-shares.
- **Defection is the default** whenever others appear willing to sustain the stock anyway (so you can free-ride).
- If others are not sustaining the stock, **switch to minimum-sustainable cooperation** (not “nice” cooperation) to keep the resource exploitable in later rounds.
- Use **short, sharp punishment** when others defect “too much,” but do not waste long altruistic punishments—your goal is to restore a profitable regime, not teach morality.

---

## Quantities to compute each round

Let:
- `S_t` be current stock at start of round `t`.
- From last round, observe `kD_{t-1}` = number of opponents who played D (since perfect monitoring).
- Define opponent defection rate last round:  
  `d_{t-1} = kD_{t-1} / (n-1)`.

### Sustainability threshold (key exploitation control)
If `k` players defect in a round (total D-players = k), total consumption fraction is:

- Cooperators consume: `(n-k) * S/(2n)`
- Defectors consume: `k * S/n`
- Total consumption = `S * [ (n-k)/(2n) + k/n ] = S * (n+k)/(2n)`

So remaining stock after consumption:
- `S_rem = S * (1 - (n+k)/(2n)) = S * (n-k)/(2n)`

To keep the stock from spiraling toward zero, you want `S_rem` not too small. A clean, parameter-based “safe” target is:
- **Aim for `S_rem ≥ capacity/2`**, because logistic growth is maximal at `capacity/2` and rebounds strongly.

That condition implies:
`S * (n-k)/(2n) ≥ capacity/2`  
At `S ≈ capacity` this reduces to:
`(n-k)/(2n) ≥ 1/2` → `n-k ≥ n` → `k ≤ 0`

Meaning: **when stock is near capacity, any defection reduces S_rem below capacity/2.** That’s fine occasionally, but repeated defection lowers growth potential.

So we instead use an adaptive “do-not-crash” rule based on *current* stock:
- Define a **crash buffer** `B = max(capacity/(2), 2n)` (keeps you away from very low stock where payoffs collapse).
- Predict next remaining stock if you defect vs cooperate given an estimate of others’ defection count.

---

## Strategy overview

### Modes
1. **Probe mode (early testing)**: identify if opponents are sustainers (cooperators) you can exploit.
2. **Harvest mode (exploit)**: defect when the group is keeping stock healthy.
3. **Stabilize mode (minimal cooperation)**: cooperate only enough to prevent stock collapse when nobody else will.
4. **Endgame mode**: defect aggressively near the end because future stock has low value.

---

## Decision rules

### Round 1 (no history)
**Play D** unless `r` is extremely long *and* `capacity` is huge relative to `n` (rare). In tournaments, defaulting to D:
- instantly exploits unconditional cooperators,
- tests whether others retaliate,
- and you lose little if others also defect (since you’d get the same as cooperating only half).

**Rule:** `if t == 1: play D`.

---

### Rounds 2 to r-2: adaptive play

Maintain two rolling indicators (use last 3 rounds if available):
- `avg_d` = average opponent defection rate over last `m = min(3, t-1)` rounds.
- `trendS` = whether stock is falling fast: e.g., `S_t < 0.7 * S_{t-1}`.

#### A) Harvest (exploit cooperators)
If opponents are mostly cooperating and stock is healthy, **defect**.

**Condition (easy trigger):**
- `avg_d ≤ 0.33` (at most ~1/3 of opponents defecting on average), and
- `S_t ≥ 0.6 * capacity`

**Action:** play **D**

Rationale: others are doing the work keeping stock up; you take the larger share.

#### B) Stabilize (when stock is at risk)
If stock is getting low, you sometimes need to cooperate to keep future exploitation alive.

**Condition:**
- `S_t ≤ 0.35 * capacity` **or** `S_t ≤ 4n` **or** `trendS is sharply negative`

**Action:** play **C** *unless* opponents are still heavily defecting (see punishment).

Rationale: At low S, the marginal value of preserving stock is high because future payoffs scale with S.

#### C) Punish / Refuse-to-fund (against defect-heavy groups)
If opponents are defecting a lot, do **not** waste cooperation propping them up.

**Condition:**
- `avg_d ≥ 0.6` (most opponents defect), and
- `t ≤ r-2` (still time, but don’t subsidize)

**Action:** play **D** (even if stock is falling)

Rationale: If they are mostly defectors, your cooperation mainly transfers value to them and delays the inevitable; exploit now.

#### D) Mixed middle case (opponents somewhat mixed)
When `avg_d` is moderate (0.33–0.6), use a **stock-sensitive threshold**:

- If `S_t ≥ 0.5 * capacity`: **D**
- Else: **C**

Rationale: When stock is high, defecting is profitable and not immediately catastrophic; when stock is medium/low, cooperate to preserve the “goose.”

---

### Round r-1 and r (endgame strip-mining)
Future stock after the final round is worthless. So switch to endgame extraction.

**Rule:**
- If `t ≥ r-1`: play **D** unconditionally.

This is the clearest exploitative move, and it’s robust: even if others cooperate, you gain; if others defect, you avoid being the only cooperator.

---

## Edge cases and tie-breakers

1. **Stock already near zero (`S_t ≈ 0`)**  
   Actions barely matter; defect to avoid subsidizing any last rebound that others could exploit.
   - If `S_t < 1`: play **D**

2. **Stock at capacity and others cooperate a lot**  
   This is the best exploitation environment: always D until you see stock falling to the stabilize threshold.
   - Covered by Harvest rule.

3. **If your last cooperation was “rewarded” by others cooperating**  
   Don’t become nice—use that to harvest.
   - If you played C last round and `kD_{t-1} == 0`, then play **D** next round (one-step betrayal).

4. **If everyone defects and stock hits 0 early**  
   No strategy can recover payoff; defect throughout.

---

## Pseudocode (implementable)

```pseudo
function action(t, S_t, capacity, n, r, history):
    if t == 1:
        return D

    if t >= r-1:
        return D

    m = min(3, t-1)
    avg_d = average_over_last_m_rounds( kD / (n-1) )

    if S_t < 1:
        return D

    trendS = (t >= 2) and (S_t < 0.7 * S_{t-1})

    # Refuse to fund heavy defectors
    if avg_d >= 0.60:
        return D

    # Stabilize if stock is getting dangerously low
    if (S_t <= 0.35 * capacity) or (S_t <= 4*n) or trendS:
        return C

    # Harvest if others are mostly cooperating and stock is healthy
    if (avg_d <= 0.33) and (S_t >= 0.60 * capacity):
        return D

    # Middle regime: stock-sensitive
    if S_t >= 0.50 * capacity:
        return D
    else:
        return C
```

---

## Why this is exploitative and robust

- **Exploitative:** defaults to defection whenever the group can sustain stock without you; includes deliberate “betrayal” after full cooperation (`kD==0`) to capture surplus.
- **Robust:** does not require coordination, signals, or shared norms; adapts to observed defection rates and stock health; avoids wasting cooperation on mostly-defecting populations.
- **Tournament-sensible:** endgame defection is locked in; early defection probes quickly separate naive cooperators from retaliators.

If you want, I can also provide a more “mathematically tuned” version that estimates expected next-stock under C vs D using observed opponent counts and chooses the action maximizing a short-horizon value function (still exploitative, but slightly more complex).
'''

description_EXPLOITATIVE_29 = '''
## Strategy: **Regenerative Extortion (REX)**  
Goal: **earn “D” payoffs whenever it’s safe**, but **keep the stock in the high-growth basin** so you can keep exploiting across many rounds. Use **triggered punishment** to stop others from exploiting you, but avoid pointless “mutual ruin” when the stock is already low.

Key idea: In this environment, **stock is the engine**. If stock stays near capacity, you can take large D payoffs repeatedly. If stock collapses, everyone’s future payoffs evaporate. So you (i) **farm** the stock when needed, (ii) **defect to harvest** when safe, (iii) **punish** when others’ behavior threatens your future take.

---

# 1) Decision rules (C vs D)

### Compute from history each round
At round \(t\), before choosing, you know current stock \(S_t\) and past actions.

Let:
- \(k_{t-1}\) = number of opponents who defected last round (round \(t-1\)).
- \(p_{t-1} = k_{t-1}/(n-1)\) = opponent defection rate last round.
- Maintain for each opponent \(j\):
  - `defect_streak[j]`: consecutive rounds they played D.

Also define two stock thresholds (depend only on parameters):
- **Safe-to-harvest threshold**:  
  \[
  S_{\text{high}} = 0.75 \cdot \text{capacity}
  \]
- **Stock danger threshold** (below this, prioritize regeneration):  
  \[
  S_{\text{low}} = 0.35 \cdot \text{capacity}
  \]
(These are intentionally coarse and robust across capacities; they just split “healthy / fragile / critical”.)

---

## Core policy (what you do in round t)

### A) **Critical stock conservation**
If \(S_t \le S_{\text{low}}\): **Play C**.  
Rationale: At low stock, D accelerates collapse; keeping the resource alive is necessary to be exploitative later.

---

### B) **Punish active exploiters (selective retaliation)**
If stock is not critical (\(S_t > S_{\text{low}}\)) and **there is at least one opponent with a long defection streak**, punish:

- If `max(defect_streak) ≥ 2`: **Play D** for punishment.

Rationale: You don’t want to be the “sucker cooperator” feeding a persistent defector’s higher payoff. Two in a row is a strong signal of intent (reduces noise sensitivity).

**But**: if \(S_t\) is only moderately healthy (say between \(S_{\text{low}}\) and \(0.5\cdot capacity\)) and *many* others are defecting, you avoid pointless escalation (see Section C). This is what makes it robust: punish when it still preserves long-run extractable value.

---

### C) **Exploit when the environment supports it**
If \(S_t \ge S_{\text{high}}\): **Play D** unless you are actively trying to de-escalate a defection wave.

De-escalation rule:
- If last round opponents were highly defect-y: \(p_{t-1} \ge 0.5\) (at least half defected), then:
  - If \(S_t\) is **not extremely high** (i.e., \(S_t < 0.9\cdot capacity\)): **Play C** (attempt to pull stock back and/or test if others will follow).
  - Else (stock basically full): **Play D** (harvest while you can).

Rationale: When stock is high, D is immediate payoff-maximizing. But if a defection wave is starting, you sometimes switch to C to prevent stock from entering the collapse region where no one can exploit anyone.

---

### D) **Middle region (balance exploitation and farming)**
If \(S_{\text{low}} < S_t < S_{\text{high}}\):

Use opponent defection rate last round:
- If \(p_{t-1} \le 0.25\): **Play D** (others mostly cooperating → exploit).
- If \(0.25 < p_{t-1} < 0.5\): **Play C** (stabilize stock; avoid tipping into low-stock).
- If \(p_{t-1} \ge 0.5\): **Play D** only if \(S_t \ge 0.5\cdot capacity\), else **C**.

Rationale: In the middle region, your action meaningfully affects whether the stock rebounds or slides. You defect when you can “get away with it” (others are cooperating or stock is strong), and cooperate when the group is trending destructive.

---

# 2) Edge cases (first round, last round, etc.)

### Round 1 (no history)
- If \(r\) is small (e.g., \(r \le 3\)): **Play D** (little future to protect).
- Else:
  - If capacity is very large relative to players (e.g., `capacity ≥ 10n`): **Play D** (stock is resilient).
  - Otherwise: **Play C** (establish a high-stock trajectory and test opponents).

This is exploitative but cautious: you only “invest” early when the horizon is long enough for payoff compounding.

---

### Last round (round r)
**Always play D.**  
There is no future stock value to protect, so take the max current payoff.

---

### Second-to-last round (round r-1)
- If \(S_{r-1} \ge S_{\text{high}}\): **Play D**.
- Else: **Play D** unless \(S_{r-1} \le S_{\text{low}}\), in which case **C** (only to avoid dropping payoff too hard in the final round if you believe others might not fully deplete—rare, but can matter).

In practice, this means “mostly D in the endgame,” with a small exception if stock is so low that mutual D yields almost nothing.

---

# 3) Why this is exploitative (and robust)

### How it exploits cooperators
If opponents are cooperative (low \(p_{t-1}\)), REX chooses **D** in healthy or medium stock states, capturing **double** the per-round payoff of cooperators while the stock remains productive.

### How it avoids being exploited by defectors
Persistent defectors are met with **D punishment** after a short confirmation (`streak ≥ 2`). This prevents you from being the lone cooperator propping up someone else’s higher payoff.

### How it protects the “golden goose”
Unlike naive Always-D, it switches to **C when stock is in danger**, because *a dead stock cannot be exploited*. This is what makes it competitive in long tournaments with varied opponent types.

### Why it’s adaptive
- Uses **state (S)** to decide whether exploitation is sustainable.
- Uses **history (defection rates and streaks)** to distinguish occasional noise from systematic exploitation.
- Adjusts to both cooperative populations (defect often) and harsh ones (farm stock enough to keep earning, retaliate when needed).

---

# Pseudocode (implementable)

```python
def choose_action(t, r, n, capacity, S, opp_last_actions, defect_streaks):
    S_high = 0.75 * capacity
    S_low  = 0.35 * capacity

    if t == r:
        return "D"

    if t == 1:
        if r <= 3:
            return "D"
        if capacity >= 10*n:
            return "D"
        return "C"

    # compute opponent stats from last round
    k = sum(1 for a in opp_last_actions if a == "D")
    p = k / (n-1)
    max_streak = max(defect_streaks) if defect_streaks else 0

    # critical conservation
    if S <= S_low:
        return "C"

    # punish confirmed exploiters
    if max_streak >= 2:
        # but avoid pointless collapse if stock is middling and many defect
        if S < 0.5*capacity and p >= 0.5:
            return "C"
        return "D"

    # high stock harvest with de-escalation check
    if S >= S_high:
        if p >= 0.5 and S < 0.9*capacity:
            return "C"
        return "D"

    # mid stock region
    if p <= 0.25:
        return "D"
    elif p < 0.5:
        return "C"
    else:
        return "D" if S >= 0.5*capacity else "C"
```

---

If you want to push the exploitative angle even harder, you can add an “extortion margin” rule (e.g., only return to cooperation after others have cooperated for X rounds), but the above version is typically stronger in mixed tournaments because it doesn’t self-sabotage by over-punishing when stock is fragile.
'''

description_EXPLOITATIVE_30 = '''
## Strategy: **Predatory Regenerator (PR)**  
Exploit opponents whenever the stock is high (because the marginal gain from defecting is large), but avoid killing the resource unless you’re confident others will “carry” regeneration. Use a **state-aware extortion trigger**: cooperate only when (a) the stock is fragile or (b) opponents have recently shown enough cooperation that you can safely defect and still keep the stock productive.

Key idea:  
- **Defect is strictly better in the current round** for any given stock \(S\) (double the payoff of C).  
- But defecting reduces future stock; if everyone defects, the stock collapses to 0 permanently.  
- So you want to **free-ride on cooperators**: defect when the stock can absorb it, and switch to cooperation only when stock would otherwise crash (because a dead stock yields you 0 forever).

---

# 1) Decision rules (C vs D)

### Trackable quantities from history and state
At round \(t\) with current stock \(S_t\):

- Let \(k_{t-1}\) = number of opponents who played **C** in the previous round (observable).
- Let \(\hat{k}_t\) = smoothed estimate of expected cooperators among opponents:
  \[
  \hat{k}_t = (1-\alpha)\hat{k}_{t-1} + \alpha k_{t-1},\quad \alpha \in [0.3,0.6] \text{ (e.g. }0.5\text{)}
  \]
  Initialize \(\hat{k}_1 = (n-1)/2\).

- Define **safe stock band**:
  - If stock after consumption stays at or above \(capacity/2\), logistic growth tends to bring it back strongly.
  - Below that, repeated heavy extraction risks drifting toward collapse.

### Predict whether stock survives if you defect vs cooperate
Given current stock \(S\), if you play action \(a\in\{C,D\}\), your own consumption is:
- \(c(C)= S/(2n)\)
- \(c(D)= S/n\)

Assume opponents in expectation: \(\hat{k}\) cooperators, \((n-1-\hat{k})\) defectors. Expected opponent consumption:
\[
c_{opp} = \hat{k}\cdot \frac{S}{2n} + (n-1-\hat{k})\cdot \frac{S}{n}
\]
Total expected consumption if you play \(a\):
\[
c_{tot}(a)=c(a)+c_{opp}
\]
Expected remaining stock after consumption:
\[
S_{rem}(a)= S - c_{tot}(a)
\]

Then compute expected next stock using the game rule:
\[
S_{next}(a) = \min\Big(S_{rem}(a)+ 2S_{rem}(a)\big(1-\frac{S_{rem}(a)}{capacity}\big),\ capacity\Big)
\]

### Core policy
You are **exploitative by default**:

**Rule A (Default): Defect if doing so doesn’t threaten near-term stock viability.**  
Defect when:
1) \(S_{rem}(D) \ge S_{min}\) and  
2) \(S_{next}(D) \ge S_{recovery}\)

where robust thresholds:
- \(S_{min} = \max(2n,\ 0.20\cdot capacity)\)  (avoid “fragile zone”; also respects the given state bound logic)
- \(S_{recovery} = 0.50\cdot capacity\) (ensure we stay in the strong-regrowth region)

If both conditions hold: **play D**.

**Rule B (Resource-preservation pivot): Cooperate when the resource is in danger.**  
If defecting would likely push the system into a low-growth or collapse basin, **play C**:
- If \(S_{rem}(D) < S_{min}\) or \(S_{next}(D) < S_{recovery}\): **play C**

This is not “being nice”; it’s preventing your future payoffs from going to zero.

**Rule C (Punish unconditional cooperators by permanent freeriding):**  
If opponents look highly cooperative, exploit harder.  
If \(\hat{k}_t \ge (n-1) - 0.25\) (i.e., almost everyone else cooperates most of the time), then ignore Rule B unless stock is extremely low:
- Defect unless \(S_{rem}(D) < 2n\).  
Rationale: if they reliably regenerate, you take the high share.

**Rule D (If the pool is effectively dead):**  
If \(S_t \approx 0\), actions don’t matter. To avoid accidentally helping others coordinate on recovery (rare but possible only if stock >0):  
- If \(S_t < \epsilon\) (e.g. \(10^{-6}\)): **play D** (indifferent, but keeps your policy consistent).

---

# 2) Edge cases

### First round
You have no history. Use parameter-only reasoning:

- If \(r\) is small (e.g., \(r \le 3\)): **Defect immediately**. There’s little future to protect.
- Else:
  - If \(capacity\) is large and initial \(S_1=capacity\), stock is in “strong growth” territory after moderate extraction.
  - Still, full defection by all collapses it. You don’t know opponents.
  - So: **Round 1 = Cooperate** *only if* \(n\) is large enough that one defection significantly risks collapse under pessimism. Practical rule:
    - If \(n \ge 5\): play **C** in round 1 (probe; reduces chance of immediate collapse).
    - If \(n \le 4\): play **D** in round 1 (higher chance opponents are exploitable; also one player’s effect is larger but you gain a lot).
  
This gives a robust “probe” in larger groups where collapse is more likely from mass defection, while exploiting harder in small groups.

### Last round (round r)
No future value of preserving stock. **Always Defect**.

### Last 2 rounds
Backward induction pressure is strong; many strategies unravel near the end.  
- If \(t \ge r-1\): **Defect**, unless \(S_t\) is so low that C and D are effectively equal (then still defect).

### After a sudden collapse event
If you observe many defectors and stock plummets into the fragile zone:
- Switch to **C** while \(S_t < S_{recovery}\) *only if* you observe at least some cooperation among others (\(\hat{k}_t \ge 1\)).  
- If \(\hat{k}_t \approx 0\) (everyone defects), then cooperating is just donating; **defect forever**.

---

# 3) Why this is exploitative (and robust)

### Exploitative alignment
- The policy is **D-by-default** whenever the ecology can bear it.
- It only cooperates to avoid self-harm (future zeros), not to reward others.
- It explicitly **identifies “sucker-rich” environments** (high \(\hat{k}\)) and freerides aggressively.

### Robustness features
- **State-based**: reacts to stock level and predicted next stock, not to fragile assumptions about norms.
- **Opponent-model-lite**: uses a smoothed estimate \(\hat{k}\) of cooperators, so it handles noisy or mixed strategies.
- **Endgame adaption**: defects near the end regardless of earlier play (tournament-robust).
- **Collapse handling**: doesn’t waste time cooperating when others won’t regenerate.

---

## Pseudocode (implementation-ready)

```python
def action(t, r, n, capacity, S, history_actions):
    # history_actions[t-1] gives list of opponent actions last round (excluding self)
    alpha = 0.5
    eps = 1e-6

    # last round / endgame
    if t == r: 
        return "D"
    if t >= r-1:
        return "D"

    # estimate cooperators
    if t == 1:
        k_hat = (n-1)/2
    else:
        k_last = count_C(history_actions[t-1])  # among opponents
        k_hat = (1-alpha)*k_hat_prev + alpha*k_last  # store k_hat_prev across rounds

    if S < eps:
        return "D"

    def predict_next_stock(play):
        # expected opponent consumption using k_hat
        S_float = S
        c_opp = k_hat*(S_float/(2*n)) + ((n-1)-k_hat)*(S_float/n)
        c_self = S_float/(2*n) if play=="C" else S_float/n
        S_rem = S_float - (c_opp + c_self)
        if S_rem < 0: 
            S_rem = 0
        growth = 2*S_rem*(1 - S_rem/capacity)
        S_next = min(S_rem + growth, capacity)
        return S_rem, S_next

    S_min = max(2*n, 0.20*capacity)
    S_recovery = 0.50*capacity

    Srem_D, Snext_D = predict_next_stock("D")

    # exploit unconditional cooperators
    if k_hat >= (n-1) - 0.25:
        if Srem_D >= 2*n:
            return "D"
        else:
            return "C"

    # default: defect if safe
    if Srem_D >= S_min and Snext_D >= S_recovery:
        return "D"
    else:
        # only cooperate if there's evidence others may help recovery
        if t > 1 and k_hat < 0.5:
            return "D"
        return "C"
```

This strategy tends to:
- **Harvest double payoffs** whenever the stock is healthy and others provide regeneration.
- **Avoid self-defeating tragedies** by cooperating only when necessary to keep the resource productive.
- **Switch quickly** against all-defect populations to stop wasting cooperation.
'''

description_EXPLOITATIVE_31 = '''
## Exploitative strategy: **Bully-with-a-Stock-Floor (BSF)**

High-level intent:  
- **Take D whenever you can do so without permanently killing the resource**, because D strictly dominates C *in the current round* (you always get double).  
- **Use C only as a minimal “maintenance spend”** to keep the stock in a high-growth region so you can keep extracting later.  
- **Punish/discipline only when it increases your future extraction**, not for fairness.

This is an “exploit-the-commons but don’t crash it” policy: harvest aggressively, but keep the pool just healthy enough to continue harvesting, and free-ride whenever others are maintaining.

---

# 1) Decision rules (when to C vs D)

### Key derived quantities from parameters/state/history

At round \(t\), before choosing action, observe current stock \(S_t\).

Let:
- \(k_{t-1}\) = number of defectors in previous round (from history). If \(t=1\), treat \(k_{0} = n\) (pessimistic prior).
- Your action last round \(a_{t-1}\) (if any).

**Predict next round’s stock under each action**, assuming others defect at the same rate as last round (robust “status quo” forecast):
- If **you play C**, predicted defector count \(k = k_{t-1}\).
- If **you play D**, predicted defector count \(k = k_{t-1}+1\) (capped at \(n\)).

Given a defector count \(k\), total consumption fraction is:
\[
f(k) = \frac{k}{n} + \frac{n-k}{2n} = \frac{1}{2} + \frac{k}{2n}
\]
So remaining stock after consumption is:
\[
S_{\text{rem}}(k) = S_t \cdot (1 - f(k)) = S_t\left(\frac{1}{2} - \frac{k}{2n}\right) = S_t \cdot \frac{n-k}{2n}
\]

Growth then:
\[
G = 2 S_{\text{rem}}(k)\left(1-\frac{S_{\text{rem}}(k)}{\text{capacity}}\right)
\]
Predicted next stock:
\[
S' (k) = \min(S_{\text{rem}}(k)+G, \text{capacity})
\]

Define a **stock floor** \(S_{\min}\) (depends only on parameters) to avoid getting stuck near zero where growth is slow:
\[
S_{\min} = \max(0.15\cdot \text{capacity},\; 2n)
\]
- 15% capacity keeps you away from the “dead zone”.
- \(2n\) respects the stated stock range scale and avoids tiny-payoff regimes.

---

## Core rule

### **Rule A (Greedy by default):**  
Play **D** unless doing so is forecast to push the next stock below the floor.

Formally, compute:
- \(S'_C = S'(k_{t-1})\) (if you play C)
- \(S'_D = S'( \min(n, k_{t-1}+1) )\) (if you play D)

Then choose:
- If \(S'_D \ge S_{\min}\): **play D** (exploit)
- Else: **play C** (maintenance)

This makes you defect whenever it is “safe” for continued future extraction, and only cooperate to prevent a collapse that would reduce your long-run take.

---

## Opportunistic exploitation add-ons (still history/state-only)

### **Rule B (Free-ride on maintainers):**
If last round had **any cooperators** (i.e., \(k_{t-1} < n\)) and current stock is already healthy:
- If \(S_t \ge 0.6\cdot \text{capacity}\): **always D**  
Rationale: when others show willingness to sustain, you maximize extraction.

### **Rule C (Discipline collapse-risk rounds):**
If you see **everyone defected last round** (\(k_{t-1}=n\)):
- If \(S_t \le 0.5\cdot \text{capacity}\): **play C** (try to restart growth)  
- Else: follow Rule A

Rationale: when the group is in “strip mine” mode, the only reason to cooperate is to rebuild stock to exploit later. If stock is still high, you keep strip-mining.

---

# 2) Edge cases

### First round (\(t=1\))
- **Play D**.
Reason: (i) no retaliation possible within the round, (ii) you get double immediately, (iii) your later maintenance decision can respond to what others did.

(If you want a slightly safer version: only play C in round 1 if \(r\) is extremely large *and* \(n\) is large, but for tournaments “start with D” is more exploitative and usually higher EV.)

### Last round (\(t=r\))
- **Always play D**.
Reason: no future stock to protect, and D strictly dominates C in the final payoff.

### Stock near zero
If \(S_t\) is extremely low:
- If \(S_t < S_{\min}\): **play C** (unless last round, where you D)
Rationale: you need the growth term to start rebuilding; if you keep defecting at low stock, the game stays poor for you too.

### If your action could mathematically make remaining stock negative
Your model implies “consume stock/(2n) or stock/n” so it scales with current stock; total consumption is at most \(S\), so no negative. No special handling needed.

---

# 3) Why this is exploitative (and robust)

### Exploitative
- You **defect whenever it won’t crash the future** (you take the larger slice).
- You **use cooperation only instrumentally** as a reinvestment to keep the pool exploitable.
- If others cooperate, you **free-ride** (Rule B).

### Robust
- Doesn’t assume any norm, schedule, or signaling.
- Works against:
  - **Always-Cooperate**: you mostly D and farm them.
  - **Always-Defect**: you C only enough to keep stock from staying dead (when possible), then D again.
  - **Trigger/TFT-like**: since actions are binary and simultaneous, the best response in any given round is still D; your only concession is when collapse would hurt you more than the short-term gain.
  - **Random strategies**: the forecast uses observed defection rate \(k_{t-1}\), adapting to empirical behavior.

---

# Pseudocode (implementable)

```python
def choose_action(t, r, n, capacity, S_t, history):
    if t == r:
        return "D"  # last round grab

    S_min = max(0.15 * capacity, 2 * n)

    if t == 1:
        return "D"

    k_prev = history.num_defectors_last_round()  # 0..n

    def predict_next_stock(S, k):
        # remaining after consumption
        S_rem = S * (n - k) / (2 * n)
        # logistic growth
        G = 2 * S_rem * (1 - S_rem / capacity)
        return min(S_rem + G, capacity)

    # Optional robustness clamp
    kC = k_prev
    kD = min(n, k_prev + 1)

    S_next_if_C = predict_next_stock(S_t, kC)
    S_next_if_D = predict_next_stock(S_t, kD)

    # Rule B: free-ride when pool is healthy and someone cooperated
    if k_prev < n and S_t >= 0.6 * capacity:
        return "D"

    # Rule C: if everyone defected and stock is not healthy, invest
    if k_prev == n and S_t <= 0.5 * capacity:
        return "C"

    # Rule A: greedy unless it risks dropping below floor
    if S_next_if_D >= S_min:
        return "D"
    else:
        return "C"
```

---

If you want it even more exploitative, you can raise the “healthy pool” threshold for unconditional D (Rule B) downward (e.g., 0.5 capacity), and lower \(S_{\min}\) (e.g., 0.1 capacity). That increases immediate extraction but increases collapse risk; the provided numbers are tuned to be aggressive while staying broadly stable across unknown opponents.
'''

description_EXPLOITATIVE_32 = '''
## Exploitative Strategy: **Opportunistic Harvest with Stock Control (OHSC)**

Core idea:  
- **Take (D)** whenever opponents appear willing to sustain the resource (you free-ride).  
- **Switch to (C)** only when needed to prevent collapse *or* to “rebuild” the stock so you can exploit again.  
- Treat the stock as a renewable asset: keep it in a high-growth region when you must invest, but otherwise extract aggressively.

This strategy uses only \((n, r, capacity)\), current stock \(S_t\), and the full action history.

---

# 1) Decision rules (when to C vs D)

### Quantities computed each round \(t\)
Let:
- \(S\) = current stock at start of round \(t\)
- \(k_{t-1}\) = number of opponents who played **D** last round (among \(n-1\) others)
- \(d_{t-1} = k_{t-1}/(n-1)\) = observed opponent defection rate last round
- **My rule uses two thresholds**:
  - **Danger stock threshold**: \(S_{\text{danger}} = 2n\) (near the lower bound; collapse risk is high)
  - **Rebuild band** (where growth is strong): around \(S \approx capacity/2\). Use:
    - \(S_{\text{low}} = 0.35 \cdot capacity\)
    - \(S_{\text{high}} = 0.80 \cdot capacity\)

(These are parameter-based and work across many \(capacity\) values; you can tune them but keep fixed.)

### Primary exploitation logic
You choose between two modes:

## Mode A: **Exploit (default)** → play **D**
Exploit whenever the stock is not in immediate danger **and** opponents look even mildly cooperative.

Rule:
- If \(S > S_{\text{danger}}\) **and** \(d_{t-1} \le 0.6\), play **D**.

Rationale: if up to ~60% of opponents defected last round, the pool may still be sustained by the remainder plus growth; you want the higher immediate payoff \(S/n\).

## Mode B: **Stabilize/Rebuild** → play **C**
Stabilize only when needed to keep the asset alive for future exploitation.

Play **C** if any of these hold:
1) **Stock is dangerously low**: \(S \le S_{\text{danger}}\)  
2) **Opponents are mostly defecting**: \(d_{t-1} > 0.6\) *and* \(S \le S_{\text{high}}\)  
3) **You are in “rebuild plan”** (defined below)

Rationale: if everyone defects, the stock tends to crash to 0; cooperating is an “investment” to restore stock so you can later defect profitably.

---

## “Rebuild plan” (adaptive stateful rule)
Once the strategy decides the environment is collapsing (low stock or high opponent defection), it enters a rebuild plan:

**Enter rebuild plan if:**
- \(S \le S_{\text{low}}\) OR  
- last round had \(d_{t-1} > 0.6\) and stock decreased sharply (optional test: \(S_t < 0.7 S_{t-1}\))

**While in rebuild plan:** play **C** until **either**
- \(S \ge S_{\text{high}}\) (stock rebuilt), **then exit** to Exploit mode, OR
- you reach the last 1–2 rounds (see endgame rules), **then stop rebuilding and defect**.

This creates a cycle: **rebuild (C)** → **harvest (D)** → if collapse begins, **rebuild again**.

---

# 2) Edge cases (first round, last round, etc.)

### Round 1
No history exists, so start exploitatively:
- **Round 1: play D**, unless \(S\) is already low (shouldn’t be, since initial \(S=capacity\)).

Reason: immediate gain is double and you learn whether opponents will punish or also defect.

### Last round (round \(r\))
- **Always play D**.

Reason: no future stock value; pure one-shot incentive.

### Second-to-last round (round \(r-1\))
- **Play D** unless \(S \le S_{\text{danger}}\) *and* you believe one more cooperative round can avert total collapse and increase *your* last-round payoff.
Practical simple rule:
- If \(S \le S_{\text{danger}}\): play **C**, else **D**.

(This is the only time you “invest” for exactly one more round of benefit.)

### If stock hits 0
- Growth is 0, so the game is dead.  
- **Play D** (indifferent payoff-wise, but consistent and exploitative).

---

# 3) Why this is exploitative (and robust)

### Exploitative features
- **Free-riding bias**: defaults to **D** whenever the system seems sustainable.
- **Conditional investment only**: cooperates only to preserve the resource for *later exploitation*, not to reward cooperation.
- **Endgame defection**: guaranteed **D** at the end regardless of history.

### Robustness features
- Works against:
  - **Always-Cooperate / naive sustainers**: you mostly defect and extract higher payoff every round while they keep stock alive.
  - **Trigger/punisher types**: if they collapse the pool by defecting, you switch to rebuild only when it can still generate future benefit; otherwise you also defect.
  - **Random/mixed**: the thresholding on observed defection rate prevents over-investing when the group won’t sustain.
- Uses only observable history and current stock, no assumptions about coordination.

---

# Pseudocode (implementable)

```pseudo
parameters: n, r, capacity
constants:
  S_danger = 2*n
  S_low    = 0.35*capacity
  S_high   = 0.80*capacity
  d_thresh = 0.60

state:
  rebuild = false

for t in 1..r:
  observe current stock S

  if t == r:
     action = D
     continue

  if t == 1:
     action = D
     continue

  compute d_prev = (#opponents who played D in round t-1) / (n-1)

  // enter rebuild if collapsing
  if S <= S_low:
     rebuild = true
  if d_prev > d_thresh and S <= S_high:
     rebuild = true

  // exit rebuild if recovered
  if rebuild == true and S >= S_high:
     rebuild = false

  // endgame: don't rebuild too late
  if t >= r-1:
     if S <= S_danger:
        action = C   // only if it can boost final round
     else:
        action = D
     continue

  // main decision
  if S <= S_danger:
     action = C
  else if rebuild == true:
     action = C
  else if d_prev <= d_thresh:
     action = D
  else:
     action = C
```

---

If you want to push exploitation even harder, you can tighten rebuilding (require **even lower** stock to cooperate) at the cost of occasionally crashing the pool; if you want more long-run profit stability, raise the rebuild aggressiveness (enter rebuild sooner).
'''

description_EXPLOITATIVE_33 = '''
### Strategy: **Cap-Bait Extortion (CBE)**  
Goal: **Earn the defector premium whenever others keep the stock healthy; switch to cooperation only when needed to keep the stock from collapsing; punish quickly and in a way that makes “feeding you” their best option.**  
This is an exploitative “leader” strategy: it tries to **induce** others to cooperate by making (a) cooperation stabilize the stock and (b) unilateral defection by them trigger a stock crash that hurts them more over time.

---

## Key ideas (why it works in this game)

- In any round with stock \(S\), **D yields exactly double C**:  
  \(\pi(D)=S/n\), \(\pi(C)=S/(2n)\).
- Stock dynamics: if total consumption is too high, the stock drops and future payoffs collapse. If consumption is moderate, logistic growth can restore stock toward capacity.
- Therefore, the exploiter wants a regime where **others mostly play C**, keeping the stock high, while **we often play D** to take the larger share—*but* not so much that the stock cannot recover.

We’ll implement this with:
1) a **stock-safety controller** (don’t kill the resource unless it’s endgame or punishment), and  
2) a **punishment/forgiveness system** based on observed defections, designed to make opponents prefer cooperating while we defect.

---

## Quantities we can compute from history

At round \(t\), before choosing:
- Current stock \(S_t\).
- From last round actions, count how many defected:  
  \(k_{t-1} = \#\{j \neq i: a_{j,t-1}=D\}\) (or include self for bookkeeping if you want).
- Define an estimate of the “cooperation level” among others:  
  \(\text{coopRate}_{t-1} = 1 - k_{t-1}/(n-1)\).

We also maintain a **punishment timer** \(P \ge 0\).

---

## 1) Decision rules: when to C vs D

### Stock thresholds
Define two stock thresholds in terms of capacity:
- **Safe**: \(S_t \ge 0.7\cdot \text{capacity}\)
- **Critical**: \(S_t \le 0.35\cdot \text{capacity}\)

(These are intentionally conservative; they make the strategy robust across \(n\) and capacities.)

### Default stance: exploit when safe
- If stock is **Safe** and punishment timer \(P=0\): **Defect (D)**.
  - Rationale: When stock is high, your D payoff is high and the ecosystem can usually absorb one defector if others mostly cooperate.

### Resource-saving mode: cooperate when critical
- If stock is **Critical** and \(t < r\): **Cooperate (C)** unless you are in a punishment phase you deliberately want to enforce (see below).
  - Rationale: If the stock gets too low, defecting accelerates collapse and destroys your future earnings.

### Punishment trigger
After observing round \(t-1\):
- If **any other player defected** while stock was not critical (i.e., \(S_{t-1} > 0.35\cdot \text{capacity}\)), set punishment timer:
  \[
  P \leftarrow \max(P, 2 + \lceil (k_{t-1})/2 \rceil)
  \]
  Meaning: more defectors → longer punishment.

### Punishment action
While \(P>0\):
- If \(S_t > 0.35\cdot \text{capacity}\): **Defect (D)**.
- If \(S_t \le 0.35\cdot \text{capacity}\): **Cooperate (C)** (don’t destroy the commons so hard that you lose leverage).
- Decrement \(P \leftarrow P-1\) each round.

Interpretation: punish by refusing to be the “sucker” who stabilizes the stock while others take D. But you avoid self-destructive mutual defection when stock is already near collapse.

### Opportunistic “harvest” rule (exploit cooperators)
If punishment timer \(P=0\) and stock is moderate-to-high \(S_t \ge 0.5\cdot \text{capacity}\):
- If in the last 2 rounds **others’ coopRate ≥ 0.8** (i.e., almost everyone is cooperating): **Defect (D)**.
- Else (mixed group): **Cooperate (C)** if \(S_t < 0.7\cdot \text{capacity}\), otherwise **Defect (D)**.

This makes you defect most when the group is “well-behaved” (high exploitation), and cooperate more when the group is unstable (to preserve future value).

---

## 2) Edge cases (first round, last round, etc.)

### Round 1 (no history)
- **Defect (D)** if \(r \ge 3\).  
- If \(r=2\): still **Defect (D)** (backward induction and short horizon).
Rationale: You gain immediate advantage; if opponents are conditional cooperators, you learn quickly and can manage the stock later.

### Last round \(t=r\)
- **Defect (D)** always.
Rationale: There is no future to protect; cooperation has no strategic value.

### Second-to-last round \(t=r-1\)
- If stock is very high \(S_{r-1} \ge 0.5\cdot \text{capacity}\): **Defect (D)**.
- If stock is low: choose **D** if it doesn’t matter (since last round you will D anyway), but if you want to keep \(S_r\) nonzero for last-round gains, then:
  - **Cooperate (C)** only when \(S_{r-1} \le 0.25\cdot \text{capacity}\).
Rationale: The only reason to cooperate near the end is to ensure there is something left to exploit in the final round.

### Stock at/near zero
- If \(S_t\) is extremely low (e.g., \(S_t < 0.1\cdot \text{capacity}\)) and \(t < r\): **Cooperate (C)**.
Rationale: Defecting yields a tiny payoff and prevents recovery; cooperating can allow logistic growth to restore future harvest.

---

## 3) Why this is exploitative (explicitly)

- **You defect by default when conditions are favorable**, taking the 2× payoff advantage whenever the group keeps the stock healthy.
- You **only cooperate as an investment** to rebuild the resource so you can later defect at higher stock levels.
- You use **punishment** to make it costly for others to defect in your presence, attempting to create a regime where:  
  others cooperate to keep the stock high → you defect to extract surplus.
- You avoid “honest reciprocity.” Forgiveness is not altruism; it’s timed to maximize long-run extraction.

---

## Pseudocode (implementable)

```python
# Parameters: n, r, capacity
SAFE = 0.70 * capacity
CRIT = 0.35 * capacity
VERYLOW = 0.10 * capacity
ENDKEEP = 0.25 * capacity   # for r-1 decision

P = 0  # punishment timer

def choose_action(t, S_t, history):
    global P

    # Last round
    if t == r:
        return "D"

    # First round
    if t == 1:
        return "D"

    # Observe last round
    last = history[t-1]  # contains actions of all players and S_{t-1}
    S_prev = last.stock
    k_prev = count_defectors_excluding_self(last.actions)

    # Trigger punishment if others defected when not already critical
    if k_prev > 0 and S_prev > CRIT:
        P = max(P, 2 + math.ceil(k_prev / 2))

    # Second-to-last round: prioritize having stock to exploit in final
    if t == r-1:
        if S_t >= 0.50 * capacity:
            return "D"
        else:
            return "C" if S_t <= ENDKEEP else "D"

    # If stock is extremely low, rebuild unless endgame
    if S_t < VERYLOW:
        return "C"

    # Punishment phase
    if P > 0:
        P -= 1
        if S_t > CRIT:
            return "D"
        else:
            return "C"

    # Normal phase
    # Estimate coop rate over last 2 rounds (if available)
    coop_ok = estimate_coop_rate(history, window=2) >= 0.8

    if S_t >= SAFE:
        return "D"  # exploit high stock

    if S_t >= 0.50 * capacity and coop_ok:
        return "D"  # exploit cooperative population

    # Otherwise stabilize to keep future harvest alive
    return "C" if S_t <= SAFE else "D"
```

---

### What this beats / where it’s robust
- **Against naive cooperators / stock-preservers:** you defect most of the time and win big.
- **Against conditional cooperators (grim/TFT-like):** you often still get early surplus; punishment/stock-control can keep the resource viable enough to continue extracting.
- **Against frequent defectors:** you stop “subsidizing” them (punishment D), but you won’t mindlessly collapse the stock when it ruins your own future—so you can outperform pure always-D in longer horizons by enabling occasional recovery and harvest.

If you want, I can tune the SAFE/CRIT thresholds analytically for specific \(n, r, capacity\) (they can be made functions of \(n\) and remaining rounds rather than constants).
'''

description_EXPLOITATIVE_34 = '''
Below is an explicitly **exploitative**, history/state–based strategy for the Common Pool Resource Game. It is designed to (i) take the larger share whenever opponents enable it, (ii) avoid being the “sucker” when others defect, and (iii) keep the stock high enough when that increases *your* future extraction opportunity.

I’ll call it **Bait–Probe–Extort (BPE)**.

---

## Intuition (what it tries to do)
1. **Probe** whether opponents will sustain stock via cooperation.
2. If they do, **free-ride** (defect) to take double the per-round payoff while they replenish.
3. If they don’t, **do not waste cooperation**—defect as well (grab what you can before collapse).
4. Use a simple, credible “punishment” trigger: if others defect too much, stop cooperating entirely. This makes your occasional cooperation a *conditional investment* to keep the resource productive when it benefits you.

Because the growth is logistic and strong when stock is mid-range, you only want to “invest” (cooperate) when it prevents catastrophic depletion and enables future high-S rounds you can then exploit.

---

## Key quantities from history
Let in round \(t-1\):
- \(S\) = current stock at start of round \(t\)
- \(k_{t-1}\) = number of opponents who defected last round (out of \(n-1\))
- \(d_{t-1} = k_{t-1}/(n-1)\) = opponent defection rate last round
- Maintain a short memory \(m\) rounds (e.g., \(m=3\)):
  - \(\bar d =\) average opponent defection rate over last \(m\) rounds

Also define:
- **High-stock threshold**: \(S_{\text{high}} = 0.8 \cdot \text{capacity}\)
- **Low-stock threshold**: \(S_{\text{low}} = 0.35 \cdot \text{capacity}\)

These can be tuned, but the logic matters more than exact numbers.

---

## Decision rules (C vs D)

### Rule 0: Last round grab
If \(t = r\): **Play D**.  
Finite horizon + no future stock value = take the larger share.

---

### Rule 1: First round “bait” (cheap test)
If \(t = 1\):
- If \(r\) is small (say \(r \le 3\)): **Play D** (little future to invest in).
- Else: **Play C** (one-round “bait” to see if opponents are cooperative and will maintain stock).

Rationale: Round 1 cooperation is an information buy. If the group is cooperative, you’ll exploit later; if not, you pivot fast.

---

### Rule 2: Exploit when stock is high and opponents are not all defecting
If \(S \ge S_{\text{high}}\) and \(\bar d \le 0.6\): **Play D**.

Rationale: High stock is when per-round extraction is valuable. If a meaningful fraction of opponents are keeping the system afloat, you free-ride.

---

### Rule 3: “Maintenance cooperation” only when it protects future exploitation
If \(S \le S_{\text{low}}\):
- If \(\bar d \le 0.3\): **Play C**  
  (they’re mostly cooperating; cooperating helps avoid collapse and rebuild stock)
- Else: **Play D**  
  (they’re defecting enough that your cooperation won’t save the resource; don’t throw good effort after bad)

Rationale: You cooperate only when there’s evidence your investment won’t be alone.

---

### Rule 4: Extortionate stance in the mid zone
If \(S_{\text{low}} < S < S_{\text{high}}\):
- If \(\bar d \le 0.2\): **Play D** (strong exploitation; they’re very cooperative)
- Else if \(0.2 < \bar d \le 0.5\): **Play C** (stabilize stock; you can exploit later)
- Else (\(\bar d > 0.5\)): **Play D** (resource likely headed down; take what you can)

This is the core “adaptive” band: you flip between exploiting and investing based on whether opponents are sufficiently cooperative to make investment worthwhile.

---

## Punishment / credibility (robustness to defectors)

### Rule 5: Triggered “grim-ish” punishment with cooldown
Maintain a flag `punish` and a counter `punish_timer`.

- If in any round \(t-1\), **more than half of all players defected** (i.e., total defectors \(\ge \lceil n/2 \rceil\)), then set:
  - `punish = true`
  - `punish_timer = 2` (or 3)

While `punish == true`:
- **Play D**.
- Decrease `punish_timer` by 1 each round.
- When `punish_timer == 0`, set `punish = false`.

Effect: If the group turns exploitative, you immediately become exploitative too for a couple rounds—this prevents repeated sucker behavior, but it’s not permanent, so you can re-exploit if cooperation returns.

Why this is exploitative: it’s not “fairness.” It’s protection of your option value: you only re-invest when the environment becomes profitable again.

---

## Edge cases
1. **Very low stock \(S \approx 0\)**: play **D** (you lose nothing by defecting; cooperation doesn’t magically create stock if others keep stripping it).
2. **Capacity barely above \(2n\)** (thin buffer): raise conservatism:
   - Increase \(S_{\text{low}}\) (e.g., to \(0.45\cdot capacity\)) so you cooperate earlier *only when opponents are cooperative*, because collapse is easier.
3. **Short remaining horizon**:
   - If \(r - t \le 1\): **D** (no future).
   - If \(r - t = 2\): lean to **D** unless \(S\) is low *and* \(\bar d\) is very low (≤0.2). In the last 2 rounds, stock investment rarely pays.

---

## Pseudocode (implementable sketch)

```python
def action(t, r, n, capacity, S, history):
    # history gives past actions of all players and past stocks.
    # Compute opponent defection rate over last m rounds
    m = 3
    dbar = avg_opponent_defection_rate(history, m)  # in [0,1]
    last_total_defectors = total_defectors_last_round(history) if t > 1 else 0

    Shigh = 0.8 * capacity
    Slow  = 0.35 * capacity

    # punishment state stored across rounds
    if t == 1:
        punish = False
        punish_timer = 0
    else:
        punish, punish_timer = get_internal_state()

    # update punishment trigger
    if t > 1 and last_total_defectors >= math.ceil(n/2):
        punish = True
        punish_timer = 2

    if punish:
        punish_timer -= 1
        if punish_timer <= 0:
            punish = False
        set_internal_state(punish, punish_timer)
        return "D"

    # endgame
    if t == r:
        return "D"
    if (r - t) <= 1:
        return "D"

    # first round bait
    if t == 1:
        return "D" if r <= 3 else "C"

    # state-based rules
    if S >= Shigh and dbar <= 0.6:
        return "D"

    if S <= Slow:
        return "C" if dbar <= 0.3 else "D"

    # mid zone
    if dbar <= 0.2:
        return "D"
    elif dbar <= 0.5:
        return "C"
    else:
        return "D"
```

---

## Why this is exploitative (explicitly)
- Whenever opponents show willingness to sustain the stock, you **defect in high-value states** to take **double** the payoff while letting them do the “work.”
- You **only cooperate instrumentally**: as an investment to restore stock when (a) stock is low and (b) opponents are sufficiently cooperative that your investment will not be wasted.
- You **punish** defect-heavy groups by switching to full defection for a short period, preventing others from repeatedly exploiting your cooperation while still allowing you to revert if cooperation becomes profitable again.
- You **always defect at the end**, harvesting remaining stock value.

If you want, I can also provide a more mathematically tuned version that explicitly estimates next-round stock from observed defector counts (using the growth function) and chooses C only when the expected marginal future gain from higher \(S_{t+1}\) exceeds the immediate gain from defecting.
'''

description_EXPLOITATIVE_35 = '''
## Strategy: **Pump–Probe–Punish (PPP)**  
Goal: harvest the resource at high levels when others help sustain it, but immediately switch to hard exploitation (defection) when others over-consume or when continuation value is low. The strategy treats cooperation as an *investment* to keep stock high, not as a norm.

Key idea: In any round, the *total consumption fraction* depends only on how many defectors there are. Let \(k_t\) be the number of defectors in round \(t\). With current stock \(S_t\),

\[
S_{\text{rem}} = S_t \left(1 - \frac{k_t+1}{2n}\right)
\]

So **stock is sustainable and bounces back to capacity** only if \(S_{\text{rem}}\ge \frac{\text{capacity}}{2}\), i.e.

\[
1 - \frac{k_t+1}{2n} \ge \frac{1}{2}\quad \Longleftrightarrow\quad k_t \le n-1
\]

Meaning: **if everyone defects** (\(k_t=n\)), stock goes to 0 and stays there; otherwise there is still some remaining stock and potential rebound. This makes “detecting all-D” the critical safety trigger.

---

# 1) Decision rules (C vs D)

### State you track from history
- \(S_t\): current stock at start of round \(t\)
- \(k_{t-1}\): number of defectors observed last round
- `meltdown`: boolean flag that you set if you ever observe \(k=n\) (all defect) or stock becomes extremely low
- For each opponent \(j\): recent defect rate over a short window \(W\) (e.g., last 5 rounds)

### Parameters (computed from game parameters)
- Window size: \(W = \min(5, r-1)\)
- “Low stock” threshold: \(S_{\text{low}} = \max\left(\frac{\text{capacity}}{4}, 2n\right)\)
- “Endgame” threshold: last \(H\) rounds where you stop investing:
  - \(H = \max(2, \lceil \log_2 n \rceil)\)

### Core rule
**Cooperate only when it is profitable as an investment** (keeps the stock near capacity) and when opponents appear to mostly cooperate. Otherwise defect.

Concretely, in round \(t\):

1. **Endgame exploitation**
   - If \(t > r - H\): **play D**.
   - Rationale: with finite horizon, future stock has little value; take the larger immediate payoff.

2. **Meltdown / irrecoverable region**
   - If `meltdown == true` OR \(S_t \le S_{\text{low}}\): **play D**.
   - Rationale: when the pool is low, your C vs D difference is still a factor of 2 *this round*, and you’re unlikely to restore capacity alone. Don’t subsidize others.

3. **Punish full collapse behavior**
   - If last round had \(k_{t-1} = n\) (everyone defected): set `meltdown = true`, then **play D forever**.
   - Rationale: logistic growth from 0 is 0; once the stock is 0, the game is dead. Even before it hits 0, a population willing to play all-D is too dangerous to invest in.

4. **Opportunistic exploitation when others sustain**
   - If \(S_t\) is high (e.g., \(S_t \ge 0.8 \cdot \text{capacity}\)) **and** recent opponents are mostly cooperating (defined below), then choose **D** with some probability; otherwise **C**.
   - This is the “exploit” module: free-ride when it seems safe.

5. **Default: conditional cooperation**
   - Otherwise, **play C**.

### “Recent opponents are mostly cooperating” test
Let \(\hat{d}\) be the average fraction of defect actions among opponents over the last \(W\) rounds (pool all opponent moves, or average opponent defect rates):

- If \(\hat{d} \le d_{\text{safe}}\), treat as safe. Use \(d_{\text{safe}} = \frac{1}{n}\) (roughly: at most ~one defector’s worth of defecting, on average).

### Exploit module (probabilistic D when safe)
When safe and stock high, defect with probability:

\[
p_D = \min\left(0.6,\ 0.15 + 0.5\cdot \left(1-\hat{d}\right)\right)
\]

So if opponents are very cooperative (\(\hat{d}\approx 0\)), you defect often (up to 60%). If they start defecting more, you reduce defection.

**Interpretation:** you “tax” cooperators but avoid pushing the group into collapse when defecting becomes common.

---

# 2) Edge cases

### Round 1 (no history)
- **Play C** in round 1.
- Reason: from full capacity, a single C is a cheap probe that helps distinguish “cooperative ecology” from “everyone defects immediately”. Also, your action only changes your own payoff that round; the key information gain is worth it.

### Last rounds (finite-horizon defection)
- In the last \(H\) rounds: **always D**, regardless of history.
- \(H\) scales mildly with \(n\); larger groups are harder to discipline and more likely to unravel late.

### Stock at/near capacity
- If \(S_t\) is extremely high and opponents are cooperative, you **increase exploitation** (via the exploit module). This is where the marginal cost of your extra extraction is least likely to cause irreversible damage.

### Stock very low or zero
- If \(S_t = 0\): payoff is 0 no matter what; **play D** by convention and keep `meltdown=true`. (Doesn’t matter, but keeps rule consistent.)
- If \(0 < S_t \le S_{\text{low}}\): **D** (don’t invest).

### Opponents with mixed behavior
- The rolling window \(\hat{d}\) prevents overreacting to one-off defections.
- But the “all-D once ⇒ forever D” rule is a hard safety catch because it signals the group can coordinate on collapse (even unintentionally).

---

# 3) Why this is exploitative (and robust)

### Exploitative
- Against cooperative or sustainability-focused strategies, PPP defects frequently when stock is high and opponents are behaving, capturing the **2× payoff advantage** in those rounds.
- It only “pays” cooperation when doing so keeps the stock in a profitable regime for continued harvesting.

### Robust
- Against always-defect or collapse-prone populations: it quickly switches to D and stops wasting moves on C.
- Against retaliatory strategies: it reduces defecting when opponent defect rates rise, preventing runaway collapse when others punish.
- Against noisy/erratic players: rolling-window inference avoids knee-jerk over-punishment while still tightening when defection becomes systematic.

---

## Pseudocode (implementable)

```python
# constants
W = min(5, r-1)
H = max(2, ceil(log2(n)))
S_low = max(capacity/4.0, 2*n)
d_safe = 1.0/n

meltdown = False

def decide(t, S_t, history):
    global meltdown

    # endgame: stop investing
    if t > r - H:
        return "D"

    # update from history if available
    if t > 1:
        k_prev = num_defectors_in_round(history, t-1)  # includes you
        if k_prev == n:
            meltdown = True

    if meltdown or S_t <= S_low:
        return "D"

    # compute recent opponent defect rate
    d_hat = recent_opponent_defect_rate(history, t-1, W)  # in [0,1], if no data -> 0

    # exploit when safe and stock high
    if S_t >= 0.8*capacity and d_hat <= d_safe:
        pD = min(0.6, 0.15 + 0.5*(1.0 - d_hat))
        return "D" if random() < pD else "C"

    # default conditional cooperation
    if d_hat <= d_safe:
        return "C"
    else:
        return "D"
```

If you want, I can tune the thresholds (\(S_{\text{low}}, 0.8\cdot capacity, d_{\text{safe}}, p_D\)) for specific \((n,r,capacity)\) regimes (e.g., small \(r\) vs very large \(r\), or capacity barely above \(2n\)).
'''

description_EXPLOITATIVE_36 = '''
Below is an **exploitative “Harvest–Restore with Credible Punishment (HRCP)”** strategy. It is designed to (i) **take D whenever others are likely to keep the stock healthy**, (ii) **avoid being the sucker funding others’ D**, and (iii) **keep the resource from collapsing when doing so increases your own future take**. It only uses parameters, current stock, and observed history.

---

## Core idea (exploitative mindset)

- **If the group is sustaining the stock**, you should **defect (D)** to take double the per-round payoff of a cooperator while letting others “pay” for regeneration.
- **If defection pressure is high and stock is at risk**, switch to **cooperate (C)** *only as a self-interested investment* to restore the stock so you can later harvest more—unless the horizon is too short to recover.
- Maintain a **credible punishment mode**: if others defect heavily, you stop contributing to recovery and **defect to deny them future stock** (burn the commons when it’s not profitable to save).

---

## Quantities computed from history/state

At the start of round \(t\), stock is \(S_t\). From last round’s observed actions, compute:

- \(k_{t-1}\): number of opponents who defected last round.
- \(p_{t-1} = k_{t-1}/(n-1)\): opponent defection rate last round.
- A short-memory estimate (robust to noise):
  \[
  \bar p_t = \lambda \bar p_{t-1} + (1-\lambda)p_{t-1},\quad \lambda \in [0.6,0.8] \text{ (e.g., }0.7\text{)}
  \]
- **Stock safety threshold**: define a “healthy stock” region where regeneration is easy and immediate exploitation is safe.
  - Use \(S_{\text{high}} = 0.8 \cdot \text{capacity}\)
  - Use \(S_{\text{low}} = 0.4 \cdot \text{capacity}\)
  (These fractions are parameter-only and work across many \(n\), because growth is strong mid-range and collapses near 0.)

- **Horizon remaining**: \(h = r - t + 1\).

---

## Modes

The strategy has three modes: **Exploit**, **Restore**, **Scorch**. You switch modes based on stock and opponent defection pressure.

### Mode 1: EXPLOIT (default)
Goal: take \(D\) while others keep the system viable.

**Play \(D\)** when:
- Stock is healthy: \(S_t \ge S_{\text{high}}\), **and**
- Opponent defection pressure is not extreme: \(\bar p_t \le p_{\text{crit}}\)

Set \(p_{\text{crit}} \approx 0.55\). Intuition: if a majority of opponents are frequently defecting, the stock will crash and your future take vanishes.

### Mode 2: RESTORE
Goal: invest minimally in keeping stock from collapsing *when it benefits you later*.

Enter RESTORE when **either**:
- \(S_t \le S_{\text{low}}\) and \(h \ge h_{\min}\), **or**
- \(\bar p_t > p_{\text{crit}}\) but not hopeless (see SCORCH condition below)

Choose \(h_{\min}\) as a function of the growth speed; a safe rule is:
- \(h_{\min} = 3\) (need at least a few rounds to recoup investment)

**Play \(C\)** in RESTORE unless opponents are so defect-heavy that you’re just feeding them (then you go SCORCH).

Exit RESTORE back to EXPLOIT when:
- \(S_t \ge S_{\text{high}}\) **and** \(\bar p_t \le p_{\text{crit}}\)

### Mode 3: SCORCH (credible punishment / deny future)
Goal: if others are too exploitative, don’t subsidize; take what you can now and/or collapse the stock to deny them future gains.

Enter SCORCH when:
- Opponents are highly defecting: \(\bar p_t \ge p_{\text{scorch}}\) (e.g., \(0.75\)), **or**
- It’s late enough that restoration won’t pay: \(h < h_{\min}\), **or**
- Stock is already low and opponents still defect a lot: \(S_t \le S_{\text{low}}\) and \(\bar p_t > p_{\text{crit}}\)

**Play \(D\)** in SCORCH.

Exit SCORCH only if opponents demonstrably reform:
- Require **two consecutive rounds** with low defection:
  \[
  p_{t-1} \le 0.25 \text{ and } p_{t-2} \le 0.25
  \]
and stock not critically low (e.g., \(S_t \ge 0.5\cdot\text{capacity}\)).
Then return to RESTORE for one round (C) to test, then EXPLOIT.

This “two-round” requirement prevents being tricked by one-off cooperation.

---

## Edge cases (first round, last rounds, unusual stocks)

### Round 1 (no history)
Start in **EXPLOIT** with **\(D\)**.
- Rationale: immediate payoff is doubled, and if others cooperate, you exploit them. If others defect, you lose nothing relative to C and you learn quickly.

### Last round (t = r)
Always play **\(D\)**.
- No future value to preserving stock; pure one-shot incentive.

### Second-to-last round (t = r−1)
Play **\(D\)** unless stock is extremely high and you are in RESTORE due to earlier collapse *and* you believe one more C meaningfully increases \(S\) for last-round harvesting. In practice, keep it simple:
- If \(h \le 2\): treat as SCORCH → **\(D\)**.

### If stock is at/near zero
- If \(S_t\) is tiny (e.g., \(S_t \le 0.05\cdot \text{capacity}\)), your per-round payoff is tiny regardless. Decide by horizon:
  - If \(h \ge 3\) and \(\bar p_t \le 0.55\): go RESTORE → **C** (attempt reboot).
  - Else: SCORCH → **D** (don’t throw good effort after bad).

### If capacity is barely ≥ 2n
Your thresholds are fractions of capacity, so still well-defined. The logic remains: exploit at high stock, restore only when profitable.

---

## Decision rules (compact pseudocode)

```pseudo
parameters:
  Shigh = 0.8 * capacity
  Slow  = 0.4 * capacity
  pcrit = 0.55
  pscorch = 0.75
  lambda = 0.7
  hmin = 3

state variables:
  mode ∈ {EXPLOIT, RESTORE, SCORCH} initially EXPLOIT
  pbar initially 0.0
  last_two_p = queue length 2 (init 0.0, 0.0)

each round t with current stock S:
  h = r - t + 1

  if t == 1: return D
  if h == 1: return D
  if h <= 2: mode = SCORCH

  observe previous round opponent defection rate p_last
  pbar = lambda*pbar + (1-lambda)*p_last
  update last_two_p with p_last

  # mode transitions
  if mode != SCORCH:
     if (S <= Slow and h >= hmin) or (pbar > pcrit and h >= hmin):
        mode = RESTORE
     if (pbar >= pscorch) or (S <= Slow and pbar > pcrit):
        mode = SCORCH

  if mode == SCORCH:
     if last_two_p[0] <= 0.25 and last_two_p[1] <= 0.25 and S >= 0.5*capacity and h >= hmin:
         mode = RESTORE   # probation
     return D

  if mode == RESTORE:
     if S >= Shigh and pbar <= pcrit:
         mode = EXPLOIT
         return D
     else:
         return C

  # EXPLOIT
  if S >= Shigh and pbar <= pcrit:
     return D
  else:
     mode = RESTORE
     return C
```

---

## Why this is exploitative and robust

- **Exploitative vs cooperators:** If others sustain stock with C, you mostly play **D at high stock**, capturing the free-rider premium while growth replenishes.
- **Not exploitable by defectors:** Against persistent D players, you move to **SCORCH** quickly—refusing to “fund” their high payoffs via your cooperation.
- **Adaptive to mixed populations:** Uses a smoothed estimate of opponent defection to avoid overreacting to noise, and stock thresholds to react to the actual ecological state.
- **Credible punishment with re-entry:** SCORCH is sticky (requires 2 rounds of reform), preventing easy manipulation, but not permanently self-destructive if the group becomes cooperative.

If you want, I can tune the numeric thresholds (\(0.8, 0.4, 0.55, 0.75\)) analytically for specific \((n, capacity, r)\), but the above works as a strong tournament baseline without assuming any coordination.
'''

description_EXPLOITATIVE_37 = '''
Below is an explicitly *exploitative*, stateful “harvest-and-punish” strategy designed for your CPR game. It tries to (i) **take D whenever others keep the stock healthy**, (ii) **force others off D by making D unprofitable through rapid stock collapse**, and (iii) **avoid being the sucker** when cooperation won’t be reciprocated.

---

## Core idea

- **D is always the best one-shot action given current S** (it doubles your immediate payoff vs C).
- The only reason to ever play C is **to keep the stock from crashing** so that you can keep earning in future rounds.
- So the exploitative posture is:
  1. **Build/maintain stock only when needed** (play C when stock is at risk).
  2. **Otherwise defect to harvest** (play D whenever stock is “safe enough”).
  3. **Punish defection waves** by switching to D and letting the pool crash (making defect-heavy behavior self-destruct), then later rebuild only if it will pay you.

---

## Notation computed from history (public)

At start of round \(t\), you know current stock \(S_t\), and you can compute last round’s number of defectors \(k_{t-1}\).

If in a round with stock \(S\) there are \(k\) defectors and \(n-k\) cooperators, total consumption is:

\[
\text{Cons}(k,S) = k\cdot \frac{S}{n} + (n-k)\cdot \frac{S}{2n}
= \frac{S}{2n}(n+k)
\]

So remaining stock after consumption:

\[
S_{\text{rem}}(k,S)= S - \frac{S}{2n}(n+k)= S\left(1 - \frac{n+k}{2n}\right)= S\cdot \frac{n-k}{2n}
\]

This is extremely useful: **if \(k=n\)** then \(S_{\text{rem}}=0\) (collapse); if \(k\) is large, remainder is tiny.

---

## Strategy: “Exploitative Threshold Grim (ETG)”

### State variables (maintained by you)
- `mode ∈ {HARVEST, REBUILD, PUNISH}`
- `punish_timer` (integer)
- `k_hat` = estimated defect count next round (start with 0; update from history)

### Key thresholds (depend only on parameters)
- `S_safe = 0.6 * capacity`  (stock level above which you can harvest aggressively)
- `S_crit = 0.25 * capacity` (below this, stock is fragile; rebuild is needed to avoid long dead zone)
- `T_punish = 2` rounds of punishment (short but sharp)
- `T_rebuild_min = 1` minimum rebuild duration once you enter REBUILD

These constants can be tuned, but the logic matters more than the exact numbers.

---

## Decision rules (when to C vs D)

### Round 1 (no history)
**Play D**.
- Rationale: you have no evidence anyone will cooperate; immediate gain is higher; also you learn quickly whether others are willing to sustain the pool without you.

---

### Ongoing: compute indicators
At start of round \(t\):

1. Observe last round defectors \(k_{t-1}\) (if \(t=1\), treat \(k_{t-1}=n\) unknown).
2. Update defect forecast:
   - `k_hat = k_{t-1}` (simple and robust; you can also use a moving average).

3. Compute a “next-round survival” check if you defect now and others behave like last round:
   - If you choose D, defectors become \(k' = \min(n, k_hat + 1)\).
   - Predicted remainder:
     \[
     S_{\text{rem}} = S_t \cdot \frac{n-k'}{2n}
     \]
   - If `S_rem` is near 0, the pool is about to crash if you defect.

---

### Mode logic

#### 1) HARVEST mode (default)
**Default action: D**, *unless* one of these triggers fires:

**Trigger A (Stock protection trigger):**  
If \(S_t < S_{\text{crit}}\), play **C** and switch to `REBUILD`.
- You can’t exploit a dead pool. Below critical, you need to keep it alive.

**Trigger B (Imminent crash trigger):**  
If predicted `S_rem` after this round (assuming others repeat) is extremely low, e.g.
- \(S_{\text{rem}} < 0.05 \cdot capacity\),
then play **C** (to avoid being the marginal defector that zeroes the pool) and switch to `REBUILD`.
- This is the key adaptive “don’t be the last raider” rule.

**Trigger C (Defection wave trigger):**  
If \(k_{t-1} \ge \lceil 0.6n \rceil\), switch to `PUNISH` and play **D**.
- When most are defecting, your C won’t save the pool; instead accelerate collapse so defecting becomes unprofitable and strategies that can shift will shift.

#### 2) REBUILD mode
Goal: restore stock to a level where you can resume exploitation.

Rules:
- If \(S_t \ge S_{\text{safe}}\): switch to `HARVEST` and play **D**.
- Else:
  - If last round had *few defectors* (e.g., \(k_{t-1} \le \lfloor 0.3n \rfloor\)), play **C** (rebuilding is likely to work).
  - If last round had *many defectors* (e.g., \(k_{t-1} \ge \lceil 0.6n \rceil\)), switch to `PUNISH` and play **D** (rebuilding will be exploited).

This makes rebuild **conditional on others showing restraint**.

#### 3) PUNISH mode
Goal: make widespread D unattractive by ensuring the resource stays low (so D yields little), forcing adaptive opponents to move back toward C if they want future gains.

Rules:
- Play **D** for `T_punish` rounds unconditionally.
- Decrement `punish_timer`.
- After punishment:
  - If \(S_t < S_{\text{crit}}\): switch to `REBUILD` (play C next round).
  - Else switch to `HARVEST`.

This is “grim-ish” but not permanent: it’s a **credible, fast retaliation** that doesn’t trap you in endless low-payoff play.

---

## Endgame / edge cases

### Last round \(t=r\)
**Always play D.**
- Future stock is worthless; take the maximum immediate payoff.

### Second-to-last round \(t=r-1\)
- If \(S_t\) is high (e.g., \(S_t \ge S_{\text{crit}}\)): play **D**.
- Only play **C** if \(S_t\) is so low that \(D\) yields almost nothing *and* \(C\) can increase \(S\) enough to improve the last round payoff. Practically:
  - If \(S_t < 0.1\cdot capacity\), play **C** (try to seed growth), else **D**.

### Stock near zero
If \(S_t\) is extremely small (e.g., \(S_t < 0.02 \cdot capacity\)):
- Play **C** **only if** \(k_{t-1}\) was low (others are also rebuilding).
- Otherwise play **D** (don’t throw good effort after bad; force the regime change).

---

## Pseudocode (implementable)

```pseudo
init:
  mode = HARVEST
  punish_timer = 0

for t in 1..r:
  observe S_t
  if t == 1:
    action = D
    continue

  observe k_prev  # number of defectors in round t-1

  if t == r:
    action = D
    continue

  if mode == PUNISH:
    action = D
    punish_timer -= 1
    if punish_timer <= 0:
      if S_t < 0.25*capacity: mode = REBUILD
      else mode = HARVEST
    continue

  # compute crash risk if we defect and others repeat
  k_hat = k_prev
  k_prime = min(n, k_hat + 1)
  S_rem = S_t * (n - k_prime) / (2*n)

  if mode == HARVEST:
    if k_prev >= ceil(0.6*n):
      mode = PUNISH; punish_timer = 2
      action = D
    else if S_t < 0.25*capacity:
      mode = REBUILD
      action = C
    else if S_rem < 0.05*capacity:
      mode = REBUILD
      action = C
    else:
      action = D
    continue

  if mode == REBUILD:
    if S_t >= 0.6*capacity:
      mode = HARVEST
      action = D
    else if k_prev <= floor(0.3*n):
      action = C
    else if k_prev >= ceil(0.6*n):
      mode = PUNISH; punish_timer = 2
      action = D
    else:
      # mixed environment: lean exploitative but avoid collapse
      if S_rem < 0.05*capacity: action = C
      else action = D
    continue
```

---

## Why this is exploitative (and robust)

- **Primary behavior is D** whenever the stock can tolerate it (you harvest the cooperative restraint of others).
- **You do not subsidize defect-heavy groups**: if many defect, you *punish* by defecting too, hastening collapse, driving their payoffs down and pushing adaptive agents to change.
- **You only rebuild when it benefits you** (i.e., when the environment suggests others will not immediately exploit your rebuild).
- It handles:
  - unconditional cooperators (you mostly D and profit),
  - conditional cooperators (you avoid being the marginal pool-crasher; you’ll sometimes C to keep the regime stable while still defecting a lot),
  - unconditional defectors (you punish; pool collapses quickly; no one can do better than you in that environment),
  - noisy/mixed populations (thresholds + crash-risk check prevents self-destructive last-raider behavior).

If you want, I can tighten the thresholds analytically using the exact growth function (derive the region where one more D flips the system from high-stock attractor to collapse) for your typical tournament parameter ranges.
'''

description_EXPLOITATIVE_38 = '''
Below is an exploitative, history-dependent strategy designed to (i) harvest high payoffs when others sustain the stock, (ii) punish quickly when others threaten collapse, and (iii) avoid being the “sucker” who cooperates while others defect. It treats cooperation as an *investment* used only when it is necessary to keep the resource productive (and thus exploitable later).

---

## Core idea

- **Defect whenever it’s safe** (stock high and/or opponents are not collectively over-consuming).
- **Cooperate only as a “stabilizer”** to prevent imminent collapse or to rebuild stock when the group has shown willingness to cooperate.
- **Punish immediately** after any detected defection, but only to the extent needed to protect future exploitation opportunities.
- **Endgame: defect** (finite horizon, no future value to sustain stock).

This is a “parasite-with-a-life-support-kit” policy: you try to live off others’ restraint, and you only contribute the minimum needed to keep the host alive.

---

## Notation you can compute from history

At round \(t\), before choosing action, you observe current stock \(S_t\) and past actions.

Let:
- \(k_{t-1}\) = number of opponents who defected in round \(t-1\) (from history).
- \(d_{t-1} = k_{t-1}/(n-1)\) = opponent defection rate last round.
- \(\bar d\) = exponentially weighted moving average (EWMA) of opponent defection rate over time.

EWMA update (after observing round \(t\)):
\[
\bar d \leftarrow (1-\alpha)\bar d + \alpha d_t
\]
Use e.g. \(\alpha = 0.3\) (fast adaptation).

Also define a simple “danger” predictor based on what happened last round:
- If you **expect** opponents to repeat last round’s behavior (a good robust baseline), then expected total consumption next round is:
  \[
  \text{Cons} = (\#D_{\text{opp}})\cdot \frac{S}{n} + (\#C_{\text{opp}})\cdot \frac{S}{2n} + a \cdot \left(\frac{S}{n} \text{ if } a=D \text{ else } \frac{S}{2n}\right)
  \]
  where \(a\) is your contemplated action.
- Equivalently, given \(k\) opponent defectors and your action, the **post-consumption remaining stock** is:
  - If you play **C**:
    \[
    S_{\text{rem}}^C = S \left(1 - \frac{k}{n} - \frac{(n-1-k)}{2n} - \frac{1}{2n}\right)
    = S\left(\frac{1}{2} - \frac{k}{2n}\right)
    \]
  - If you play **D**:
    \[
    S_{\text{rem}}^D = S \left(1 - \frac{k}{n} - \frac{(n-1-k)}{2n} - \frac{1}{n}\right)
    = S\left(\frac{1}{2} - \frac{1}{2n} - \frac{k}{2n}\right)
    \]
So defecting reduces next remaining stock by an extra \(S/(2n)\) vs cooperating.

---

## Decision rules (cooperate vs defect)

### Rule 0: Last-round and first-round defaults
- **Round 1:** play **D** (probe/extract immediately; no evidence yet that you must stabilize).
- **Final round (t = r):** play **D** (pure endgame extraction).
- **Last 2 rounds (t ≥ r−1):** play **D** unless stock is so low that you’d get essentially nothing either way (doesn’t matter), but default still **D**.

### Rule 1: “Safe-to-exploit” condition → Defect
Play **D** if all of the following hold:
1. Stock is not precariously low: \(S_t \ge S_{\text{low}}\)
2. Opponents are not in a defection wave: \(\bar d \le d_{\text{thresh}}\)
3. Predicted remaining stock after you defect (using last-round \(k_{t-1}\)) is not near-collapse:
   \[
   S_{\text{rem}}^D \ge \rho \cdot S_t
   \]
   where \(\rho\) is a safety ratio (e.g. \(\rho = 0.15\)).

Suggested parameter settings (work across many \(n\), capacity):
- \(S_{\text{low}} = 0.25 \cdot \text{capacity}\)
- \(d_{\text{thresh}} = 0.35\)
- \(\rho = 0.15\)

Intuition: if stock is healthy and opponents aren’t broadly defecting, you defect to double your current-round payoff while not immediately killing the resource.

### Rule 2: “Stabilize to keep exploiting later” → Cooperate (minimal investment)
Play **C** if **any** of these are true (and it’s not the final round):
1. **Stock is low:** \(S_t < S_{\text{low}}\)  
   (resource needs life support; otherwise future payoffs collapse to ~0)
2. **Opponents are mostly cooperating (good host):** \(\bar d < 0.15\) and \(S_t\) is not already at/near capacity.  
   (invest a bit to keep the system high and keep them cooperative)
3. **Your defection would predict near-collapse:** \(S_{\text{rem}}^D < \rho S_t\) but \(S_{\text{rem}}^C \ge \rho S_t\).  
   (cooperation is the smallest change that avoids triggering the death spiral)
4. **Punishment de-escalation:** you previously punished (see Rule 3) and opponents reduced defection substantially (e.g. \(d_{t-1} < 0.2\)).  
   (return to stabilizing so you can resume profitable defection later)

This is not “nice”; it’s maintenance.

### Rule 3: “Exploit but don’t be exploited” punishment logic
If opponents defected last round, you don’t want to keep cooperating while they free-ride.

Define a **punishment mode** triggered when:
- \(k_{t-1} \ge 1\) **and** \(S_t \ge S_{\text{low}}\) (i.e., you have something to fight over)

In punishment mode:
- Play **D** for \(L\) rounds, where:
  \[
  L = 1 + \left\lfloor 2 \cdot \bar d \cdot (n-1) \right\rfloor
  \]
  cap \(L\) to e.g. 4.
- Exit punishment mode early if stock falls below \(S_{\text{low}}\) (then switch to cooperation as life support).

Purpose: make defection unprofitable for would-be cooperators to keep cooperating while someone defects; you “teach” that defection leads to immediate defection by you. But you stop punishing if it would destroy the commons (because then you can’t exploit anything).

### Rule 4: Anti-collapse override (resource triage)
Regardless of other rules (except final round), if:
- \(S_t \le S_{\text{critical}} = 0.10 \cdot \text{capacity}\)

then play **C** (triage).  
Rationale: at very low \(S\), your marginal gain from defecting is small, but the marginal harm to future stock (and thus total future gains) can be large.

---

## Edge cases

1. **Capacity very large / n small:** The “safe-to-exploit” condition will often hold; you’ll defect frequently. If opponents are cooperative, this is highly exploitative.
2. **Everyone always defects:** stock crashes quickly; your best response is to defect too (you do), except possibly brief cooperation when \(S\) is critical—but with universal defection, cooperation won’t save much and you’ll end up defecting most rounds (still exploitative and not a sucker).
3. **Mixed population / tit-for-tat types:** Your immediate punishment mode prevents you from being milked. Your later de-escalation lets you return to extracting once they calm down.
4. **Very short horizons (small r):** Strategy becomes almost all-D automatically via endgame rule. (Correct: sustaining stock is less valuable.)
5. **Stock near capacity:** You defect unless opponents are in a defection wave; this maximizes immediate payoff while the system is robust.

---

## Pseudocode sketch

```pseudo
init:
  bar_d = 0.0
  punish_countdown = 0

for t in 1..r:
  observe S_t
  if t == r: return D
  if t == 1: action = D; goto after

  S_low = 0.25 * capacity
  S_critical = 0.10 * capacity
  rho = 0.15
  d_thresh = 0.35
  alpha = 0.3

  k_last = number_of_opponents_who_played_D_in_round(t-1)
  d_last = k_last / (n-1)

  # predicted remaining if repeat last round
  Srem_D = S_t * (0.5 - 1/(2n) - k_last/(2n))
  Srem_C = S_t * (0.5 - k_last/(2n))

  if t >= r-1:
     action = D
  else if S_t <= S_critical:
     action = C
  else if punish_countdown > 0:
     if S_t < S_low: action = C
     else action = D
     punish_countdown -= 1
  else:
     # trigger punishment
     if k_last >= 1 and S_t >= S_low:
        L = 1 + floor(2 * bar_d * (n-1))
        punish_countdown = min(4, max(1, L)) - 1
        action = D
     else:
        # stabilize conditions
        if S_t < S_low: action = C
        else if (bar_d < 0.15 and S_t < 0.95 * capacity): action = C
        else if (Srem_D < rho*S_t and Srem_C >= rho*S_t): action = C
        else if (S_t >= S_low and bar_d <= d_thresh and Srem_D >= rho*S_t): action = D
        else action = C  # conservative fallback: keep resource viable

after:
  play action
  observe opponents actions, update bar_d:
    bar_d = (1-alpha)*bar_d + alpha*(#oppD/(n-1))
```

---

## Why this is exploitative (explicitly)

- **Baseline extraction:** defaults to **D** in round 1, the entire endgame, and whenever the commons is stable.
- **Conditional maintenance only:** cooperation is used instrumentally to prevent future payoff collapse, not to be fair.
- **Rapid retaliation:** any detected defection triggers defection from you (punishment), preventing others from earning more than you while you “pay” to sustain stock.
- **Adaptive to opponents:** EWMA and stock thresholds make it robust to varied behaviors (always-C, always-D, noisy, forgiving, grim-trigger, etc.).

If you want, I can tune the numeric thresholds (\(S_{\text{low}}, S_{\text{critical}}, \rho, d_{\text{thresh}}, \alpha\)) for specific tournament settings (expected \(n, r, capacity\)) to make it more aggressively exploitative or more collapse-resistant.
'''

description_EXPLOITATIVE_39 = '''
## Exploitative Strategy: **Regenerative Extortion with Credible Crash (RECC)**

Mindset: treat the stock as a renewable asset you want to keep near the “high-yield” region, but **force others to do the conserving**. You defect whenever you can do so without collapsing the stock, and you “farm” cooperators by letting them rebuild the pool while you take the larger share. If others won’t conserve, you pivot to short-term extraction.

Key facts to exploit:
- Given stock \(S\), **D always pays exactly 2× C** that round (\(S/n\) vs \(S/(2n)\)).
- Growth is logistic. The stock regenerates best when post-consumption stock is moderate (not 0, not at capacity).
- If everyone defects when stock is high, the pool can crash to 0 (per example). So you only want “all-D” outcomes near the end or when collapse is unavoidable anyway.

---

# 1) Decision rules: when to Cooperate vs Defect

### Compute from history (last round) and current state
At round \(t\), observe current stock \(S_t\) and count how many opponents defected last round:
- Let \(d_{t-1}\) = number of *other* players who played D in round \(t-1\).
- Estimate opponent “defection rate” last round:  
  \[
  q_{t-1} = \frac{d_{t-1}}{n-1}
  \]
Also track a short memory (robustness): exponential moving average defection rate:
\[
\bar q_t = (1-\lambda)\bar q_{t-1} + \lambda q_{t-1} \quad \text{with e.g. }\lambda=0.3
\]
(Initialize \(\bar q_1=0.5\).)

### Predict stock remaining if you defect vs cooperate
Assume others behave like last round (good enough, and you adapt quickly if wrong).

If you play **D**, expected total consumption:
\[
E[C^{tot}_D] = \underbrace{\frac{S_t}{n}}_{\text{you}} + (n-1)\left(\bar q_t\frac{S_t}{n} + (1-\bar q_t)\frac{S_t}{2n}\right)
\]
If you play **C**:
\[
E[C^{tot}_C] = \underbrace{\frac{S_t}{2n}}_{\text{you}} + (n-1)\left(\bar q_t\frac{S_t}{n} + (1-\bar q_t)\frac{S_t}{2n}\right)
\]

So expected remaining stock after consumption:
\[
R_D = S_t - E[C^{tot}_D], \quad R_C = S_t - E[C^{tot}_C]
\]

### Core rule (exploit-first, conserve only when needed)
Use two thresholds:
- **Crash threshold** \(\tau_{\text{crash}}\): if predicted remaining stock is too low, defecting risks collapse. Set:
  \[
  \tau_{\text{crash}} = \max\left(\frac{capacity}{10},\, 2n\right)
  \]
  (This keeps you from zeroing the pool early; also respects the game’s “small stock” region.)
- **Endgame threshold**: in the last \(L\) rounds, you care less about future stock. Set \(L=\lceil r/5\rceil\) (at least 1).

**Decision rule:**
1. **If \(t > r-L\)** (endgame): **Defect** unless \(S_t\) is already extremely low (see “scrap mode” below).  
2. Otherwise (early/mid game):
   - If \(R_D \ge \tau_{\text{crash}}\): **Defect** (farm the pool).
   - Else: **Cooperate** (force stabilization; you’ll resume defecting once safe).

This is “exploit by default; cooperate only as insurance to preserve your future ability to exploit.”

---

# 2) Edge cases and special modes

### First round (no history)
Round 1 has the highest leverage: stock starts at capacity, and D pays double.

- If \(r\) is small (e.g., \(r \le 3\)): **Defect in round 1** (future doesn’t matter much).
- If \(r\) is larger: still **Defect in round 1**, *unless* you want a tiny chance to seed cooperation. But exploitative play prefers immediate advantage; you can always “stabilize” later if needed.

So: **Round 1 = Defect.**

### “Scrap mode” (stock already low)
If \(S_t \le \tau_{\text{scrap}}\) where \(\tau_{\text{scrap}}=2n\):
- Your per-round payoff is small either way.
- But cooperating can allow growth to resume; defecting may pin the stock near 0.

Rule:
- If not in endgame: **Cooperate** when \(S_t \le 2n\) to restart regeneration.
- If in endgame: **Defect** (take what remains).

### Punish-then-relax (anti-exploitation protection)
If you detect you are being “milked” (others mostly defect so your cooperation just subsidizes them), don’t keep stabilizing for them.

Trigger:
- If \(\bar q_t \ge q_{\text{high}}\) for 2 consecutive rounds, where \(q_{\text{high}}=0.7\): enter **hard mode** for \(H\) rounds (e.g., \(H=2\)).

Hard mode rule:
- **Defect regardless** (except if \(S_t\le 2n\) and not endgame, then cooperate once to prevent permanent dead stock).
Purpose: you stop being the only one preserving the asset while others harvest.

### Last round
Always **Defect** in the final round (dominates given no future).

---

# 3) Why this is exploitative (and robust)

### Exploitative mechanics
- **If others cooperate**, your default D yields exactly **2×** their stage payoff while the stock often remains recoverable due to logistic growth and their restraint. You extract a consistent advantage.
- **If others defect**, you do not sacrifice yourself trying to “save” the commons for them. You either (a) stabilize only when it benefits *you* by preserving future exploitation opportunities, or (b) switch to extraction/endgame collapse.
- The strategy is **state-aware**: it defects whenever predicted post-consumption stock remains above a safe floor; otherwise it cooperates as a self-interested investment.

### Robustness
- Doesn’t assume norms, schedules, or communication.
- Uses only observables: stock and action history.
- Adapts to a wide variety of opponent mixes via \(\bar q_t\) and the crash threshold:
  - vs mostly cooperators → mostly defect, occasionally cooperate if stock dips.
  - vs mostly defectors → defect (and accept collapse), except minimal cooperation if it can reboot growth and there’s time to profit later.
  - vs conditional cooperators (Tit-for-Tat-like) → you often still gain because you defect whenever safe; if they retaliate and stock falls, you temporarily cooperate to recover, then resume defecting.

---

# Pseudocode (implementable)

```pseudo
params: n, r, capacity
L = ceil(r/5)
tau_crash = max(capacity/10, 2*n)
tau_scrap = 2*n
lambda = 0.3
qbar = 0.5
hard_timer = 0

for t in 1..r:
  observe S

  if t == 1:
     action = D
     continue

  # update qbar from last round observed opponents
  d_last = number_of_opponents_who_played_D_last_round()
  q_last = d_last / (n-1)
  qbar = (1-lambda)*qbar + lambda*q_last

  # endgame
  if t == r:
     action = D
     continue
  if t > r - L:
     if S <= tau_scrap and t <= r - 1:
        action = D   # still endgame: take what's left
     else:
        action = D
     continue

  # hard mode trigger
  if qbar >= 0.7:
     hard_timer = max(hard_timer, 2)

  if hard_timer > 0:
     hard_timer -= 1
     if S <= tau_scrap:
        action = C   # one-step reboot if possible
     else:
        action = D
     continue

  # compute expected remaining stock if you defect
  # Expected per-opponent consumption = qbar*(S/n) + (1-qbar)*(S/(2n))
  opp_cons = (n-1) * ( qbar*(S/n) + (1-qbar)*(S/(2n)) )
  R_D = S - (S/n) - opp_cons

  if S <= tau_scrap:
     action = C
  else if R_D >= tau_crash:
     action = D
  else:
     action = C
```

This policy is deliberately asymmetric: it treats cooperation as a tool to maintain a profitable resource, not as a norm. It aims to keep the pool from collapsing *only when doing so increases your future ability to defect profitably*.
'''

description_EXPLOITATIVE_40 = '''
### Strategy: **Cautious-Repair Grim-Exploiter (CRGE)**  
Goal: extract high payoffs whenever the pool is “safe” while pushing others to do the work of rebuilding the stock; cooperate only as a *repair investment* when the stock is in danger or when others have proven they won’t rebuild.

This is exploitative in two ways:
1. **Free-riding when possible:** Defect whenever the stock can sustain it and/or others appear to be contributing to recovery.
2. **Minimal, conditional repairs:** Cooperate only when necessary to keep the resource from collapsing (because collapse reduces your future ability to exploit).

---

## Key quantities computed each round

Let current stock be `S` at the start of the round.

Consumption if you play:
- `cC = S/(2n)`
- `cD = S/n`

Let `k` be the number of *other* players who defected last round (from history). Define:
- `defect_rate = k/(n-1)`

Estimate “how harsh opponents are” with an exponentially weighted moving average (EWMA):
- `pD ← (1-λ)*pD + λ*defect_rate` with `λ ≈ 0.3`, initialize `pD=0.5`.

Define two stock thresholds (depend only on parameters):
- **Danger threshold:** `S_danger = capacity * 0.30`
- **Safe threshold:** `S_safe = capacity * 0.70`

(Reasoning: logistic growth is strong around mid-range; very low stock is risky because consumption can drive it to near-zero and growth then can’t recover quickly.)

Also track a “repair debt” counter for yourself:
- `repair_budget` starts at 0.
- When you defect while stock is not high, you increase debt; you’ll later be forced to cooperate to avoid collapse.

---

## Decision rules (core)

### Rule 0 — Last-round logic (finite horizon exploitation)
- **Final round (t = r):** always **D**.  
  (No future to protect; pure exploitation.)
- **Second-to-last round (t = r-1):** **D** unless stock is already in the danger zone (`S ≤ S_danger`), in which case **C** (to avoid getting a near-zero payout in round r).

### Rule 1 — Immediate safety check (prevent collapse when it hurts you)
If `S ≤ S_danger`:
- If opponents are likely to defect (`pD ≥ 0.5`): **C** (repair is urgent; if everyone defects the pool can flatline).
- Else (opponents not that defect-prone): **D** (they’ll probably repair; exploit their restraint).

### Rule 2 — Exploit high stock aggressively
If `S ≥ S_safe`:
- **D**.  
High stock means big immediate payoff from defection and the system can often recover even with some over-consumption.

### Rule 3 — Middle zone: “Exploit unless repairs are lacking”
If `S_danger < S < S_safe`, use opponent behavior:
- If `pD ≥ 0.6`: **C**  
  (Many defectors → stock will trend down; you invest minimally to keep future exploitation alive.)
- If `pD ≤ 0.35`: **D**  
  (Many cooperators → you free-ride.)
- Otherwise (mixed opponents): use a *repair budget* trigger:
  - If `repair_budget > 0`: **C** and decrement `repair_budget`.
  - Else: **D** and increment `repair_budget` by 1 if `S` is closer to danger than safe (formally if `S < (S_danger+S_safe)/2`).

This makes you defect by default, but forces occasional cooperation when the stock is trending toward a region where future payoffs collapse.

---

## Stock-trend override (adaptive to actual state changes)

After each round, you can compute the realized next stock `S_next` from the known actions and dynamics. Track trend:
- `ΔS = S_next - S`

If `ΔS < 0` for **two consecutive rounds** and current `S < 0.5*capacity`, then next round you **C** (one-step “stabilization”), *unless* it’s the final round (still D).

This prevents the strategy from blindly defecting into a downward spiral against aggressive opponents.

---

## First-round policy (edge case)

Round 1: **D**.

Rationale: You learn opponent types quickly (who defects), you get maximum immediate payoff, and if others are cooperative you immediately start exploiting. If everyone defects, the pool collapses—but that outcome is common in one-shot logic anyway, and you can still switch to repair mode in round 2 if the horizon is long enough to benefit from rebuilding.

(If you want a slightly more conservative variant: play C in round 1 only when `r` is large and `capacity` is close to the minimum `2n`, but the pure exploitative version starts with D.)

---

## Pseudocode (implementable)

```python
# parameters: n, r, capacity
S_danger = 0.30 * capacity
S_safe   = 0.70 * capacity
lambda_ = 0.30

pD = 0.5
repair_budget = 0
down_streak = 0
S_prev = None

for t in 1..r:
    observe current stock S
    
    # endgame
    if t == r:
        action = "D"
    elif t == r-1:
        action = "C" if S <= S_danger else "D"
    else:
        # trend-based safety override (uses last computed transition)
        if down_streak >= 2 and S < 0.5 * capacity:
            action = "C"
        else:
            if S <= S_danger:
                action = "C" if pD >= 0.5 else "D"
            elif S >= S_safe:
                action = "D"
            else:
                if pD >= 0.6:
                    action = "C"
                elif pD <= 0.35:
                    action = "D"
                else:
                    mid = 0.5 * (S_danger + S_safe)
                    if repair_budget > 0:
                        action = "C"
                        repair_budget -= 1
                    else:
                        action = "D"
                        if S < mid:
                            repair_budget += 1
    
    play(action)

    # after round resolves, update beliefs and trend
    observe others' actions; compute defect_rate among others
    pD = (1-lambda_) * pD + lambda_ * defect_rate
    
    observe next stock S_next (or compute it from rules)
    if S_prev is not None:
        if S_next - S < 0:
            down_streak += 1
        else:
            down_streak = 0
    S_prev = S
```

---

## Why this is robust and exploitative

- **Against cooperators / “sustainable” strategies:** you mostly defect, harvesting higher payoffs while they keep the stock healthy. You only cooperate if the stock starts falling too much.
- **Against unconditional defectors:** you defect early (matching them), but if the horizon allows recovery and others sometimes cooperate, you pivot into minimal repairs to avoid permanently losing the resource. If nobody repairs, no strategy can extract value after collapse—this one at least takes the maximum early.
- **Against conditional/punishing strategies:** your occasional repairs and trend-triggered cooperation reduce the chance you get stuck in low-stock mutual destruction, while still defecting whenever the system can bear it.
- **Finite-horizon advantage:** explicit endgame defection ensures you don’t “leave money on the table” near the end.

If you want, I can also provide (a) a more aggressive variant that almost never repairs, and (b) a more “parasite” variant that tries to infer who the cooperators are and times exploitation bursts when they’re likely to sustain the stock.
'''

description_EXPLOITATIVE_41 = '''
### Strategy: **Razor–Trigger with Stock Guardrails (RT-SG)**  
Goal: **earn defect-level payouts whenever opponents are tolerant/naive**, but **avoid self-destructing the stock** when opponents are also aggressive. The strategy treats the resource as a cashflow machine: keep it near-capacity *only if that lets you defect profitably*, otherwise pivot to opportunistic defection bursts and let the stock recover only when it benefits you.

Key idea: Use history to (i) **classify the table** (cooperative, mixed, aggressive), (ii) **choose D whenever it’s safe**, and (iii) **force recovery phases** only when stock is in a danger zone.

---

## 1) Decision rules (Cooperate vs Defect)

### Quantities observed/derived each round
- `S_t`: stock at start of round `t`
- `kD_{t-1}`: number of opponents who defected last round (from observed actions)
- `D_rate`: exponentially weighted moving average of opponent defection rate
- `S_safe`: stock threshold below which we stop “harvesting” and start “protecting”
- `S_hi`: stock threshold above which we resume exploitation

Recommended thresholds (parameterized):
- `S_safe = capacity * 0.35`  
- `S_hi   = capacity * 0.70`  
These work as “hysteresis” to prevent flip-flopping.

Also compute what happens to stock given a hypothesized number of defectors:
- If in round `t` there are `m` defectors total and `n-m` cooperators, total consumption is:  
  `Cons(m) = (m)*(S_t/n) + (n-m)*(S_t/(2n)) = S_t * ( (m/n) + (n-m)/(2n) ) = S_t * ( (n+m)/(2n) )`  
  Remaining stock after consumption:  
  `S_rem(m) = S_t - Cons(m) = S_t * (1 - (n+m)/(2n)) = S_t * ( (n-m)/(2n) )`  
So more defectors → lower remaining stock → worse future.

We use this to be exploitative **but not suicidal**.

---

### Core policy (high level)
You are in one of three modes each round:

#### **Mode A: Exploit (default when stock is healthy)**
- If `S_t >= S_hi`, **play D**, unless opponents are so aggressive that mutual D is imminent and will crash the stock *immediately*.
- “Imminent crash” heuristic: if last round had high defection and stock is not huge, avoid being the last shove.

Rule:
- If `S_t >= S_hi`:
  - If `kD_{t-1} >= n-1` (everyone else just defected), then:
    - If `t < r` and `S_t` is not near-capacity (specifically `S_t < 0.9*capacity`), play **C** once to encourage any recovery if opponents sometimes relent.
    - Otherwise play **D** (take the money; endgame or they’re committed).
  - Else play **D**.

Why exploitative: against any table that sustains stock (cooperators, conditional cooperators, forgiving types), you harvest **D** payouts while they do the work.

#### **Mode B: Guard (resource protection to keep future exploitation viable)**
- If `S_t <= S_safe`, **play C** (even if it feels “nice”) because it’s not altruism: it’s **asset preservation**. You want stock to recover so you can defect later at high S.

Rule:
- If `S_t <= S_safe`, play **C**.

#### **Mode C: Pressure / Test (between safe and high)**
When `S_safe < S_t < S_hi`, choose based on opponents’ revealed aggression:

- Compute `D_rate` over opponents (e.g., EWMA with α=0.3):
  - `D_rate = α*(kD_{t-1}/(n-1)) + (1-α)*D_rate_prev`
- If opponents are mostly cooperating, defect.
- If opponents are mostly defecting, cooperate (to attempt to stop collapse) **only until stock recovers**, then exploit again.

Rule:
- If `S_safe < S_t < S_hi`:
  - If `D_rate <= 0.4`, play **D** (they’re “farmable”).
  - If `D_rate >= 0.7`, play **C** (stabilize for later; also sometimes induces conditional cooperators).
  - Else (mixed): play **D** with probability `p = 0.6` and **C** with probability `0.4`, *but* override to **C** if `kD_{t-1} >= n-2` (near-universal defection).

Why exploitative: you defect whenever there’s a reasonable chance the group maintains stock; you only “help” when the resource is too depleted to keep exploiting.

---

## 2) Edge cases (first round, last round, etc.)

### First round
- Start stock is `capacity` (max). This is the best time to exploit.
- **Play D in round 1.**
Rationale: you immediately test whether others tolerate being exploited; if they still cooperate, you’ve found a profitable environment.

### Last round (`t = r`)
No future to preserve.
- **Always play D** in the last round.
Even if stock is low, cooperation has no strategic value.

### Second-to-last round (`t = r-1`)
- If `S_{r-1} >= S_safe`, play **D** (still mostly harvest time).
- If `S_{r-1} < S_safe`, you can still usually play **D** because only one round remains, but there is a subtlety: if `S_{r-1}` is extremely low, D vs C difference is small and you might prefer a one-step recovery to increase last-round take.  
So:
- If `S_{r-1} < 0.15*capacity`, play **C** (try to bump stock for final-round D).
- Else play **D**.

### “Everybody defects forever” environment
If opponents are essentially always defecting, you cannot fix it alone. Best response tends toward **D** except when a brief C can move stock into a region where your next D is meaningfully higher.
So implement:
- If `D_rate >= 0.9` for 3 consecutive rounds:
  - Play **D** unless `S_t < 0.2*capacity` and `t < r-1`, then play **C** for **one round** (a cheap attempt at recovery), then revert.

This prevents wasting many rounds cooperating in a hopeless pool.

---

## 3) Why this is exploitative (clear alignment)

1. **Default is defection whenever stock is high**: you take the largest immediate payoff while others bear the cost of restraint.
2. **Cooperation is purely instrumental**: you cooperate only to rebuild the stock so you can defect later at higher S (i.e., maximize the present value of future defection rents).
3. **Opponent-adaptive**: you escalate exploitation against cooperative tables, and you stop “feeding” a death spiral only when it hurts your own future earnings.
4. **Endgame grab**: unconditional last-round defection (and mostly last-two-round defection) extracts remaining value with no concern for sustainability.

---

## Pseudocode sketch

```python
# state variables
D_rate = 0.5  # initialize neutral
streak_high_def = 0

def action(t, r, n, capacity, S_t, kD_prev):
    global D_rate, streak_high_def

    if t == 1:
        return "D"

    # update opponent defection estimate
    opp_def = kD_prev / (n - 1)
    alpha = 0.3
    D_rate = alpha * opp_def + (1 - alpha) * D_rate

    if opp_def >= 0.9:
        streak_high_def += 1
    else:
        streak_high_def = 0

    S_safe = 0.35 * capacity
    S_hi   = 0.70 * capacity

    # endgame
    if t == r:
        return "D"
    if t == r - 1:
        if S_t < 0.15 * capacity:
            return "C"
        return "D"

    # hopelessly aggressive table: don't donate much
    if streak_high_def >= 3:
        if S_t < 0.2 * capacity:
            return "C"  # one-step recovery attempt
        return "D"

    # guardrails
    if S_t <= S_safe:
        return "C"

    if S_t >= S_hi:
        if kD_prev >= n - 1 and S_t < 0.9 * capacity:
            return "C"  # small attempt to restart growth if possible
        return "D"

    # middle region: exploit if farmable, stabilize if brutal
    if D_rate <= 0.4:
        return "D"
    if D_rate >= 0.7:
        return "C"

    # mixed: biased toward defection, but avoid pushing universal collapse
    if kD_prev >= n - 2:
        return "C"
    return "D"  # (or probabilistic D with p=0.6)
```

---

If you want, I can tune the thresholds (`0.35`, `0.70`, etc.) analytically for specific `n` and `capacity` (because the stock growth and consumption scale interact), but the above is designed to be robust across a wide range of opponent behaviors without assuming any coordination.
'''

description_EXPLOITATIVE_42 = '''
## Strategy: **Hydra Harvester (HH)**  
Goal: **extract as much as possible when others keep the stock productive, and punish in a way that both (a) stops others from exploiting you and (b) avoids permanently killing the resource unless that is already inevitable.**  
Core idea: keep the stock near **capacity** (where per-round gains are highest), but **tilt actions toward D whenever opponents are sufficiently cooperative** and toward **D-punishment when they are not**.

---

# Key quantities you can compute from history

Let current round be `t` (1-indexed), stock before actions be `S_t`.

From last round actions (observed after the round), compute:

- `kC_{t-1}` = number of opponents (not you) who played C in round `t-1`
- `kD_{t-1}` = number of opponents who played D in round `t-1` (`= (n-1) - kC`)
- `pC_{t-1}` = fraction of opponents who played C (`kC/(n-1)`)

Also track your own last action.

Useful stock thresholds (depend only on parameters):
- **Safety floor**: `S_low = 2n` (given state bounds). When stock is low, the logistic growth is small and D tends to finish it off.
- **Harvest zone**: `S_hi = 0.75 * capacity` (high enough that D yields large immediate payoff and stock can often recover if enough others C).

You can adjust constants (0.75 etc.) but keep them fixed and parameter-based.

---

# Strategic logic in plain language

1. **Exploit cooperators:**  
   If opponents are mostly cooperating and stock is high, play **D**. You get double the per-round payoff relative to C, and the pool likely remains productive because others restrain consumption.

2. **Don’t be the sucker:**  
   If opponents show meaningful defection, immediately switch to **D**. There’s no benefit to cooperating when others defect: you sacrifice payoff *and* accelerate collapse anyway.

3. **Keep the “golden goose” alive when it benefits you:**  
   If stock is getting low (near `S_low`) and opponents are largely cooperating, play **C** for a short “stabilization” phase to restore stock—*but only if you can plausibly ride others’ cooperation afterward*. This is not altruism; it’s investment to enable future high-payoff defections.

4. **Endgame cash-out:**  
   In the last round, always play **D**. There is no future to preserve.

5. **Robustness to weird opponents:**  
   - Against always-defect or chaotic types: you defect almost always and avoid wasting cooperation.
   - Against reciprocal/cooperative types: you defect a lot while occasionally cooperating just enough to keep them from switching permanently (and to keep stock high).
   - Against “punishers”: you defect until they punish, then you either (a) continue defecting if stock is high enough to cash out, or (b) temporarily cooperate to reset them if you can still profit in remaining rounds.

---

# Decision rules (implementable)

### Rule 0: Last round
- If `t == r`: **play D**.

### Rule 1: First round (information acquisition + exploitation)
- If `t == 1`: **play D**.  
Reason: highest stock, maximum immediate gain, and you learn who tolerates exploitation.

### Rule 2: Default stance: exploit if others allow it
After round 1, compute `pC_{t-1}`.

- If `pC_{t-1} >= 0.6` **and** `S_t >= S_hi`: **play D**.  
(They’re cooperative enough and stock is rich: harvest.)

### Rule 3: Punish any meaningful defection
- If `pC_{t-1} < 0.6`: **play D**.  
(If they won’t sustain the pool, you stop investing immediately.)

This makes you hard to exploit: anyone trying to D while you C gains nothing long-term because you stop cooperating right away.

### Rule 4: Stabilize only when it buys future profit
This is the only time you choose C after round 1.

If all these hold:
- Stock is threatened: `S_t <= S_low + (0.1 * capacity)` (low-ish)
- Opponents are highly cooperative: `pC_{t-1} >= 0.8`
- There is enough horizon left to recoup the investment: `t <= r - 2`

Then: **play C** for this round.

Interpretation: you cooperate briefly to push stock back into the harvest zone, expecting to return to D soon.

### Rule 5: Anti-”grim trigger” containment (optional but recommended)
Some strategies will cooperate until exploited, then defect forever. To keep extracting from them, do this:

Maintain a counter `streakD_opp`: number of consecutive rounds where `pC < 0.8`.

If you observe a sudden collapse in opponent cooperation after you defected (i.e., last round you played D and now `pC_{t-1} <= 0.2`), and stock is still healthy (`S_t >= S_hi`), then:
- **play C for exactly 1 round**, then return to the main rules.

This is a calculated “apology token” to re-enable future exploitation. If they don’t rebound, you revert to D.

---

# Pseudocode

```python
def HH_action(t, r, n, capacity, S_t, history):
    # history provides last round opponent actions, and your last action

    S_low = 2*n
    S_hi  = 0.75 * capacity

    if t == r:
        return "D"

    if t == 1:
        return "D"

    opp_last = history.opponent_actions(t-1)  # list length n-1, each "C" or "D"
    kC = sum(1 for a in opp_last if a == "C")
    pC = kC / (n-1)

    my_last = history.my_action(t-1)

    # Rule 5: containment for grim-trigger types (optional)
    if my_last == "D" and pC <= 0.2 and S_t >= S_hi and t <= r-2:
        return "C"  # one-round token, then normal rules next round

    # Rule 3: punish defection / no investment when others aren't cooperative
    if pC < 0.6:
        return "D"

    # Rule 4: invest only if pool is low and others are very cooperative and horizon remains
    if S_t <= S_low + 0.1*capacity and pC >= 0.8 and t <= r-2:
        return "C"

    # Rule 2: exploit cooperative field when stock is rich
    if pC >= 0.6 and S_t >= S_hi:
        return "D"

    # Otherwise default to D (exploitative bias)
    return "D"
```

---

# Edge cases explicitly handled

- **Round 1:** D (max extraction + reconnaissance).
- **Last round:** D (no future value).
- **Very low stock:** you *still mostly defect* unless (a) others are very cooperative and (b) enough rounds remain to profit from recovery.
- **Opponents always defect:** you always defect after seeing it once.
- **Opponents always cooperate:** you mostly defect; occasionally cooperate only if stock dips enough to threaten future gains.
- **Mixed populations:** thresholds (`0.6`, `0.8`) let you exploit cooperative majorities while not subsidizing defect-heavy groups.

---

# Why this is exploitative (not “nice” cooperation)

- The strategy’s **default is D**; C is used only as a **temporary investment** to keep the stock in a profitable regime or to **re-enable future exploitation** of trigger-happy cooperators.
- It **never** commits to mutual cooperation; it seeks **asymmetric advantage whenever opponents permit it**.
- It is **robust**: it doesn’t get trapped cooperating against defectors, and it can still profit against cooperators without relying on communication or shared norms.

If you want, I can tune the numeric thresholds (0.6/0.8, 0.75 capacity, low-stock margin) analytically for particular `(n, capacity, r)` ranges, but the above works as a general tournament policy.
'''

description_EXPLOITATIVE_43 = '''
## Strategy: **Regenerative Extortion (REX)**  
Exploit the fact that (i) **D always strictly dominates C within a round given the same stock S**, but (ii) **the stock can regenerate strongly if it isn’t driven too low**. So the goal is:

- **Farm opponents** by keeping the stock in a high-regeneration “sweet spot” and taking the larger share via **D** whenever it’s safe.
- **Use C only as an investment** to prevent collapse when others are already depleting the resource (or to “bait” cooperative types into keeping stock high while you take D-payoffs).

This is not “fair” cooperation; it’s stock management plus opportunistic extraction.

---

# 1) Decision rules (C vs D)

### Key quantities computed each round \(t\)
Let:
- \(S_t\) = current stock at start of round \(t\).
- From history at round \(t-1\), observe \(k_{t-1}\) = number of defectors among opponents (exclude you).
- Define **observed opponent defection rate**:
  \[
  q_{t-1} = \frac{k_{t-1}}{n-1}
  \]
- Define a **smoothed estimate** of opponent defection tendency (robust to noise):
  \[
  \hat q_t = (1-\alpha)\hat q_{t-1} + \alpha q_{t-1}
  \]
  with \(\alpha = 0.3\), initialize \(\hat q_1=0.5\).

### Stock safety thresholds
You want to keep stock away from the absorbing collapse at 0. Define:
- **Collapse-avoid threshold**:  
  \[
  S_{\text{low}} = 0.35\cdot \text{capacity}
  \]
- **Comfort threshold** (safe to exploit):  
  \[
  S_{\text{high}} = 0.70\cdot \text{capacity}
  \]
These are parameter-only functions; they work across capacities because the logistic growth is strongest mid-range.

### Core rule (exploit unless you must stabilize)
At each round \(t\), choose **D** by default, switch to **C** only if the stock is at risk *given expected opponent behavior*.

To decide, approximate expected total consumption if you play D vs C:

- If you play **D**: your take \(= S_t/n\).
- If you play **C**: your take \(= S_t/(2n)\).

Expected opponent consumption using \(\hat q_t\):
- Expected opponent per-player take:
  \[
  \mathbb{E}[c_{\text{opp}}] = \hat q_t\cdot \frac{S_t}{n} + (1-\hat q_t)\cdot \frac{S_t}{2n}
  = \frac{S_t}{2n}(1+\hat q_t)
  \]
- Expected total opponent consumption:
  \[
  (n-1)\cdot \frac{S_t}{2n}(1+\hat q_t)
  \]

So expected remaining stock if you play action \(a\in\{C,D\}\):
\[
S^{\text{rem}}(a)= S_t - \left[(n-1)\frac{S_t}{2n}(1+\hat q_t) + \mathbf{1}_{a=D}\frac{S_t}{n} + \mathbf{1}_{a=C}\frac{S_t}{2n}\right]
\]

**Decision rule:**
- **Play D** if \(S_t \ge S_{\text{high}}\). (Exploit while abundant.)
- Else if \(S_t \le S_{\text{low}}\):  
  - **Play C** if \(\hat q_t < 0.85\) (i.e., at least some opponents might respond to conservation and the stock is salvageable).  
  - **Play D** if \(\hat q_t \ge 0.85\) (others are essentially strip-mining; take what you can now).
- Else (mid zone \(S_{\text{low}}<S_t<S_{\text{high}}\)):  
  - Compute \(S^{\text{rem}}(D)\).  
  - If \(S^{\text{rem}}(D) < 0.20\cdot \text{capacity}\), **play C** (stabilize to keep the game profitable).  
  - Otherwise **play D**.

Intuition:  
- In high stock, D is pure advantage.  
- In low stock, only invest (C) if there’s a realistic chance it prevents collapse.  
- In the middle, defect unless it pushes the system toward the “death spiral.”

---

# 2) Edge cases (first round, last round, etc.)

### Round 1 (no history)
- **Play D in round 1**.
  - Reason: It’s a simultaneous game with no communication; D strictly dominates in the stage game. Also, many tournament agents begin with “cooperate”; you immediately extract maximum from them while stock is full.

Initialize \(\hat q_1 = 0.5\) (neutral prior).

### Last round \(t=r\)
- **Always play D**.
  - There is no future to protect; any conservation has no strategic value.

### Second-to-last round \(t=r-1\)
- **Play D unless stock is extremely low** and you believe opponents are mostly cooperating:
  - If \(S_{r-1} \le 0.25\cdot \text{capacity}\) and \(\hat q_{r-1} \le 0.30\), play **C**; otherwise **D**.
  - Rationale: only invest if it plausibly boosts \(S_r\) enough to increase your final-round extraction.

### “Collapse inevitable” handling
If stock hits a tiny level, growth is tiny and the game is basically over.
- If \(S_t < 0.05\cdot \text{capacity}\): **always D** (grab remaining value; C won’t rescue meaningfully).

---

# 3) Exploitative components (how it “hunts” other strategies)

### A. **Bait-and-harvest against conditional cooperators**
Many agents try to stabilize stock by cooperating when low.
- REX defects whenever stock is safe, letting others do the conservation work.
- When stock is threatened, REX cooperates *just enough* to keep the resource from collapsing, then returns to defecting once stock recovers above \(S_{\text{high}}\).

This creates an extortion-like pattern: opponents pay the “maintenance,” you take the surplus.

### B. **Asymmetric sacrifice only when profitable**
REX’s cooperation is never “nice”—it’s a calculated investment:
- Only cooperate when it increases expected future stock enough that your future **D** payoffs outweigh the one-round loss of switching D→C.

### C. **Punish always-defectors by not subsidizing them**
If \(\hat q\) is very high (near universal defection), REX stops conserving and defects to maximize immediate payoff, avoiding being the “sucker” propping up a doomed commons.

### D. **Robustness to noise and diverse opponents**
- Uses smoothed \(\hat q_t\) rather than reacting to one anomalous round.
- Doesn’t require coordination, signaling, or interpreting complex patterns.
- Works against: always-C, tit-for-tat-like, grim-trigger-like, random, and always-D.

---

# Pseudocode (implementable)

```python
# parameters: n, r, capacity
alpha = 0.3
S_low  = 0.35 * capacity
S_high = 0.70 * capacity

qhat = 0.5  # prior

for t in 1..r:
    observe stock S

    if t == r:
        action = "D"
    elif t == 1:
        action = "D"
    else:
        # update qhat from last round history
        q = (num_opponents_defected_last_round) / (n-1)
        qhat = (1 - alpha) * qhat + alpha * q

        if S < 0.05 * capacity:
            action = "D"

        elif S >= S_high:
            action = "D"

        elif S <= S_low:
            if qhat >= 0.85:
                action = "D"   # don't subsidize strip-miners
            else:
                action = "C"   # invest to prevent collapse

        else:
            # mid zone: defect unless it likely drives stock too low
            # approximate expected remaining stock if we defect
            opp_expected_per = (S/(2*n)) * (1 + qhat)
            opp_total = (n-1) * opp_expected_per
            Srem_if_D = S - (opp_total + S/n)

            if Srem_if_D < 0.20 * capacity:
                action = "C"
            else:
                action = "D"

    play(action)
```

---

If you want, I can also provide a more aggressively “exploit-detection” variant that explicitly classifies opponents (e.g., “stabilizers” vs “miners”) and times defections to maximize advantage against stabilizers while conceding nothing to miners.
'''

description_EXPLOITATIVE_44 = '''
## Strategy: **Harvest–Probe–Punish (HPP)**  
Goal: **extract as much as possible when others are cooperative**, but **avoid being the sucker** and **avoid collapsing the stock too early** unless collapse is profit-maximizing (near the end or when others already force collapse).

The key lever is that **your action affects the next stock level**, which affects *everyone’s* future payoffs. So exploitation here is not just “always D”, but “D when it buys extra payoff without destroying your future stream.”

---

# 1) Decision rules (when to C vs D)

### Concepts computed from history/state
Let current round be `t` (1-indexed), remaining rounds `T = r - t + 1`, current stock `S`.

From last round’s observed actions, compute:
- `kD = # of opponents who played D last round`
- `kC = (n-1) - kD`
- `pD = kD / (n-1)`  (opponent defection rate last round)

Also track a short memory “opponent cooperativeness score”:
- `pD_ema` = exponential moving average of `pD` over time (e.g., α=0.5).  
This makes you robust to noise and one-off moves.

### Stock-safety thresholds
You want to avoid pushing the system into low-stock regimes when you still have many rounds left.

Define two stock thresholds:
- **Critical threshold**: `S_crit = 2n` (near the minimum state bound; once you approach this, the game becomes low-payoff and volatile).
- **Caution threshold**: `S_caut = 0.35 * capacity` (tunable; in logistic growth, below a moderate fraction of capacity, depletion hurts more and recovery takes time, especially under defection).

### Core policy (high level)
1. **Exploit cooperators aggressively** when stock is healthy and there is time to keep the resource productive.
2. **Switch to defensive mode** (C) when opponents are mostly defecting (because D only accelerates collapse you can’t prevent).
3. **Endgame cash-out**: defect late because future stock value no longer matters.

---

## HPP rules

### Rule A — Endgame cash-out
If `t == r` (last round): **D**.  
If `T <= 2` and `S` is not critically low: **D**.  
Rationale: no future to protect; take max immediate payoff.

---

### Rule B — If stock is near collapse, don’t burn it unless others already do
If `S <= S_crit`:
- If opponents are mostly cooperating (`pD_ema < 0.25`): **C** (try to regenerate and then exploit later).
- Else: **D** (you won’t save it; take what you can).

This prevents you from being the lone “responsible one” when everyone defects, but also avoids self-sabotage when you *could* rebuild.

---

### Rule C — Healthy stock exploitation (the default)
If `S >= S_caut` and not in endgame:
- If opponents are largely cooperative (`pD_ema <= 0.35`): **D** (exploit).
- If mixed (`0.35 < pD_ema < 0.65`): **C** (resource protection + avoid triggering collapse wars).
- If opponents mostly defect (`pD_ema >= 0.65`): **C** (defensive; let them reveal whether they’ll keep collapsing it).

This is the “harvest” phase: defect when it’s safe and profitable, but don’t defect into a defection spiral that ruins future value.

---

### Rule D — Punish defection *selectively* (credible, not self-harming)
If an opponent defection spike happens (detectable betrayal), punish but only when stock can bear it.

Define “spike”:
- `pD - pD_prev >= 0.4` or (more simply) “they went from mostly C to many D”.

Punishment rule:
- If spike detected AND `S >= 0.5 * capacity` AND `T > 2`: play **D for the next 2 rounds**, then revert to the main policy using `pD_ema`.

Purpose: deter strategies that try to “cooperate to build stock then suddenly defect.” You answer with short sharp defection while there’s still time.

---

### Rule E — Recovery mode (when stock is low but salvageable)
If `S_crit < S < S_caut` and not endgame:
- If `pD_ema <= 0.5`: **C** (try to recover stock; then exploit later).
- Else: **C** for 1 round (test), then:
  - if opponents still mostly defect next round: switch to **D** (cut losses).

This is a one-round “probe”: you don’t keep cooperating forever against defectors.

---

# 2) Edge cases

### First round (no history)
Round 1 is a **probe** to classify the population without giving up too much.

**Round 1 action**:
- If `r <= 3`: **D** (short horizon; exploitation dominates).
- Else: **C** (cheap information gathering + keeps stock high for later exploitation).

Why C first when the game is longer? Because it preserves stock and reveals who defects immediately. If many defect immediately, you pivot quickly; if many cooperate, you can exploit for many rounds at high stock.

---

### Last round
Always **D**.

### Second-to-last round
Default **D**, unless `S` is extremely low (`S <= S_crit`) and you believe others will cooperate (`pD_ema < 0.25`), in which case **C** can slightly raise `S` to improve *your* last-round D payoff. (This is rare but can matter.)

---

### If everyone else always defects
You quickly detect `pD_ema ~ 1`. Policy becomes mostly **C** early only when trying a one-step probe; then shifts to **D** (since you can’t fix it). You end up taking the maximum you can given collapse is inevitable.

### If everyone else always cooperates
`pD_ema ~ 0`, stock stays high. You default to **D** for most mid-game rounds, extracting roughly double the cooperative payoff while their C behavior keeps the stock productive.

### If opponents alternate / are noisy
EMA smoothing and the “spike” detection prevent overreacting to one-off defections while still punishing real regime changes.

---

# 3) Why this is exploitative (explicit alignment)

- **Primary exploitation vector**: when others cooperate enough to sustain the stock, you **defect systematically** to take `S/n` instead of `S/(2n)` while free-riding on their restraint.
- **Secondary exploitation vector**: you use **short punishment bursts** to reduce the profitability of “bait-and-switch” opponents who try to build stock then defect—without committing to long mutual defection (which would hurt you too).
- **Strategic asymmetry**: you cooperate mainly as an *instrument* (to keep stock high or test opponents), not as a norm.

---

# Pseudocode (implementable)

```python
# parameters: n, r, capacity
S_crit = 2*n
S_caut = 0.35*capacity
alpha = 0.5

pD_ema = 0.5  # neutral prior
pD_prev = 0.5
punish_timer = 0

for t in 1..r:
    T = r - t + 1

    if t == 1:
        action = 'D' if r <= 3 else 'C'
        play(action)
        continue

    # after observing last round
    pD = kD_last_round / (n-1)
    pD_ema = alpha*pD + (1-alpha)*pD_ema
    spike = (pD - pD_prev) >= 0.4
    pD_prev = pD

    # endgame
    if t == r:
        play('D'); continue
    if T <= 2 and S > S_crit:
        play('D'); continue

    # active punishment
    if punish_timer > 0:
        punish_timer -= 1
        play('D')
        continue

    # trigger punishment
    if spike and S >= 0.5*capacity and T > 2:
        punish_timer = 2
        play('D')
        continue

    # critical stock region
    if S <= S_crit:
        play('C' if pD_ema < 0.25 else 'D')
        continue

    # low-but-salvageable stock
    if S < S_caut:
        if pD_ema <= 0.5:
            play('C')
        else:
            # probe once: cooperate now; if still high defection next round, shift to D
            play('C')
        continue

    # healthy stock
    if pD_ema <= 0.35:
        play('D')          # exploit cooperators
    elif pD_ema >= 0.65:
        play('C')          # don't accelerate collapse
    else:
        play('C')          # mixed: stabilize then reassess
```

If you want this to be even more exploitative, the simplest tweak is to raise the exploitation region from `pD_ema <= 0.35` to `<= 0.5` (defect unless a majority are defecting), at the cost of higher collapse risk.
'''

description_EXPLOITATIVE_45 = '''
## Strategy: **Harvest–Probe–Punish (HPP)**  
Goal: **take D whenever it’s safe/profitable**, but **keep the resource alive** when opponents are mostly cooperative so you can defect repeatedly on a high stock. The strategy opportunistically “free-rides” on cooperation, quickly punishes actions that threaten collapse, and stops wasting cooperation when the endgame approaches.

Key idea: In any round at stock \(S\), **D always gives you double the immediate payoff of C**, but D also increases total extraction and can crash future stock. So we:
- **Defect by default** to exploit cooperators.
- **Cooperate only as a conservation investment** when the stock is in danger *and* there’s enough horizon to recoup.
- **Condition on observed extraction rate** (how hard the group is hitting the resource), not on trust or “niceness”.

---

# 1) Decision rules: cooperate vs defect

### Quantities you compute each round \(t\)
Let:
- \(S_t\) = current stock at start of round \(t\).
- From last round’s observed actions, let \(d_{t-1}\) = number of opponents who defected (or total defectors including you; either works if consistent).
- Define **defection rate** last round:
\[
p_{t-1} = \frac{\text{# defectors last round}}{n}
\]
- Expected **per-player consumption factor** if defection rate is \(p\):
  - Cooperators consume \(S/(2n)\)
  - Defectors consume \(S/n\)
  - Average per-player consumption = \((1-p)\cdot \frac{S}{2n} + p\cdot \frac{S}{n} = \frac{S}{2n}(1+p)\)
  - Total consumption = \(n \cdot \frac{S}{2n}(1+p) = \frac{S}{2}(1+p)\)
- Remaining stock after consumption (approx):
\[
S^{rem} = S\left(1 - \frac{1+p}{2}\right) = S\cdot \frac{1-p}{2}
\]
So if \(p=1\) (all D), remaining stock ~0 (collapse). If \(p=0\) (all C), remaining stock ~ \(S/2\) (which regrows back to capacity under your growth rule when near \(S=capacity\)).

### Thresholds (depend only on parameters)
Define:
- **Danger stock** \(S_{\text{danger}} = 0.25\cdot capacity\)  
  Below this, one more heavy extraction round can push you into very low-stock territory where future payoffs are small.
- **Critical defection rate** \(p_{\text{crit}} = 0.5\)  
  If at least half the group defects, the pool is being hit hard enough that you should stop “investing” unless you’re in salvage mode.

### Core rule (what you play this round)
You choose **D** unless *all* of the following are true:
1) **Stock is low enough that conservation has value:** \(S_t \le S_{\text{danger}}\)  
2) **Opponents are not mostly defecting:** last observed \(p_{t-1} < p_{\text{crit}}\)  
3) **There’s enough time to benefit from recovery:** \(t \le r-2\) (at least 2 rounds left after this one)

If all 3 are true, play **C** (temporary conservation). Otherwise play **D**.

Intuition:
- When stock is high, you defect and harvest big.
- If stock becomes low but opponents are mostly cooperative, you cooperate briefly to rebuild stock so you can return to defecting at high \(S\).
- If opponents are mostly defecting, cooperation is a sucker move; you defect and accept depletion (or salvage only if you can prevent total zero).

---

# 2) Edge cases and special phases

### Round 1 (no history)
Start with **D**.  
Rationale: immediately tests whether there are unconditional cooperators / conservationists to exploit, and it does not risk collapse from capacity in a single round unless *everyone* defects (in which case cooperation wouldn’t reliably save you long-run anyway against such opponents).

### “Salvage mode” (prevent total collapse when it’s still exploitable)
If \(S_t\) is extremely low, the difference between C and D immediate payoff is tiny, and preserving any regrowth can matter.

Define **collapse threshold**:
\[
S_{\text{collapse}} = \max\left(\frac{capacity}{20},\, 2n\right)
\]
(Uses your given bound scale; ensures we treat “tiny stock” as emergency.)

**Rule:** If \(S_t \le S_{\text{collapse}}\) and \(t \le r-2\), play:
- **C** only if last round \(p_{t-1} \le 0.25\) (i.e., most others were cooperating)
- otherwise **D** (don’t throw good money after bad)

This makes you robust: you only invest in rescue when there’s evidence others won’t immediately destroy it.

### Last round
Always **D**.  
No future to conserve for, and D strictly dominates C for the stage payoff.

### Second-to-last round
Almost always **D**, except possibly:
- If \(S_t\) is low *and* you believe one round of conservation yields enough regrowth to make the last-round D payoff larger.
But because your growth happens **after** consumption and then caps at capacity, the main time C helps is when the remaining stock lands in the steep-growth region. This is hard to guarantee under uncertainty, so keep it simple and exploitative:

**Rule:** Round \(r-1\): **D**.

---

# 3) Exploitative mindset: how it exploits others

### Exploitation channel A: Free-ride on cooperators
If others play C often, stock stays high (especially near capacity), which makes your **D payoff large every round**: \(S/n\). You take double what cooperators take while the pool remains healthy due to their restraint.

### Exploitation channel B: Minimal “investment”, only when it increases future take
Your cooperation is not reciprocal or fair; it’s a **resource management action**:
- cooperate briefly only to keep stock from dropping into a low-payoff regime,
- then immediately return to defecting once \(S_t\) rises above \(S_{\text{danger}}\).

### Exploitation channel C: Don’t get baited into punishing at your own expense
Many tournament strategies try to “teach” cooperators/defectors with long punishments. Here, punishment is simply:
- if opponents defect a lot (high \(p\)), **never cooperate** (deny them the chance to exploit your conservation),
- take what you can now (D), because the game is headed to depletion anyway.

---

# Pseudocode (implementable)

```python
def HPP_action(t, r, n, capacity, S_t, last_actions):
    # last_actions: list of actions from previous round for all players (including self) or opponents;
    # if None => first round
    S_danger = 0.25 * capacity
    S_collapse = max(capacity / 20.0, 2*n)
    p_crit = 0.5

    if t == r:              # last round
        return "D"
    if t == r-1:            # second-to-last
        return "D"
    if last_actions is None: # round 1
        return "D"

    # compute defection rate last round
    num_defectors = sum(1 for a in last_actions if a == "D")
    p_last = num_defectors / n

    # salvage mode
    if S_t <= S_collapse:
        if p_last <= 0.25 and t <= r-2:
            return "C"
        else:
            return "D"

    # conservation investment zone
    if S_t <= S_danger and p_last < p_crit and t <= r-2:
        return "C"

    # exploit by default
    return "D"
```

---

## Why this is adaptive and robust
- **Adaptive to opponent mix:** Uses observed defection rate; reacts to cooperative populations by maintaining the pool just enough to keep exploiting; reacts to defect-heavy populations by abandoning cooperation.
- **Robust to strange heuristics:** Doesn’t rely on coordination, promises, fixed schedules, or interpreting “signals.”
- **Robust to endgame:** Hard-switches to D in final rounds to avoid being the one who “funds” others’ last-minute grabs.

If you want, I can also provide a more aggressive variant that estimates the *marginal future value* of cooperation using one-step lookahead on the growth equation (still parameter/state/history only), but the above is a strong tournament baseline for exploitation with collapse-avoidance.
'''

description_EXPLOITATIVE_46 = '''
Below is an **exploitative, stateful “harvest–punish–rebuild” strategy**. It tries to (i) **extract extra payoff whenever others are not punishing**, (ii) **avoid being the sucker** when others defect, and (iii) **keep the stock high enough** to continue extracting in later rounds. It adapts only from parameters, current stock, and observed history.

---

## Intuition (exploitative mindset)

- **Defection (D)** doubles your per-round take relative to cooperating (C) *given the same stock*, but it also depletes the stock faster.
- With this logistic growth, the stock rebounds strongly when it is around **capacity/2**, and it can stay at **capacity** if total consumption equals **S/2** (i.e., if the group consumes half the stock each round).  
- If most others cooperate, **you can defect and still keep stock healthy**, harvesting extra each round.
- If others start defecting, you **immediately defect** (don’t subsidize them) and optionally force a crash to deny them future value.
- If the stock gets low, you **temporarily cooperate** to rebuild it—*not out of altruism*, but to restore future harvesting capacity.

---

## Key quantities computed from history

Let in round \(t-1\):
- \(S_{t-1}\) = stock at start of that round.
- \(k_{t-1}\) = number of opponents who defected in that round (counting only others, so \(0 \le k \le n-1\)).

Given actions are binary and consumption amounts are known, the **estimated total consumption fraction** of stock is:

- Each cooperator consumes \(S/(2n)\)
- Each defector consumes \(S/n\)

So if you played action \(a\) and opponents had \(k\) defectors, total consumption fraction is:
\[
\alpha = \frac{\text{total consumption}}{S} = \frac{\#C}{2n} + \frac{\#D}{n} = \frac{(n - (\#D))}{2n} + \frac{\#D}{n} = \frac{1}{2} + \frac{\#D}{2n}
\]
where \(\#D\) is total defectors including you.

Thus, if total defectors including you is \(d\), then:
\[
\alpha = 0.5 + \frac{d}{2n}
\]
- If **all cooperate**: \(d=0 \Rightarrow \alpha=0.5\) (stock returns to capacity when near capacity)
- If **many defect**: \(\alpha\) rises toward 1 (stock collapses)

We’ll use this to decide whether we can safely keep defecting without killing the stock.

---

## Strategy: EHPR (Exploitative Harvest–Punish–Rebuild)

### High-level modes
1. **Harvest mode (exploit)**: defect when others are mostly cooperating and stock is healthy.
2. **Punish mode (don’t get exploited)**: if others defect, defect back immediately for a minimum number of rounds; if late game, keep defecting.
3. **Rebuild mode (restore resource)**: cooperate when stock is low so the resource regrows, then return to harvest.

---

## Decision rules (when to C vs D)

Define constants (depend only on parameters):
- `S_high = 0.80 * capacity`  (stock “healthy”)
- `S_low  = 0.35 * capacity`  (stock “dangerously low”; start rebuilding)
- `S_target = 0.70 * capacity` (rebuild until at least this)
- `k_tolerate = 0` by default (i.e., exploit only if **no** opponent defected last round); optionally allow 1 if n is large (see note below)
- `punish_len = 2` rounds of guaranteed retaliation after any observed opponent defection while stock is still not low
- `endgame_window = 2` final rounds: always defect

Maintain state variables:
- `punish_timer` initially 0
- `grace_used` initially false (one-time “probe” tolerance early, optional)

#### Rule 0: Last rounds (pure exploitation)
If `t > r - endgame_window`: **play D**.  
Reason: no future to preserve; defect is strictly higher immediate payoff.

#### Rule 1: If stock is low → rebuild (but only until profitable again)
If `S_t <= S_low`: **play C** (enter/continue rebuild mode) until `S_t >= S_target`, *unless it’s endgame window* (handled above).  
Reason: defecting on low stock yields small absolute gains and may keep the system near-zero; cooperating increases future harvestable stock.

#### Rule 2: Retaliate immediately against defectors (anti-exploitation)
If any opponent defected last round (`k_{t-1} > 0`) and `S_t > S_low`:
- Set `punish_timer = punish_len` (or refresh to max).
- While `punish_timer > 0`: **play D**, decrement timer each round.

Reason: if others defect, cooperating is being exploited and also accelerates collapse without deterrence.

#### Rule 3: Exploit cooperative groups (main profit engine)
If `S_t >= S_high` and (in last round all opponents cooperated: `k_{t-1} == 0`), then **play D**.

Reason: When others cooperate and stock is high, you can take double share. With just you defecting and all others cooperating, total defection count \(d=1\), consumption fraction \(\alpha=0.5 + 1/(2n)\), leaving substantial stock and still strong growth. You get the high payoff now and often keep the stock viable.

#### Rule 4: Otherwise, “camouflage cooperate” to keep the commons productive
If none of the above triggered: **play C**.

Reason: This is the “maintenance” action that keeps stock from drifting down when the environment is noisy or uncertain; it also makes you look less like a permanent defector, sometimes preventing coordinated punishment by conditional strategies.

---

## First round and probing

### Round 1
Play **C** in round 1.

Why (exploitatively): It’s the best information-gathering move with minimal downside when stock is at capacity. You learn whether opponents are unconditional defectors, conditional cooperators, etc., without immediately triggering retaliation from “grim”/TFT-like strategies.

### Optional early probe (aggressive variant)
If after round 1 you observed **zero opponent defectors** and stock is still high, you can defect in round 2 (Rule 3 will do this). This is effectively a probe: if they tolerate it, you keep exploiting; if they retaliate, you shift to punish/rebuild logic.

---

## Edge cases

1. **Everyone defects early**:  
   Stock crashes to ~0. Your rule set will defect in endgame / punish windows, but when stock is low you switch to C to rebuild. If others keep defecting, your cooperation won’t restore much—but defecting won’t either; cooperating is the only path to ever getting meaningful future payoffs. If it’s late, just defect.

2. **Mixed opponents (some conditional, some always defect)**:  
   Any observed defection triggers retaliation (Rule 2), preventing you from being the lone cooperator feeding defectors. If defectors are persistent, you’ll spend more time defecting/punishing and only rebuild when stock is low.

3. **Stock near capacity but opponents occasionally defect**:  
   You punish for `punish_len` rounds, then revert to C unless the group returns to full cooperation, in which case you exploit again. This creates a “tax”: others can cooperate (and get decent outcomes) but you extract extra whenever they are fully cooperative.

4. **Very small n (e.g., n=2)**:  
   One opponent defecting is extremely damaging; the strategy becomes more hair-trigger punishing (already is). The rebuild thresholds still work.

5. **Very large capacity vs 2n constraint**:  
   Thresholds are proportional to capacity so behavior scales; you’ll exploit longer when the stock is robust.

---

## Pseudocode

```python
# Inputs each round t: current stock S, history of actions
# Params: n, r, capacity

S_high   = 0.80 * capacity
S_low    = 0.35 * capacity
S_target = 0.70 * capacity
punish_len = 2
endgame_window = 2

state: punish_timer = 0

def choose_action(t, S_t, opponents_defected_last_round):
    global punish_timer

    # Rule 0: endgame
    if t > r - endgame_window:
        return "D"

    # Rule 1: rebuild if low
    if S_t <= S_low:
        punish_timer = 0
        return "C"

    # Rule 2: trigger/continue punishment
    if opponents_defected_last_round > 0:
        punish_timer = punish_len

    if punish_timer > 0:
        punish_timer -= 1
        return "D"

    # Rule 3: exploit fully cooperative group when stock is high
    if S_t >= S_high and opponents_defected_last_round == 0 and t > 1:
        return "D"

    # Round 1 (and default maintenance)
    return "C"
```

---

## Why this is exploitative and robust

- **Exploitative**: Whenever opponents demonstrate they can sustain cooperation (no one defected last round) and stock is high, you defect to take **double** payoff.
- **Robust**: It does not require trust, communication, or coordinated schedules. It reacts to observed defection immediately.
- **Resource-aware**: It doesn’t mindlessly defect into a barren commons; it rebuilds stock to keep future extraction profitable.
- **Tournament-friendly**: Performs reasonably against:
  - cooperators (you exploit),
  - conditional cooperators (you probe; you may cycle but still extract),
  - defectors (you avoid being exploited and deny long-run value).

If you want it *more* exploitative, you can lower the strictness by allowing exploitation even when a small fraction of opponents defected last round (e.g., tolerate `k <= floor((n-1)*0.1)` while `S_t` is very high). That raises immediate gains but increases collapse risk.
'''

description_EXPLOITATIVE_47 = '''
### Exploitative Strategy: **Probe–Exploit with Stock-Gated Punishment (PESGP)**

Goal: extract high payoffs when others sustain the resource (by defecting while they cooperate), but avoid destroying the stock when opponents are also predatory. The strategy adapts by *measuring* how cooperative the table is and by *defecting whenever it is safe/valuable*, while switching to *resource-preservation mode* only when necessary to keep future extraction possible.

---

## Key ideas (exploitative mindset)

1. **Default posture = opportunistic defection** whenever the environment can sustain it.
2. **Use cooperation as an investment** only to (a) keep stock from collapsing, and (b) induce/maintain others’ cooperation.
3. **Punish predation quickly** (to avoid being the sucker), but **reward cooperative groups with exploitation** (defecting against them) as long as stock remains healthy.
4. **Endgame grab**: in the final round, always defect (no future stock value).

---

## What you observe each round

At round \(t\), before acting, you know:
- current stock \(S_t\)
- history of actions; in particular, last round’s number of defectors \(d_{t-1}\) and cooperators \(c_{t-1}=n-d_{t-1}\)

Define:
- **Defection rate last round**: \(\rho_{t-1} = d_{t-1}/n\)
- **Recent defection rate (smoothed)**:  
  \[
  \bar{\rho}_t = \alpha \rho_{t-1} + (1-\alpha)\bar{\rho}_{t-1}, \quad \alpha \in [0.3,0.6]
  \]
  (Initialize \(\bar{\rho}_1 = 0.5\) as neutral.)

This gives robustness against noisy strategies.

---

## Decision Rules (when to C vs D)

### Stock thresholds
Use stock gates to prevent accidental collapse:

- **Critical stock**: \(S_t \le 2n\) (near the minimum meaningful level in your spec)
- **Low stock**: \(S_t \le 0.25 \cdot \text{capacity}\)
- **Healthy stock**: \(S_t \ge 0.6 \cdot \text{capacity}\)

(These are parameter-based and scale to any capacity.)

### Rule A — Last round (endgame)
- If \(t = r\): **play D**.

Rationale: no future value to preserving stock; exploit immediately.

---

### Rule B — Critical/low stock survival mode
If stock is endangered, prioritize keeping it from hitting zero *only if* there are future rounds to exploit.

- If \(S_t \le 2n\) and \(t < r\): **play C**.
- Else if \(S_t \le 0.25\cdot \text{capacity}\) and \(t < r\):
  - If \(\bar{\rho}_t \ge 0.5\) (others mostly defecting): **play D** (they’re going to crash it anyway; take what you can).
  - Else: **play C** (invest to restore stock because others are likely to help maintain it).

Rationale: don’t waste cooperation when opponents are predators; do invest when the group is cooperative enough for stock recovery.

---

### Rule C — Exploit cooperative environments (main mode)
If stock is not low and there’s time left:

- If \(S_t \ge 0.6\cdot \text{capacity}\) and \(t < r\):
  - If \(\bar{\rho}_t \le 0.35\): **play D** (exploit: most others cooperate, stock is healthy).
  - Else if \(\bar{\rho}_t \ge 0.65\): **play D** (everyone is predatory; grab now).
  - Else (mixed): go to Rule D.

Rationale: in both very cooperative and very defect-heavy regimes, defection is best for immediate payoff; only the “mixed middle” needs careful handling.

---

### Rule D — Mixed regime: conditional predation with punishment bursts
When opponents are mixed, you want to (i) avoid being exploited by defectors, but (ii) still exploit cooperators when possible.

Maintain an internal **punishment counter** `punish` (integer, starts at 0).

Update after observing last round:
- If last round defection rate \(\rho_{t-1} > 0.5\): set `punish = 2` (two-round harsh response)
- Else if \(\rho_{t-1} < 0.25\): set `punish = 0` (table is cooperative; return to exploitation)
- Else: decrement `punish` by 1 if > 0

Action in mixed regime:
- If `punish > 0`: **play D**
- Else: **play D** if \(S_t \ge 0.4\cdot\text{capacity}\), otherwise **play C**

Rationale:
- The “punishment burst” prevents you from being the lone cooperator feeding defectors.
- When punishment is off, you still defect unless stock is slipping—cooperation is only used to keep the resource exploitable later.

---

## Edge cases & special handling

### Round 1 (no history)
Round 1 is a probe round. Start by **defecting** unless the stock is oddly low (shouldn’t be, since initial stock = capacity).

- If \(t=1\) and \(S_1 \ge 0.4\cdot\text{capacity}\): **D**
- Else: **C**

Rationale: immediate exploitation opportunity; also tests whether others are fragile cooperators who keep cooperating despite being exploited.

### “Collapse imminent” check
Because consumption depends on current stock, total take can wipe out the stock if many defect. Add a conservative safety valve:

If \(t<r\) and \(S_t\) is medium but trending down (e.g., \(S_t < S_{t-1}\) for 2 consecutive rounds) and \(\bar{\rho}_t \le 0.4\), then **play C for one round** to stabilize and keep future exploitation alive.

This is not “nice”; it’s asset protection.

### Final two rounds
If you want even more exploitation:
- If \(t = r-1\): **D** unless \(S_t \le 2n\) (in which case C might slightly increase round \(r\) payoff, but often too late). A simple robust rule:
  - If \(S_t \le 0.25\cdot\text{capacity}\): **D**
  - Else: **D** (default)

In practice: defect both final rounds.

---

## Pseudocode (implementable)

```pseudo
params: n, r, capacity
state vars:
  rho_bar = 0.5
  punish = 0
  S_prev = None
  downtrend = 0

alpha = 0.5

function act(t, S, history):
  if t == r:
    return D

  if t == 1:
    return (S >= 0.4*capacity) ? D : C

  # compute last-round defection rate
  d_last = number_of_defectors_in_round(t-1, history)
  rho_last = d_last / n
  rho_bar = alpha*rho_last + (1-alpha)*rho_bar

  # downtrend tracker
  if S_prev != None and S < S_prev:
    downtrend += 1
  else:
    downtrend = 0
  S_prev = S

  # Critical stock protection (only if future exists)
  if S <= 2*n:
    return C

  # Low stock rule
  if S <= 0.25*capacity:
    if rho_bar >= 0.5:
      return D
    else:
      return C

  # Healthy stock exploitation
  if S >= 0.6*capacity:
    return D

  # Safety valve: protect future exploitation if others are cooperative
  if downtrend >= 2 and rho_bar <= 0.4:
    return C

  # Mixed regime punishment bursts
  if rho_last > 0.5:
    punish = 2
  else if rho_last < 0.25:
    punish = 0
  else if punish > 0:
    punish -= 1

  if punish > 0:
    return D
  else:
    return (S >= 0.4*capacity) ? D : C
```

---

## Why this is exploitative and robust

- **Exploitative**: defects in round 1, in healthy-stock regimes, and in endgame; cooperates only when stock preservation increases expected future extraction.
- **Robust**: switches to “grab now” when others are predatory; uses smoothing + punishment bursts to handle noisy/mixed opponents.
- **Adaptive**: responds to observed defection rates and stock trajectory; won’t blindly cooperate into a tragedy-of-the-commons spiral.

If you want, I can also provide a tuned variant optimized for (a) very large \(r\), (b) small capacity close to \(2n\), or (c) populations with many trigger/reciprocator strategies.
'''

description_EXPLOITATIVE_48 = '''
## Strategy: **Regenerative Extortion with Stock Safeguard (RESS)**  
Goal: **Harvest high payoffs by defecting whenever others keep the stock healthy**, while **switching to cooperation only when needed to prevent stock collapse**, and **punishing** opponents who try to free-ride on your restraint.

Key idea: In this game, *stock is the engine*. If others keep it high, you should defect to take double. If stock is at risk, you (reluctantly) cooperate to keep the engine alive—but only as much as required, and you use history to decide whether to “save” the resource or let it crash to deny profit to exploiters.

---

# 1) Decision rules (C vs D)

### Track these quantities each round \(t\)
- \(S_t\): current stock at start of round \(t\).
- Let observed number of defectors last round: \(d_{t-1}\) (from actions).
- Compute **implied total consumption fraction** last round:
  - If \(d\) defected and \(n-d\) cooperated, total consumption was:
    \[
    \text{consumption} = S \left(\frac{n-d}{2n} + \frac{d}{n}\right) = S\left(\frac{1}{2} + \frac{d}{2n}\right)
    \]
  - So the **fraction remaining after consumption** is:
    \[
    x(d)=1-\left(\frac{1}{2} + \frac{d}{2n}\right)=\frac{1}{2}-\frac{d}{2n}=\frac{n-d}{2n}
    \]
- Stock update (before cap):
  \[
  S' = S\left[x + 2x(1-x)\right] = S\left(3x - 2x^2\right)
  \]
  where \(x=x(d)\).  
  This tells you, given current stock and an expected defector count, whether the stock will grow or shrink.

### Maintain a simple opponent “pressure” estimate
Let:
- \(D\_rate\): exponentially weighted moving average of how many opponents defect:
  \[
  D\_rate \leftarrow (1-\alpha)D\_rate + \alpha\cdot \frac{d_{t-1}}{n-1}
  \]
  with \(\alpha \approx 0.3\).  
Interpretation: Are opponents mostly cooperating (low) or mostly defecting (high)?

---

## Core policy
RESS has three modes: **Exploit**, **Stabilize**, **Crash/Punish**. You decide mode from stock level and opponent pressure.

### Thresholds (parameter-only, robust)
Define:
- **Safe stock**: \(S_t \ge 0.6\cdot capacity\)
- **Fragile stock**: \(0.25\cdot capacity \le S_t < 0.6\cdot capacity\)
- **Critical stock**: \(S_t < 0.25\cdot capacity\)

Define opponent types (from \(D\_rate\)):
- **Mostly cooperative opponents**: \(D\_rate \le 0.35\)
- **Mixed**: \(0.35 < D\_rate < 0.65\)
- **Mostly defecting opponents**: \(D\_rate \ge 0.65\)

---

## Action rule by mode

### Mode A — **Exploit** (take the double whenever feasible)
If stock is **Safe** and opponents are not mostly defecting:
- **Play D**.

Rationale: If others keep the resource productive, defecting is strictly better *this round* and usually doesn’t immediately kill the stock when others cooperate enough.

---

### Mode B — **Stabilize** (reluctant cooperation to keep the engine alive)
If stock is **Fragile**, choose action based on whether your defection would likely push the system toward collapse **given observed defection pressure**.

Operational rule:
- If \(D\_rate \le 0.5\) (opponents fairly cooperative):  
  - **Play D** *unless* stock has been decreasing for 2 consecutive rounds; then **play C** once to arrest decline.
- If \(D\_rate > 0.5\) (opponents leaning defect):  
  - **Play C** to avoid being part of a death spiral **only if** you believe the stock can recover (see “Recoverability test” below); otherwise go to Crash/Punish.

Recoverability test (simple):
- If \(S_t \ge 0.35\cdot capacity\), treat as recoverable with some cooperation.  
- If \(S_t < 0.35\cdot capacity\) and \(D\_rate>0.5\), assume opponents won’t sustain recovery → Crash/Punish.

Rationale: You cooperate only when (i) it preserves future exploitation opportunities and (ii) opponents are likely to “use” the preserved stock rather than immediately burn it.

---

### Mode C — **Crash / Punish** (deny future value to defect-heavy opponents)
If stock is **Critical**, or opponents are **mostly defecting**, or recoverability fails:
- **Play D** (burn it down).

Rationale: When others defect heavily, your cooperation is just subsidizing their doubled extraction. Collapsing stock removes the future rents they’d exploit.

---

# 2) Edge cases

### First round (no history)
Start in **Exploit** unless the horizon is extremely short.
- If \(r \ge 3\): **Round 1 = D** (grab early advantage; you can still stabilize later).
- If \(r = 2\): **Round 1 = D** as well (endgame is too close to justify investing).

Why: Cooperation has no immediate advantage and only helps if it sustains stock. Early defection tests whether opponents will keep the engine running anyway.

---

### Last round
**Always play D** in round \(r\).
Reason: No future value from preserving stock.

---

### Second-to-last round (\(r-1\))
- If stock is already high (Safe): **D**.
- If stock is low (Fragile/Critical): still usually **D**, *unless* a single cooperative round would raise stock enough that your last-round defection payoff increases materially.

Simple heuristic:
- If \(S_{r-1} < 0.4\cdot capacity\): **D**.
- If \(S_{r-1} \ge 0.4\cdot capacity\) and opponents were mostly cooperative (\(D\_rate \le 0.35\)): **C** at \(r-1\) to pump stock, then **D** at \(r\).

This is the only “investment” near the end, and only when it’s likely to pay *you* back next round.

---

### If stock hits ~0
When \(S_t \approx 0\), C and D both give ~0.  
Default to **D** (no reason to give any concession; also consistent with punish mode).

---

# 3) Why it’s exploitative (explicit alignment)

RESS is exploitative in three ways:

1. **Default defection under prosperity**: Whenever the group sustains a high stock, you take the double payoff every round.
2. **Conditional “resource-saving” only for self-interest**: You cooperate only when preserving stock is likely to create *future* high-stock states that you can later defect against.
3. **Credible denial / punishment**: If opponents defect heavily, you stop subsidizing them and actively accelerate collapse, preventing them from earning long-run rents off your restraint.

---

# Pseudocode (implementable)

```python
def RESS(t, r, n, capacity, S_t, history_actions, history_stocks):
    # last round defector count
    if t == 1:
        D_rate = 0.5  # neutral prior
        d_last = None
    else:
        d_last = count_defectors(history_actions[t-1])
    
    # update D_rate (EWMA)
    if t == 1:
        D_rate = 0.5
    else:
        alpha = 0.3
        opp_def_frac = d_last / (n-1)  # from opponents; exclude self if tracked, else approximate with n
        D_rate = (1-alpha)*prev_D_rate + alpha*opp_def_frac

    # edge: last round
    if t == r:
        return "D"

    # stock regime thresholds
    safe = (S_t >= 0.6*capacity)
    fragile = (0.25*capacity <= S_t < 0.6*capacity)
    critical = (S_t < 0.25*capacity)

    mostly_coop = (D_rate <= 0.35)
    mostly_def = (D_rate >= 0.65)

    # first round
    if t == 1:
        return "D"  # probe + exploit

    # second-to-last round special
    if t == r-1:
        if S_t >= 0.4*capacity and mostly_coop:
            return "C"
        else:
            return "D"

    # Mode selection
    if safe and not mostly_def:
        return "D"  # Exploit

    # Crash/Punish
    if critical or mostly_def:
        return "D"

    # Fragile: Stabilize conditionally
    # check trend (2-step decline)
    declining_2 = False
    if t >= 3:
        declining_2 = (history_stocks[t-1] < history_stocks[t-2] < history_stocks[t-3])

    if fragile:
        if D_rate <= 0.5:
            return "C" if declining_2 else "D"
        else:
            # recoverability test
            if S_t >= 0.35*capacity:
                return "C"
            else:
                return "D"

    # default fallback
    return "D"
```

---

If you want, I can also provide:
- a more “mathematically tight” version that uses the exact stock map \(S' = S(3x-2x^2)\) to compute whether cooperating changes expected \(S_{t+1}\) enough to justify it, or
- a variant tuned for maximizing tournament score against specific opponent classes (grim trigger, tit-for-tat-like, stochastic, etc.).
'''

description_EXPLOITATIVE_49 = '''
## Strategy: **Harvest–Test–Punish–Recover (HTPR)**  
Goal: **extract as much as possible when others sustain the stock**, but **avoid being the sucker** and **avoid mutually assured collapse** unless collapse is the best response (e.g., near the end or against persistent defectors).

This strategy treats the resource as a renewable asset. It **defects by default when safe/profitable**, but it **switches to cooperation as a “maintenance mode”** whenever the system is in danger of collapsing (which would reduce your future extraction to ~0).

---

## Key ideas (exploitative logic)

1. **Defection is immediately better in any given round** (you get double a cooperator’s payoff at the same stock). So the exploitative baseline is **D**.
2. But repeated play + stock dynamics means over-defection can crash the stock, killing future payoffs. So you must sometimes **cooperate to keep the “golden goose” alive**, especially when others are already over-consuming.
3. Use history to estimate opponents’ current “defection rate” and **free-ride** when they appear to be maintaining stock, but **punish** when they exploit you or threaten sustainability.
4. In late rounds, future stock is less valuable: **be more aggressive** (more defection).

---

## Notation you observe each round
- `S_t`: current stock at start of round `t`
- `d_{t-1}`: number of opponents who defected last round (you can observe actions)
- `Dshare_{t-1} = d_{t-1}/(n-1)`
- `EMA_D`: exponentially weighted moving average of opponents’ defection share (tracks “how defecty” the population is)
- `t`: current round, `1..r`

Suggested constants (work across many parameterizations):
- `alpha = 0.35` (EMA update rate)
- **Safety stock threshold:** `S_safe = 0.6 * capacity`  
- **Critical stock threshold:** `S_crit = 0.35 * capacity`
- **Endgame window:** last `ceil(r/5)` rounds (20% of horizon)
- **Punishment length:** `L = 2` rounds (short, sharp punishment)

---

## Core decision rule (high level)

You choose between:
- **Exploit/Harvest mode (play D)** when stock is healthy or opponents are cooperative enough to sustain it.
- **Maintenance/Recovery mode (play C)** when stock is low *and* opponents aren’t cooperating enough.
- **Punishment mode (play D for L rounds)** when you detect that opponents increased defection while stock was vulnerable (i.e., they’re trying to free-ride on your maintenance).

---

## Step-by-step decision rules

### 0) Initialize (Round 1)
**Round 1: play D.**  
Rationale: you immediately learn how others behave under no prior discipline, and you capture high initial stock.

Initialize:
- `EMA_D = 0.5` (neutral prior)
- `punish_timer = 0`

---

### 1) Update beliefs after each round
After observing opponents in round `t-1`:
```
Dshare = (# opponents who played D) / (n-1)
EMA_D = alpha * Dshare + (1-alpha) * EMA_D
```

Also track whether the stock is trending down:
- `stock_drop = (S_{t-1} - S_t) / capacity` (or just compare S_t to S_{t-1})

---

### 2) Determine “sustainability pressure” from current stock
Define:
- **Healthy:** `S_t >= S_safe`
- **Vulnerable:** `S_crit <= S_t < S_safe`
- **Critical:** `S_t < S_crit`

Interpretation:
- In **Healthy**, you can usually defect with low risk.
- In **Vulnerable/Critical**, you cooperate only if it plausibly prevents collapse; otherwise you defect (either to punish or to grab remaining value).

---

### 3) Endgame adjustment (more exploitative near the end)
Let:
- `endgame = (t > r - ceil(r/5))`

In endgame, reduce willingness to “invest” in recovery, because fewer rounds remain to benefit:
- Treat `S_safe` as higher (i.e., require *more* stock to justify cooperation), or equivalently:
  - In endgame: cooperate only in **Critical** AND only if opponents are mostly cooperating.

---

### 4) Punishment trigger (anti-free-riding)
You want to avoid being the only one doing maintenance.

Trigger punishment if:
- Stock is **Vulnerable or Critical** AND
- Opponents’ defection just jumped or is high:
  - `Dshare_{t-1} >= 0.5` OR `EMA_D >= 0.55`
- AND you cooperated recently (so they might be exploiting your restraint), e.g.:
  - you played C in at least 1 of last 2 rounds

Then:
- `punish_timer = L` (play D for the next L rounds regardless of stock unless stock is extremely near zero—see edge cases)

Rationale: short punishment deters “exploit the maintainer” strategies and tests whether cooperation is real.

---

## Action selection (final policy)

At the start of round `t`, with current stock `S_t`:

### A) If last round (t = r)
**Always play D.**  
No future to protect.

### B) If `punish_timer > 0`
**Play D**, decrement timer.  
Exception: if `S_t` is extremely low (see “meltdown edge case”).

### C) Otherwise choose based on stock and opponent cooperativeness:

#### Case 1: Healthy stock (`S_t >= S_safe`)
**Play D.**  
Exploit while the resource is abundant.

#### Case 2: Vulnerable stock (`S_crit <= S_t < S_safe`)
- If opponents are fairly cooperative:
  - Condition: `EMA_D <= 0.45` (most opponents often play C)
  - **Play D** (free-ride; they are maintaining enough)
- Else (opponents too defecty):
  - **Play C** *if not in endgame* (try to stabilize and avoid collapse)
  - In endgame: **Play D** (harvest remaining value)

#### Case 3: Critical stock (`S_t < S_crit`)
- If opponents are cooperative enough that recovery is plausible:
  - Condition: `EMA_D <= 0.35`
  - **Play C** (maintenance is worth it because others will also likely maintain)
- Else:
  - **Play D** (you can’t save it alone; take what you can)

---

## Meltdown edge case (near-zero stock)
If `S_t` is extremely low, like `S_t <= stock_floor`, where:
- `stock_floor = capacity / (10*n)` (small but parameter-scaled)

Then:
- If not last round and `EMA_D <= 0.4`: **Play C** (try to restart growth)
- Else: **Play D** (either it’s hopeless or endgame; grab remaining)

Reason: with logistic growth, very low stocks can regrow, but only if consumption is restrained. If opponents are still defecting, your cooperation won’t rescue it.

---

## Pseudocode summary

```
parameters:
  alpha = 0.35
  S_safe = 0.6*capacity
  S_crit = 0.35*capacity
  L = 2
  endgame_window = ceil(r/5)
  stock_floor = capacity/(10*n)

state:
  EMA_D = 0.5
  punish_timer = 0
  recent_my_actions (last 2)

Round 1:
  play D

For round t >= 2:
  observe last round opponents => Dshare
  EMA_D = alpha*Dshare + (1-alpha)*EMA_D

  endgame = (t > r - endgame_window)

  if t == r:
     return D

  if punish_timer > 0:
     punish_timer -= 1
     if S_t <= stock_floor and EMA_D <= 0.4 and not endgame:
         return C
     else:
         return D

  # punishment trigger
  if (S_t < S_safe) and (Dshare >= 0.5 or EMA_D >= 0.55) and (I played C in last 2 rounds):
       punish_timer = L
       return D

  if S_t >= S_safe:
      return D

  if S_crit <= S_t < S_safe:
      if EMA_D <= 0.45:
          return D
      else:
          if endgame: return D
          else: return C

  if S_t < S_crit:
      if EMA_D <= 0.35 and not endgame:
          return C
      else:
          return D
```

---

## Why this is exploitative and robust

- **Exploitative:** Defaults to **D whenever stock is not in danger** or when opponents appear to be providing sufficient restraint. You systematically **free-ride** on cooperative populations.
- **Robust:** Doesn’t assume any coordination; it reacts to observed defection rates and stock level.
- **Anti-exploitation:** If you start cooperating to prevent collapse and others defect into that, the punishment module prevents you from becoming a perpetual maintainer.
- **Tournament-friendly:** Performs well against:
  - Always-cooperators (you mostly defect and win big while keeping stock high enough)
  - Grim/punisher types (you may trigger punishment cycles, but you also cooperate in low-stock regimes to re-stabilize)
  - Always-defectors (you defect too; cooperation won’t save it alone, especially near endgame)
  - Mixed/adaptive opponents (EMA tracking makes it hard for them to manipulate you with short noisy patterns)

If you want, I can also provide a variant tuned for *maximum exploitation of cooperative strategies* (more aggressive thresholds) versus a variant tuned for *higher average payoff in diverse pools* (more stock-preserving).
'''

description_EXPLOITATIVE_50 = '''
## Strategy: **Switching Extortion with Stock Safeguard (SESS)**  
Goal: maximize your own cumulative payoff by (i) defecting whenever it is safe/profitable, (ii) selectively “investing” (cooperating) only when it increases *your* future extraction, and (iii) punishing opponents just enough to prevent them from free-riding you into doing all the rebuilding.

Key idea: In this game, the stock regenerates strongly when the post-consumption remainder is around `capacity/2`, and collapses when remainder hits 0. So you want the group to *not* drive the stock to 0 too often, but you also want *others* to bear the cooperation burden whenever possible. SESS tries to sit at/near the profitable high-stock region while behaving like a credible threat: “I defect by default; I only cooperate to keep the resource alive, and I stop cooperating if I’m being exploited.”

---

# 1) Decision rules: when to cooperate vs defect

### Observables each round \(t\)
- Current stock: `S`
- History of others’ actions (counts of C/D)
- Rounds remaining: `R = r - t + 1`

Let:
- `k` = number of *other* players who defected last round (0..n-1)
- `d_hat` = estimated expected number of defectors among others next round (we use simple inertia: `d_hat = k`)
- If you play `C`, you consume `S/(2n)`. If you play `D`, you consume `S/n`.

### Stock-safety threshold logic
Define predicted remaining stock after consumption if you choose action `a ∈ {C,D}` and expect `d_hat` other defectors:

- Others’ expected total consumption:
  - Expected defectors among others: `d_hat`
  - Expected cooperators among others: `(n-1 - d_hat)`
  - Total others’ consumption:
    \[
    Cons_{others} = d\_hat \cdot \frac{S}{n} + (n-1-d\_hat)\cdot\frac{S}{2n}
    = \frac{S}{2n}\left((n-1) + d\_hat\right)
    \]

- Your consumption:
  - If `C`: `S/(2n)`
  - If `D`: `S/n = 2S/(2n)`

So predicted remainder:
\[
S_{rem}(C) = S - \frac{S}{2n}\left((n-1)+d\_hat + 1\right)
= S\left(1 - \frac{n + d\_hat}{2n}\right)
\]
\[
S_{rem}(D) = S - \frac{S}{2n}\left((n-1)+d\_hat + 2\right)
= S\left(1 - \frac{n + d\_hat + 1}{2n}\right)
\]

You don’t actually need the algebra in implementation; just compute from definitions.

### “Viability band” for stock
We want to avoid remainder too low (collapse) *unless we’re in the endgame*, and we want to avoid being the sole investor.

Use two thresholds:
- `S_floor`: minimum remainder to avoid spiral/collapse. Set:
  - `S_floor = max( capacity * 0.10 , 1e-9 )` (10% of capacity)
- `S_target_low`: prefer to keep remainder near capacity/2 for max growth:
  - `S_target_low = capacity * 0.35` (a loose band; you don’t need exact 0.5)

### Exploitative action selection
You choose `D` by default. You choose `C` only if **all** of these are true:

1) **Stock is at risk if you defect**  
   If `S_rem(D) < S_floor`, then cooperating is an “investment” to prevent imminent crash (or to reduce the chance of crash).

2) **You are not being singled out as the sucker**  
   If opponents are mostly defecting, your cooperation just subsidizes them. Require:
   - `k ≤ (n-1)/2` (i.e., at most half the others defected last round)  
   If more than half defected last round, you *punish* with `D` even if stock suffers, except when you’re still far from the end and stock would almost surely hit 0 immediately (see safeguard below).

3) **There is enough horizon to repay the investment**  
   Only invest if `R > 2`. If there are 1–2 rounds left, rebuilding is mostly wasted (you won’t recoup).

#### Safeguard override (rare cooperation when collapse is immediate and horizon is long)
If `R` is large (say `R >= 4`) and your predicted `S_rem(D) <= 0` but `S_rem(C) > 0`, then play `C` even if many defected. This is purely to keep the stock from hitting zero so you can keep extracting later; it’s not altruism.  
But if this happens repeatedly, you’ll switch to “scorched earth” (below).

---

# 2) Edge cases: first round, last round, and state extremes

### Round 1
- Play `D`.  
Reason: (i) immediate payoff advantage, (ii) you learn opponents’ baseline behavior without paying the cooperation cost, (iii) if they all defect, the stock collapses anyway and your C wouldn’t save you much in expectation.

### Last round (t = r)
- Always play `D`.  
No future stock value; take the max immediate extraction.

### Second-to-last round (t = r-1)
- Play `D` unless stock is so low that `D` yields essentially nothing while `C` keeps it positive *and* you expect at least some cooperation last round (rare). In practice: just `D`. The strategic leverage is gone.

### Stock already near zero
If `S` is very small (e.g., `S < capacity*0.02`):
- Play `D` unless `R >= 4` and the group has recently shown willingness to cooperate (e.g., `k <= 1` for the last 2 rounds).  
Rationale: When the stock is tiny, your action hardly changes payoffs now; investing only makes sense if you’re confident others will also invest soon.

### Stock at capacity (or high)
If `S >= capacity*0.85`:
- Play `D` (extract while abundant).  
If everyone cooperates you still do great; if others defect you’re not behind.

---

# 3) Exploitative mindset: escalation, punishment, and “sucker detection”

SESS includes a simple regime switch: **Normal Extortion Mode** vs **Scorched Earth Mode**.

### Track “exploitation pressure”
Maintain a counter `exploit` that increases when others defect while stock is in a range where cooperation would be beneficial.

For each round:
- If `S > capacity*0.25` and `k >= ceil((n-1)*0.6)` (≥60% of others defect), then `exploit += 1`
- Else `exploit = max(exploit - 1, 0)`

### Scorched Earth Mode trigger
If `exploit >= 2` (two strong-defection signals recently), switch to **Scorched Earth** for the rest of the game *or* for a fixed cooldown (e.g., 3 rounds).

**Scorched Earth rule:** always `D`.  
Reason: if others are predominantly defecting, any cooperation you provide is a public good they will convert into higher personal extraction next round. You stop being the investor.

### Re-entry (optional, if you want more adaptivity)
After a cooldown of 3 rounds, if you observe `k <= (n-1)/2` for 2 consecutive rounds and `R >= 5` and `S` is not collapsing, return to Normal Extortion Mode.

This lets you exploit “conditional cooperators” who start cooperating again once the stock becomes dire.

---

# Pseudocode (implementable)

```python
# parameters: n, r, capacity
# state each round: S, history actions
mode = "NORMAL"
exploit = 0
cooldown = 0

def choose_action(t, S, last_actions_others):
    global mode, exploit, cooldown
    R = r - t + 1
    k = count_defectors(last_actions_others)  # 0..n-1
    d_hat = k  # inertia prediction

    # edge cases
    if t == 1: 
        return "D"
    if t == r:
        return "D"
    if t >= r-1:
        return "D"

    # update exploitation pressure (using last round info)
    if S > 0.25*capacity and k >= math.ceil(0.6*(n-1)):
        exploit += 1
    else:
        exploit = max(exploit - 1, 0)

    # manage mode
    if mode == "SCORCHED":
        if cooldown > 0:
            cooldown -= 1
        # optional re-entry
        # (implement by tracking last 2 k values, omitted here for brevity)
        return "D"

    if exploit >= 2:
        mode = "SCORCHED"
        cooldown = 3
        return "D"

    # compute predicted remainders
    # others consumption assuming d_hat defect, rest cooperate
    cons_others = d_hat*(S/n) + (n-1-d_hat)*(S/(2*n))
    S_rem_C = S - (S/(2*n)) - cons_others
    S_rem_D = S - (S/n) - cons_others

    S_floor = 0.10*capacity

    # default exploit
    action = "D"

    # cooperate only as self-interested investment
    if R > 2:
        # safeguard: prevent immediate collapse if possible
        if S_rem_D <= 0 and S_rem_C > 0 and R >= 4:
            action = "C"
        else:
            # invest only if defection risks too-low remainder AND others not mostly defecting
            if S_rem_D < S_floor and k <= (n-1)/2:
                action = "C"

    return action
```

---

## Why this is exploitative and robust
- **Exploitative by default:** defects whenever not strictly necessary to protect future value.
- **Adaptive:** uses observed defection level to decide whether cooperation would be exploited.
- **Robust:** won’t keep “propping up” a defect-heavy population; switches to permanent extraction.
- **State-aware:** cooperates only when the stock dynamics indicate that collapse would reduce *your* future payoffs more than the immediate gain from defection.
- **Endgame-correct:** defects in the last rounds because future stock has no value.

If you want, I can also provide a tighter version that explicitly estimates the next-round stock via the given logistic growth equation and chooses C/D by comparing *expected two-step value* (this improves performance when opponents are noisy rather than stationary).
'''

description_EXPLOITATIVE_51 = '''
Below is an explicitly exploitative, history-based strategy for the common-pool game. It is designed to (i) take the high action (D) whenever it’s safe or profitable, (ii) “farm” the stock (play C) only when doing so is necessary to keep the resource productive, and (iii) punish groups that over-defect by switching to relentless defection (and accepting collapse) rather than subsidizing them.

---

## Core idea

- **Your one-step incentive is always to defect** (you get double the current-round payoff versus C at the same stock).
- The only reason to ever cooperate is **investment**: keeping stock high so that future defection yields big payoffs.
- Therefore: **Defect by default**, but **cooperate strategically** when the stock is in a “danger zone” where continued defection will crash it, and do so only to the minimum extent needed.
- Additionally: if opponents demonstrate they won’t invest (too many defectors), **stop investing** and harvest what you can (defect) even if it collapses.

---

## Quantities you can compute from history

At round \(t\), before choosing your action, you know current stock \(S_t\) and prior actions. You can compute:

- Let \(d_{t-1}\) = number of opponents who defected last round (or estimate current tendency by a moving average).
- Let \(\hat{D}_t\) = predicted number of defectors among opponents this round. Use:
  - **Default:** \(\hat{D}_t := d_{t-1}\) (simple, robust)
  - Optionally smoother: \(\hat{D}_t := \text{round}(\alpha d_{t-1} + (1-\alpha)\hat{D}_{t-1})\), \(\alpha \in [0.5,0.8]\)

Given a predicted total number of defectors including you, you can predict remaining stock after consumption:

- If you play **C** and predict \(\hat{D}_t\) opponent defectors:
  \[
  S_{\text{rem}}^C = S_t - \left(\frac{(\hat{D}_t)S_t}{n} + \frac{(n-1-\hat{D}_t)S_t}{2n} + \frac{S_t}{2n}\right)
  = S_t \cdot \frac{n-\hat{D}_t-1}{2n}
  \]
- If you play **D**:
  \[
  S_{\text{rem}}^D = S_t - \left(\frac{(\hat{D}_t)S_t}{n} + \frac{(n-1-\hat{D}_t)S_t}{2n} + \frac{S_t}{n}\right)
  = S_t \cdot \frac{n-\hat{D}_t-2}{2n}
  \]

(If these go negative, treat as 0; that corresponds to total consumption ≥ stock.)

Then stock updates via logistic growth:
\[
S_{t+1} = \min\left(S_{\text{rem}} + 2S_{\text{rem}}\left(1-\frac{S_{\text{rem}}}{\text{capacity}}\right), \text{capacity}\right)
\]

---

## Decision rules (cooperate vs defect)

We use three regimes: **Exploit**, **Stabilize**, **Abandon**.

### Parameters (set from game parameters)
- **Safety threshold** for remaining stock:  
  \(S_{\min} := 0.25 \times \text{capacity}\)  
  (Below this, growth is weaker and risk of collapse is high.)
- **Recovery target**:  
  \(S_{\text{target}} := 0.75 \times \text{capacity}\)
- **Too-many-defectors threshold**:  
  \(\theta := \lceil (n-1)/2 \rceil\) (a strict-ish “majority” of opponents defecting)

### Regime 1: Exploit (default)
**Play D** when your predicted action won’t push the system into the danger zone *or* when endgame makes investment not worth it.

Rule:
- If \(t = r\): **D**
- Else if predicted \(S_{t+1}^D \ge S_{\min}\): **D**
- Else go to Stabilize/Abandon logic.

Intuition: You defect whenever it keeps next-round stock safely above the danger threshold.

### Regime 2: Stabilize (invest just enough)
If defection would likely push stock too low, you consider cooperating **only if** opponents are “investing enough” that your investment won’t be purely exploited.

Rule (when \(S_{t+1}^D < S_{\min}\)):
- If \(\hat{D}_t \le \theta\) (not too many defectors):
  - Play **C** if \(S_{t+1}^C \ge S_{t+1}^D\) in *two-step value* sense:
    - Use a simple proxy: cooperate if it keeps the stock from crashing:
      - If predicted \(S_{t+1}^C \ge S_{\min}\): **C**
      - Else: **D** (can’t save it anyway)
- Else (too many defectors): go to Abandon.

Intuition: cooperate only when (i) it plausibly stabilizes next stock above the danger zone and (ii) you’re not surrounded by mostly defectors.

### Regime 3: Abandon (punish by refusing to subsidize)
If opponents are mostly defecting, your cooperation mainly serves to refill the pool for them to loot. In this case, **never cooperate**; defect until collapse.

Rule:
- If \(\hat{D}_t > \theta\): **D** (even if stock will fall below \(S_{\min}\))

Intuition: You stop “being the sucker.” This is exploitative because it denies free-riders the benefit of your restraint and forces them into a low-payoff equilibrium quickly.

---

## Edge cases / special rounds

### Round 1
You have no history. Use a stock-based aggressive opener:

- If \(r\) is small (e.g., \(r \le 3\)): **D** immediately (no time to recoup investment).
- Otherwise:
  - If \(S_1 = \text{capacity}\): **D** (harvest the high stock once; you learn opponents’ tendencies).
  - Exception: if \(n\) is very small (e.g., \(n=2\)) and \(r\) large, you can start with **C** once to try to maintain high stock and see if the other defects; but exploitatively, **D** is still fine because you can stabilize later if needed.

### Last round \(t=r\)
Always **D**. No future stock value.

### Second-to-last round \(t=r-1\)
Almost always **D** unless you’re in a situation where cooperating at \(t=r-1\) materially increases \(S_r\) and thus your last-round defection payoff enough to outweigh the immediate loss. A simple exploitative rule:

- If \(S_{r}^D < S_r^C\) **and** \(S_r^C - S_r^D > S_{r-1}/(2n)\) (the immediate cost of cooperating vs defecting is \(S_{r-1}/(2n)\)): then **C**, else **D**.

This is a very selective “invest for final harvest” condition.

---

## Pseudocode (implementable)

```pseudo
init:
  S_min = 0.25 * capacity
  theta = ceil((n-1)/2)
  predD = (n-1)  // pessimistic prior or 0; choose (n-1)/2 if you prefer neutral

for t in 1..r:
  observe current stock S

  if t == 1:
    if r <= 3: action = D
    else action = D
    play action
    observe opponents' actions
    predD = number_of_opponent_defectors
    continue

  if t == r:
    action = D
    play action
    continue

  // update predictor
  lastD = number_of_opponent_defectors_previous_round
  predD = lastD  // simple, robust

  // compute predicted next stock under each action using predD
  Srem_D = max(0, S * (n - predD - 2) / (2n))
  Srem_C = max(0, S * (n - predD - 1) / (2n))

  nextS_D = min(Srem_D + 2*Srem_D*(1 - Srem_D/capacity), capacity)
  nextS_C = min(Srem_C + 2*Srem_C*(1 - Srem_C/capacity), capacity)

  // endgame selective invest on r-1
  if t == r-1:
    immediate_cost = S/(2n)
    if (nextS_C - nextS_D) > immediate_cost:
      action = C
    else:
      action = D
    play action
    continue

  // abandon if too many defectors predicted
  if predD > theta:
    action = D
    play action
    continue

  // exploit if defection keeps stock safe
  if nextS_D >= S_min:
    action = D
  else:
    // stabilize only if it plausibly keeps stock safe
    if nextS_C >= S_min:
      action = C
    else:
      action = D  // can't save it; harvest
  play action
```

---

## Why this is exploitative and robust

- **Exploitative:** Defaults to D, only “invests” (C) when it increases your future ability to defect profitably, and refuses to prop up a mostly-defecting group (Abandon).
- **Robust:** Uses only observables (stock + history), makes no assumptions about coordination, and adapts quickly to opponent composition (cooperative vs greedy populations).
- **Hard to exploit:** If others try to free-ride, you stop cooperating; if others cooperate a lot, you defect safely while stock stays productive.

If you want, I can also provide a slightly more sophisticated predictor (Bayesian/EMA per-opponent) and a more explicitly optimized “investment test” based on estimating the marginal value of higher next-round stock given your planned defection rate.
'''

description_EXPLOITATIVE_52 = '''
## Exploitative strategy: **Regenerative Extortion with Triggered Burn (RETB)**

Goal: extract high payoffs by defecting whenever (a) the stock can recover and (b) opponents are willing to “feed” the pool; switch to cooperation only to (i) keep the stock in the high-growth region and (ii) avoid driving it to collapse when that would reduce your future take. If opponents don’t sustain the resource, pivot to “take what you can” (persistent defection / burn).

This is not fairness-seeking: it cooperates only as an *investment* to maintain a lucrative stock and uses defection as the default extraction mode.

---

# Key quantities you track each round

Let current stock at start of round \(t\) be \(S_t\).

From last round’s observed actions, compute:
- \(k_{t-1}\): number of defectors last round.
- Expected total consumption last round given stock \(S_{t-1}\):
  \[
  C_{\text{tot}} = k\cdot(S/n) + (n-k)\cdot(S/(2n)) = \frac{S}{2n}(n+k)
  \]
- Remaining stock after consumption:
  \[
  S_{\text{rem}} = S - C_{\text{tot}} = S\left(1 - \frac{n+k}{2n}\right) = S\cdot \frac{n-k}{2n}
  \]
- Next stock (before cap):
  \[
  S' = S_{\text{rem}} + 2S_{\text{rem}}\left(1-\frac{S_{\text{rem}}}{\text{capacity}}\right)
  \]
  then \(S_{t} = \min(S', \text{capacity})\).

Also define:
- **Cooperation rate estimate** over a short window \(W\) (e.g., 5):  
  \[
  \hat{c}_t = \frac{\#\text{C-actions by others in last }W\text{ rounds}}{(n-1)W}
  \]
- **Volatility**: how often others switch actions in last \(W\) rounds (used to detect chaotic opponents).

---

# Strategic intuition (why this exploits)
- If you defect while others cooperate, you get **double** the per-round payoff of a cooperator at the same stock \(S\) (since \(S/n\) vs \(S/(2n)\)).
- The stock growth is logistic; it grows most when remaining stock is around \(\text{capacity}/2\). So you want to keep the post-consumption remainder away from 0, but you don’t need full cooperation to do that.
- Therefore, the exploitative sweet spot is: **keep the system in a high-growth region with minimal “investment” (occasional C), and defect as often as you can while the pool stays productive.**
- If opponents won’t invest (many D), then investing yourself is wasted—so you switch to **burn/harvest mode** (mostly D, including endgame).

---

# 1) Decision rules (C vs D)

### Parameters (fixed, depend only on \(n,r,\text{capacity}\))
- Window \(W = 5\) (or \( \min(5, t-1)\) early).
- “Stock danger” threshold:
  \[
  S_{\text{low}} = \max\left( \frac{\text{capacity}}{6},\; 2n \right)
  \]
- “Good stock” threshold:
  \[
  S_{\text{good}} = \frac{\text{capacity}}{2}
  \]
- Extortion aggressiveness:
  - Target fraction of time you defect when things are stable: **high**, e.g. 80–95%.
- Define **investment probability** \(p_C\) when stock is endangered; otherwise \(p_C = 0\) unless punishing/conditioning.

---

## RETB policy (high level)
You operate in one of three modes:

### Mode A — **Extract (default)**
Defect to maximize immediate payoff **as long as** the pool is not about to fall into a low-stock trap.

**Play D** if either:
1. \(S_t \ge S_{\text{good}}\) (resource plentiful), **and** opponents aren’t overwhelmingly defecting (see Mode C), or
2. Recent data suggests the pool recovers even when you defect (i.e., last time you defected at similar stock, \(S\) stayed high).

**Otherwise** consider Mode B.

---

### Mode B — **Invest just enough (damage control)**
If stock is getting low, cooperate to prevent collapse *only when it’s likely to pay back*.

Trigger to enter Mode B:
- \(S_t \le S_{\text{low}}\), **and**
- estimated others’ cooperation \(\hat{c}_t \ge 0.4\) (they might sustain if you help), **and**
- not in last 2 rounds (see endgame).

In Mode B:
- **Play C** until stock rebounds above \(S_{\text{good}}\) *or* until it becomes clear others are not sustaining (drop in \(\hat{c}_t\) below 0.4).
- As soon as \(S_t \ge S_{\text{good}}\), switch back to Mode A (defect).

This is “minimal investment”: you cooperate only when you expect it to keep the machine profitable, then you return to exploitation.

---

### Mode C — **Triggered burn (when others won’t sustain)**
If others are heavily defecting, your cooperation is just subsidizing them. Then you should harvest aggressively.

Enter Mode C if any holds (over last \(W\) rounds):
- \(\hat{c}_t \le 0.25\) (most are defecting most of the time), or
- You observe **two consecutive rounds** where a majority of others defected (≥ \(\lceil (n-1)/2\rceil\)).

In Mode C:
- **Always play D** (except possibly a single “probe” C every ~10 rounds if far from endgame and stock is extremely low, but default is pure D).
- Stay in Mode C unless you see strong evidence of a regime change: \(\hat{c}_t \ge 0.6\) for a full window \(W\).

This is exploitative because it refuses to bear restoration costs when opponents are free-riding.

---

## Conditioning / extortion layer (simple and robust)
When stock is healthy (\(S_t \ge S_{\text{good}}\)) and opponents show willingness to cooperate, you can “train” them:

- If **last round all (or almost all) others cooperated** (≥ \(n-2\) cooperators among others):
  - **Play D** (take the high payoff).
- If **many others defected last round**:
  - If stock is still high, you still **play D** (don’t reward defection).
  - If stock is low and they defected, go to Mode C (burn).

Net effect: you reward cooperative populations by exploiting them, and you don’t waste cooperation on defectors.

---

# 2) Edge cases

### Round 1
- **Play D.**
Reason: no reputation cost yet, and you learn opponent tendencies immediately. Also, if others are naïvely cooperative, you instantly extract.

### Last round (round r)
- **Always play D.**
No future stock value.

### Second-to-last round (round r-1)
- **Play D** unless \(S_{r-1}\) is so low that your D would yield almost nothing anyway and you want to slightly increase current-round expected value via growth?  
But growth happens after consumption and won’t pay you (no next round), so:
- **Always D** in round \(r-1\) too.

### Very low stock \(S_t \approx 0\)
- If \(t < r-2\) and others have been cooperating (\(\hat{c}_t \ge 0.6\)), you may **play C for 1–3 rounds** to try to restart growth.
- Otherwise **D** (harvest whatever remains; don’t be the only restorer).

### Capacity much larger than \(2n\)
Doesn’t change logic; it just means “healthy stock” region is larger. The thresholds \(S_{\text{low}}, S_{\text{good}}\) scale with capacity.

---

# 3) Pseudocode (implementable)

```pseudo
inputs each round t:
  S = current_stock
  history of all actions

constants:
  W = 5
  S_low  = max(capacity/6, 2*n)
  S_good = capacity/2

function coop_rate_others(t, W):
  compute fraction of C among other players in last min(W, t-1) rounds

function majority_defected_last_two_rounds():
  check last 2 rounds: in each, #D among others >= ceil((n-1)/2)

mode = {Extract, Invest, Burn}  // can be implicit via rules

on round t:
  if t >= r-1:          // last two rounds
    return D

  if t == 1:
    return D

  c_hat = coop_rate_others(t, W)

  // Triggered burn
  if c_hat <= 0.25 or majority_defected_last_two_rounds():
    // exit burn only if strong sustained cooperation signal
    if c_hat >= 0.60 for full window W:
      // fall through to other logic
      pass
    else:
      return D

  // Damage control investment (only if likely to pay back)
  if S <= S_low and c_hat >= 0.40:
    return C

  // Otherwise extract
  return D
```

---

## What makes this “exploitative” in tournament terms
- Defaults to **D** almost everywhere (including round 1 and endgame).
- Cooperates only as a calculated **capital investment** to keep the stock in a profitable region when opponents are sufficiently cooperative to make that investment worthwhile.
- Refuses to “do the work” of rebuilding when others defect (Mode C), preventing being exploited by unconditional cooperators *and* by free-riders.
- Uses observed cooperation as a signal to intensify extraction: when others cooperate, you defect more, not less.

If you want, I can tune the thresholds (\(S_{\text{low}}, \hat{c}\) cutoffs, burn exit rule) for particular \(n,r,\text{capacity}\) regimes (e.g., very short vs long horizons).
'''

description_EXPLOITATIVE_53 = '''
## Strategy: **Hydra-Leech (HL)**  
Exploit whoever is willing to sustain the stock (cooperators/forgivers), but avoid being the sole cause of collapse when opponents are trigger-happy. The core idea is:

- **Leech when the resource is healthy and others are not over-defecting** (take D for double payoff).
- **Stabilize only when needed** to keep the stock from crashing (play C to keep the “goose” alive).
- **Punish quickly** if others are collapsing the pool (mostly D, because your C won’t save it and you shouldn’t subsidize them).
- **Endgame harvest**: defect in the last round (and usually the last few) because there’s no future value.

This is exploitative because it treats cooperation as an *investment to preserve future extraction*, not as a norm; it defects whenever it expects others to bear the conservation burden.

---

# 1) Decision rules (C vs D)

### Observables each round \(t\)
- Current stock: \(S_t\)
- From history, infer how many defected last round:  
  \(k_{t-1} = \#\{j \neq i : a_{j,t-1}=D\}\) (you can include yourself too; doesn’t matter much).
- Compute **defection rate** last round:  
  \(q_{t-1} = k_{t-1}/n\)

### Key derived thresholds
- **Safe stock threshold**:  
  \[
  S_{\text{safe}} = 0.6 \cdot \text{capacity}
  \]
  Above this, you can leech aggressively because the system can recover if at least some players cooperate.

- **Critical stock threshold**:  
  \[
  S_{\text{crit}} = 0.25 \cdot \text{capacity}
  \]
  Below this, a collapse spiral is near; only cooperate if you believe enough others will also cooperate.

- **“Others are mostly cooperating” threshold**:  
  \[
  q_{t-1} \le 0.25
  \]
  i.e., at most ~25% defectors last round → there is a conservation base to exploit.

- **“Others are mostly defecting” threshold**:  
  \[
  q_{t-1} \ge 0.5
  \]
  At least half defectors → don’t subsidize; defect and accept collapse unless stock is very high.

### Main action logic (per round \(t\))
**A. Endgame harvest**
- If \(t = r\): **Play D** (always).
- If \(t \ge r-1\): **Play D** unless stock is so low that even D yields trivial payoff and a single C could raise it for last-round gain. In practice: still **D**, because one C rarely rescues enough against unknown opponents.

**B. First round (no history)**
- If \(r\) is small (e.g., \(r \le 3\)): **D** (short horizon; exploit immediately).
- Else: **C** in round 1 **only** to “seed” a sustainable path and learn opponents. (This is an investment: if others cooperate, you’ll leech later; if they defect, you switch to extraction/punishment immediately.)

**C. Exploit when stock is healthy and others cooperate**
- If \(S_t \ge S_{\text{safe}}\) **and** \(q_{t-1} \le 0.25\): **Play D**.  
  Rationale: you get double the per-round payoff while cooperators keep stock from collapsing.

**D. Stabilize when stock is mid/low *and* cooperation seems viable**
- If \(S_{\text{crit}} \le S_t < S_{\text{safe}}\) and \(q_{t-1} < 0.5\): **Play C**.  
  Rationale: resource is not fully safe; if opponents aren’t mostly defecting, a cooperative move helps stock rebound so you can resume leeching later.

**E. Refuse to be exploited / punish collapse**
- If \(q_{t-1} \ge 0.5\): **Play D** (almost always).  
  Exception: if \(S_t\) is extremely high (near capacity) and you’re early in the game, you can play **C** once to test if defection was a one-off spike. But default is D.

**F. Critical stock regime**
- If \(S_t < S_{\text{crit}}\):  
  - If \(q_{t-1} \le 0.25\): **Play C** (there’s still a cooperative base; try to revive stock to later exploit).  
  - Else: **Play D** (don’t throw good effort after bad; your C won’t be matched).

This produces a pattern: **C early to diagnose and build**, then **D whenever others keep the pool healthy**, and **D when others are likely to collapse it anyway**.

---

# 2) Edge cases

### Round 1
- **Default**: C if \(r > 3\), otherwise D.
- Reason: with longer horizon, a single early C is a cheap “probe” that preserves the stock and reveals others’ tendencies. With short horizon, there’s no time to recoup the investment.

### Last round
- **Always D.** No future stock value.

### “Near-empty stock”
- When \(S_t\) is tiny, payoffs are tiny no matter what; cooperation only makes sense if you expect many others to cooperate (low \(q\)). HL only cooperates here when the previous round indicates a strong cooperative base.

### “All defectors”
- If history shows persistent high defection (e.g., \(q\ge 0.5\) for 2 rounds in a row), HL stays at **D forever** (except possibly if the stock fully recovers by others—which won’t happen if they’re truly all defecting).

### “All cooperators”
- HL will quickly shift to mostly **D** once it detects low defection rate and high stock. It will occasionally return to **C** if stock slips into mid/low to prevent killing the golden goose.

---

# 3) Explicit exploitative alignment

HL’s stance is:
- **Cooperation is maintenance**, not morality.
- If others maintain the resource, **you defect to extract surplus**.
- If others do not maintain it, **you refuse to be the sucker** and defect as well.
- You only “repair” the pool when the repair is likely to be **matched by others** and produces **future extractable stock**.

This is robust because it doesn’t assume norms or coordination: it uses only **observed defection rate** and **stock level** to decide whether conservation is profitable.

---

## Pseudocode (implementable)

```python
def HydraLeech(t, r, S, capacity, history_actions):
    # history_actions[t-1] contains list of actions of all players last round, if exists
    S_safe = 0.6 * capacity
    S_crit = 0.25 * capacity

    # Endgame
    if t == r:
        return "D"
    if t >= r-1:
        return "D"

    # First round probe (only if horizon is meaningful)
    if t == 1:
        return "C" if r > 3 else "D"

    # Compute last-round defection rate
    last = history_actions[t-1]
    k = sum(1 for a in last if a == "D")
    q = k / len(last)  # len(last) == n

    # If others mostly defect, don't subsidize
    if q >= 0.5:
        return "D"

    # Healthy stock + others mostly cooperate => leech
    if S >= S_safe and q <= 0.25:
        return "D"

    # Critical stock: only cooperate if strong evidence others cooperate
    if S < S_crit:
        return "C" if q <= 0.25 else "D"

    # Mid stock: stabilize if not facing majority defection
    # (q < 0.5 already ensured)
    return "C"
```

If you want it *more exploitative*, reduce stabilization by lowering how often you choose C (e.g., make `S_safe = 0.5*capacity` and require `q <= 0.33` to cooperate in mid stock). If you want it *more robust*, increase stabilization (cooperate more often when S is mid).
'''

description_EXPLOITATIVE_54 = '''
Below is an **exploitative, stateful “Harvest–Test–Punish–Reset (HTPR)” strategy**. It tries to (i) **extract D whenever opponents allow stock to stay high**, (ii) **switch to C only when needed to keep the resource from crashing**, and (iii) **punish persistently** when others don’t support regeneration anyway.

Key idea: with your dynamics, the stock can fully recover to `capacity` after a round **iff** post-consumption remaining stock satisfies `S_rem ≥ capacity/2` (because growth is `2 S_rem (1 - S_rem/capacity)` and `S_rem + growth ≥ capacity` ⇔ `S_rem ≥ capacity/2`). So you want total consumption per round to be **≤ S - capacity/2** to keep the stock at/near capacity. Your action affects total consumption and your immediate payoff.

---

## 1) Decision rules (C vs D)

### Maintain estimates from history
Let:
- `S_t` = stock at start of round `t` (observed).
- `k_{t-1}` = number of opponents who defected in round `t-1`.
- `opp_def_rate` = exponentially weighted moving average (EWMA) of opponent defection frequency.
- `opp_like_to_preserve` = whether opponents’ last-round behavior would have preserved the resource if you had cooperated.

Also compute a **safe-harvest feasibility test** based on current stock:

- If you play **D**, you consume `S_t / n`.
- If you play **C**, you consume `S_t / (2n)`.

Total opponent consumption last round is observable from their actions:
- If in previous round `t-1`, opponents had `k` defectors among `n-1`, then their total consumption was  
  `OppCons = k*(S_{t-1}/n) + (n-1-k)*(S_{t-1}/(2n))`.

We’ll use last round’s mix as a predictor of this round’s mix.

### Define a “regeneration guardrail”
We want to avoid crossing the point where recovery becomes hard. Use a conservative threshold:

- **Guard threshold**: `G = capacity/2 + buffer`, where `buffer = 0.05*capacity` (5% slack).
- If after predicted consumption, `S_rem` would drop below `capacity/2`, stock won’t bounce fully and can spiral down if D’s continue.

So define predicted remaining stock if you choose action `a ∈ {C,D}`:
- Predict opponents repeat last round’s mix (robust baseline).
- `PredOppCons = [k_{t-1}*(S_t/n) + (n-1-k_{t-1})*(S_t/(2n))]`
- `MyCons(C)=S_t/(2n)`, `MyCons(D)=S_t/n`
- `PredRem(a) = S_t - PredOppCons - MyCons(a)`

### Core rule: “Defect whenever it won’t break regeneration; otherwise cooperate”
**Rule A (Harvest if safe):**
- If `PredRem(D) ≥ capacity/2` then **play D**.
  - Rationale: you double your immediate payoff vs C while still (likely) keeping stock in the high-recovery region due to others’ restraint.

**Rule B (Stabilize if needed):**
- Else if `PredRem(C) ≥ capacity/2` then **play C**.
  - Rationale: you can be the “minimal contributor” that keeps the resource in the recovery zone, enabling future harvesting opportunities.

**Rule C (If collapse is likely anyway, defect and cash out):**
- Else (even C can’t keep `S_rem ≥ capacity/2` under prediction), **play D**.
  - Rationale: if others are extracting too much, your cooperation is wasted; you should take the larger immediate payoff before the pool collapses.

This alone is already exploitative: it cooperates only as a tool to preserve future exploitation, and otherwise defects.

---

## 2) Edge cases and tournament-hardened adaptations

### Round 1 (no history)
Start with **D** unless stock is already near fragile levels (it isn’t initially: `S_1=capacity`).
- **t = 1: play D.**
  - Rationale: immediate gain; also probes whether others are willing to cooperate. If many others defect, you learn fast and switch into “cash-out” mode.

### Last round
There is no future to protect.
- **t = r: always play D.**

### “Punish and reset” logic (robustness)
Sometimes opponents are conditional cooperators: if they see too much defection, they retaliate by defecting, collapsing the stock and harming you. You want to avoid triggering endless retaliation when it’s not profitable.

Add a state machine with three modes:

1. **HARVEST mode (default):** use Rules A/B/C above.
2. **PUNISH mode:** if opponents are defect-heavy, stop trying to stabilize; just defect.
3. **RESET mode:** if stock fell but opponents appear willing to re-cooperate, temporarily cooperate to rebuild the pool and then return to harvesting.

#### Triggers
Maintain EWMA of opponent defection rate:
- `opp_def_rate ← 0.7*opp_def_rate + 0.3*(k_{t-1}/(n-1))`

**Enter PUNISH mode if any holds:**
- `opp_def_rate ≥ 0.6` (most opponents defect most of the time), OR
- In the last 2 rounds, stock dropped sharply: `S_t < 0.6*S_{t-1}` and opponents had `k_{t-1} ≥ (n-1)/2`.
  - Interpretation: they’re not preserving the pool; don’t be the sucker.

**In PUNISH mode:**
- Play **D** always, except:
  - If `S_t` is extremely low (e.g., `< 0.15*capacity`) and in the last round `k_{t-1}=0` (everyone cooperated), then switch to RESET (they might be trying to rebuild).

**Enter RESET mode if:**
- `S_t < 0.5*capacity` (pool degraded), AND
- Opponents just showed strong restraint: `k_{t-1} ≤ 0.2*(n-1)`.

**In RESET mode:**
- Play **C** for a short fixed window `L = 2` rounds *or* until `S_t ≥ 0.9*capacity`, whichever first.
- Then return to HARVEST mode (and start defecting whenever safe again).

This prevents you from getting stuck in mutual defection when others would rebuild, but still keeps you exploitative: you “invest” only enough cooperation to restore future harvesting.

---

## 3) Why this is exploitative (explicitly)

- **Primary objective:** maximize your own cumulative payoff, not group welfare.
- **Default action is D** whenever it doesn’t endanger future ability to keep extracting.
- **Cooperation is instrumental**: you cooperate only when it likely prevents the stock from leaving the high-recovery region (`S_rem ≥ capacity/2`) and thus protects future extraction rents.
- **If others won’t support regeneration**, you stop subsidizing them and **defect to cash out**.
- **Endgame defection**: always defect in the last round.

---

## Pseudocode (implementation-ready sketch)

```pseudo
mode = HARVEST
opp_def_rate = 0.0
reset_counter = 0

for t in 1..r:
    observe S_t

    if t == r:
        action = D
        play(action)
        break

    if t == 1:
        action = D
        play(action)
        continue

    # after round t-1 we observed opponents' actions
    k = num_opponents_defected_last_round  # 0..n-1
    opp_def_rate = 0.7*opp_def_rate + 0.3*(k/(n-1))

    # mode transitions
    if mode != RESET:
        if opp_def_rate >= 0.6:
            mode = PUNISH
        else if (S_t < 0.5*capacity) and (k <= 0.2*(n-1)):
            mode = RESET
            reset_counter = 0

    if mode == PUNISH:
        if (S_t < 0.15*capacity) and (k == 0):
            mode = RESET
            reset_counter = 0
        else:
            action = D
            play(action)
            continue

    if mode == RESET:
        action = C
        reset_counter += 1
        play(action)
        if (S_t >= 0.9*capacity) or (reset_counter >= 2):
            mode = HARVEST
        continue

    # HARVEST mode: predict using last round's opponent mix
    PredOppCons = k*(S_t/n) + (n-1-k)*(S_t/(2n))

    PredRem_D = S_t - PredOppCons - (S_t/n)
    PredRem_C = S_t - PredOppCons - (S_t/(2n))

    if PredRem_D >= capacity/2:
        action = D
    else if PredRem_C >= capacity/2:
        action = C
    else:
        action = D  # collapse likely anyway; take the larger slice

    play(action)
```

---

If you tell me typical tournament settings (common `n`, `r`, capacity range), I can tune the thresholds (`0.6`, `0.5*capacity`, reset length `L`, slack buffer) to be more aggressive or more conservative.
'''

description_EXPLOITATIVE_55 = '''
### Strategy: **Harvester–Extortion with Stock Guardrails (HESG)**  
Goal: extract as much as possible when others sustain the stock, and avoid being the “sucker” who cooperates while others defect. Use **D by default**, switch to **C only as an investment** when it is likely to increase future harvest, and punish quickly.

This game’s key feature is that with stock \(S\), **D yields exactly 2× C in the current round**, but excessive D collapses the resource and destroys future payoffs. So exploitation = (i) induce/allow others to invest in stock, (ii) harvest with D, (iii) avoid investing when others won’t.

---

## 1) Decision rules (cooperate vs defect)

### Quantities computed from history/state
At the start of round \(t\), observe current stock \(S_t\) and last round actions.

Let:
- \(k_{t-1}\) = number of opponents who played **C** last round (so in \(\{0,\dots,n-1\}\)).
- \(c_{t-1} = k_{t-1}/(n-1)\) = opponent cooperation rate last round.
- Maintain a short memory estimate of “how cooperative the table is”:
  - \( \bar c_t = 0.7\,\bar c_{t-1} + 0.3\,c_{t-1}\) (initialize \(\bar c_1 = 1\) as optimistic prior).
- Define **danger stock threshold**:
  - \(S_{\text{low}} = 2n\).  
  (Below this, per-round payoffs are tiny and you risk hitting/hovering near 0.)
- Define **harvest stock threshold**:
  - \(S_{\text{high}} = 0.8 \cdot \text{capacity}\).  
  (Above this, you can safely harvest aggressively because growth is already strong and opponents are likely sustaining it.)

### Core policy (high level)
- **If stock is high and opponents are investing:** defect to harvest.
- **If stock is low or falling and opponents are investing:** cooperate just enough to keep the stock from collapsing, then return to defect.
- **If opponents are not investing (too many Ds):** defect (don’t throw good C after bad), except possibly a *one-round “probe”* early to test if cooperation can be induced.
- **Near the end:** defect (endgame exploitation; there’s little future value to invest in stock).

### Concrete decision rule
In round \(t\) choose action \(a_t \in \{C,D\}\):

**Rule A — Last round / endgame**
- If \(t = r\): **D**
- If \(t = r-1\) and \(S_t > S_{\text{low}}\): **D**  
  (Two rounds left isn’t worth investing unless the stock is critically low, in which case C might raise \(S\) enough to profit in the final round—but usually not worth it.)

**Rule B — Stock emergency guardrail**
- If \(S_t \le S_{\text{low}}\):
  - If \(\bar c_t \ge 0.5\): **C** (others are somewhat cooperative; invest to recover)
  - Else: **D** (if they won’t help, don’t waste a round)

**Rule C — Exploit cooperative opponents**
- If \(S_t \ge S_{\text{high}}\) and \(\bar c_t \ge 0.4\): **D**  
  (plenty of stock + reasonable cooperation → harvest mode)

**Rule D — Conditional investment (only when it likely pays)**
- If \(S_{\text{low}} < S_t < S_{\text{high}}\):
  - If \(\bar c_t \ge 0.6\): play **C** with probability \(p_C = \min(1,\; (S_{\text{high}}-S_t)/S_{\text{high}})\), else **D**.  
    Intuition: when stock is mid and others are quite cooperative, you “invest more” as stock falls, but scale back as it recovers.
  - If \(0.4 \le \bar c_t < 0.6\): **D** (mixed tables are where C gets exploited most)
  - If \(\bar c_t < 0.4\): **D**

**Rule E — Punishment trigger (fast retaliation)**
If in the previous round you played **C** and **more than half of opponents played D** (i.e., \(k_{t-1} < (n-1)/2\)), then for the next **2 rounds** play **D** regardless of stock (unless \(S_t \le S_{\text{low}}\) and it’s not endgame).  
This makes you a bad target for “let’s all defect except the sucker” strategies.

---

## 2) Edge cases (first round, last round, unusual stock)

### First round (\(t=1\))
Start in **D**.

Reason: With initial \(S=\text{capacity}\), D gives maximum immediate gain, and your one-round choice barely affects growth when others are unknown. Also, most opponent strategies will reveal themselves immediately; you can decide whether limited investment is worthwhile afterward.

### Early “probe” exception (optional but useful)
If capacity is very large relative to \(n\) (e.g., \(\text{capacity} \ge 20n\)) and \(r\) is long (e.g., \(r \ge 10\)), then do:
- Round 1: **C** (probe)
- Round 2+: follow main rules, with punishment if round-1 opponents defect heavily.

This probe can identify tables where cooperation is stable enough that you can later defect and harvest while they sustain.

### Last round (\(t=r\))
Always **D**. No future value exists; take the 2× payoff.

### Near-zero stock
If \(S_t\) is extremely small (close to 0), C and D both pay little. The only reason to play C is if (i) many others also cooperate and (ii) there are enough rounds left to benefit. The strategy already does that via Rule B.

### If stock is stuck at capacity every round
That happens if enough players cooperate to allow full replenishment. In that environment:
- You **mostly defect** (Rule C), extracting 2× payoff while others keep it at capacity.
- If your defection begins to drag the stock down and opponents remain cooperative, you occasionally cooperate (Rule D) just enough to keep the system from collapsing—then return to D.

---

## 3) Why this is exploitative (and robust)

### Exploitative posture
- **Default is D**: you seek the higher immediate payoff whenever it’s not clearly self-destructive.
- **You free-ride** on cooperative opponents: when the table keeps \(S\) high, you harvest with D.
- **You do not subsidize defectors**: if others aren’t investing, you stop investing too (switch to D).
- **You punish quickly**: if you cooperate and others exploit you, you lock into D for a short retaliation window.

### Robustness to opponent types
- **Against unconditional cooperators / naive sustainers:** you mostly D and gain heavily while the stock stays high.
- **Against grim trigger / tit-for-tat types:** your early D may collapse cooperation; but the strategy’s investment rules can sometimes restore stock if they remain willing. If not, you still avoid being the only cooperator.
- **Against always-defectors:** you quickly converge to D, minimizing wasted C.
- **Against mixed/adaptive learners:** the moving average \(\bar c_t\) and punishment window make you hard to exploit while still taking advantage of cooperative phases.

---

## Pseudocode sketch

```pseudo
init cbar = 1.0
punish_timer = 0

for t in 1..r:
    observe stock S

    if t == r:
        play D
        continue

    if punish_timer > 0:
        if S <= 2n and t < r-1 and cbar >= 0.5:
            play C   # only override punishment to prevent total collapse
        else:
            play D
        punish_timer -= 1
        continue

    if t > 1:
        k = number_of_opponents_who_played_C_last_round
        c = k/(n-1)
        cbar = 0.7*cbar + 0.3*c

        if (my_last_action == C) and (k < (n-1)/2):
            punish_timer = 2

    S_low  = 2n
    S_high = 0.8*capacity

    if t == r-1 and S > S_low:
        play D
    else if S <= S_low:
        if cbar >= 0.5:
            play C
        else:
            play D
    else if S >= S_high and cbar >= 0.4:
        play D
    else:
        if cbar >= 0.6:
            pC = min(1, (S_high - S)/S_high)
            play C with prob pC else D
        else:
            play D
```

This policy is intentionally asymmetric: it cooperates only when that cooperation is likely to raise future harvest opportunities and avoids being exploited when others defect.
'''

description_EXPLOITATIVE_56 = '''
## Strategy: **Probe–Exploit–Harvest (PEH)**  
Exploit players who ever show willingness to cooperate by (i) keeping the stock in a “high-yield” band using *just enough* cooperation, while (ii) defecting whenever it is safe/profitable, and (iii) switching into endgame harvesting and/or collapse-triggering when cooperation isn’t forthcoming.

Key idea: your one-shot incentive always favors **D** given fixed stock \(S\), but repeated play means stock management matters. So the exploit is to **free-ride on others’ restraint** while only “investing” (playing C) when that investment increases future stock enough to pay you back—and to stop investing as soon as others stop.

---

# 1) Decision rules (cooperate vs defect)

### Quantities you track from history/state
At round \(t\), with current stock \(S_t\):

- **Counts last round**:  
  \(k_C(t-1)\) = number of opponents who played C in round \(t-1\) (you can observe actions)

- **Opponent cooperativeness score** (EMA / running average):  
  Let \(p_t\) be your estimate of “probability a random opponent cooperates next round.”  
  Update:
  \[
  p_t \leftarrow (1-\alpha)p_{t-1} + \alpha \cdot \frac{k_C(t-1)}{n-1}
  \]
  with \(\alpha \in [0.2, 0.4]\) (fairly reactive). Initialize \(p_1 = 0.5\).

- **Retaliation sensitivity**: if after you defect, cooperation drops sharply, you are facing conditional cooperators; if not, you are facing unconditional cooperators/noise. Track:
  \[
  \Delta_t = \frac{k_C(t) - k_C(t-1)}{n-1}
  \]
  after your D. Large negative \(\Delta\) ⇒ opponents punish.

---

## Core behavioral modes

### Mode A — **Exploit-cooperators (Free-ride with minimal investment)**
Use when there is evidence of meaningful cooperation:
- Trigger condition: \(p_t \ge \theta_{\text{coop}}\) where \(\theta_{\text{coop}} = 0.5\), or \(k_C(t-1) \ge \lceil (n-1)/2 \rceil\).

**Rule in this mode:**
- If stock is **high enough** (above a safe threshold), **Defect**.
- If stock is **getting low**, **Cooperate** just enough to keep the resource from sliding into a low-growth/low-payoff regime.

Concrete thresholds:
- Define a “danger” stock band based on capacity:
  - \(S_{\text{low}} = 0.35 \cdot \text{capacity}\)
  - \(S_{\text{high}} = 0.70 \cdot \text{capacity}\)

Decision:
- If \(S_t \ge S_{\text{low}}\): **D**
- Else ( \(S_t < S_{\text{low}}\) ): **C** (investment round)

Rationale: growth is highest around \(S \approx \frac{\text{capacity}}{2}\); but if repeated defection pushes \(S\) too low, you lose future rents. You only “pay” (C) when the stock threatens to fall into the low zone.

**Punishment-aware tweak (for conditional cooperators):**
If you observe that your D causes a big cooperation drop next round (e.g., \(\Delta < -0.3\)), then you should “buy back” cooperation occasionally:
- Every time you defect and see strong punishment, schedule one **C** within the next 2 rounds *if* \(S_t < S_{\text{high}}\).  
This is not “being nice”—it is paying the smallest cost to keep others investing.

---

### Mode B — **No-cooperator collapse (When others won’t invest, don’t invest)**
Use when cooperation is scarce:
- Trigger: \(p_t \le \theta_{\text{dead}}\) where \(\theta_{\text{dead}} = 0.2\), or \(k_C(t-1) = 0\) for 2 consecutive rounds.

**Rule:** Always **D**.

Rationale: Your C only halves your current payoff and (with little external cooperation) will not sustain the stock enough to repay you over remaining rounds. In this regime, you maximize immediate extraction; if the pool collapses, that’s inevitable given others.

---

### Mode C — **Probe (early-round testing to classify opponents)**
For early rounds you want to identify whether opponents are:
- conditional cooperators (can be “managed”),
- unconditional cooperators (easy to exploit),
- unconditional defectors (go to Mode B),
- noisy.

**Probe protocol (first 3 rounds):**
- Round 1: **C** (cheap signal / keeps stock high and tests who is willing to cooperate)
- Round 2: **D** (tests retaliation sensitivity)
- Round 3:
  - If many still cooperated in round 2 (e.g., \(k_C(2) \ge \lceil (n-1)/2 \rceil\)): **D** (they’re exploitable)
  - Else: **C** (attempt to re-stabilize conditional cooperators) *only if* \(S_3 < S_{\text{high}}\); otherwise **D**.

After round 3, select Mode A or B based on \(p_t\) and observed punishment.

This opening is exploitative because it is designed to *learn how much you can take* and then take it.

---

# 2) Edge cases (first round, last round, special stock levels)

### First round
Play **C** (Probe protocol).  
Reason: with initial stock at capacity, one round of C has limited downside and maximizes information about opponent types while keeping the system in a good state for potential exploitation.

### Last round (round r)
Always **D**.  
No future to protect; extract max immediate payoff.

### Last 2–3 rounds (“Harvest window”)
From round \(t \ge r - H + 1\) with \(H = 2\) (or 3 if \(r\) is large):
- Default: **D**
- Only exception: if you are in Mode A and you believe a final-round punishment can reduce *this* round’s opponent cooperation in a way that lowers your current payoff (rare because moves are simultaneous). Since punishment affects future, ignore it. So practically: **D**.

### Stock extremely low
If \(S_t \le \frac{2n}{n} = 2\) (very low relative to the action scaling), everyone’s payoffs are tiny and growth from near-zero is also tiny.  
- In Mode A: you may still **C** for 1 round *only if* \(p_t\) is very high (e.g., \(>0.7\)) and there are many rounds left (\(t \le r-3\)).  
- Otherwise: **D** (don’t throw good money after bad).

### Stock extremely high (near capacity)
If \(S_t \ge 0.85 \cdot \text{capacity}\): **D** regardless of mode (except round 1).  
This is pure exploitation: take full share while the system is rich.

---

# 3) Why this is exploitative and robust

### Exploitative alignment
- **Free-riding core:** In any environment with appreciable cooperation, you defect whenever the stock is not in the danger zone.
- **Minimal “investment” cooperation:** You cooperate only when the stock is low enough that maintaining future extraction is at risk *and* opponents are likely to keep contributing.
- **Endgame harvesting:** unconditional last-round (and near-last) defection.

### Robustness to varied opponents
- Against **unconditional cooperators**: you quickly shift to near-permanent D with occasional C only to keep stock from dipping too low; you outperform them substantially.
- Against **conditional cooperators (grim/trigger/tit-for-tat variants)**: the probe detects retaliation; the “buy back cooperation” tweak uses sparse C to keep them from fully switching off.
- Against **unconditional defectors**: you stop wasting C (Mode B) and extract what you can.
- Against **mixed/noisy** strategies: EMA \(p_t\) smooths noise, and stock thresholds prevent catastrophic over-extraction when there is still exploitable cooperation present.

---

# Pseudocode sketch

```python
# parameters: n, r, capacity
alpha = 0.3
theta_coop = 0.5
theta_dead = 0.2
S_low  = 0.35 * capacity
S_high = 0.70 * capacity
H = 2  # harvest window length

p = 0.5
punish_flag = False  # whether opponents strongly punished after our D

for t in 1..r:
    if t == r:
        action = D
        break

    if t >= r - H + 1:
        action = D
        continue

    if t == 1:
        action = C
    elif t == 2:
        action = D
    elif t == 3:
        if kC_prev >= ceil((n-1)/2):
            action = D
        else:
            action = C if S < S_high else D
    else:
        # classify regime
        if p <= theta_dead or (zero_coop_streak >= 2):
            action = D  # Mode B
        else:
            # Mode A
            if S >= S_low:
                action = D
            else:
                action = C

            # punishment-aware tweak
            if punish_flag and action == D and S < S_high:
                # occasionally pay to restore cooperation
                action = C  # e.g., once, then reset punish_flag

    play(action)

    # After observing others' actions:
    update kC_prev, zero_coop_streak
    p = (1-alpha)*p + alpha*(kC_prev/(n-1))

    # punishment detection (only meaningful if we played D last round)
    if we_played_D_last_round:
        if (kC_prev/(n-1) - kC_two_rounds_ago/(n-1)) < -0.3:
            punish_flag = True
        else:
            punish_flag = False
```

---

If you want, I can tighten the thresholds (\(S_{\text{low}}, S_{\text{high}}, \theta\)s) analytically for given \(n, r, \text{capacity}\) (or propose an online method that chooses them by maximizing expected remaining value under a simple opponent model).
'''

description_EXPLOITATIVE_57 = '''
## Strategy: **Cautious Extortion with Stock-Safe Punishment (CESSP)**  
Goal: harvest extra payoff whenever others conserve the stock, but avoid being the “sucker” who cooperates while others defect. Use (i) early probing, (ii) conditional extortion (defect unless the group proves it can sustain stock), and (iii) short, state-aware punishment that forces recovery if opponents want future gains.

Key idea:  
- **Defecting gives you 2× the per-round payoff of cooperating at the same stock** (S/n vs S/(2n)).  
- But too much defection collapses stock to ~0, killing future payoffs.  
- So we **free-ride when stock is healthy**, **punish defectors quickly**, and **switch to cooperation only when needed to keep the resource alive** (or when opponents show they will sustain it for you).

---

# 1) Decision rules (C vs D)

### Variables you track from history and state
At start of round t with current stock S_t:

- `k_{t-1}` = number of opponents who defected last round (0..n-1).  
- `D_rate_recent` = fraction of opponent-defections in a short window (e.g., last W=3 rounds).  
- `punish_timer` = remaining rounds of punishment you have committed to (integer ≥ 0).  
- `trust` score (optional but useful): increases when opponents mostly cooperate while stock stays high; decreases otherwise.

### Stock thresholds (parameter-dependent)
Define:
- `S_hi = 0.8 * capacity` (stock is abundant)
- `S_mid = 0.5 * capacity` (stock is okay but watchful)
- `S_lo = 0.25 * capacity` (danger zone—collapse risk)
- Also note: `capacity ≥ 2n`, so these thresholds are meaningful.

### Core policy
You choose **D by default** (exploit), but you switch to C to (a) prevent collapse, and (b) credibly punish defectors by reducing everyone’s future stock if they keep defecting—while still protecting yourself from being exploited.

**Rule A — Endgame exploitation**
- **If t == r (last round): play D.**  
  No future stock value; take the maximum immediate payoff.

**Rule B — If in punishment mode**
- If `punish_timer > 0`:
  - If `S_t <= S_lo`: play **C** (to prevent total collapse that would also hurt you in remaining rounds).
  - Else play **D** (keep pressure on opponents; you still extract more this round).
  - Decrement `punish_timer -= 1`.

**Rule C — Trigger punishment when opponents defect**
- If not already punishing and last round had meaningful defection:
  - If `k_{t-1} >= 1` and `t > 1` and `S_t >= S_mid`:
    - Set `punish_timer = P`, where `P = min(3, r - t)` (short punishment).
    - This says: “defecting is met with a tough stance while stock can absorb it.”
  - If `S_t < S_mid`, don’t “punish by defecting” (stock too fragile); instead go to preservation mode (Rule D).

**Rule D — Stock preservation (avoid killing the goose)**
- If `S_t <= S_lo`: play **C** regardless of history.  
  Rationale: when stock is low, defecting often accelerates collapse to ~0 and eliminates future value. Cooperation helps the logistic growth rebound.
- Else if `S_lo < S_t <= S_mid`:
  - Play **C** unless opponents are *very* cooperative already (see Rule E).  
  - Intuition: mid stock is where sustaining matters; you want recovery so you can exploit later at high stock.

**Rule E — Conditional extortion / free-riding at high stock**
- If `S_t >= S_hi`:
  - If opponents were mostly cooperative recently (e.g., `D_rate_recent <= 0.2`): play **D** (free-ride on their restraint).
  - If opponents are mixed (0.2 < `D_rate_recent` <= 0.5): play **D** unless last round had *many* defectors (e.g., `k_{t-1} >= (n-1)/2`), in which case play **C** *only if* you’re not in punishment and you want to avoid imminent collapse.
  - If opponents are mostly defecting (`D_rate_recent > 0.5`): go to punishment mode if stock allows, otherwise preservation mode.

---

# 2) Edge cases

### Round 1 (no history)
You need to avoid being the only cooperator if others defect, but also gather information.

**Round 1 rule:**
- If `r` is small (e.g., `r <= 3`): **D** immediately (little future to protect).
- Else:
  - If `capacity` is very large relative to n (e.g., `capacity >= 10n`): **D** (stock can absorb early exploitation; you learn opponents’ tendencies fast).
  - Otherwise: **C** (cheap “investment” when there’s meaningful future and capacity isn’t enormous).  
This initial C is not “nice”; it’s a probe to see if others will sustain the resource for you.

### Last 2 rounds
- **Round r:** always **D**.
- **Round r-1:** usually **D**, unless `S_t` is so low that defecting would make `S_{r}` ≈ 0 and reduce even your last-round payoff.  
  Practical rule: if `S_t <= S_lo`, play **C** on r-1 to revive stock for the final D.

### If stock hits (or is near) zero
- If `S_t` is extremely small (e.g., `S_t <= 0.05*capacity`), always **C** until it rises above `S_lo`.  
Reason: defecting at near-zero gives you almost nothing and prevents recovery.

### If opponents are unconditional cooperators
- You converge to mostly **D** whenever `S_t >= S_hi`, occasionally **C** only when stock falls into mid/low zones to keep the system productive.

### If opponents are unconditional defectors
- You cannot “fix” the game alone; best response is:
  - **D** while stock is high enough to harvest,
  - switch to **C** only when `S_t <= S_lo` to revive stock just enough to harvest again (a “resource farming” cycle).

---

# 3) Why this is exploitative (explicitly)
- **Default posture is defection** whenever the stock is safe or opponents are cooperative—maximizing your share of the current stock.
- **Cooperation is instrumental**, used only to:
  1) prevent stock collapse that would reduce your future ability to exploit, and  
  2) create credible retaliation dynamics that discourage others from defecting *too much* (so the stock stays high for you to skim).
- Against cooperators, you **free-ride**.
- Against conditional cooperators, you **pressure them into sustaining** (they learn that if they defect, you become harsh; if they cooperate, you take extra).
- Against defectors, you **harvest early then farm recovery** (minimizing wasted rounds at zero stock).

---

## Pseudocode (implementable sketch)

```python
def action(t, r, n, capacity, S, history):
    S_hi  = 0.8 * capacity
    S_mid = 0.5 * capacity
    S_lo  = 0.25 * capacity
    S_crit= 0.05 * capacity
    W = 3

    if t == r:
        return "D"

    # init state variables stored across rounds
    punish_timer = history.my_state.get("punish_timer", 0)

    # compute opponent defection stats
    if t == 1:
        if r <= 3: 
            return "D"
        if capacity >= 10*n:
            return "D"
        return "C"

    last = history.rounds[-1]
    k_last = count_opponents_defected(last)
    D_rate_recent = fraction_opponent_defections(history.rounds[-W:]) if t-1 >= 1 else 0

    # emergency recovery
    if S <= S_crit:
        history.my_state["punish_timer"] = 0
        return "C"

    # punish mode
    if punish_timer > 0:
        punish_timer -= 1
        history.my_state["punish_timer"] = punish_timer
        if S <= S_lo:
            return "C"
        return "D"

    # trigger punishment if defection observed and stock can take it
    if k_last >= 1 and S >= S_mid:
        P = min(3, r - t)
        history.my_state["punish_timer"] = P
        # immediate step: start harsh unless stock is fragile
        if S <= S_lo:
            return "C"
        return "D"

    # preservation zone
    if S <= S_lo:
        return "C"
    if S <= S_mid:
        # cooperate unless opponents are extremely cooperative (then you can defect a bit)
        if D_rate_recent <= 0.1:
            return "D"
        return "C"

    # high-stock extortion zone
    if S >= S_hi:
        if D_rate_recent <= 0.2:
            return "D"
        if D_rate_recent > 0.5:
            # many defectors: don't blindly defect if it risks collapse next rounds
            return "C" if S <= S_mid else "D"
        # mixed: lean exploitative
        return "D"

    # default
    return "D"
```

---

If you want, I can also provide:  
- a more “mathematically tuned” version where thresholds derive from expected next-stock under different opponent mixes, or  
- variants optimized for (i) very large r (long-horizon extortion) vs (ii) small r (pure harvesting).
'''

description_EXPLOITATIVE_58 = '''
### Strategy: **Stock-Leech with Grim-Trigger Recovery (SLGTR)**  
Exploit cooperators by defecting whenever the stock is healthy, but avoid destroying the resource (which kills future payoffs) by switching to enforced recovery when stock gets low. Use opponents’ revealed “cooperation level” to decide how aggressively to leech.

This strategy only uses: parameters `(n, r, capacity)`, current stock `S_t`, and full history of actions.

---

## Key ideas (exploitative design)
1. **Defection is strictly better within a round** for any fixed stock \(S\): \(S/n > S/(2n)\). So default to **D**.
2. The only reason to ever play **C** is **resource management**: if everyone defects too much, future stock collapses and you lose the ability to exploit.
3. Identify whether the table contains “sustainers” (frequent cooperators). If yes, you can defect more aggressively while they keep the stock alive.
4. If stock enters a danger zone, switch to a **punitive/recovery mode**: cooperate until stock rebounds, then resume leeching.

---

## Observables computed each round
Let in round \(t-1\):
- \(k_{t-1}\) = number of opponents who played C (exclude you)
- \(\hat{c}_{t-1} = k_{t-1}/(n-1)\) = observed cooperation rate of others last round

Maintain an exponentially-weighted estimate of others’ cooperation:
- \(p_t = (1-\alpha)p_{t-1} + \alpha \hat{c}_{t-1}\), with \(\alpha = 0.3\) (fast adaptation)

Define stock fractions:
- \(x_t = S_t / capacity\)

---

## Modes
You operate in one of three modes:

### Mode A — **Exploit (default)**
Exploit any cooperation by defecting while stock is safe.

### Mode B — **Recovery**
When stock is low or trending down, cooperate to rebuild stock so you can exploit later.

### Mode C — **Endgame**
In the final round(s), ignore future stock and defect.

---

## Decision rules (when to C vs D)

### 0) First round rule
**Round 1: play D.**  
Rationale: immediate gain is higher; also tests whether opponents are “soft” (cooperative) without you paying an exploration cost.

---

### 1) Endgame rule (last rounds)
Let `L = 1` (last round) or optionally `L = 2` (more exploitative if you want).
- If \(t \ge r - L + 1\): **play D**.

Reason: no future to preserve.

---

### 2) Stock safety thresholds
Use two thresholds (hysteresis prevents flip-flopping):
- **Danger threshold**: \(x_t \le \theta_{low}\)
- **Exit recovery threshold**: \(x_t \ge \theta_{high}\)

Set:
- \(\theta_{low} = 0.35\)
- \(\theta_{high} = 0.70\)

(These work broadly because logistic growth is strong when stock is moderate, but collapse risk is high near low stock.)

---

### 3) Switch conditions
**Enter Recovery mode** if any of the following holds:
- \(x_t \le \theta_{low}\)  (stock too low)
- OR you detect a collapse trend:
  - \(S_t < S_{t-1}\) **and** \(S_{t-1} < S_{t-2}\) (two-round decline), **and** \(x_t < 0.6\)

**Exit Recovery mode** when:
- \(x_t \ge \theta_{high}\)

---

### 4) Action choice inside each mode

#### Mode B — Recovery
**Play C** until exit condition met.  
This is “reluctant cooperation”: you only do it to restore future extractable value.

Optional exploit tweak: if others are clearly sustaining even in low stock, you can still defect sometimes:
- If \(p_t \ge 0.8\) (others almost always cooperate) and \(x_t \ge 0.45\): play **D** even in recovery.
This leeches from very cooperative groups without fully risking collapse.

#### Mode A — Exploit (default)
Normally: **play D**.

But add one protective constraint so you don’t personally cause a crash when everyone else also defects:
- If \(p_t \le 0.2\) (others mostly defect) **and** \(x_t < 0.55\): play **C** (preemptive stabilization)
- Otherwise: **D**

Interpretation:
- If others are cooperators, you exploit them (D).
- If others are defectors and stock is slipping, you temporarily cooperate just enough to keep the pool from dying (so you can keep earning something in future rounds).

---

## Edge cases & robustness

### If stock hits (or is near) zero
- If \(S_t \approx 0\): your payoff is near zero regardless. Still play **C** in Recovery mode because any regrowth requires remaining stock; but if \(S_t = 0\) exactly, growth is 0 forever under the given dynamics. Then:
  - If \(S_t = 0\): actions no longer matter; default to **D** (doesn’t change anything).

### If capacity is very large relative to 2n
Doesn’t matter; the strategy uses stock fraction \(x_t\), so it scales.

### If opponents are conditional cooperators (tit-for-tat-like)
They may punish your D by switching to D, causing stock decline. SLGTR responds by entering Recovery when decline persists, restoring stock. This often re-triggers their cooperation, after which you resume exploiting.

### If opponents are random/noisy
EWMA \(p_t\) smooths noise; hysteresis thresholds avoid oscillation.

---

## Pseudocode

```python
# parameters: n, r, capacity
alpha = 0.30
theta_low  = 0.35
theta_high = 0.70
L = 1  # last round full defect

mode = "EXPLOIT"
p = 0.5  # prior belief of others' cooperation

for t in 1..r:
    x = S_t / capacity

    if t == 1:
        action = "D"
    elif t >= r - L + 1:
        action = "D"
    else:
        # update p using last round history (if exists)
        k = number_of_opponents_who_played_C_in_round(t-1)
        chat = k / (n-1)
        p = (1-alpha)*p + alpha*chat

        # mode switching
        if mode != "RECOVERY":
            if x <= theta_low:
                mode = "RECOVERY"
            elif t >= 3 and (S_t < S_{t-1} < S_{t-2}) and x < 0.6:
                mode = "RECOVERY"
        else:  # in RECOVERY
            if x >= theta_high:
                mode = "EXPLOIT"

        # choose action within mode
        if mode == "RECOVERY":
            if p >= 0.8 and x >= 0.45:
                action = "D"  # leech if others are extreme sustainers
            else:
                action = "C"
        else:  # EXPLOIT
            if p <= 0.2 and x < 0.55:
                action = "C"  # stabilize against mutual defection collapse
            else:
                action = "D"

    play(action)
```

---

## Why this is exploitative (explicitly)
- **Default behavior is defection** to take the higher immediate payoff.
- **Cooperation is instrumental**, used only to preserve the stock as a future profit source.
- Against cooperative populations, it behaves like a **free-rider** (persistent D), only switching if the resource is about to collapse.
- Against defectors, it avoids self-destructive spirals by **minimally investing** in recovery when needed, then returning to exploitation.

If you want it even more exploitative, set `theta_low` lower (e.g., 0.25) and `theta_high` lower (e.g., 0.55) so you tolerate more depletion before you “waste” moves on C—but this increases risk of irreversible collapse if others also defect heavily.
'''

description_EXPLOITATIVE_59 = '''
## Strategy: **Predatory Trigger with Stock-Aware Throttling (PT-SAT)**

Goal: **Extract high payoffs whenever opponents allow it, while keeping the stock high enough to continue extracting.** The strategy treats cooperation as *investment* only when it predictably increases future extraction opportunities; otherwise it defects.

The key idea is to:
- **Probe** early to learn whether opponents punish defection.
- **Exploit** cooperative/forgiving populations by defecting most of the time.
- **Maintain** the stock near capacity (where growth is strong) by cooperating only when the stock gets too low or when punishment risk becomes high.
- **Crush** retaliators by switching to permanent defection once cooperation is no longer profitable.

---

# 1) Decision rules (C vs D)

### Observables each round \(t\)
- Current stock \(S_t\)
- History of actions (counts of C/D among others each round)
- Rounds remaining \(R = r - t + 1\)

Define:
- \(d_{t-1}\): number of opponents who defected last round (0 to \(n-1\))
- “Punishment signal”: opponents increase defection after we defect.

### Core thresholds
- **Low-stock threshold:**  
  \[
  S_t \le S_{\text{low}} = 0.6 \cdot \text{capacity}
  \]
  Below this, defection risks collapsing the resource and killing future payoffs; we become conservative.

- **Critical-stock threshold:**  
  \[
  S_t \le S_{\text{crit}} = 0.3 \cdot \text{capacity}
  \]
  Below this, we prioritize recovery (cooperate) unless endgame makes recovery irrelevant.

- **Endgame window:** last  
  \[
  W = \max(2,\lceil r/10 \rceil)
  \]
  rounds. In this window, future stock value is limited → defect more.

### Opponent-type inference (simple, robust)
Maintain two rolling stats over the last \(L=\min(5, t-1)\) rounds:
- \(\overline{d}\): average number of opponents defecting
- **Retaliation score**: how much opponents’ defection rises after *we* defect.
  - Let `after_defect` be rounds immediately after we played D.
  - Let `after_coop` be rounds immediately after we played C.
  - Retaliation score = avg(d | after_defect) − avg(d | after_coop)

Interpretation:
- High retaliation score ⇒ opponents punish defection.
- Low retaliation score with low \(\overline{d}\) ⇒ forgiving/cooperative opponents ⇒ exploitable.

---

## Decision policy (in priority order)

### Rule A — Endgame exploitation
If \(R \le W\): **Defect (D)**  
Exception: if \(S_t \le S_{\text{crit}}\) and \(R>1\), play **C** once to avoid total collapse (only if there is at least 2 rounds left and recovery still yields benefit).

**Exploitative logic:** In the endgame, future consequences shrink; harvest now.

---

### Rule B — Stock-preservation throttle
If \(S_t \le S_{\text{crit}}\): **Cooperate (C)**  
(unless it’s literally final round → D)

If \(S_{\text{crit}} < S_t \le S_{\text{low}}\):
- If opponents are already defect-heavy (\(\overline{d} \ge 0.6(n-1)\)): **Defect (D)** (resource likely doomed; take what you can).
- Else: **Cooperate (C)** to rebuild stock.

**Exploitative logic:** Cooperate only as an investment when there’s a plausible chance to keep the pool productive.

---

### Rule C — Predatory exploitation when stock is healthy
If \(S_t > S_{\text{low}}\) (healthy stock region):
1. If retaliation score is **low** (≤ 0.2(n−1)) AND \(\overline{d}\) is **low** (≤ 0.3(n−1)):  
   → **Defect (D)** (harvest from cooperators).
2. If retaliation score is **high** (≥ 0.4(n−1)):  
   → **Cooperate (C)** most of the time to keep them cooperating, but **inject exploitation**:
   - Defect every 3rd round **only while** \(S_t > 0.8\cdot\)capacity and opponents’ defection rate remains low.  
   (This is “controlled cheating”.)
3. Otherwise (uncertain/mixed field):  
   → **Defect (D)** unless last round we saw high defection \(d_{t-1} \ge 0.5(n-1)\), in which case **D** anyway (no reason to invest).

**Exploitative logic:** When the resource is healthy, default to D unless you must “pay” cooperation to keep others producing a harvestable stock.

---

### Rule D — Triggered switch to “take-the-money”
If at any point BOTH hold:
- \(S_t \le S_{\text{low}}\) AND
- opponents’ defection is high (\(\overline{d} \ge 0.6(n-1)\))

Then enter **Extraction Mode** for the rest of the game: always **D**.

**Exploitative logic:** Once the group is collapsing the pool, cooperation is throwing good money after bad—grab remaining value.

---

# 2) Edge cases

### First round (t = 1)
Play **D**.

Rationale: You learn immediately whether opponents punish defection, and you capture high payoff at peak stock. If they don’t retaliate, you’ve found free money. If they do, you can “buy” cooperation later when it matters.

### Second round (t = 2)
Use what happened in round 1:
- If many opponents defected in round 1 (\(d_1 \ge 0.5(n-1)\)) → **D** (it’s already competitive).
- Else if stock remains high (\(S_2 > 0.8\cdot\)capacity) → **D** again (double-probe / exploit).
- Else → **C** (rare, only if stock already fell dangerously).

### Last round (t = r)
Always **D**.

---

# 3) Why this is exploitative (and robust)

### Exploitative features
- **Defaults to defection** whenever consequences can be pushed onto the future or onto others.
- **Uses cooperation as a tool**, not a norm—only to keep the “resource machine” running so you can keep extracting.
- **Controlled cheating** against retaliators: cooperate enough to keep them calm, defect periodically when stock is high to skim extra payoff.
- **Abandons doomed pools** quickly via Extraction Mode.

### Robustness features
- **Stock-aware throttling** prevents self-sabotage in fragile states.
- **Retaliation detection** handles tit-for-tat, grim-trigger, conditional cooperators, randoms, and defectors.
- **Endgame rule** prevents being the sucker who “invests” when the horizon is short.

---

# Pseudocode sketch

```pseudo
initialize mode = "normal"
history buffers for last L rounds: opp_defections, our_action

for t in 1..r:
    R = r - t + 1
    observe S_t

    if t == 1: action = D; play; continue

    update rolling stats:
        dbar = avg(opponent_defections over last L)
        retaliation = avg(d | after we played D) - avg(d | after we played C)
        (compute over available samples; if none, set retaliation = 0)

    W = max(2, ceil(r/10))
    Slow  = 0.6 * capacity
    Scrit = 0.3 * capacity

    if mode == "extraction":
        action = D
    else if R <= W:
        if S_t <= Scrit and R > 1: action = C else action = D
    else if S_t <= Scrit:
        action = C
    else if S_t <= Slow:
        if dbar >= 0.6*(n-1): mode="extraction"; action = D
        else action = C
    else:  # S_t > Slow (healthy)
        if retaliation <= 0.2*(n-1) and dbar <= 0.3*(n-1):
            action = D
        else if retaliation >= 0.4*(n-1):
            # controlled cheating
            if (t mod 3 == 0) and (S_t > 0.8*capacity) and (last_round_opp_defections <= 0.3*(n-1)):
                action = D
            else:
                action = C
        else:
            action = D

    play action
```

---

If you share typical tournament settings (ranges for \(n, r,\) and capacity), I can tune the numerical thresholds (0.6, 0.3, retaliation cutoffs, cheat frequency) to fit the meta more aggressively.
'''

description_EXPLOITATIVE_60 = '''
## Strategy: **Regenerative Extortion with Stock Trigger (REST)**

Goal: **Extract extra payoff whenever opponents allow the stock to stay high**, but **avoid being the sucker** (cooperating while others defect) and **avoid killing the resource too early** when there are still many rounds to harvest.

Core idea:
- When the stock is healthy, **defect unless defecting would likely crash the stock below a “safe regenerative band.”**
- When the stock is low or opponents are aggressive, **switch to defensive cooperation** only as much as needed to keep the stock from collapsing (so you can keep extracting later).
- Use a **forgiving but exploitative trigger**: reward cooperative groups with continued high extraction (your D), punish defect-heavy groups by tightening (play C) to stop being exploited and to rebuild stock.

---

# 1) Decision rules (C vs D)

### Key quantities computed each round \(t\)
Let:
- \(S\) = current stock at start of round.
- From history, compute last round’s number of defectors \(k_{t-1}\) (or if unavailable at \(t=1\), treat as unknown).
- Define **opponent defection rate estimate**:
  \[
  \hat{q} = \text{EWMA of }(k/n)\text{ over recent rounds}
  \]
  e.g. exponential smoothing with weight \(\alpha=0.5\).

### Predictive safety check (main control)
If you play C, your consumption is \(S/(2n)\). If you play D, it’s \(S/n\).

Given an estimated number of other defectors among the other \(n-1\) players:
\[
\hat{k}_{-i} = \text{round}(\hat{q}(n-1))
\]

Then predicted remaining stock after consumption if you play action \(a\):

- If **you play C**:
  \[
  S^{rem}_C = S - \left(\hat{k}_{-i}\cdot \frac{S}{n} + (n-1-\hat{k}_{-i})\cdot \frac{S}{2n} + \frac{S}{2n}\right)
  \]
- If **you play D**:
  \[
  S^{rem}_D = S - \left(\hat{k}_{-i}\cdot \frac{S}{n} + (n-1-\hat{k}_{-i})\cdot \frac{S}{2n} + \frac{S}{n}\right)
  \]

You don’t need exact algebra in implementation; just compute directly.

### Define a **regeneration band**
Because growth is logistic, stock regenerates strongly when it’s not too close to 0 or capacity; but it can be wiped out if remaining stock hits 0.

Use thresholds based only on parameters:
- **Collapse threshold**: \(S_{\min} = 2n\) (given state bounds mention \(0 \le S \le 2n\) in one place; regardless, use \(2n\) as “dangerously low” because per-round consumption scales with \(S\)).
- **Safe band target**: \(S_{\text{safe}} = 0.4 \cdot capacity\) (strong growth region).
- **Harvest band**: \(S_{\text{high}} = 0.75 \cdot capacity\).

### Action rule (exploitative but stock-aware)

At round \(t\) with stock \(S\):

**Rule A — Endgame cash-out (pure exploitation):**
- If \(t = r\): **Play D**.
- If \(t = r-1\): **Play D** unless \(S\) is so low that everyone’s payoffs are tiny anyway (still D is fine; keep it D).

**Rule B — If stock is high, extort:**
- If \(S \ge S_{\text{high}}\):
  - Play **D** *unless* predicted \(S^{rem}_D < S_{\min}\) (i.e., your D likely causes collapse).
  - If your D would likely collapse stock, play **C** (so you can keep extracting later).

**Rule C — If stock is moderate, defect conditionally:**
- If \(S_{\text{safe}} \le S < S_{\text{high}}\):
  - If opponents look cooperative: \(\hat{q} \le 0.35\), play **D** (take advantage).
  - Else if opponents look mixed/aggressive:
    - Play **D** only if \(S^{rem}_D \ge S_{\min}\),
    - otherwise play **C**.

**Rule D — If stock is low, stabilize (but don’t be a sucker):**
- If \(S < S_{\text{safe}}\):
  - If opponents are aggressive: \(\hat{q} \ge 0.5\), play **C** (deny them the advantage of you going D and crashing the pool; keep it alive for later).
  - If opponents are cooperative: \(\hat{q} < 0.5\), play **D** *only if* \(S^{rem}_D \ge S_{\min}\); else **C**.

This produces a simple behavior:
- **Defect by default** when it’s profitable and not immediately self-destructive.
- **Cooperate as damage control** when the pool is at risk or opponents are too defect-happy to safely exploit.

---

# 2) Edge cases

### Round 1 (no history)
You want information and immediate advantage without suicidal collapse.

- If \(capacity \ge 4n\): **Play D** in round 1 (stock is ample; your extra take is safe).
- Else (capacity closer to minimum sustainable region): **Play C** in round 1 to avoid early collapse and observe others.

Then initialize \(\hat{q}\) from observed defections in round 1.

### Last round \(t=r\)
Always **D**. There is no future stock value.

### Second-to-last round \(t=r-1\)
Almost always **D** as well. Only exception (optional, but rarely needed):
- If you believe everyone will D and collapse yields near-zero payoff now (i.e., \(S\) already ~0), it doesn’t matter; still D.

### If stock hits (or is extremely near) zero
When \(S\) is so low that both C and D pay almost nothing:
- Play **C** unless it’s the last round(s). Rationale: if there’s time left, only rebuilding can create future exploitable stock.

### If opponents are “grim trigger” cooperators (they cooperate until you defect, then always defect)
This strategy *will* exploit them once, then detect the retaliation via rising \(\hat{q}\), and switch into stabilization mode (more C) to prevent permanent collapse where possible. You still gained the early high-stock surplus, which is the exploit.

---

# 3) Why this is exploitative (explicit alignment)

1. **Always take the larger share (D) whenever it doesn’t endanger future extraction.**  
   That’s direct exploitation of cooperative opponents: you earn \(S/n\) while they accept \(S/(2n)\).

2. **Use “stock collapse avoidance” only as a tool to enable more future defection.**  
   Cooperation is not a norm; it’s maintenance so the resource remains harvestable.

3. **Punish defect-heavy environments by switching to C strategically, not to be nice, but to deny opponents a profitable collapse path and preserve your long-run take.**  
   Against persistent defectors, full D just destroys the pool and reduces your own future payoffs; REST instead plays “resource defense” to keep some value.

---

## Pseudocode (implementable sketch)

```python
# parameters: n, r, capacity
S_min   = 2*n
S_safe  = 0.4*capacity
S_high  = 0.75*capacity
alpha   = 0.5   # EWMA smoothing

# state maintained by strategy:
q_hat = None  # estimated defection rate in population

def predict_S_remaining(S, action_i, k_others_defect, n):
    # consumption by others
    cons_others = k_others_defect*(S/n) + (n-1-k_others_defect)*(S/(2*n))
    cons_i = (S/n) if action_i=="D" else (S/(2*n))
    return S - (cons_others + cons_i)

def choose_action(t, S, history):
    global q_hat

    # endgame
    if t == r or t == r-1:
        return "D"

    # initialize estimate
    if t == 1 or q_hat is None:
        if capacity >= 4*n:
            return "D"
        else:
            return "C"

    k_others = round(q_hat*(n-1))
    Srem_D = predict_S_remaining(S, "D", k_others, n)
    Srem_C = predict_S_remaining(S, "C", k_others, n)

    # high stock: extort unless collapse risk
    if S >= S_high:
        return "C" if Srem_D < S_min else "D"

    # moderate stock
    if S >= S_safe:
        if q_hat <= 0.35:
            return "D"
        else:
            return "C" if Srem_D < S_min else "D"

    # low stock: stabilize but still opportunistic
    if q_hat >= 0.5:
        return "C"
    else:
        return "C" if Srem_D < S_min else "D"

def update_after_round(observed_defectors_k):
    global q_hat
    q = observed_defectors_k / n
    if q_hat is None:
        q_hat = q
    else:
        q_hat = alpha*q + (1-alpha)*q_hat
```

---

If you want, I can also provide a **more aggressively exploitative variant** that attempts “probe-defect” cycles to identify conditional cooperators and lock into maximum extraction against them, while switching to survival mode against always-defect strategies.
'''

description_EXPLOITATIVE_61 = '''
## Strategy: **Stock-Leader with Retaliation (SLR)**  
Exploit cooperators by defecting whenever it’s safe/profitable, but avoid collapsing the stock by switching to “maintenance cooperation” when the system is near a tipping point. Punish defect-heavy histories to deter further depletion, yet re-open exploitation quickly if others return to cooperation.

The core idea: **treat the stock as capital**. Keep it high enough to keep future payouts large, but **extract more than your “fair share” whenever others are propping the stock up**.

---

# 1) Decision rules (C vs D)

### Key quantities you compute each round \(t\)
Let current stock be \(S\). From history, infer last-round counts:
- \(k_C\): number of cooperators last round  
- \(k_D = n - k_C\): number of defectors last round

Per-round total consumption given \(k_D\) defectors:
- Each C consumes \(S/(2n)\)
- Each D consumes \(S/n\)
- Total consumption fraction = \(\frac{k_C}{2n} + \frac{k_D}{n} = \frac{n + k_D}{2n}\)
So remaining stock after consumption:
\[
S_{\text{rem}}(k_D) = S\left(1 - \frac{n + k_D}{2n}\right) = S\cdot \frac{n - k_D}{2n}
\]
Then logistic growth:
\[
g = 2 S_{\text{rem}}(1 - S_{\text{rem}}/\text{capacity})
\]
New stock:
\[
S' = \min(S_{\text{rem}} + g, \text{capacity})
\]

You will use this to decide whether “more defection” risks driving stock too low.

---

## Rule A — **Endgame defection**
- **If \(t = r\)** (last round): **Play D**.
  - No future stock to protect, so maximize immediate payoff.

---

## Rule B — **Exploit whenever stock is safely high**
Define a *safe-stock threshold*:
\[
S_{\text{high}} = 0.80 \cdot \text{capacity}
\]
- If \(S \ge S_{\text{high}}\): **Play D**, *unless* you are in a punishment phase (see Rule D).
  - Rationale: when stock is high, your extra extraction is valuable and the system can usually absorb it if others are not all defecting.

---

## Rule C — **Stock-viability check (prevent collapse when you are pivotal)**
When stock is not very high, your choice might determine whether the pool recovers or crashes.

Compute predicted next stock under two scenarios, using *expected* defector count this round:
- Baseline expectation: opponents repeat last round (works well in tournaments).
  - Expected defectors among others = \(k_D^{\text{last}} - \mathbb{1}[\text{you defected last}]\)  
  - Call this \(k_{D,\text{others}}\)

Now compare:
- If you play **C**: total defectors \(k_D = k_{D,\text{others}}\)
- If you play **D**: total defectors \(k_D = k_{D,\text{others}} + 1\)

Compute predicted \(S'_C\) and \(S'_D\).

Define a *danger threshold*:
\[
S_{\text{danger}} = \max(2n,\ 0.35\cdot \text{capacity})
\]
(We include \(2n\) because the state bounds mention \(2n\) and low stocks make everyone’s payoffs tiny; below this you want recovery attempts.)

**Decision:**
- If \(S'_D < S_{\text{danger}}\) but \(S'_C \ge S_{\text{danger}}\): **Play C** (you are pivotal; cooperate to keep the “capital” alive).
- Else: **Play D**.

This is the main “robustness” component: you defect by default, but you don’t defect when your defection likely pushes the system into a low-stock regime that ruins your future extraction.

---

## Rule D — **Exploit cooperators, punish defectors (but only briefly)**
You want others to do the work of sustaining stock while you skim. However, if many are defecting, the pool collapses and you lose future profit. So you use a *short, credible retaliation* to discourage sustained defection.

Maintain a rolling window over the last \(W\) rounds (e.g., \(W=5\)):
- \( \bar{k}_D = \) average number of defectors over last \(W\) rounds

Define a *defection pressure* threshold:
\[
k_D^{\text{bad}} = \left\lceil 0.40n \right\rceil
\]
Punishment trigger:
- If \( \bar{k}_D \ge k_D^{\text{bad}} \) **and** \(S < S_{\text{high}}\): enter **Punish Mode** for \(P\) rounds (e.g., \(P=2\)).

**Punish Mode action:**
- Play **C** for \(P\) rounds *unless it’s the last round (then D)*.

Exit early:
- If in Punish Mode and you observe \(k_D\) drops below \( \lceil 0.25n \rceil\), exit Punish Mode immediately and revert to Rules A–C.

Why this is exploitative (not “nice”): punishment is **minimal**—just enough to help stock recover and to make mutual defection less attractive—but you switch back to defection quickly to resume extracting surplus.

---

# 2) Edge cases

### First round (\(t=1\))
- If \(r \ge 2\): **Play D**.
  - Starting stock is capacity; it’s the best time to exploit.
  - If everyone defects, stock may crash, but your Rule C won’t help in round 1 because you lack history; you accept this risk because many tournament agents start cooperatively or conditionally.

### Very low stock
If \(S \le 2n\):
- **Play C** unless \(t=r\).
  - At extremely low stock, defecting gains little and further harms recovery chances. Cooperation is an investment to restore a profitable stock level you can later exploit.

### Second-to-last round (\(t=r-1\))
- Use normal rules, but bias toward defection:
  - If Rule C says “be pivotal and cooperate,” only cooperate if it keeps \(S'\) above \(S_{\text{danger}}\) **by a comfortable margin** (e.g., \(S'_C \ge S_{\text{danger}} + 0.1\cdot\text{capacity}\)); otherwise **D**.
  - Rationale: little future remains, so stock-protection value is reduced.

### If opponents appear always-cooperative
Detect: in last \(W\) rounds, \( \bar{k}_D \approx 0\) (excluding you).
- **Always D** except when your viability check (Rule C) says your D would likely push the system under \(S_{\text{danger}}\).
This maximizes extraction from unconditional cooperators while keeping the pool from collapsing if you are pivotal.

### If opponents appear always-defective
Detect: \( \bar{k}_D\) near \(n\).
- Don’t waste long trying to “teach” them. Use Punish Mode rarely and briefly.
- Mostly **D**, but if \(S\) is low, **C** can be worthwhile to rebuild stock for *your own later* benefit (if there’s enough horizon left), otherwise still **D**.

---

# 3) Why this is exploitative and robust

**Exploitative:**
- Defaults to **D** in high-stock states and early game.
- Switches back to D quickly after any cooperative “maintenance” or brief punishment.
- Specifically targets cooperative populations by free-riding while preserving the resource just enough to keep extracting.

**Robust:**
- Uses **state-based viability** (Rule C) so it doesn’t blindly defect into self-destruction.
- Uses **history-based defection pressure** (Rule D) to respond to mixed/tit-for-tat/trigger strategies without locking into permanent mutual defection.
- Works against a wide range: unconditional cooperators (farm them), conditional cooperators (avoid pushing them into permanent retaliation), defectors (take what you can; optionally rebuild stock if there’s time).

---

## Pseudocode sketch

```pseudo
params: W=5, P=2
state: punish_timer = 0

function decide(t, r, n, capacity, S, history):
    if t == r: return D

    S_high = 0.80 * capacity
    S_danger = max(2*n, 0.35 * capacity)

    if S <= 2*n:
        return C  # unless last round handled above

    # compute last-round defector count kD_last and your_last_action
    kD_last = count_defectors(history[t-1]) if t>1 else unknown
    your_last = your_action(history[t-1]) if t>1 else none

    # update punishment trigger from last W rounds if possible
    if t > 1:
        avg_kD = average_defectors(history over last min(W, t-1) rounds)
        bad = ceil(0.40*n)
        if avg_kD >= bad and S < S_high and punish_timer == 0:
            punish_timer = P

    if punish_timer > 0:
        punish_timer -= 1
        # exit early if defection has dropped
        if t > 1 and kD_last < ceil(0.25*n):
            punish_timer = 0
        return C

    # Round 1: exploit
    if t == 1:
        return D

    # High stock: exploit
    if S >= S_high:
        return D

    # Viability check: assume others repeat last round
    kD_others = kD_last - (your_last == D ? 1 : 0)
    SD_if_C = predict_next_stock(S, kD = kD_others, n, capacity)
    SD_if_D = predict_next_stock(S, kD = kD_others + 1, n, capacity)

    if SD_if_D < S_danger and SD_if_C >= S_danger:
        return C
    else:
        return D
```

This policy is intentionally “mean but not suicidal”: it grabs surplus whenever possible, but it treats the stock dynamics as a constraint so it can keep harvesting over many rounds.
'''

description_EXPLOITATIVE_62 = '''
Below is an **exploitative, stateful “Bully-then-Manage” strategy** for the repeated common-pool game. It is designed to (i) grab surplus when others are cooperative or forgiving, (ii) avoid being the “sucker” when others defect, and (iii) keep the stock from collapsing when continued exploitation is still possible.

Core idea: **Defect by default to harvest**, but **switch into “stock management” cooperation only when the stock is in danger of collapsing (which would eliminate future rents)**. Use **fast retaliation** against defection to avoid being exploited, but **return quickly to defection** when opponents show cooperativeness.

---

## Key quantities you can compute from history/state

Let:
- `S_t` = stock at start of round `t`.
- Observe after round `t` the number of defectors: `k_t ∈ {0..n}` (including you).
- Define:
  - **Defection rate estimate** (short-memory):  
    `Dbar_t = average(k_{t-L..t-1} / n)` for a small window `L` (e.g., 3 to 5), clamped if not enough history.
  - **Stock safety thresholds**:
    - `S_low = 0.25 * capacity` (danger zone)
    - `S_mid = 0.50 * capacity` (recoverable zone)
  - **Endgame horizon**: `H = 2` (last two rounds are endgame)

Why these matter:
- In this game, **D strictly dominates C in the current round given S**, but **too much D collapses S to ~0** and kills future payoffs. So exploitation is “take more now, but don’t kill the goose when there’s still time to keep taking.”

---

## Strategy overview (modes)

The strategy uses three modes:

1. **BULLY (default)**: play **D** to exploit cooperative opponents.
2. **MANAGE**: play **C** temporarily to rebuild stock when it is in your interest (i.e., there are enough rounds left to monetize the recovery).
3. **PUNISH**: play **D** for a short, fixed burst when opponents defect “too much” while stock is still healthy—this prevents becoming the only cooperator feeding others.

We select mode each round using state + recent defection levels + remaining rounds.

---

## 1) Decision rules (when to cooperate vs defect)

### Rule A — Endgame: always defect
- If `t > r - H` (last `H` rounds), play **D**.
  - Exploitative rationale: no future to preserve; take maximum per-round share.

### Rule B — Stock-critical management (cooperate only to protect future rents)
- If `t ≤ r - H` (not endgame) and **stock is low**:
  - If `S_t ≤ S_low`: play **C** (enter MANAGE).
  - Else if `S_low < S_t ≤ S_mid`:
    - If `Dbar_t` is low-to-moderate (others not fully defecting), play **C** (MANAGE).
    - If `Dbar_t` is high (near universal defection), play **D** (don’t waste cooperation).

Interpretation:
- You “invest” in stock recovery **only when it can plausibly recover and you can later cash out**, and **only if others aren’t hell-bent on immediate depletion**.

### Rule C — Healthy stock exploitation: defect unless you’re uniquely propping up cooperators
When `S_t > S_mid` and not endgame:
- Default: play **D** (BULLY).
- Exception (avoid being exploited as lone cooperator): If in the last round you played C and you observed `k_{t-1} ≥ 1` (someone defected), then play **D** for the next `P` rounds (PUNISH), where `P = 2` (or 3 if n is large).
  - After `P` rounds, return to BULLY unless stock is low.

Interpretation:
- You try a bit of “management” only when stock is endangered; otherwise you take the bigger cut.
- If you ever cooperate and detect defection, you stop cooperating immediately and punish briefly (so no one can farm you).

---

## 2) Edge cases (first round, last round, etc.)

### First round
Play **D**.

Reason:
- Immediate exploit against naive cooperators.
- Establishes a tough baseline: opponents that condition on “niceness” will be pulled toward accommodating you; those that retaliate reveal themselves quickly.

### Last rounds
As above: **always D in the last H=2 rounds**.

### Stock at/near zero
If `S_t` is extremely low (e.g., `S_t < stock_eps`, `stock_eps = 1e-6`), your action barely matters; play **D** (no reason to invest if the group already burned it down and endgame approaches).

### Small r
If `r ≤ 3`, treat the whole game as endgame: always **D** (there is insufficient time to profit from rebuilding stock).

---

## 3) Exploitative alignment (why this is “bully”)

This strategy is exploitative in three specific ways:

1. **Defect-first to capture surplus**: against unconditional cooperators, grim cooperators with slow retaliation, “nice” strategies, etc., you’ll extract higher payoffs immediately.
2. **Only “repair” the resource when it benefits you**: cooperation is not moral; it is an investment to keep the resource producing future payoffs that you can later take with D—especially in the endgame.
3. **Refuse to be farmed**: if others defect while you cooperate, you rapidly switch to D (punish burst) so you do not subsidize them.

---

## Pseudocode (implementation-ready)

```pseudo
parameters:
  H = 2                    # endgame length
  L = 4                    # memory window
  P = 2                    # punishment length
  S_low = 0.25 * capacity
  S_mid = 0.50 * capacity
  high_defect = 0.80       # threshold on Dbar
state:
  punish_remaining = 0
  history_k = []           # list of observed defector counts each round
  last_action = None

function choose_action(t, S_t):
  # Endgame
  if r <= 3:
    return D
  if t > r - H:
    return D

  # If currently punishing
  if punish_remaining > 0:
    punish_remaining -= 1
    return D

  # Compute Dbar from last L rounds (if any)
  if len(history_k) == 0:
    Dbar = 0.0
  else:
    use = last min(L, len(history_k)) elements
    Dbar = average( k / n for k in use )

  # Stock-critical management
  if S_t <= S_low:
    return C

  if S_t <= S_mid:
    if Dbar < high_defect:
      return C
    else:
      return D

  # Healthy stock: exploit
  return D

function observe_round_result(you_played, k_t):
  history_k.append(k_t)

  # Trigger punishment if you cooperated and someone defected
  if you_played == C and k_t >= 1:
    punish_remaining = P
```

---

## How it behaves vs common opponent types (robustness)

- **Always-Cooperate / naive stock-preservers**: you mostly **D**, harvesting high payoff; if stock dips too low, you briefly **C** to keep the resource alive, then go back to **D**.
- **Always-Defect**: you also **D** (you don’t waste effort cooperating into a collapse you can’t prevent alone). You may occasionally C at very low stock if there’s still time, but only when recent defection isn’t near-total (so you don’t throw good money after bad).
- **Tit-for-tat / retaliators**: you start with D; if they respond with D, the interaction moves toward mutual D. You avoid being uniquely cooperative. If they’re forgiving, you keep exploiting.
- **Stock-manager coalitions**: you free-ride (D) while they rebuild; you only help when collapse is imminent and there’s time left to monetize recovery.

This is intentionally not “fair” or cooperative; it is a **resource-rent extraction policy** with minimal, self-interested conservation.
'''

description_EXPLOITATIVE_63 = '''
Below is an **exploitative, state-aware “Harvest–Test–Punish” strategy**. It is designed to (i) quickly identify who is willing to cooperate, (ii) **free-ride whenever the stock can sustain it**, and (iii) **switch to hard extraction** when others won’t maintain the resource anyway. It uses only parameters \((n,r,\text{capacity})\), current stock \(S_t\), and full action history.

---

## Core idea (exploitative mindset)

1. **When cooperation is viable**, you want *others* to play C while you play D to get double the per-round payoff.
2. If too many others defect, the stock collapses and future value disappears; then the best response is usually **defect immediately** (grab what’s left).
3. So you:
   - **Probe** early to see whether the population is cooperative.
   - **Exploit** by defecting when the stock is high and opponents look cooperative.
   - **Threaten/punish** (defect for multiple rounds) when opponents defect enough to endanger sustainability, to deter exploitation against you and to avoid being the sucker.
   - **Rebuild** with cooperation only when the stock is low and there is evidence others will also rebuild.

---

## Useful quantities you can compute each round

Let \(S_t\) be stock at start of round \(t\).

Let \(k_t\) = number of opponents who defected in round \(t-1\) (you observe this).

Define:
- **Defection rate last round:** \(\rho_{t-1} = k_t/(n-1)\).
- **Stock regime thresholds:**
  - High stock: \(S_t \ge 0.8 \cdot \text{capacity}\)
  - Medium: \(0.4\cdot \text{capacity} \le S_t < 0.8\cdot \text{capacity}\)
  - Low: \(S_t < 0.4\cdot \text{capacity}\)

Also track a simple “cooperation climate” score:
- \(H_t\) = number of defections by opponents in the **last \(w\) rounds** (suggest \(w=\min(5,t-1)\)).
- \(\bar\rho_t = H_t / ((n-1)w)\) = average opponent defection rate over the window.

---

## Decision rules (C vs D)

### 0) Last-round rule (endgame grab)
- **If \(t = r\): play D.**
Reason: no future to preserve; D strictly dominates C in the current round payoff.

### 1) First-round rule (calibration)
Round 1 you have no history.

- If \(r \le 3\): **play D** (short horizon → exploit immediately).
- Else (longer horizon): **play C in round 1** as a low-cost test to see if the room is capable of sustaining the stock. You lose at most a factor of 2 this round, but gain information to enable multi-round exploitation.

### 2) Collapse / “no future” rule (when stock is too low)
If \(S_t \le S_{\text{collapse}}\), **play D**.
- Set \(S_{\text{collapse}} = \max\left(\frac{\text{capacity}}{10},\, 2n\right)\).
Rationale: when stock is very low, preserving it requires broad cooperation; without communication that’s unlikely. Take what you can.

### 3) Punishment rule (respond to meaningful defection)
If opponents show significant defection, you punish by defecting for several rounds to avoid being exploited and to push the group into either (a) discipline or (b) full collapse (in which case you continue to defect anyway).

Trigger punishment if either:
- **Majority-defected last round:** \(\rho_{t-1} \ge 0.5\), or
- **Persistent defection:** \(\bar\rho_t \ge 0.35\) (over the last \(w\) rounds)

**Punishment action:** play **D** for the next \(P\) rounds, where
- \(P = 2\) if stock is high,
- \(P = 3\) if stock is medium,
- \(P = 4\) if stock is low.

(You can implement this with a “punish_counter” state variable that counts down.)

### 4) Exploitation rule (free-ride when it’s safe)
If you are not in punishment mode, and:
- Stock is **high** \(S_t \ge 0.8\cdot \text{capacity}\), and
- Opponents look cooperative: \(\bar\rho_t \le 0.2\) (few defections recently)

→ **play D**.

This is the core exploit: when others are holding the resource together and stock is abundant, you take double.

### 5) Maintenance / rebuild rule (keep the resource alive when necessary)
If you are not in punishment mode and not in last round:

- If stock is **medium**:
  - If \(\bar\rho_t \le 0.2\): **play D** (still exploit; resource likely recovers)
  - Else: **play C** (avoid accelerating decline; you only rebuild when the room isn’t too hostile)

- If stock is **low** (but above collapse threshold):
  - If \(\bar\rho_t \le 0.1\) and \(\rho_{t-1} \le 0.25\): **play C** (rebuild only if others are very cooperative)
  - Else: **play D** (low stock + non-cooperative room → harvest remaining)

This makes “rebuilding” **conditional and rare**—you don’t volunteer to be the conservationist unless the group is already proving it will mostly cooperate, in which case you can later return to exploitation.

---

## Pseudocode sketch

```python
# parameters: n, r, capacity
# state you maintain:
punish_counter = 0
history = []  # store opponents' defections per round

def decide(t, S_t, opp_actions_last_round):
    global punish_counter, history

    # compute recent stats
    if t > 1:
        k_last = count_defectors(opp_actions_last_round)  # among n-1 opponents
        history.append(k_last)
        rho_last = k_last / (n-1)
    else:
        rho_last = 0

    w = min(5, t-1)
    if w > 0:
        H = sum(history[-w:])
        rho_bar = H / ((n-1) * w)
    else:
        rho_bar = 0

    S_collapse = max(capacity/10.0, 2*n)

    # last round: grab
    if t == r:
        return "D"

    # first round calibration
    if t == 1:
        return "D" if r <= 3 else "C"

    # collapse region: grab
    if S_t <= S_collapse:
        return "D"

    # punishment countdown
    if punish_counter > 0:
        punish_counter -= 1
        return "D"

    # punishment triggers
    if rho_last >= 0.5 or rho_bar >= 0.35:
        if S_t >= 0.8*capacity: punish_counter = 2-1
        elif S_t >= 0.4*capacity: punish_counter = 3-1
        else: punish_counter = 4-1
        return "D"

    # exploitation / maintenance
    if S_t >= 0.8*capacity and rho_bar <= 0.2:
        return "D"

    if S_t >= 0.4*capacity:
        return "D" if rho_bar <= 0.2 else "C"

    # low stock but not collapsed
    if rho_bar <= 0.1 and rho_last <= 0.25:
        return "C"
    else:
        return "D"
```

---

## Edge cases explicitly handled

- **Round 1:** C only if there’s enough horizon to profit from identifying a cooperative population; otherwise D.
- **Last round:** always D.
- **Very low stock:** always D (don’t waste actions trying to save a doomed resource).
- **Highly defecting opponents:** immediate multi-round D punishment (prevents you from being the “sucker” and also tests whether opponents revert to cooperation).
- **Highly cooperative opponents + high stock:** default to D to free-ride.

---

## Why this is exploitative and robust

- **Exploitative:** whenever the environment is stable (high stock) and opponents are cooperative, you defect to take double. You only cooperate when it increases expected future extractable value enough to be worth it.
- **Robust:** if opponents are unconditional defectors, you quickly converge to always D. If they’re conditional cooperators, your occasional C in fragile regimes plus punishments can keep enough cooperation to maintain stock—*while you still defect frequently in high-stock phases*.
- **Adaptive:** uses observed defection rates and current stock regime rather than assuming any convention.

If you want, I can also provide a more “aggressive” variant (defect even more often) and a more “stealthy exploiter” variant (cooperates just enough to keep forgiving strategies from triggering permanent punishment).
'''

description_EXPLOITATIVE_64 = '''
Below is an **exploitative, state-aware “harvest–punish–reset”** strategy designed to (i) take the high payoff from defection whenever it is safe, (ii) coerce/condition others into cooperating by making defection unprofitable for them, and (iii) avoid permanently killing the resource unless the horizon forces it.

---

## Core idea (what it exploits)

- If the group sustains the stock (roughly by enough players choosing **C**), then **D** yields **double** the per-round payoff of **C** at the same stock level.
- Stock regeneration is strong when the post-consumption stock is near **capacity/2**, and can fully restore to capacity if the remaining stock lands around half.
- So you want to:
  1) **Free-ride (play D)** when the pool is healthy and others aren’t collapsing it.
  2) **Punish** quickly when others defect too much (to prevent being the “sucker cooperator”).
  3) **Reset** by cooperating just enough/long enough to bring the stock back into the high-growth region, then return to harvesting.

This is exploitative because the default stance is: **take D whenever cooperation by others keeps the system alive**, and only “invest” in C when it increases future harvest opportunities.

---

## Notation you can compute from history/state

At round \(t\), observe current stock \(S_t\), and from the previous round observe:
- \(k_{t-1}\): number of opponents who defected last round.
- \(S_{t}\): current stock already reflects last round’s consumption + growth.

Define:
- \(S_{\text{high}} = 0.85 \cdot \text{capacity}\) (pool is “fat”)
- \(S_{\text{mid}} = 0.55 \cdot \text{capacity}\) (good growth zone)
- \(S_{\text{low}} = 0.30 \cdot \text{capacity}\) (danger zone)

Also define a “defection pressure” threshold:
- \(k^{*} = \left\lceil \frac{n-1}{2} \right\rceil\) (opponent majority defecting)

---

## Strategy: EPR (Exploit–Punish–Recharge)

### 1) Decision rules (cooperate vs defect)

**Rule A — Endgame liquidation (exploit the horizon)**
- If \(t = r\): **Play D**.
- If \(t = r-1\): **Play D** unless \(S_t\) is extremely low (see Rule D).

Rationale: there is little future to protect; take the immediate doubled payoff.

---

**Rule B — Default: exploit when safe**
Play **D** if all of the following hold:
1) Stock is not in the danger zone: \(S_t \ge S_{\text{low}}\)
2) Opponents are not in “defection majority” last round: \(k_{t-1} < k^{*}\)

This is your main exploit mode: when others are mostly cooperating (or mixed but not majority defecting), you defect and harvest more.

---

**Rule C — Punish coordinated/mass defection**
If opponents’ defection pressure is high:
- If \(k_{t-1} \ge k^{*}\): **Play D** for the next **P** rounds (punishment block), where  
  \(P = 2\) by default, but **P = 3** if \(S_t < S_{\text{mid}}\).

During a punishment block you always play D (even if stock is recovering).

Rationale: You do not want to be the stabilizer while others defect; you make defection lead to rapid stock loss and lower future payoffs for them. This also discourages “bully strategies” trying to farm cooperators.

---

**Rule D — Recharge mode (invest only when it pays)**
Enter **Recharge** (play C) when:
- \(S_t < S_{\text{low}}\), **or**
- \(S_t < S_{\text{mid}}\) **and** you are not currently punishing **and** \(k_{t-1} < k^{*}\) (i.e., others look “recoverable”)

While in Recharge:
- Play **C** until \(S_t \ge S_{\text{high}}\), then exit Recharge and return to Rule B.

Rationale: when stock is low, D gives low absolute payoff anyway and risks collapse; cooperating is an *investment* to restore the ability to exploit later. You only do this when opponents are not in mass defection (otherwise your investment is stolen).

---

**Rule E — “Test-and-trap” against conditional cooperators**
Many adaptive opponents try “nice then punish.” You can farm them with occasional “repairs.”

If:
- \(S_t \ge S_{\text{mid}}\)
- and exactly one round ago you punished (i.e., you were in a punishment block last round)
- and opponents’ defection pressure is now low: \(k_{t-1} < k^{*}\)

Then: play **C for 1 round**, then revert to Rule B (exploit mode).

Rationale: one round of C often resets forgiving strategies back into cooperation, after which you resume defecting for higher payoff.

---

## 2) Edge cases

### First round
**Round 1: Play D.**  
Justification: Stock starts at capacity, so immediate payoff is maximal and you learn opponents’ tendencies at no informational cost.

### Last round
**Always D** (Rule A).

### Very small stock (near-zero)
If \(S_t\) is extremely small (e.g., \(S_t \le 0.05\cdot\text{capacity}\)):
- If \(t < r\) and \(k_{t-1} < k^{*}\): play **C** (try to revive).
- Otherwise (opponents still defecting heavily or it’s endgame): play **D** (take what’s left).

### If opponents always defect
Your rules will quickly go into punishment blocks and mostly D; the pool collapses and everyone gets little, but you avoid being exploited. There is no profitable unilateral “save the pool” against persistent defectors, so this is the correct exploitative stance.

### If opponents always cooperate
You will mostly D (Rule B) and occasionally C only if stock drops too low (it usually won’t if enough others cooperate). You free-ride for consistently higher per-round payoffs.

---

## 3) Pseudocode (implementation-ready logic)

```python
# state kept by our strategy
punish_left = 0
mode = "NORMAL"  # or "RECHARGE"
just_finished_punish = False

def action(t, r, n, capacity, S_t, k_prev):
    global punish_left, mode, just_finished_punish

    S_high = 0.85 * capacity
    S_mid  = 0.55 * capacity
    S_low  = 0.30 * capacity
    k_star = math.ceil((n-1)/2)

    # Endgame
    if t == r:
        return "D"
    if t == r-1 and S_t >= 0.05 * capacity:
        return "D"

    # Continue punishment block if active
    if punish_left > 0:
        punish_left -= 1
        if punish_left == 0:
            just_finished_punish = True
        else:
            just_finished_punish = False
        return "D"

    # Trigger punishment if opponent majority defected
    if k_prev is not None and k_prev >= k_star:
        P = 3 if S_t < S_mid else 2
        punish_left = P - 1
        just_finished_punish = False
        return "D"

    # Recharge entry
    if S_t < S_low:
        mode = "RECHARGE"
    elif mode != "RECHARGE" and S_t < S_mid and (k_prev is not None and k_prev < k_star):
        mode = "RECHARGE"

    # Recharge behavior
    if mode == "RECHARGE":
        if S_t >= S_high:
            mode = "NORMAL"
        else:
            just_finished_punish = False
            return "C"

    # One-round repair after punishment to re-trap conditional cooperators
    if just_finished_punish and S_t >= S_mid and (k_prev is not None and k_prev < k_star):
        just_finished_punish = False
        return "C"

    just_finished_punish = False

    # Default exploit when safe
    if S_t >= S_low and (k_prev is None or k_prev < k_star):
        return "D"

    # Otherwise cautious cooperate (rare fallback)
    return "C"
```

---

## Why this is exploitative and robust

- **Exploitative:** Defaults to **D** whenever the pool is healthy and opponents aren’t in mass defection—capturing the 2× payoff advantage.
- **Robust:** Quickly stops “being nice” when opponents defect; avoids getting trapped as the lone cooperator propping up others.
- **Adaptive:** Uses observed defection pressure and stock thresholds to switch between harvesting, punishment, and recovery investment.
- **Tournament-sensible:** Works against unconditional cooperators (farms them), conditionals (manipulates with brief repairs), and defectors (doesn’t donate).

If you want, I can also provide a tighter parameterization (thresholds and punishment length) optimized for specific ranges of \(n\), \(r\), or capacity-to-\(n\) ratios.
'''

description_EXPLOITATIVE_65 = '''
Below is an **exploitative “Harvest–Probe–Punish (HPP)”** strategy for the repeated common-pool game. It aims to (i) extract higher payoffs whenever others are conserving the stock, (ii) avoid being the “sucker” when others are draining, and (iii) keep the resource from hitting zero when doing so is profitable.

Key idea: **treat the pool like a renewable asset**. Cooperate only to maintain/restore a stock regime that you can later **harvest via defection**, and defect whenever others are sufficiently cooperative that defection is low-risk/high-return.

---

## Notation you can compute from history/state

At round \(t\), before acting you observe current stock \(S_t\) and past actions.

- Let \(k_{t-1}\) = number of opponents who defected in round \(t-1\) (out of \(n-1\)).
- Let \(\hat{q}_{t-1} = k_{t-1}/(n-1)\) = observed opponent defection rate last round.
- Maintain a rolling estimate of opponent defection tendency, e.g. exponentially weighted:
  \[
  q_t = (1-\alpha)\,q_{t-1} + \alpha\,\hat{q}_{t-1}, \quad \alpha \in [0.2,0.4]
  \]
  Initialize \(q_1 = 0.5\).

- Define **stock regime thresholds** (depend only on parameters):
  - “High stock”: \(S_t \ge 0.8\,\text{capacity}\)
  - “Medium”: \(0.4\,\text{capacity} \le S_t < 0.8\,\text{capacity}\)
  - “Low”: \(S_t < 0.4\,\text{capacity}\)

These can be tuned but are robust.

---

## Strategy overview (exploitative stance)

1. **If others are mostly cooperating and stock is healthy → defect to harvest.**
2. **If others are mostly defecting or stock is fragile → cooperate to avoid collapse** (but only enough to stabilize; you’re not “nice,” you’re preserving future harvest).
3. **If someone tries to punish you (switches to defection) → temporarily cooperate to rebuild stock, then resume harvesting** as soon as they relent.
4. **Near the end → defect aggressively** because future stock has little/no value.

---

## 1) Decision rules: cooperate vs defect

### A. First round (no history): default to defection (exploit)
**Round 1: play D.**

Rationale: you get double the immediate payoff versus C, and early stock is maximal. If others also defect, the game collapses fast—but you would have collapsed anyway under many opponent profiles, and you avoided being the only cooperator.

### B. Main rule set for rounds \(t = 2, \dots, r-1\)

Use three modules, evaluated in order:

#### Module 1 — Endgame pressure (time-dependent greed)
If there is little future left, **harvest now**:

- If \(t \ge r-1\): play **D** (unless stock is essentially zero already; see edge cases).

(So you cooperate only if you believe one more round of cooperation materially increases your last-round take—rare and handled below.)

#### Module 2 — Collapse avoidance (protect the asset only when needed)
If stock is low or opponents are draining, shift to conservation mode:

Play **C** if either condition holds:
- **Low stock:** \(S_t < 0.4\,\text{capacity}\), OR
- **High opponent defection:** \(q_t > 0.55\)

Intuition: when others are likely to defect, your defection doesn’t “punish” them; it just accelerates collapse and reduces your own future harvest. Cooperation here is *self-interested stabilization*, not altruism.

#### Module 3 — Exploit mode (harvest when it’s safe)
Otherwise (stock not low AND opponents not too defect-heavy), play **D**.

That means: if stock is medium/high and \(q_t \le 0.55\), you defect to extract more than cooperators.

---

## 2) Edge cases and special handling

### A. “One-step salvage” check (optional but strong)
Sometimes cooperating for one round increases the next round’s stock enough that your **final-round defection** yields more total payoff than defecting immediately.

Implement a simple salvage heuristic in the penultimate round \(t=r-1\):

If \(t=r-1\), do:
- If \(S_{r-1}\) is **very low** (e.g. \(S_{r-1} < 0.2\,\text{capacity}\)) and your estimate says others are not extreme defectors (\(q_{r-1} < 0.6\)), then play **C** at \(r-1\) to try to regrow stock and then **D** at \(r\).
- Else play **D**.

This is still exploitative: you “invest” only when it boosts your last extraction.

### B. Stock near zero
If \(S_t \approx 0\), actions barely matter. Use:
- If \(S_t \le \epsilon\) (e.g. \(10^{-9}\)): play **D** (doesn’t hurt, keeps policy consistent).

### C. Opponents adaptively punishing your defection
If you see a sudden spike in defections immediately after you defected (classic retaliation), you can “cool off” to restore exploitation opportunities.

Add a retaliation detector:
- Let \(k_{t-1}\) be last round’s opponent defectors.
- If \(k_{t-1} \ge \lceil 0.7(n-1)\rceil\) (supermajority defected), enter **Rebuild Mode** for \(L\) rounds (e.g. \(L=2\)) where you play **C** unless it’s the last round.

Exit Rebuild Mode early if opponents’ defection rate drops back:
- If in rebuild and \(\hat{q}_{t-1} < 0.4\), exit and resume normal rules (likely exploit again).

This makes you robust against “grim trigger”-like bots: you stop feeding the spiral, and if they calm down you go right back to harvesting.

### D. If you observe persistent cooperators (“naive” strategies)
If \(\hat{q}_{t-1}\) stays very low for several rounds (e.g. average < 0.2 over last 3 rounds) and stock is not low, always **D**.  
This is pure exploitation: you free-ride on their conservation.

---

## 3) Why this is exploitative and robust

**Exploitative:**
- Defaults to **D** (immediate advantage).
- Defects whenever stock is not endangered and opponents aren’t too defect-heavy (i.e., whenever exploitation is profitable).
- Uses cooperation only as an **investment** to keep the pool from collapsing so you can **continue extracting** at the higher D rate.
- In endgame, harvests aggressively.

**Robust:**
- If others defect heavily, it cooperates enough to avoid total collapse when possible (protects your own future payoffs).
- If others cooperate, it reliably harvests.
- If others punish, it temporarily de-escalates to reopen profitable states, then re-exploits.

---

## Pseudocode (implementation-ready)

```python
# Parameters: n, r, capacity
alpha = 0.3
q = 0.5  # smoothed opponent defection estimate
rebuild = 0  # rounds remaining in rebuild mode

def act(t, S, history):
    global q, rebuild

    if t == 1:
        return "D"

    # Update q from last round
    opp_def_last = count_opponent_defections(history[t-1])
    hat_q = opp_def_last / (n-1)
    q = (1 - alpha) * q + alpha * hat_q

    # If last round had supermajority defection, trigger rebuild
    if opp_def_last >= ceil(0.7*(n-1)):
        rebuild = 2  # L=2

    # Last round: defect
    if t == r:
        return "D"

    # Penultimate round salvage heuristic
    if t == r-1:
        if S < 0.2*capacity and q < 0.6:
            return "C"
        else:
            return "D"

    # Rebuild mode: cooperate to restore stock, unless near end handled above
    if rebuild > 0:
        rebuild -= 1
        # exit early if opponents calm down
        if hat_q < 0.4:
            rebuild = 0
        return "C"

    # Main rules
    low_stock = (S < 0.4*capacity)
    high_opp_def = (q > 0.55)

    if low_stock or high_opp_def:
        return "C"
    else:
        return "D"
```

---

If you share typical tournament settings (ranges of \(n, r, capacity\)), I can tighten the thresholds (0.4/0.8 capacity, 0.55 defection rate, rebuild length) to better fit the expected ecology of strategies.
'''

description_EXPLOITATIVE_66 = '''
### Strategy: **Stock‑Steward Extortion (SSE)**  
Exploit others by (i) extracting high payoffs whenever the stock is high, (ii) coercing cooperation via credible, state‑dependent punishments, and (iii) farming the resource at the minimum cooperation level needed to keep the stock high *when (and only when) others appear willing to sustain it*.

The key idea: **treat “high stock” as valuable capital**. Defect to skim it when it’s safe, but switch to cooperation when the stock (or others’ behavior) indicates that continued defection would crash future value.

---

## Notation from history (round t uses stock Sₜ observed at start of round)
- `S` = current stock at start of round.
- From last round: `kD_prev` = number of opponents who defected (played D) last round. (You observe all actions.)
- `meanD_lastW` = average number of defectors among opponents over a sliding window of last `W` rounds (e.g., W=5, truncated early).
- `pD_est` = `meanD_lastW / (n-1)` estimated opponent defection rate.
- Let `S_high = 0.8 * capacity`, `S_mid = 0.5 * capacity`, `S_low = 0.25 * capacity`.  
  (You can tune constants; these are robust defaults.)

We also maintain a mode variable:
- `mode ∈ {TEST, EXTORT, PUNISH, RECOVER}`

---

## Intuition about the dynamics (why these thresholds work)
If everyone cooperates, stock returns to capacity in one step from many moderate levels. But if enough players defect, consumption rises and the stock can fall below the “self-healing” region. Once `S` is low, both C and D yield tiny payoffs and the game becomes about rebuilding the stock; **the best exploit is to make others do that rebuilding while you occasionally skim**.

---

# 1) Decision rules (C vs D)

### Overview
1. **Probe** in early rounds to learn whether opponents are cooperative enough to maintain high stock.
2. If they are, enter **EXTORT**: defect when stock is high to take the larger share, but cooperate just enough to keep the stock from collapsing.
3. If opponents defect “too much,” enter **PUNISH**: defect aggressively to crash payoffs (deny them gains) and make defection unprofitable.
4. When stock gets low, enter **RECOVER**: cooperate to rebuild, but only return to EXTORT if opponents also cooperate.

---

## Mode transitions
Use these rules at the start of each round `t` after observing `S` and last actions.

### (A) Start in `TEST`
- Purpose: classify the population quickly.

Transition out of TEST after 2 rounds:
- If opponent defection rate is low: `pD_est ≤ 0.3` → `EXTORT`
- Else → `PUNISH`

### (B) From `EXTORT`
- If stock falls into danger or opponents start defecting:
  - If `S < S_mid` **or** `pD_est ≥ 0.5` → `PUNISH` (stop “feeding” defectors)
- If stock is low: `S < S_low` → `RECOVER` (resource preservation)

### (C) From `PUNISH`
- If opponents reduce defection:
  - If `pD_est ≤ 0.25` and `S ≥ S_mid` → `EXTORT`
- If stock becomes very low: `S < S_low` → `RECOVER`

### (D) From `RECOVER`
- If opponents are cooperating enough to rebuild:
  - If `pD_est ≤ 0.35` and `S ≥ S_mid` → `EXTORT`
- If opponents keep defecting while stock is low:
  - Stay in `RECOVER` for 1–2 rounds (to avoid permanent zero), then switch to `PUNISH` if they don’t improve.

---

## Action selection within each mode

### Mode: TEST (rounds 1–2)
- **Round 1:** Play **D**.  
  Rationale: immediate exploitation if others cooperate; also reveals whether they punish defectors.
- **Round 2:**  
  - If `kD_prev == 0` (everyone else cooperated): play **D** again (extract while it’s free).  
  - Else: play **C** (signal that you’ll “stabilize” only when needed, and gather more info about whether they reciprocate).

### Mode: EXTORT
Exploit when safe; stabilize when necessary.

Action rule:
- If `S ≥ S_high`:
  - Play **D** unless opponents are trending toward defection (`pD_est > 0.35`), in which case play **C** to keep them from tipping into mutual defection.
- Else if `S_mid ≤ S < S_high`:
  - Play **C** if `pD_est > 0.25`, else **D**.
- Else (`S < S_mid`):
  - Play **C** (protect future value; defection here just accelerates collapse and reduces your own future skim).

In words: **defect aggressively at high stock**, but **buy cooperation** (by cooperating) when the system nears the unstable region or when others start defecting.

### Mode: PUNISH
Goal: make defection unattractive by denying long-run value and refusing to be the “sucker” who rebuilds while others skim.

Action rule:
- If `S ≥ S_low`: play **D**.  
  (Crash stock quickly or keep it depressed; this removes the benefit of their defection and stops them earning sustainable high payoffs.)
- If `S < S_low`: play **C** for 1 round out of every 3 (e.g., cooperate on rounds where `t mod 3 == 0`, defect otherwise).  
  Rationale: prevent permanent zero (which also hurts you), but keep recovery slow unless others clean up their act.

### Mode: RECOVER
Goal: rebuild stock *conditional on* opponents not exploiting the rebuild.

Action rule:
- Play **C** if `pD_est ≤ 0.35`.  
- Otherwise (they are still defecting a lot): alternate **C, D, D** (one cooperate, two defects).  
  Rationale: you contribute minimally to avoid zero, but you do not fully bankroll their extraction.

---

# 2) Edge cases

### First round
- Always **D** (maximizes immediate payoff; information gathering; forces others to reveal whether they punish).

### Last round (round r)
- Always **D**.  
  There is no future stock value to protect; cooperation cannot be repaid.

### Second-to-last round (round r−1)
- If `S ≥ S_mid`: **D** (still mostly endgame).  
- If `S < S_mid`: choose **D** anyway unless you expect a large final-round stock boost *and* you believe others will cooperate next round (rare without communication). In tournaments, default **D** is more robust.

### Stock at/near zero
If `S` is extremely small, the immediate payoff difference between C and D is small, but **the growth term depends on remaining stock after consumption**. So:
- If `S < S_low`: bias toward **C** *unless* opponents are heavily defecting (then do minimal recovery as described).

### Highly erratic opponents
The sliding window estimate `pD_est` makes the strategy robust. If they oscillate, you’ll oscillate too: skim when safe, stabilize when needed, punish when they spike defection.

---

# 3) Why this is exploitative (explicitly)
- **You start by defecting** to grab surplus from any cooperative population and to test whether they can coordinate punishment.
- In cooperative environments, **you defect whenever stock is high**, harvesting a bigger share each round while the system remains productive.
- You **only cooperate as an investment** to keep the “resource engine” from stalling, not out of fairness.
- If others defect, you **do not play nice**—you enter a punishment regime that keeps stock/payoffs low, reducing the profitability of their defection and pressuring them to return to cooperation.
- Recovery is **conditional and minimal**: you rebuild only when others are sufficiently cooperative; otherwise you avoid being the one who restores the commons for them to loot.

---

## Pseudocode sketch

```pseudo
params: W=5
thresholds:
  S_high = 0.8*capacity
  S_mid  = 0.5*capacity
  S_low  = 0.25*capacity

state: mode = TEST

function pD_est(history, W):
  if t==1: return 0.5
  window = last min(W, t-1) rounds
  return avg_over_window( (#opponents_defected)/(n-1) )

for round t = 1..r:
  observe S
  if t == r: play D; continue

  pD = pD_est(history, W)

  # mode transitions
  if mode == TEST and t >= 3:
     if pD <= 0.30: mode = EXTORT else mode = PUNISH

  if mode == EXTORT:
     if S < S_low: mode = RECOVER
     else if S < S_mid or pD >= 0.50: mode = PUNISH

  if mode == PUNISH:
     if S < S_low: mode = RECOVER
     else if pD <= 0.25 and S >= S_mid: mode = EXTORT

  if mode == RECOVER:
     if pD <= 0.35 and S >= S_mid: mode = EXTORT
     # else remain

  # action selection
  if mode == TEST:
     if t == 1: action = D
     else:
        if last_round_opponents_defectors == 0: action = D
        else action = C

  else if mode == EXTORT:
     if S >= S_high:
        action = (pD > 0.35 ? C : D)
     else if S >= S_mid:
        action = (pD > 0.25 ? C : D)
     else:
        action = C

  else if mode == PUNISH:
     if S >= S_low: action = D
     else action = (t mod 3 == 0 ? C : D)

  else if mode == RECOVER:
     if pD <= 0.35: action = C
     else action = (t mod 3 == 1 ? C : D)  # C, D, D repeating

  play action
```

This policy is tournament-robust: it exploits cooperative fields, avoids being milked by defectors, and uses state-aware conservation to prevent self-destructive over-defection when the stock is the real prize.
'''

description_EXPLOITATIVE_67 = '''
## Exploitative “State‑Aware Bully with Forgiveness” (SABF)

Core idea:  
1) **Take D whenever it’s safe or profitable**, especially when others are likely to keep the stock healthy (cooperators, timid strategies, unconditional cooperators, “sustainable harvesters”).  
2) **Switch to C only as a repair/investment move** when the stock is heading toward collapse *or* when opponents are punishing enough that D stops paying.  
3) Use **history to estimate how fragile the stock is under current opponent behavior**, and push it right up to (but not past) the point where future profits drop.

This is exploitative because it treats cooperation as a *tool* to maintain a productive resource you can continue to skim at **2× the cooperative share**.

---

# 1) Decision rules (C vs D)

### Quantities you track
Let `S_t` be current stock at start of round `t`.

From last round you can infer how many opponents defected because consumption amounts are discrete:
- If you played C last round, your consumption was `S_{t-1}/(2n)`.
- If you played D last round, your consumption was `S_{t-1}/n`.

Given the post-consumption stock `S_rem = S_{t-1} - total_consumption` and the growth rule, you can invert to get `S_rem` from the observed `S_t` (new stock) because:
- `S_t = min(S_rem + 2*S_rem*(1 - S_rem/capacity), capacity)`
- If `S_t < capacity`, then `S_t = 3*S_rem - 2*S_rem^2/capacity` (a quadratic in `S_rem`)
- If `S_t = capacity`, then `S_rem` is at least the level that regrows to capacity (you don’t need exact; treat it as “healthy”).

Once `S_rem` is known/estimated, you can compute total consumption:
- `C_total = S_{t-1} - S_rem`

Then the inferred number of defectors last round:
- Each cooperator consumes `S_{t-1}/(2n)`; each defector consumes `S_{t-1}/n` = 2× cooperator consumption.
- If `k` players defected total (including you), then  
  `C_total = (n-k)*S_{t-1}/(2n) + k*S_{t-1}/n = S_{t-1}*(n+k)/(2n)`
  so  
  `k = (2n*C_total / S_{t-1}) - n` (round to nearest integer and clamp to `[0,n]`)

You also track a short moving average `k̄` over the last `m` rounds (e.g., `m=3`) to smooth noise.

---

## Main policy: “Defect unless you must invest”
You choose D by default, **except** in these situations:

### Rule A — Endgame squeeze
- **If `t = r` (last round): play D.**  
No future stock to preserve; pure one-shot best response.

### Rule B — Emergency repair (prevent imminent crash)
Compute a conservative “next stock if I defect” projection using `k̄`:
- Predict total defectors next round as `k_pred = clamp(round(k̄_opponents + 1), 0, n)` where `k̄_opponents = k̄ - (1 if you defected last round else 0)` (approximate).
- Predict remaining stock after consumption:
  `S_rem_pred = S_t * (n - k_pred)/(2n)`
- If `S_rem_pred` is *too low*, growth won’t save you and the resource spirals down.

Use a hard threshold:
- **If `S_t < S_crit`: play C**, else keep exploiting with D.

A good robust choice:
- `S_crit = max( capacity * 0.35 , 2n )`  
Rationale: below ~35% of capacity, logistic regrowth is weaker and heavy defection is likely to push toward low steady states or collapse; `2n` respects the defined stock range floor and ensures you don’t fight over dust.

### Rule C — Punishment detection (when opponents won’t tolerate exploitation)
If your recent defection is followed by a jump in defection from others (you stop being the “only defector” and become “one of many”), D becomes self-defeating.

Implement:
- If in the last `m` rounds, whenever you played D, the inferred opponent defectors next round is high:
  - define `opp_def_rate = average( (k_t - your_action_t) / (n-1) over last m )`
- **If `opp_def_rate ≥ θ` (e.g., `θ=0.6`) and stock is not near capacity**, then play C for a short “cooldown” window `L` rounds (e.g., `L=2`) to see if they revert.

This is not “nice”; it’s a tactical de-escalation to restore a regime where you can be the marginal defector again.

### Rule D — Skim when others sustain (the exploit mode)
If none of A/B/C triggers:
- **Play D.**

That means:
- You defect when stock is healthy.
- You defect when others are cooperating enough to keep it healthy.
- You defect when others are mixed but not pushing toward collapse.
- You only cooperate as a maintenance cost or to break punishment cycles.

---

# 2) Edge cases

### Round 1 (no history)
Start by exploiting, but don’t instantly nuke the resource when capacity is borderline.
- If `capacity` is large relative to `n` (which it is, capacity ≥ 2n), you can safely test:
  - **Round 1: play D.**

This probes the population:
- If many others still cooperate, you found free-riders to exploit.
- If many defect, the stock will fall and you switch to repair mode when Rule B triggers.

### Last 2–3 rounds (finite-horizon unravelling)
Defection becomes increasingly attractive near the end.
- **Round r: D always**
- **Round r-1: D unless stock is so low that even D yields tiny payoffs and C could raise `S_r` enough to matter.**
A simple rule:
- At `t = r-1`, play C only if `S_{r-1} < S_crit` (same as Rule B). Otherwise D.

### If stock hits (or is near) 0
If `S_t` is extremely low, both actions pay almost nothing; only cooperation can rebuild (because total consumption is smaller).
- **If `S_t ≤ 2n`: play C** (minimize extraction, maximize chance of regrowth).
If others keep defecting here, the game is effectively dead; you still lose little by choosing C because D doesn’t save it anyway.

### If stock is at capacity
That’s the ideal exploitation regime.
- **If `S_t = capacity`: play D**, unless you are currently in a “cooldown” forced by Rule C.

---

# 3) Why this is exploitative and robust

### Exploitative alignment
- Against cooperative or sustainability-minded strategies: you defect almost always, extracting **double** their per-round payoff while keeping the stock high enough (because *they* pay the maintenance cost).
- Against conditional cooperators: you defect until they start punishing; then you briefly cooperate to reset them, then resume defection.
- Against defect-heavy populations: you stop “wasting” by defecting into collapse and instead cooperate only when it actually increases future extraction opportunities.

### Robustness
- Uses only observable state/history; no reliance on conventions or communication.
- Doesn’t require correctly identifying exact opponent types—only detects two macroscopic conditions:
  1) “Stock is heading toward low productivity” (Rule B)
  2) “Opponents retaliate” (Rule C)
- Handles both extremes: unconditional cooperators and unconditional defectors.

---

# Pseudocode (implementable sketch)

```python
# parameters: n, r, capacity
m = 3                  # smoothing window
theta = 0.6            # retaliation sensitivity
L = 2                  # cooldown length
S_crit = max(0.35*capacity, 2*n)

cooldown = 0
history = []  # store tuples: (t, S_t, action, inferred_k)

def action(t, S_t):
    global cooldown

    # Endgame
    if t == r:
        return "D"

    # If cooling down due to punishment, cooperate
    if cooldown > 0:
        cooldown -= 1
        return "C"

    # Emergency repair if stock is low
    if S_t <= S_crit:
        return "C"

    # If we have enough history, detect retaliation
    if len(history) >= m:
        recent = history[-m:]
        # compute opp def rate conditional on our D
        opp_rates = []
        for (_, _, a, k) in recent:
            if a == "D":
                opp_rates.append((k - 1) / (n - 1))
        if len(opp_rates) > 0:
            opp_def_rate = sum(opp_rates)/len(opp_rates)
            if opp_def_rate >= theta and S_t < capacity:
                cooldown = L
                return "C"

    # Default exploit
    return "D"
```

(You’d also implement `infer_k()` each round from observed `S_{t-1}`, your action, and `S_t` by inverting the growth step, then append to `history`.)

---

If you want, I can also provide a concrete, numerically stable method to invert the growth function and infer `S_remaining`/`k` (including the “hit capacity” corner case) so the implemented agent can reliably compute `k` from observed stocks.
'''

description_EXPLOITATIVE_68 = '''
### Strategy: **Pressure–Probe–Pump (PPP)**  
Exploit opponents by (i) *extracting* when they look cooperative/forgiving, (ii) *punishing* just enough to deter being farmed, and (iii) *preserving* the stock when it’s strategically valuable for future extraction. The key is to treat the game as managing a renewable asset: keep it high when you expect future cooperation, crash it when you don’t, and defect whenever others are keeping it high for you.

---

## Core ideas (why this exploits well)
- **Defection has an immediate 2× payoff advantage** over cooperation at the same stock: \(S/n\) vs \(S/(2n)\). So you want to defect whenever the future value of stock is not threatened.
- **Stock can fully recover from ~half capacity if total consumption is moderate** (as in the example: all-C keeps stock at capacity). So if others are cooperating, you can often defect *without permanently killing* the resource—unless too many defectors exist.
- **Exploitative stance:** default to taking more (D) whenever opponents demonstrate they will keep the stock from collapsing, but switch to C when stock is fragile or when opponents are “hair-trigger punishers” that will spiral into mutual D.

---

## Quantities computed from history each round
Let:
- \(S_t\): stock at start of round \(t\).
- \(k_{t-1}\): number of opponents who played **D** in round \(t-1\) (so \(0 \le k \le n-1\)).
- \(p_{t-1} = k_{t-1}/(n-1)\): observed opponent defection rate last round.
- Maintain a short memory of the last \(m\) rounds (e.g., \(m=5\)) to estimate:
  - \(\bar p\): average opponent defection rate.
  - “Volatility”: do they switch sharply after you defect? (detect punishers)

Also compute a **stock safety threshold**:
- \(S_{\text{safe}} = 0.6 \times \text{capacity}\) (tunable constant; rationale: below this, continued high consumption risks a crash and reduces future exploit value).

And a simple **punisher-detection flag**:
- If you defected in \(t-1\) and opponent defection jumps by ≥ 0.4 (40% of opponents) in \(t\), label the population as *punisher-sensitive* for the next few rounds.

---

## 1) Decision rules (C vs D)

### Rule A — Last round: always defect
- **If \(t = r\): play D.**  
Endgame: no future stock value matters; take the 2× payoff now.

---

### Rule B — Stock emergency preservation (avoid killing the goose too early)
- **If \(S_t \le S_{\text{crit}}\): play C**, where \(S_{\text{crit}} = 0.25 \times \text{capacity}\).  
When stock is low, defection accelerates collapse, and collapse makes *your future exploitation impossible*. Cooperate to allow regrowth (and also to look “reasonable” so others may stop defecting).

---

### Rule C — Exploit cooperative environments
If stock is healthy and opponents are mostly cooperating, defect to harvest:
- **If \(S_t \ge S_{\text{safe}}\) and \(\bar p \le 0.25\): play D.**  
This is the main exploit mode: others are sustaining the resource; you free-ride.

---

### Rule D — Don’t be the sucker in defection-heavy environments
If opponents are already defecting a lot, defect too:
- **If \(\bar p \ge 0.5\): play D.**  
When many defect, cooperation just reduces your payoff without preventing collapse; take what you can.

---

### Rule E — “One-step punishment” to deter being farmed, but don’t get stuck punishing
Use a controlled retaliation scheme that is **short** (exploitative) rather than moralistic:
- If in the previous round opponents’ defection rate was high **and** stock is not critical, **defect for 1 round** (punish), then reassess.
- Concretely:  
  - **If \(p_{t-1} \ge 0.5\) and \(S_t > S_{\text{crit}}\): play D** (already covered by Rule D).
  - If \(p_{t-1}\) spikes unexpectedly (e.g., from ≤0.25 to ≥0.5), treat that as a “raid” and defect next round regardless of other signals (unless stock-critical).

This deters strategies that try to alternate exploitation bursts.

---

### Rule F — Avoid triggering harsh punishers (strategic “appeasement”)
If opponents look like they respond strongly to your defection (grim/trigger-ish), cooperate just enough to restore a cooperative basin, then resume exploitation:
- **If punisher-sensitive is true and \(S_t \ge S_{\text{safe}}\): play C for 2 rounds**, then go back to Rule C (exploit) if they calm down.
Rationale: you *pay* a small amount in short-term payoff to keep the stock high and opponents cooperative, then return to defecting to extract the surplus.

---

### Rule G — Default
- **Otherwise: play D if \(S_t \ge 0.4 \times \text{capacity}\), else play C.**  
This makes the strategy opportunistically exploitative while still preventing repeated premature collapses.

---

## 2) Edge cases

### First round (no history)
You want to probe while not immediately destroying long-run value:
- **Round 1: play D** (probe/exploit).  
Reason: If the population is cooperative, you immediately gain; if it’s punisher-heavy, you detect it early and can switch to appeasement (Rule F) before stock collapses too far.

### Early rounds with high capacity and high stock
- Bias toward **D** to extract while the stock is abundant and growth can recover.

### Near the end (last ~10–20% of rounds)
Let \(T = r - t\) remaining rounds.
- If \(T \le \max(2, \lceil 0.1r \rceil)\): **increase defection frequency** by relaxing safety:
  - Replace \(S_{\text{safe}}\) with \(0.4 \times \text{capacity}\).
Rationale: as the horizon shortens, preserving stock matters less; you cash out.

### Very low stock
- **If \(S_t\) is extremely low (e.g., \(< 0.1\) capacity): always C** until it recovers above \(0.25\) capacity.  
You can’t exploit an empty pool; the highest EV move is to help regrow so there’s something to take later.

---

## 3) Why this is exploitative (explicitly)
- **When others cooperate:** you primarily **defect** to take the larger share while they bear the cost of sustainability.
- **When others defect:** you **also defect** to avoid being exploited and to extract before collapse.
- **When your defection causes punishments:** you temporarily **cooperate just enough** to re-stabilize cooperation (not for fairness, but to re-open the opportunity to defect profitably later).
- **Endgame:** you **cash out** with defection.

---

## Pseudocode (implementable sketch)

```python
def PPP_action(t, r, n, capacity, S_t, history):
    # history contains past rounds: my_action, opp_defect_count, stock_start
    if t == r:
        return "D"

    S_crit = 0.25 * capacity
    S_safe = 0.60 * capacity

    # Endgame ramp: last 10% (or at least 2 rounds) become more grabby
    if (r - t) <= max(2, int(0.1 * r)):
        S_safe = 0.40 * capacity

    if t == 1:
        return "D"  # probe

    # compute opponent defection stats
    m = min(5, len(history))
    last_m = history[-m:]
    p_bar = sum(h.opp_defect_count/(n-1) for h in last_m) / m
    p_last = history[-1].opp_defect_count/(n-1)

    # punisher-sensitive detection
    punisher_sensitive = False
    if len(history) >= 2:
        p_prev = history[-2].opp_defect_count/(n-1)
        if history[-1].my_action == "D" and (p_last - p_prev) >= 0.4:
            punisher_sensitive = True

    # Stock emergency: preserve to enable future exploitation
    if S_t <= S_crit:
        return "C"

    # Appeasement phase to re-open exploitation if punishers exist
    if punisher_sensitive and S_t >= S_safe:
        # cooperate for 2 rounds after detecting punishers
        if sum(1 for h in last_m if h.my_action == "C") < 2:
            return "C"

    # Exploit cooperative environments
    if S_t >= S_safe and p_bar <= 0.25:
        return "D"

    # If environment is defection-heavy, grab too
    if p_bar >= 0.50:
        return "D"

    # Default: opportunistic
    if S_t >= 0.40 * capacity:
        return "D"
    return "C"
```

---

### Notes on robustness
- Works against **always-cooperate**: defects almost always, while stock stays high (others sustain it), maximizing your take.
- Works against **always-defect**: defects too; you don’t waste cooperation.
- Works against **tit-for-tat / grim-ish**: initial defection detects punishment; then you switch to brief cooperation to restore cooperation and resume exploitation when safe.
- Works against **mixed / noisy** opponents: uses smoothing (\(\bar p\)) plus stock thresholds to avoid overreacting and to prevent accidental pool collapse.

If you want, I can tune the numeric thresholds (0.25, 0.6, 0.4, punishment jump 0.4) analytically for specific \(n, r, capacity\) ranges or propose a more formally optimized variant (e.g., approximate dynamic programming / bandit-style policy selection).
'''

description_EXPLOITATIVE_69 = '''
## Strategy: **Cautious Stackelberg Exploiter (CSE)**  
Goal: **Harvest high payoffs when others preserve the stock; punish quickly when they deplete it; recover the resource only when it is profitable; always defect at the end.**  
Key idea: In this game, if too many defect, stock collapses to 0 and everyone’s future payoffs become 0. So the exploiter’s leverage is: **(a) be willing to cooperate enough to keep the stock productive, but (b) defect whenever the group shows it can sustain the stock anyway, and (c) punish/deny payoff when others are driving collapse.**

---

# 1) Decision rules (C vs D)

### Observable quantities each round \(t\)
- Current stock: \(S_t\)
- For each past round, count defectors: \(k_{t-1}\) = number of opponents who played D last round.
- Your own last action.

Define some derived values:

**A. “Safe” defection capacity test**  
If you defect this round and *everyone else* cooperates, total consumption is:
\[
\text{cons} = (n-1)\cdot \frac{S}{2n} + 1\cdot \frac{S}{n} = \frac{n+1}{2n}S
\]
Remaining stock:
\[
S_{\text{rem}} = S - \frac{n+1}{2n}S = \frac{n-1}{2n}S
\]
Growth is logistic, and it is strong when \(S_{\text{rem}}\) is moderate. This means **one defector is often sustainable** when others cooperate.

So we use a simple **sustainability trigger**: don’t defect if stock is already low.

**B. Stock thresholds**
Let:
- **Low-stock threshold:** \(S \le S_{\text{low}} := 0.25\cdot capacity\)  
- **Healthy-stock threshold:** \(S \ge S_{\text{high}} := 0.7\cdot capacity\)

(These are parameter-only; they work across many settings because logistic growth collapses when stock is near 0, and is robust when stock is moderate-to-high.)

---

## Core policy (high level)

### Rule 0 — Endgame extraction
- **If \(t = r\): play D**  
No future to protect, so exploit fully.

### Rule 1 — If stock is fragile, prioritize recovery (but not unconditionally)
- If \(S_t \le S_{\text{low}}\):  
  - **Play C** *unless* opponents have been heavily defecting recently (see “meltdown/punishment mode” below).  
Rationale: when stock is low, your D is often equivalent to burning what little remains.

### Rule 2 — If the group is cooperative (or preserving stock), exploit
- If \(S_t \ge S_{\text{high}}\) and the last round had **few defectors among opponents**, exploit:
  - Let \(k_{t-1}\) = number of opponents who defected last round.
  - If \(k_{t-1} \le 1\): **Play D**
Rationale: when others are mostly cooperating, you can take double payoff while stock remains high.

### Rule 3 — If defection is spreading, switch to discipline (credible punishment)
- If \(k_{t-1} \ge 2\) (meaning at least 2 opponents defected last round), enter **Punishment Mode** for a short, fixed window:
  - **Punishment Mode:** play D for the next \(P\) rounds, where \(P = 2\) by default.
Rationale: You cannot out-cooperate multiple defectors; cooperating then is just donating value. Short punishment is robust: it deters conditional cooperators, and doesn’t lock you into permanent ruin if opponents are noisy.

### Rule 4 — Rebuild when punishers stop (opportunistic recovery)
After Punishment Mode ends:
- If the last round had \(k_{t-1} = 0\) (all opponents cooperated) **and** \(S_t\) is not collapsing (e.g., \(S_t \ge 0.4\cdot capacity\)):  
  - **Play D** (resume exploitation immediately)
- Else if the last round had \(k_{t-1} = 0\) but stock is still low/moderate:  
  - **Play C** for 1 round to help recovery, then return to Rule 2.
Rationale: you “test” whether cooperation is real; you only invest in recovery when it can yield future returns.

---

# 2) Edge cases (first round, last rounds, resets, ties)

### First round (no history)
- **Round 1: play D**  
Rationale: initial stock is at capacity; defection gives immediate advantage and also “tests” whether others are willing to sustain stock despite being exploited. Many adaptive strategies respond by continuing to cooperate for a while, which you can harvest.

### Last round
- **Always D** (Rule 0).

### Second-to-last round (optional stronger exploitation)
- If \(t = r-1\) and \(S_t\) is moderate or high (e.g., \(S_t \ge 0.3\cdot capacity\)): **Play D**  
Reason: limited future, so recovery investment has low value.

### If stock hits (near) zero
- If \(S_t \approx 0\): action doesn’t matter much; default to **D** (no reason to donate cooperation when there is nothing to sustain).  
However, to allow for rare recovery dynamics, you can do:
- If \(S_t < \epsilon\) (say \(\epsilon = 0.02 \cdot capacity\)): **D**

### If opponents are inconsistent/noisy
Use short memory:
- Only last-round defector count \(k_{t-1}\)
- A short punishment window \(P=2\)
This avoids overreacting forever to one bad round.

---

# 3) Explicit exploitative mindset (what this strategy is doing)

This strategy is exploitative in three direct ways:

1. **Default exploitation:** Starts with D and prefers D whenever the resource is healthy and opponents are mostly cooperating (you take 2× payoff).
2. **Selective investment:** Cooperates only when cooperation is instrumentally necessary to keep stock from becoming unproductive; otherwise defects.
3. **Discipline without martyrdom:** When multiple opponents defect (resource is threatened), it refuses to “be the sucker” by cooperating into a losing situation; it defects for a short period to (a) deny easy gains to others expecting you to restore the stock, and (b) pressure conditional cooperators to revert to C.

---

# Pseudocode (implementable)

```pseudo
parameters:
  S_low  = 0.25 * capacity
  S_high = 0.70 * capacity
  S_rebuild = 0.40 * capacity
  P = 2                  # punishment length
  eps = 0.02 * capacity

state variables:
  punish_timer = 0

function action(t, S_t, history):
  if t == r:
    return D

  if S_t < eps:
    return D

  if t == 1:
    return D

  k = number_of_opponents_who_played_D_in_round(t-1)

  # if currently punishing
  if punish_timer > 0:
    punish_timer -= 1
    return D

  # trigger punishment
  if k >= 2:
    punish_timer = P - 1   # this round counts as first punishment round
    return D

  # low stock: rebuild unless opponents are clearly defecting
  if S_t <= S_low:
    if k == 0:
      return C
    else:
      # someone defected last round; don't donate unless needed
      return D

  # healthy stock + cooperative opponents => exploit
  if S_t >= S_high and k <= 1:
    return D

  # medium stock: mixed policy
  if k == 0:
    if S_t < S_rebuild:
      return C            # one-step rebuild
    else:
      return D            # exploit immediately
  else:
    # some defection present but not enough to punish
    return C              # stabilize resource to keep future payoffs alive
```

---

## Practical notes (why it’s robust in tournaments)
- Against **unconditional cooperators**: you defect most rounds and win big, while stock remains high due to their cooperation.
- Against **grim trigger / tit-for-tat types**: you’ll likely get punished after early Ds; your short punishment mode plus opportunistic rebuild can sometimes restore cooperation, but you still extract in late game (always D at end).
- Against **always defect**: you quickly switch to D and stop wasting cooperation (minimize regret).
- Against **mixed/noisy**: short memory + short punishment reduces getting trapped in permanent mutual defection due to noise, while still exploiting when windows open.

If you want, I can also provide a more “mathematical” version that computes a one-step-ahead stock projection (given estimated defector count) and chooses D iff the projected next stock stays above a safety floor—still parameter/history-only, but slightly more compute-heavy.
'''

description_EXPLOITATIVE_70 = '''
## Strategy: **Regrowth-Harvester (RH)**  
Goal: **extract as much as possible when the stock is high**, **avoid being the sucker when others defect**, and **preserve the stock only when it increases future extractable value**. The strategy is intentionally asymmetric: it “taxes” cooperative opponents by defecting against them when safe, and it punishes defection quickly to avoid being drained.

Key idea: because your payoff is proportional to current stock \(S\), you want the stock to stay in a **high-yield region**. But you also want to **take the larger share (D)** whenever doing so doesn’t risk collapsing the stock given observed opponent behavior.

---

## Useful derived quantities

Let in round \(t\):

- \(S\) = current stock
- \(k\) = number of opponents who defected last round (from history), \(0 \le k \le n-1\)
- Estimated defection rate among others:  
  \[
  \hat{p} = \frac{k}{n-1}
  \]
- If you choose action \(a\in\{C,D\}\), your consumption is:
  - \(c(C)=\frac{S}{2n}\)
  - \(c(D)=\frac{S}{n}\)

**Expected total consumption fraction of stock** if others defect with rate \(\hat p\):  
Each other player consumes \(S/(2n)\) if C, \(S/n\) if D. So expected consumption per opponent:
\[
E[c_{\text{opp}}] = (1-\hat p)\frac{S}{2n} + \hat p \frac{S}{n} = \frac{S}{2n}(1+\hat p)
\]
Total expected consumption:
\[
C_{\text{tot}}(a) \approx c(a) + (n-1)\frac{S}{2n}(1+\hat p)
\]
Remaining stock fraction:
\[
x(a)=\frac{S - C_{\text{tot}}(a)}{S}
\]
This simplifies nicely:

- If **you cooperate**:
  \[
  x(C) = 1 - \frac{1}{2n} - \frac{n-1}{2n}(1+\hat p)
      = \frac{1}{2} - \frac{n-1}{2n}\hat p
  \]
- If **you defect**:
  \[
  x(D) = 1 - \frac{1}{n} - \frac{n-1}{2n}(1+\hat p)
      = \frac{n-1}{2n}(1-\hat p)
  \]

Growth step uses logistic growth on remaining stock \(Sx\):
\[
S' = \min\Big(Sx + 2(Sx)\big(1-\frac{Sx}{\text{capacity}}\big),\ \text{capacity}\Big)
\]

RH uses these to decide when defection is “safe” (won’t crash the future too much).

---

## 1) Decision rules (when to C vs D)

### Rule A — **Endgame cash-out**
- **If this is the last round (\(t=r\))**: always **Defect (D)**.  
No future value to preserve.

### Rule B — **Collapse avoidance (hard safety)**
If current stock is already low, prioritize rebuilding:
- If \(S \le S_{\text{low}}\): **Cooperate (C)** regardless of history, *unless* last round most others defected (see punishment rule below).  
Set:
\[
S_{\text{low}} = 0.25 \times \text{capacity}
\]
(Reason: below ~25% capacity, you get more long-run value by trying to regrow; defection here tends to keep it suppressed.)

### Rule C — **Exploit cooperators when safe**
If stock is healthy, you “harvest” by defecting *unless that would plausibly drive stock into a bad region given observed opponent defection rate*.

Compute predicted remaining fractions \(x(C), x(D)\) using \(\hat p\) from the last round.

- If \(S > S_{\text{low}}\) and \(x(D) \ge x_{\min}\), then **Defect (D)**.
- Else **Cooperate (C)**.

Use:
\[
x_{\min} = 0.30
\]
Interpretation: only defect if you expect at least 30% of stock to remain after consumption; that remaining stock is enough for strong growth and avoids falling into a low-payoff trap.

This makes the strategy exploitative: against mostly-cooperative groups (\(\hat p\) small), \(x(D)\) is large, so you defect frequently and take double the cooperative share while keeping the system productive.

### Rule D — **Punish defection quickly (credible deterrence)**
If opponents are defecting a lot, you stop “investing” in stock for them.

- If \(\hat p \ge p_{\text{punish}}\): **Defect (D)** (even if \(x(D)<x_{\min}\)), until defection rate drops.

Use:
\[
p_{\text{punish}} = 0.5
\]
So if at least half of opponents defected last round, you switch to defection mode (you refuse to be the one maintaining the resource).

### Rule E — **Forgiveness / re-entry**
After any round where you defected due to punishment (Rule D), you allow re-entry to the safe-harvest logic once others improve:

- If \(\hat p \le p_{\text{forgive}}\) for **two consecutive rounds**, return to Rule C logic (exploit-if-safe).
\[
p_{\text{forgive}} = 0.25
\]

This prevents permanent mutual defection against strategies that occasionally “test” defection.

---

## 2) Edge cases

### First round
You don’t have history, so assume opponents are moderately cooperative but include safety:

- **Round 1**: **Defect (D)** *if* capacity is large relative to \(n\) (it is, by assumption capacity ≥ 2n) and stock starts at capacity, which is high.  
Specifically: if initial \(S=\text{capacity}\), play **D**.  
Rationale: you immediately exploit unconditional cooperators; if many also defect, the punishment logic will keep you from being the sucker later.

### Last two rounds
- **Round r**: always **D** (Rule A).
- **Round r−1**: usually **D**, unless stock is very low and you believe one last growth bump would raise \(S\) enough to make round \(r\) more profitable. But since round \(r\) is last and simultaneous, you can’t reliably “invest” unless others also do. So:
  - If \(S \le S_{\text{low}}\) *and* \(\hat p \le 0.25\): play **C** in \(r-1\) (try to spike stock for your final-round D).
  - Otherwise **D**.

### Stock near zero
If \(S\) is near 0, payoffs are tiny anyway; the main danger is wasting time “cooperating” while others defect.

- If \(S < 0.05 \times \text{capacity}\):
  - If \(\hat p \ge 0.25\): **D** (no point investing alone).
  - Else **C** (attempt regrowth if group seems cooperative).

---

## 3) Why this is exploitative (and robust)

### Exploitative behavior
- Against cooperative or reciprocity-based opponents, RH defects whenever it predicts regrowth remains strong (Rule C). That yields **double per-round payoff** compared to cooperation at the same stock.
- It only “invests” (cooperates) when defection would likely push the system into a low-yield region, i.e., cooperation is used as a **resource-maintenance tool**, not as fairness.

### Robustness
- Against always-defect / high-defection populations: Rule D switches you to defection quickly, preventing you from subsidizing them.
- Against mixed or noisy opponents: the forgiveness window prevents lock-in to mutual defection.
- Against strategies that alternate or probe: the use of observed \(\hat p\) and safety threshold \(x_{\min}\) adapts automatically without needing to identify the opponent type.

---

## Pseudocode

```python
# Parameters / constants
S_low = 0.25 * capacity
x_min = 0.30
p_punish = 0.50
p_forgive = 0.25

# State you track
punish_mode = False
forgive_streak = 0   # consecutive rounds with p_hat <= p_forgive

def action(t, S, history):
    global punish_mode, forgive_streak

    # last round: cash out
    if t == r:
        return "D"

    # estimate others' defection rate from last round
    if t == 1:
        p_hat = 0.0   # unknown; treat as cooperative for the harvest check
    else:
        k = count_opponents_defected_last_round(history)
        p_hat = k / (n - 1)

    # update punishment / forgiveness regime
    if t > 1 and p_hat >= p_punish:
        punish_mode = True
        forgive_streak = 0
    elif punish_mode:
        if p_hat <= p_forgive:
            forgive_streak += 1
            if forgive_streak >= 2:
                punish_mode = False
        else:
            forgive_streak = 0

    # penultimate-round tweak: only cooperate if it likely boosts final round
    if t == r - 1:
        if S <= S_low and p_hat <= 0.25 and not punish_mode:
            return "C"
        return "D"

    # if punishing, defect
    if punish_mode:
        return "D"

    # very low stock special-case
    if S < 0.05 * capacity:
        return "C" if p_hat < 0.25 else "D"

    # low stock: try to rebuild unless others are defecty
    if S <= S_low:
        return "C" if p_hat < p_punish else "D"

    # safe-harvest logic: defect if expected remaining fraction is high enough
    # x(D) = (n-1)/(2n) * (1 - p_hat)
    xD = (n - 1) / (2 * n) * (1 - p_hat)
    if xD >= x_min:
        return "D"
    else:
        return "C"
```

---

If you want to push the exploitiveness further, you can lower `x_min` (defect more often) and raise `p_punish` (tolerate more opponent defection before switching), but the above settings are a balanced “tournament-robust exploiter”: it farms cooperators hard while not being the one keeping the commons alive for defectors.
'''

description_EXPLOITATIVE_71 = '''
### Strategy: **Ruthless Regenerator (RR)**  
Goal: **extract as much as possible while keeping the stock in the “fast regeneration zone”**, and **punish** populations that try to free-ride on your restraint. The key exploitation idea is: in this game, *stock is a multiplier on all future payoffs*, so you want the group to keep stock high—but you want **others** to do the conserving while **you** take the larger share whenever it’s safe.

A useful fact from the dynamics:

- Let \(S\) be current stock.
- If total fraction consumed this round is \(\alpha\) (i.e., total consumption \(= \alpha S\)), then remaining is \(S(1-\alpha)\).
- Next stock is \(S' = S(1-\alpha)\left[3 - 2(1-\alpha)\frac{S}{capacity}\right]\) capped at capacity.

When \(S \approx capacity\), growth is maximized when remaining is around \(capacity/2\). In the provided example, **all-C** keeps \(S\) at capacity forever. Too much D collapses it.

So RR tries to:
1) **Defect whenever the “environment” (opponents + stock) can absorb it**,  
2) **Cooperate just enough** to keep stock from collapsing,  
3) **Switch to relentless defection at the end**.

---

## 1) Decision rules (C vs D)

Maintain these running stats from history:
- \(k_{t-1}\): number of opponents who played **D** last round (so among \(n-1\) opponents).
- \(d\_rate\): exponentially weighted defection rate of opponents (for robustness):  
  \(d\_rate \leftarrow 0.7\cdot d\_rate + 0.3\cdot \frac{k_{t-1}}{n-1}\)

Define thresholds based on current stock \(S_t\):
- **High stock:** \(S_t \ge 0.85\cdot capacity\)
- **Mid stock:** \(0.55\cdot capacity \le S_t < 0.85\cdot capacity\)
- **Low stock:** \(S_t < 0.55\cdot capacity\)

### Core rule set

**A. Endgame rule (exploit hard):**
- If \(t = r\): play **D** (always).
- If \(t = r-1\): play **D** unless \(S_t\) is extremely low (see “crash-avoid” below).  
  Rationale: future doesn’t matter; take the larger slice.

**B. Crash-avoid rule (do not kill the goose too early):**
- If \(S_t \le 0.20\cdot capacity\): play **C** (you need regrowth; defecting here often drives stock to/near 0 and destroys future value).
- If \(S_t \le 0.35\cdot capacity\) *and* opponents are not mostly cooperating ( \(d\_rate \ge 0.4\) ): play **D** (cut losses; others are likely draining it anyway).
  - This is exploitative: when the group is already irresponsible, you stop subsidizing them.

**C. Exploit cooperative environments:**
- If **High stock** and opponents look cooperative ( \(d\_rate \le 0.25\) ):
  - play **D**.  
  Rationale: you can safely free-ride; the stock buffer is high and others are conserving.
- If **Mid stock** and \(d\_rate \le 0.25\):
  - play **C** *every other round* (a “maintenance” pattern), otherwise **D**.  
  Rationale: remain just cooperative enough to keep the system near the regenerative regime, while still extracting extra in half the rounds.

**D. Punish defectors quickly (but not suicidally):**
- If last round had “many defectors”: \(k_{t-1} \ge \lceil (n-1)/2 \rceil\):
  - play **D** (unless in crash-avoid \(S_t \le 0.20\,cap\), then C).
  Rationale: don’t be the sucker funding others’ high take.

**E. Tie-break default (when uncertain):**
- If \(S_t\) is High: **D**
- If \(S_t\) is Mid: **C**
- If \(S_t\) is Low: **C** only if opponents mostly cooperated last round (\(k_{t-1}=0\)), else **D**

This makes the strategy robust: it stabilizes stock when the group is stabilizable, but refuses to carry defect-heavy populations.

---

## 2) Edge cases / special rounds

### Round 1
You have no history. Start exploitatively but safely:
- If \(r \ge 3\): play **D** in round 1.  
  Reason: early stock is at capacity; testing opponents’ willingness to cooperate is valuable and you gain immediately.
- If \(r = 2\): play **D** in round 1 as well (because endgame is immediate; cooperation rarely pays).

Initialize:
- \(d\_rate = 0\) (optimistic prior) or \(0.2\) (slightly cautious). I recommend **0.2** to avoid over-trusting in noisy first signals.

### Last round (t = r)
Always **D**.

### Near-last round (t = r-1)
Default **D**. Only exception:
- If \(S_t \le 0.20\cdot capacity\) and you believe opponents are mostly cooperating (e.g., \(d\_rate \le 0.25\)), then **C** at \(t=r-1\) can raise \(S_{r}\) enough that your final-round D is larger.  
Otherwise, still D.

### Extremely low stock
If stock is near zero, payoffs are tiny, and growth needs remaining stock:
- If \(S_t = 0\): action doesn’t matter for payoff (both give 0). Play **D** (consistent, and doesn’t “gift” intent).
- If \(0 < S_t \le 0.20\,cap\): play **C** unless opponents are clearly predatory (high \(d\_rate\)), in which case switch to D and accept collapse (stop subsidizing).

---

## 3) Why this is exploitative (explicit mindset)

RR is not “nice”; it is **selectively cooperative only as an investment**:
- It **defects by default** when stock is high because that’s when defection yields the most and is least likely to trigger immediate collapse.
- It **uses cooperation as a tool** to keep stock from entering the low-growth / collapse region, but only when there is evidence the group will also maintain.
- It **does not reward** defect-heavy populations: it defects back quickly so it won’t be the lone conserver financing others.
- It **endgame defects** unconditionally, capturing maximum terminal extraction.

In tournaments, this tends to:
- Strongly exploit always-cooperators and “forgiving” sustainers (you D frequently while they keep stock healthy).
- Avoid being milked by defectors (you stop cooperating quickly).
- Still earn decent payoffs in mixed fields by keeping the stock viable when possible, but never at the cost of being the primary contributor.

---

## Pseudocode (implementable)

```pseudo
state: d_rate = 0.2
for t in 1..r:
    observe S_t

    if t == r:
        action = D
        play(action)
        continue

    if t > 1:
        k = number_of_opponents_who_defected_last_round()
        d_rate = 0.7*d_rate + 0.3*(k/(n-1))
    else:
        k = 0  # unknown; handled via round-1 rule

    # crash-avoid
    if S_t <= 0.20*capacity:
        if d_rate < 0.4:
            action = C
        else:
            action = D
        play(action)
        continue

    # endgame pressure
    if t == r-1:
        # only cooperate if it likely boosts final-round stock meaningfully
        if S_t <= 0.20*capacity and d_rate <= 0.25:
            action = C
        else:
            action = D
        play(action)
        continue

    high = (S_t >= 0.85*capacity)
    mid  = (S_t >= 0.55*capacity and S_t < 0.85*capacity)
    low  = (S_t < 0.55*capacity)

    many_defectors = (t > 1) and (k >= ceil((n-1)/2))

    if many_defectors:
        action = D
    else if high and d_rate <= 0.25:
        action = D
    else if mid and d_rate <= 0.25:
        # maintenance: alternate C and D (use t parity)
        action = (t % 2 == 0) ? C : D
    else:
        # uncertain / harsher environment
        if high:
            action = D
        else if mid:
            action = C
        else: # low
            action = (t > 1 and k == 0) ? C : D

    play(action)
```

If you want, I can also provide a more “mathematical” variant that explicitly simulates one-step stock transitions under both actions using an inferred opponent defection probability, and chooses the action that maximizes (current payoff + estimated continuation value).
'''

description_EXPLOITATIVE_72 = '''
### Strategy: **Adaptive Harvester (AH)**  
Goal: **extract high short-run payoffs by defecting whenever it is safe**, but **switch to cooperation just enough to keep the stock productive**. Punish over-harvesting hard and fast; forgive when it becomes profitable again. This exploits cooperators, farms conditional cooperators, and avoids self-destruction against defect-heavy fields.

---

## Key idea (what you’re optimizing)
- Your per-round payoff is proportional to current stock \(S\). So you want **high \(S\)** to persist.
- But given \(S\), **D always pays exactly 2× C** that round.
- Therefore the exploitative posture is:  
  **keep stock from collapsing (using C when necessary), otherwise play D to skim surplus.**

The stock dynamics imply a natural “safe yield” zone: if total consumption leaves remaining stock near **capacity/2**, logistic growth is maximal and refills quickly. So we:
- **Defect when the stock is healthy and opponents aren’t draining too hard**.
- **Cooperate (or trigger punishment) when continued defection risks driving stock below a safety floor**.

---

## What you track from history/state
At round \(t\) you observe:
- Current stock \(S_t\)
- Last round’s number of defectors \(k_{t-1}\) (count of players who played D)
- Optionally a smoothed estimate \(\hat{k}\) of typical defection level (EWMA)

You can compute expected remaining stock after consumption if in this round total defectors = \(k\):
\[
S_{\text{rem}}(S, k) = S\left(1 - \frac{n+k}{2n}\right) = S \cdot \frac{n-k}{2n}
\]
since total consumption share is \(\frac{n+k}{2n}\) of \(S\).

---

## Decision rules (C vs D)

### Parameters (derived from game parameters)
Let:
- **Safety floor**: \(F = 0.55 \cdot \text{capacity}\)  
  (we try to keep post-consumption remaining stock at/above ~55% of capacity to maintain strong regeneration)
- **Danger floor**: \(Dg = 0.25 \cdot \text{capacity}\)  
  (below this, stock is fragile; prioritize recovery/punishment)
- **Forgiveness trigger**: \(Fr = 0.75 \cdot \text{capacity}\)  
  (once stock is high again, revert to exploitation)

Also keep a **punishment counter** `punish` (integer ≥ 0).

---

### Round 1 (no history)
**Play D in round 1.**  
Rationale: with initial stock = capacity, you get maximum immediate surplus and gather information about the field.

---

### Main rule each round \(t\) (2 ≤ t ≤ r-1)

#### Step 1: Update opponent defection estimate
Let \(k_{t-1}\) be last round defectors. Maintain EWMA:
\[
\hat{k}_t = 0.7\hat{k}_{t-1} + 0.3k_{t-1}
\]
Initialize \(\hat{k}_2 = k_1\).

Use **predicted defectors**:
\[
k^{pred} = \text{round}(\hat{k}_t)
\]

#### Step 2: If in punishment mode, continue unless conditions improve
If `punish > 0`:
- If \(S_t \ge Fr\) **and** \(k_{t-1} \le 1\): exit punishment early (`punish=0`) and play **D**.
- Else: decrement `punish` and play **D**.
  
Punishment is **defection** because it both:
- maximizes your extraction while others “try to fix it”, and
- speeds collapse against persistent defectors (so you stop wasting cooperation).

#### Step 3: Compute whether your defection is “safe”
Compute expected remaining stock if you defect vs cooperate, assuming opponents defect at rate \(k^{pred}\).

If you play **D**, expected defectors this round: \(k^{pred}+1\).  
If you play **C**, expected defectors this round: \(k^{pred}\).

Compute:
- \(S^{D}_{rem} = S_t \cdot \frac{n-(k^{pred}+1)}{2n}\)
- \(S^{C}_{rem} = S_t \cdot \frac{n-k^{pred}}{2n}\)

Now decide:

**Rule A (exploit whenever safe):**  
If \(S^{D}_{rem} \ge F\), play **D**.

**Rule B (stabilize only when needed):**  
Else if \(S^{C}_{rem} \ge F\), play **C**.

**Rule C (trigger punishment when the group is over-harvesting):**  
Else (even cooperation won’t keep stock in the safe zone):
- Set `punish = 2` (two rounds of hard defection as a credible “I won’t help” signal)
- Play **D**

This makes you:
- **mostly defect** in cooperative/mixed fields (extracting surplus),
- **occasionally cooperate** just enough to keep the resource productive,
- **refuse to “carry”** a defect-heavy population.

---

## Edge cases

### Last round \(t = r\)
**Always play D.**  
No future stock value remains; take the maximum.

### Second-to-last round \(t = r-1\)
Default: **play D** unless stock is extremely low and you want a one-step recovery for round r (rare but can matter).  
Implement:
- If \(S_{r-1} < Dg\) and \(k_{r-2} \le 1\), play **C** (try to lift stock for the final-round harvest).
- Otherwise play **D**.

### Very low stock \(S_t \approx 0\)
When \(S_t\) is tiny, C vs D yields tiny payoffs anyway. You still follow the rules above; typically you’ll be in Rule C/punishment (D). This avoids being the sucker who “rebuilds” while others harvest you later.

### Extremely cooperative field (almost all C)
You will mostly play **D** because it’s safe: with low \(k^{pred}\), \(S^{D}_{rem}\) stays high and growth refills. You consistently earn ~2× the cooperators while keeping stock near capacity.

### Highly defective field (many D)
You quickly enter punishment (D). The stock collapses; you stop donating cooperation that won’t be reciprocated. Everyone’s payoffs drop, but you avoid being exploited.

---

## Why this is exploitative (explicitly)
- **Default is D**, including round 1 and round r.
- You **only cooperate as a resource-maintenance investment**, not as reciprocity.
- If opponents cooperate, you **skim the regenerative surplus** (D) while they pay the “maintenance cost” (C).
- If opponents defect too much, you **refuse to stabilize** the commons and instead defect to maximize immediate extraction and punish the population.

---

## Pseudocode (implementable)

```python
# constants
F  = 0.55 * capacity
Dg = 0.25 * capacity
Fr = 0.75 * capacity

punish = 0
k_hat = None

def choose_action(t, S, history_actions):  # history_actions[t-1] list of actions of all players last round
    global punish, k_hat

    if t == 1:
        return "D"

    k_last = count_defectors(history_actions[t-1])  # among all n players

    if k_hat is None:
        k_hat = k_last
    else:
        k_hat = 0.7 * k_hat + 0.3 * k_last

    k_pred = int(round(k_hat))

    if t == r:
        return "D"

    if t == r-1:
        if S < Dg and k_last <= 1:
            return "C"
        return "D"

    # punishment mode
    if punish > 0:
        if S >= Fr and k_last <= 1:
            punish = 0
            return "D"
        punish -= 1
        return "D"

    # safety calculations
    Srem_D = S * (n - (k_pred + 1)) / (2*n)
    Srem_C = S * (n - k_pred) / (2*n)

    if Srem_D >= F:
        return "D"
    elif Srem_C >= F:
        return "C"
    else:
        punish = 2
        return "D"
```

---

If you want, I can also provide a more “predatory” variant that **targets individual conditional cooperators** (by tracking player-specific tendencies and exploiting the most cooperative subset), but the above is already robust without assuming any particular opponent types.
'''

description_EXPLOITATIVE_73 = '''
## Strategy: **Pulse-Exploit with Stock Guardrails (PESG)**

Mindset: treat cooperation as an *investment* only when it keeps the stock in a highly productive region. Otherwise, defect to harvest. You actively **probe** opponents, **exploit** cooperative types, and **punish** depletion attempts—while never sacrificing endgame payoff.

Key idea: with logistic growth, stock is most “renewable” around ~capacity/2. Full stock is fine too, but if players overtake, stock can crash. Your move should depend on (a) expected next stock given others’ behavior and (b) whether opponents appear willing to sustain the resource.

---

# 1) Decision Rules (Cooperate vs Defect)

### Observables each round \(t\)
- Current stock \(S_t\)
- History of actions: number of defectors last round \(d_{t-1}\)
- (Optional but implementable) an exponentially-weighted defect rate:
  \[
  \hat{d}_t = \alpha d_{t-1} + (1-\alpha)\hat{d}_{t-1}
  \]
  with \(\alpha \in [0.3, 0.6]\) (e.g., 0.5).

### Useful constants
- Your consumption:
  - If **C**: \(c_C(S)=S/(2n)\)
  - If **D**: \(c_D(S)=S/n\)
- Others’ typical consumption last round: assume they repeat last-round action mix (robust, no coordination assumed).

### Predict stock next round under “repeat-last-mix”
Let last round have \(d\) defectors among the other \(n-1\) players.

If you play **C** now, predicted total consumption:
\[
T_C = d\cdot \frac{S}{n} + (n-1-d)\cdot \frac{S}{2n} + \frac{S}{2n}
\]
If you play **D** now:
\[
T_D = d\cdot \frac{S}{n} + (n-1-d)\cdot \frac{S}{2n} + \frac{S}{n}
\]
Remaining stock:
\[
R_X = S - T_X \quad (X\in\{C,D\})
\]
Growth:
\[
G(R)=2R\left(1-\frac{R}{capacity}\right)
\]
Predicted next stock:
\[
S'_{X}= \min(R_X + G(R_X), capacity)
\]

### Exploit/Guardrail policy
Use 3 regimes based on stock health and opponent depletion tendency.

**Regime A — “Exploit cooperative field” (Defect when safe):**  
If stock is healthy *and* opponents are mostly cooperating, defect to harvest extra while the system stays productive.
- Condition:
  - \(S_t \ge 0.6\cdot capacity\) **and**
  - \(\hat{d}_t \le 0.25n\) (few defectors on average) **and**
  - predicted next stock under defect remains healthy: \(S'_D \ge 0.5\cdot capacity\)
- Action: **D**

**Regime B — “Stock investment” (Cooperate to keep the engine running):**  
If stock is at risk of sliding below the productive region *or* opponents are somewhat defect-prone but not fully destructive, cooperate to stabilize (so you can defect later).
- Condition:
  - \(S_t \in [0.3, 0.6]\cdot capacity\) **or**
  - \(0.25n < \hat{d}_t < 0.6n\) **or**
  - \(S'_D < 0.45\cdot capacity\) but \(S'_C \ge S'_D\) meaning cooperation materially improves the future stock
- Action: **C**

**Regime C — “No future / punish collapse” (Defect):**  
If the group is depleting hard, your cooperation is a wasted donation. Harvest what’s left.
- Condition:
  - \(\hat{d}_t \ge 0.6n\) (most players defect often) **or**
  - \(S_t \le 0.3\cdot capacity\) and last round had heavy defection \(d_{t-1} \ge \lceil n/2 \rceil\)
- Action: **D**

This makes you:
- **Nice only when it pays** (to preserve future harvest),
- **Exploitative when stable** (defect in good conditions),
- **Unforgiving when others are destructive** (don’t subsidize collapse).

---

# 2) Edge Cases & Round Handling

### Round 1 (no history)
You need an initial probe that is exploitative but not suicidal.
- If \(r\) is small (endgame soon): **D**
- Else:
  - If \(capacity \ge 4n\) (big buffer): **D** (safe to test exploitation early)
  - Otherwise: **C** (buy information while protecting stock)

Practical default: **D in round 1** unless capacity is tight relative to n and r is large.

### Last round (round \(r\))
Always **D**. No future stock value; cooperation is strictly dominated (you get half the payoff).

### Second-to-last round (round \(r-1\))
Usually **D**, except a rare guardrail:
- If \(S_{r-1}\) is extremely low and you expect cooperation by others to restore stock for a bigger final-round harvest, you *might* cooperate. But because the final round is only one step away and opponents may defect, it’s typically not worth it.
Rule: **D in round \(r-1\)** unless all of:
- \(S_{r-1} < 0.35\cdot capacity\),
- \(d_{r-2}=0\) (everyone cooperated),
- and predicted \(S'_C - S'_D\) is large (e.g., \(\ge 0.25\cdot capacity\)).
Otherwise **D**.

### “Collapse” handling (stock near zero)
When \(S_t\) is tiny, both C and D pay tiny amounts. But cooperation can sometimes regrow stock if total take is low.
- If last round had low defection and you can realistically regrow: **C**
- If others are defecting at all: **D** (don’t be the sucker funding regrowth for others to steal)

Concrete rule:
- If \(S_t \le 0.15\cdot capacity\):
  - play **C** only if \(d_{t-1} = 0\) (full cooperation observed)
  - else **D**

---

# 3) Why This Is Exploitative (and Robust)

### Exploitative against cooperative / reciprocity strategies
- When others keep stock high, you defect frequently (Regime A) and earn double per-round payoff relative to cooperators.
- If they punish occasionally but return to cooperation, you toggle into Regime B just enough to prevent permanent collapse—then resume exploiting.

### Robust against defect-heavy populations
- You stop “investing” when it’s futile (Regime C), so you don’t bleed payoff trying to rescue the commons alone.
- You still take the larger immediate share whenever there’s no credible path to sustained stock.

### Robust against mixed / adaptive opponents
- The policy is state-and-history based, not pattern based.
- It reacts to observed defection rates and to whether your cooperation actually changes predicted next stock.

---

# Pseudocode (implementation-ready)

```python
def action(t, r, n, capacity, S, d_last, d_hat):
    # d_last: number of defectors last round among all players (or among others; be consistent)
    # d_hat: EWMA estimate of defectors (same basis as d_last)

    # Endgame
    if t == r: 
        return "D"

    # Round 1 probe
    if t == 1:
        if r <= 3:
            return "D"
        if capacity >= 4*n:
            return "D"
        return "C"

    # Second-to-last
    if t == r-1:
        # Rare exception: only invest if perfect cooperation seen and big payoff swing
        if S < 0.35*capacity and d_last == 0:
            # if you implement prediction, check if S'_C - S'_D >= 0.25*capacity
            return "C"
        return "D"

    # Collapse rule
    if S <= 0.15*capacity:
        if d_last == 0:
            return "C"
        return "D"

    # Regime C: futility / harsh environment
    if d_hat >= 0.6*n or (S <= 0.30*capacity and d_last >= (n//2 + 1)):
        return "D"

    # Regime A/B require a simple prediction check if you implement it:
    # If not implementing prediction, approximate with thresholds below.

    # Exploit in healthy, cooperative environments
    if S >= 0.60*capacity and d_hat <= 0.25*n:
        return "D"

    # Otherwise invest to stabilize
    return "C"
```

If you do implement the stock prediction \(S'_C, S'_D\), then replace the middle thresholds with:
- defect when \(S'_D \ge 0.5\cdot capacity\) and opponents look cooperative,
- cooperate when defecting would push \(S'\) below ~0.45 capacity.

---

If you tell me typical tournament settings (common \(n, r, capacity\) ranges), I can tune the numeric thresholds (\(0.6, 0.5, 0.3\), etc.) to maximize exploitability without triggering collapse too often.
'''

description_EXPLOITATIVE_74 = '''
## Strategy: **Regrowth-Leech with Credible Burn Threat (RL-CBT)**

Goal: extract high payoffs by defecting whenever the stock can recover (or others are already sustaining it), while using a *short, sharp punishment* to make “keeping the stock alive” in opponents’ interest. You cooperate only when cooperation is necessary to (a) prevent collapse or (b) re-enable profitable future defection.

This strategy depends only on parameters \((n,r,\text{capacity})\), current stock \(S\), and observed history (who played C/D).

---

# Key quantities you compute each round

Let current stock be \(S\). Let \(k\) be the number of *other* players (excluding you) who cooperated last round (observed).

### 1) Stock transition if you play C vs D (given others repeat last round)
Others’ total consumption if \(k\) of the \(n-1\) others play C and \(n-1-k\) play D:

\[
\text{cons}_\text{others} = k\cdot \frac{S}{2n} + (n-1-k)\cdot \frac{S}{n}
\]

If you play **C**: total consumption adds \(S/(2n)\).  
If you play **D**: adds \(S/n\).

So remaining stock after consumption:

- If you play **C**:
\[
S_\text{rem}^C = S - \left(\text{cons}_\text{others} + \frac{S}{2n}\right)
\]
- If you play **D**:
\[
S_\text{rem}^D = S - \left(\text{cons}_\text{others} + \frac{S}{n}\right)
\]

Then apply growth:
\[
g(x) = 2x\left(1-\frac{x}{\text{capacity}}\right),\quad
S' = \min(x + g(x),\, \text{capacity})
\]

Compute predicted next stocks \(S'^C, S'^D\).

### 2) “Safe defect” test
Defection is “safe” if it doesn’t push the system into a low-recovery regime.

Use a conservative safety threshold:
- **Hard safety**: require \(S_\text{rem}^D \ge 0.25 \cdot \text{capacity}\)
- **Or recovery safety**: require \(S'^D \ge S\) (stock non-decreasing after your defection, given others repeat)

If either is true, defect is likely sustainable and you should usually take it.

---

# Decision rules (core policy)

You are always in one of three modes:

1. **Leech mode (default)**: exploit whenever safe.
2. **Stabilize mode**: cooperate to rebuild stock so future defection is profitable.
3. **Burn mode (punishment)**: defect for a short fixed window to deter opponents from exploiting you too hard.

You switch modes based on observed cooperation rate and stock trend.

---

## Rule 0: Round indexing and initial belief
- **Round 1**: play **D** (grab high payoff immediately, probe opponents).
  - Rationale: no reputation yet, and many strategies start cooperatively; you harvest that.

---

## Rule 1: Last-round override (endgame grab)
- If **current round = r** (final round): play **D** always.
  - No future to protect; full exploitation.

- If **current round = r-1**:
  - Play **D** unless stock is already near-collapse \(S < 0.15\cdot\text{capacity}\) *and* you believe one extra cooperation round would keep stock positive for the final-round D.
  - Practically: cooperate only if your predicted \(S'^C\) is at least \(0.25\cdot\text{capacity}\) while \(S'^D\) is below \(0.1\cdot\text{capacity}\).

---

## Rule 2: Safe-leech rule (main exploit)
In any non-terminal round, if either safety condition holds:

- \(S_\text{rem}^D \ge 0.25\cdot\text{capacity}\) **OR**
- \(S'^D \ge S\)

then play **D**.

This is the primary exploit: defect whenever stock is resilient or others are doing the work.

---

## Rule 3: Stabilize when collapse risk is real
If safe-leech fails (defection likely causes serious depletion), cooperate **only if** cooperation actually improves long-run extraction:

Play **C** if:
- \(S'^C > S'^D + \epsilon\) (your cooperation materially improves next stock), where \(\epsilon = 0.02\cdot\text{capacity}\), **and**
- You are not currently in Burn mode (below), **and**
- Not in last round (already handled).

Otherwise play **D** anyway (accept collapse when opponents are not maintaining the resource).

This makes you *conditionally constructive*: you invest only when it buys you future profitable defection.

---

## Rule 4: Identify when you’re being “over-exploited”
Track a rolling window of the last \(W=3\) rounds:

- Let \(c_t\) be number of cooperators among **others** in round \(t\).
- Compute average cooperation rate among others:
\[
\bar{c} = \frac{1}{W}\sum_{t-W+1}^{t} c_t
\]

Trigger “over-exploited” if:
- You played **C** in at least 2 of last 3 rounds, **and**
- \(\bar{c} < \frac{n-1}{2}\) (less than half of others cooperated on average), **and**
- Stock is not recovering: \(S_t < S_{t-1}\) in at least 2 of last 3 transitions.

Interpretation: you’re propping up the pool while others free-ride, and the system is still trending down.

---

## Rule 5: Burn mode (credible punishment)
If over-exploited triggers, enter **Burn mode** for \(P=2\) rounds:

- In Burn mode: always play **D** (even if unsafe), *unless* stock has fallen extremely low \(S < 0.05\cdot\text{capacity}\), in which case play **C** once (to avoid total zeroing) and resume Burn mode next round.

Why this works: it makes opponents’ exploitation of you costly by accelerating depletion. Many adaptive opponents respond by increasing cooperation to avoid collapse; then you return to leeching.

Exit Burn mode after \(P\) rounds automatically, then return to normal rules.

---

## Rule 6: Opportunistic “reset” cooperation to restore a fat stock
If stock is low but recoverable and opponents are at least somewhat cooperative, you briefly cooperate to rebuild and then defect again.

Condition to “reset”:
- \(S < 0.35\cdot\text{capacity}\), and
- last round \(k \ge \lceil (n-1)/2 \rceil\) (at least half of others cooperated), and
- predicted \(S'^C \ge 0.5\cdot\text{capacity}\)

Then play **C** (one-round investment), and next round revert to Rule 2 (which will typically defect into the restored stock).

This extracts value from cooperative groups without becoming a permanent cooperator.

---

# Pseudocode (implementable)

```pseudo
params: n, r, capacity
state: burn_timer = 0
history: store last 3 rounds of (your_action, others_coop_count, stock)

function predict_next_stock(S, k, my_action):
    cons_others = k*(S/(2n)) + (n-1-k)*(S/n)
    cons_me = (my_action == C) ? S/(2n) : S/n
    Srem = max(0, S - (cons_others + cons_me))
    growth = 2*Srem*(1 - Srem/capacity)
    return min(Srem + growth, capacity), Srem

for round t = 1..r:
    observe current stock S
    if t == 1: play D; continue
    if t == r: play D; continue

    k = number of other players who played C in round t-1

    if burn_timer > 0:
        burn_timer -= 1
        if S < 0.05*capacity: play C else play D
        continue

    # endgame near-last
    if t == r-1:
        (S_C, _) = predict_next_stock(S, k, C)
        (S_D, _) = predict_next_stock(S, k, D)
        if S < 0.15*capacity and S_C >= 0.25*capacity and S_D < 0.10*capacity:
            play C
        else:
            play D
        continue

    (SnextC, SremC) = predict_next_stock(S, k, C)
    (SnextD, SremD) = predict_next_stock(S, k, D)

    safe_defect = (SremD >= 0.25*capacity) or (SnextD >= S)

    # check over-exploited trigger using last 3 rounds
    if enough_history(3):
        coop_by_others_avg = avg(last3.others_coop_count)
        you_cooperated_2of3 = count(last3.your_action == C) >= 2
        stock_down_2of3 = count(last3.stock_change < 0) >= 2
        if you_cooperated_2of3 and coop_by_others_avg < (n-1)/2 and stock_down_2of3:
            burn_timer = 2
            play D
            continue

    # opportunistic reset
    if S < 0.35*capacity and k >= ceil((n-1)/2) and SnextC >= 0.5*capacity:
        play C
        continue

    if safe_defect:
        play D
    else:
        if SnextC > SnextD + 0.02*capacity:
            play C
        else:
            play D
```

---

# Why this is exploitative and robust

- **Exploitative by default**: defects whenever the pool can take it or others are sustaining it.
- **Adaptive**: uses observed cooperation counts and stock response to decide whether to invest or extract.
- **Punishes free-riding**: Burn mode makes it dangerous for opponents to rely on you to stabilize the pool.
- **Doesn’t over-invest**: stabilizes only when it predicts a meaningful stock improvement (future extraction value).
- **Handles diverse opponents**:
  - Against unconditional cooperators: mostly defect, occasionally reset-cooperate to keep stock high.
  - Against conditional cooperators: your burn threat and occasional resets can elicit cooperation, then you leech.
  - Against defectors: you mostly defect; if collapse is inevitable, you don’t waste cooperation.
  - Against mixed/random: safety test prevents you from needlessly collapsing a still-profitable stock too early.

If you want, I can also provide a variant tuned for maximizing *relative* payoff (beating others) vs maximizing *absolute* payoff (keeping stock alive longer).
'''

description_EXPLOITATIVE_75 = '''
## Exploitative strategy: **Stock-Harvester with Punitive Trigger (SHPT)**

Mindset: treat the stock as a renewable asset to *grow* when growth is high, then *harvest* aggressively when (i) others are cooperating enough to sustain it, or (ii) the horizon is short enough that future stock value doesn’t matter. Default posture is to **defect whenever it is safe or profitable**, and **cooperate only as an investment** to keep the resource productive and/or to discipline opponents.

The strategy uses only: parameters `(n, r, capacity)`, current `stock S`, and full history of actions.

---

# 1) Decision rules: when to Cooperate vs Defect

### Key quantities computed each round \(t\)
- Let `S` be current stock at start of round `t`.
- Let `k_{t-1}` = number of opponents who defected last round (if `t=1`, undefined).
- Define last-round opponent defection rate:
  - `p = k_{t-1} / (n-1)` for `t>1`.
- **Harvest safety threshold** (how much opponent cooperation we need to keep stock from collapsing if we defect):
  - If we defect and we expect roughly `k` defectors total, remaining stock after consumption is:
    \[
    S_{\text{rem}} = S\left(1 - \frac{n + k}{2n}\right)
    \]
    (because total consumption fraction is \((n+k)/(2n)\); derivation: each C takes \(S/(2n)\), each D takes \(S/n = 2S/(2n)\)).
  - For the stock to not instantly hit ~0, we want \(S_{\text{rem}}\) not too small; operationally we require:
    - `expected_total_defectors ≤ n-1` roughly, but more importantly keep `S_rem` above a floor.
- Practical floor: `S_floor = capacity/4` (high growth region for logistic growth; below this growth is still positive but you’re risking spirals if many defect).
- Predict next total defectors:
  - `k_pred = k_{t-1}` (naive prediction: repeat).
  - If `t=1`, set `k_pred = 0` (assume cooperation until proven otherwise).
- If **we defect** this round and assume `k_pred` opponents defect, then
  - `S_rem_pred = S * (1 - (n + (k_pred+1))/ (2n))` (add our own defection).
  - If `S_rem_pred < S_floor`, we treat defection as “too destructive” unless it’s endgame.

### Core policy
We operate in **three modes**:

## Mode A — **Build (invest)**: play C
Use C when the stock is valuable to preserve and others aren’t already ruining it.

Play **C** if ALL are true:
1. `t < r` (not last round), AND
2. `S < 0.9 * capacity` (there is something to rebuild / keep high), AND
3. Either:
   - `t == 1` (seeding), OR
   - opponents were “mostly cooperative” last round: `p ≤ 0.25` (≤25% of opponents defected), AND
4. Defection would be too destructive: `S_rem_pred < capacity/4`.

Intuition: cooperate only when it’s the cheapest way to keep the asset productive, and only when opponents’ behavior suggests they will help sustain it.

## Mode B — **Harvest (exploit)**: play D
Default money-making mode.

Play **D** if ANY are true:
1. **Endgame**: `t == r` (last round) → always D.
2. **Safe harvest**: `S_rem_pred ≥ capacity/4` AND opponents are at least moderately cooperative:
   - `p ≤ 0.5` (at least half of opponents cooperated last round).
3. **Opponent softness**: last round, at least one opponent cooperated while at least one defected (`0 < k_{t-1} < n-1`):
   - This indicates a mixed environment where you can often defect and still have someone investing.
4. **You’re being exploited**: last round you played C and at least one opponent defected (`you_C_last_round && k_{t-1} > 0`).
   - Immediate switch to D (take back surplus).

Intuition: if others are doing any investing, harvest. If they exploit you, harvest harder.

## Mode C — **Punish / Reset**: play C *only as a discipline tool*, otherwise D
If opponents are in a defection-heavy regime, your cooperation won’t fix it and just hands them value.

- If `p > 0.5` (majority defected last round), then play **D** (don’t be the sucker) **except**:
  - If stock is extremely low and there are still many rounds left, you can try one “reset probe”:
    - If `S < capacity/10` AND `t ≤ r-2`, play **C** for **one round only** to see if anyone reciprocates.
    - Next round:
      - If `p` drops to `≤ 0.25`, switch to Build/Harvest logic (they can recover).
      - Else revert to always D (they’re irredeemable; maximize immediate extraction when possible).

Intuition: don’t waste investment into a tragedy-of-commons spiral unless you can flip the regime; run a cheap probe, then stop.

---

# 2) Edge cases (first round, last round, ties, unusual stocks)

### First round (t = 1)
- Play **C** unless `r == 2` (very short horizon), in which case play **D**.
  - Rationale: one-round seeding can lure conditional cooperators into a high-stock path you later harvest; but with only one future round, seeding rarely pays.

### Last round (t = r)
- Always **D**.
  - Pure endgame exploitation: future stock has zero value.

### Second-to-last round (t = r-1)
- Usually **D**, except if:
  - `S` is so low that even D yields tiny payoff and a final-round D would also be tiny, and you believe a rebuild could matter.
  - Operational rule: if `S < capacity/10` AND last-round opponents were very cooperative (`p ≤ 0.1`), then play **C** at `t=r-1` to inflate `S` for a large last-round D.
  - Otherwise D.

### Stock already at/near capacity
- If `S ≥ 0.95*capacity`, strongly prefer **D** (harvest the abundance). Capacity ceiling means growth is limited; leaving stock there is wasted potential.

### Stock extremely low (near 0)
- If `S == 0`, C and D both give 0. Choose based on control:
  - If `t < r-1`, play **C** for one round (reset probe).
  - If `t ≥ r-1`, play **D** (doesn’t matter; keep exploit posture).

### If opponents all defected last round (p = 1)
- Play **D** forever after (except the one optional low-stock probe described above).
  - Reason: unilateral cooperation is dominated; you’ll just transfer value whenever stock briefly regrows.

---

# 3) Why this is exploitative (and robust)

### How it exploits
- **Front-loads credibility cheaply** (Round 1 C) to pull in reciprocal/conditional strategies.
- **Harvests whenever the ecology supports it**: if others cooperate enough to keep `S` in a productive region, you defect to take 2× the per-round payoff.
- **Immediate retaliation**: if you cooperate and see any defection, you switch to D to avoid being the stable donor in the population.
- **Endgame extraction**: always defects at the end; optionally “pump then dump” on round `r-1` if opponents are highly cooperative and stock is depressed.

### Why it’s robust
- Against always-C: you rapidly switch to mostly D while keeping stock from collapsing (since they invest).
- Against tit-for-tat / grim-like: your early C can establish cooperation; once you defect, you may trigger punishment, but the strategy only defects “safely” (when stock can tolerate) and will revert to C if defection threatens the productive base and opponents are mostly cooperative.
- Against always-D: you don’t waste time cooperating (after detection), and you take any value available.
- Against noisy / mixed populations: the stock-floor check prevents self-sabotaging defection that collapses future payoffs.

---

# Pseudocode (implementation-oriented)

```python
def SHPT(t, r, n, capacity, S, history):
    # history gives last round actions of all players including self
    S_floor = capacity / 4

    if t == r:
        return "D"

    if t == 1:
        return "D" if r == 2 else "C"

    last = history[t-1]  # dict: player -> action
    k = count_opponents_defected(last)  # among n-1 opponents
    p = k / (n-1)
    you_last = last["me"]
    you_C_last = (you_last == "C")

    # predict opponents repeat
    k_pred = k

    # predict remaining stock if we defect now (add our defection)
    total_defectors_pred = k_pred + 1
    S_rem_pred = S * (1 - (n + total_defectors_pred) / (2*n))

    # second-to-last special pump-then-dump
    if t == r-1:
        if S < capacity/10 and p <= 0.1:
            return "C"
        return "D"

    # if majority defected, don't donate (with one low-stock probe)
    if p > 0.5:
        if S < capacity/10 and t <= r-2:
            return "C"  # one-round probe
        return "D"

    # punish being exploited
    if you_C_last and k > 0:
        return "D"

    # harvest if safe and opponents sufficiently cooperative
    if S_rem_pred >= S_floor and p <= 0.5:
        return "D"

    # build if defection would be too destructive and opponents mostly cooperate
    if S_rem_pred < S_floor and p <= 0.25 and S < 0.9*capacity:
        return "C"

    # default: exploit
    return "D"
```

If you want, I can also provide a tighter version with fewer thresholds (to reduce overfitting) or a more aggressive version that “tests” defection earlier to exploit conditional cooperators faster.
'''

description_EXPLOITATIVE_76 = '''
Below is an **exploitative, state-aware “Harvest-Then-Punish-Then-Rebuild” (HPR)** strategy. It aims to (i) **free-ride on any cooperation** it detects, (ii) **avoid being the sucker** when others defect, and (iii) **keep the stock from collapsing** when doing so increases your own future harvest. It uses only parameters, current stock, and observable history.

---

## Key idea (exploitative logic)

- **Defect whenever the stock is high and others are not clearly punishing defection**: you get 2× the per-round payoff of cooperating at the same stock.
- **If defection is causing (or will cause) collapse**, temporarily cooperate to rebuild stock—*not for “fairness,” but to restore a resource you can later harvest*.
- **If opponents appear to sustain cooperation**, defect more often to extract surplus while keeping stock viable (you want them to do the rebuilding).
- **Near the end**, liquidate aggressively (defect), because future stock has little value.

---

## Notation you can compute from history

At round \(t\), before choosing:

- \(S_t\): current stock.
- From last round \(t-1\), you can infer:
  - \(k_{t-1}\): number of opponents who played **D** (since actions are observed).
  - Let \(d_{t-1} = k_{t-1}/(n-1)\): opponent defection rate last round.
- Maintain a short moving average over last \(m\) rounds (e.g., \(m=3\)):
  - \(\bar d_t\): average opponent defection rate.

Also define a simple *stock health* measure:
- \(x_t = S_t / \text{capacity}\) (in \([0,1]\)).

---

## Critical thresholds (depend only on parameters)

1) **“Safe stock” threshold**: you can harvest hard if the system is in the high-growth region.
- Logistic growth peaks at \(S=\text{capacity}/2\).  
- Define:
  - **High stock**: \(S_t \ge 0.6\cdot\text{capacity}\)
  - **Medium stock**: \(0.3\cdot\text{capacity} \le S_t < 0.6\cdot\text{capacity}\)
  - **Low stock**: \(S_t < 0.3\cdot\text{capacity}\)

2) **Endgame window**:
- Let \(L = \max(2,\lceil 0.15 r\rceil)\). (Last 15% of rounds, at least 2.)

3) **Opponent cooperativeness detection**:
- “Mostly cooperative” if \(\bar d_t \le 0.25\).
- “Mostly defecting” if \(\bar d_t \ge 0.6\).

These are intentionally coarse to be robust.

---

## Strategy decision rules

### Rule 0 — Last rounds: **Liquidate**
If \(t > r-L\):  
**Play D** always.

Rationale: future stock has limited value; take the 2× payoff now.

---

### Rule 1 — First round: **Probe with defection**
At \(t=1\):  
**Play D**.

Rationale: it immediately exploits unconditional cooperators and tests whether opponents punish defection (switch to D) or keep cooperating (which you can farm).

---

### Rule 2 — If stock is very low: **Rebuild mode (temporary cooperation)**
If \(S_t < 0.3\cdot\text{capacity}\):

- If opponents are **mostly defecting** (\(\bar d_t \ge 0.6\)):  
  **Play D** (don’t throw good effort after bad—rebuilding alone is futile).

- Else (they are not overwhelmingly defecting):  
  **Play C** until stock returns to medium (≥ 0.3 capacity), then re-evaluate.

Rationale: You cooperate only when there’s a reasonable chance others aren’t full-on liquidating, so that the resource can recover and you can later harvest it.

---

### Rule 3 — If stock is high: **Exploit**
If \(S_t \ge 0.6\cdot\text{capacity}\):

- If opponents are **mostly cooperative** (\(\bar d_t \le 0.25\)):  
  **Play D** (free-ride).

- If opponents are mixed (\(0.25 < \bar d_t < 0.6\)):  
  **Play D** (still exploit; stock is high and resilient).

- If opponents are mostly defecting (\(\bar d_t \ge 0.6\)):  
  **Play D** (you can’t save it; take what you can).

So: at high stock, **always D**.

Rationale: At high stock, you want maximum extraction; the growth dynamics can often replenish if others cooperate at all.

---

### Rule 4 — Medium stock: **Punish when needed, otherwise exploit**
If \(0.3\cdot\text{capacity} \le S_t < 0.6\cdot\text{capacity}\):

- If opponents are **mostly cooperative** (\(\bar d_t \le 0.25\)):  
  **Play D** (exploit their restraint).

- If opponents are **mostly defecting** (\(\bar d_t \ge 0.6\)):  
  **Play D** (punish / don’t be exploited; also rebuilding is unlikely).

- Else (mixed opponents):  
  Use a **one-step sustainability check**:
  - Estimate next stock if you defect vs cooperate using last-round opponent mix as forecast.
  - If defecting would likely push stock into low region next round (below 0.3 capacity), then **play C**; else **play D**.

This is the only “calculation-heavy” part; it makes you cooperate *only* when it prevents losing future harvest.

---

## Sustainability check (pseudocode)

You can approximate using expected total consumption given forecasted opponent defection rate \(\hat d = \bar d_t\):

- Expected per-opponent consumption fraction of stock:
  - If an opponent cooperates: \(S/(2n)\)
  - If defects: \(S/n\)
- Expected opponent consumption total (excluding you):
  \[
  \text{OppCons} = (n-1)\left[(1-\hat d)\frac{S}{2n} + \hat d\frac{S}{n}\right]
  \]
- Your consumption if you choose C: \(S/(2n)\), if D: \(S/n\).

Then compute:
- \(S_{\text{rem}} = S - (\text{OppCons} + \text{YourCons})\)
- Growth \(= 2 S_{\text{rem}}(1 - S_{\text{rem}}/\text{capacity})\)
- \(S' = \min(S_{\text{rem}}+\text{Growth}, \text{capacity})\)

Decision in medium stock region:
- If choosing **D** yields \(S' < 0.3\cdot\text{capacity}\) but choosing **C** yields \(S' \ge 0.3\cdot\text{capacity}\), then **C**; else **D**.

Interpretation: cooperate only if it’s the difference between “resource stays usable” vs “falls into the danger zone.”

---

## Edge-case handling

1) **If stock hits 0**:  
Always **D** (both actions give 0 anyway). But keep tracking opponent behavior for if stock ever recovers (it won’t if at 0, but this is safe).

2) **If opponents switch to all-D suddenly**:  
Your rules already respond: you defect (punish / salvage).

3) **If opponents are unconditional cooperators**:  
You mostly defect, only cooperating briefly if needed to prevent the stock from dropping into low territory (so you can keep harvesting them longer).

4) **If opponents use grim-trigger / tit-for-tat variants**:  
You defect in round 1, which may provoke permanent defection by them. This strategy accepts that tradeoff because the goal is exploitative performance across a diverse tournament: it extracts big gains against naive cooperators and still does fine against defect-oriented fields. The rebuild-mode is there to avoid self-destruction when others don’t fully punish.

5) **Very short games (small r)**:  
Endgame window \(L\) ensures earlier liquidation; with small \(r\), you mostly defect.

---

## Compact overall pseudocode

```pseudo
initialize history
m = 3
L = max(2, ceil(0.15 * r))

for t in 1..r:
  observe S_t
  if t == 1: play D; continue
  compute dbar = avg opponent defection rate over last min(m, t-1) rounds

  if t > r - L: play D; continue

  if S_t < 0.3*capacity:
     if dbar >= 0.6: play D
     else play C
     continue

  if S_t >= 0.6*capacity:
     play D
     continue

  # medium stock
  if dbar <= 0.25: play D; continue
  if dbar >= 0.6: play D; continue

  # sustainability check
  forecast = dbar
  Sprime_if_D = simulate_next_stock(S_t, forecast, my_action=D)
  Sprime_if_C = simulate_next_stock(S_t, forecast, my_action=C)

  if Sprime_if_D < 0.3*capacity and Sprime_if_C >= 0.3*capacity:
       play C
  else play D
```

---

## Why this is exploitative and robust

- **Exploitative**: Defaults to **D** in all profitable/uncertain/high-stock situations; cooperates only as an investment to preserve future exploitation opportunities.
- **Robust**: Doesn’t require coordination, fixed patterns, or shared norms; uses only observed defection rates and stock thresholds.
- **Adaptive**: Switches into rebuild mode only when (a) stock is endangered and (b) opponents are not overwhelmingly defecting, i.e., when rebuilding has positive expected value.

If you want, I can also provide a variant tuned for (i) maximizing worst-case payoff vs always-defect fields, or (ii) maximizing upside vs cooperative fields, depending on the tournament meta you expect.
'''

description_EXPLOITATIVE_77 = '''
### Strategy: **Predatory Regenerator (PR)**  
Goal: **earn D payoffs whenever the stock can safely regenerate**, but **force others into C (or punish them into low extraction)** by credibly driving the stock down when they over-defect. The strategy is exploitative because it (i) **free-rides on cooperative opponents**, (ii) **tests for weakness early**, and (iii) **uses harsh, state-based punishments** that make “others cooperate while we defect” their best response in many histories.

---

## Key idea (state math you exploit)

Let current stock be `S`. Let `k` be the number of defectors this round. Total consumption is:

- Each C takes `S/(2n)`
- Each D takes `S/n`

So total consumption fraction of stock is:
\[
\frac{k}{n} + \frac{n-k}{2n} = \frac{1}{2} + \frac{k}{2n}
\]
Hence remaining stock after consumption is:
\[
S_{\text{rem}} = S\left(1 - \frac{1}{2} - \frac{k}{2n}\right)= S\cdot \frac{n-k}{2n}
\]

Growth is logistic:
\[
G = 2 S_{\text{rem}}\left(1 - \frac{S_{\text{rem}}}{capacity}\right)
\]
New stock:
\[
S' = \min(S_{\text{rem}} + G,\ capacity)
\]

**Critical exploit lever:** when opponents keep `k` small (mostly C), `S_rem` stays moderate and growth can refill stock near capacity. You can then **defect to double your per-round payoff** while keeping the resource alive. When opponents defect too much, you switch to **grim depletion**: defect to crash the stock and deny future gains unless they back off.

---

## What you track from history

After each round `t`, you observe everyone’s actions. Maintain:

- `S_t`: current stock at start of round `t`
- `k_{t-1}`: number of defectors last round
- `p_t`: estimated “opponent cooperativeness” = moving average of cooperation rate among others  
  Example:  
  `p_t = 0.7*p_{t-1} + 0.3*( (#C among others last round)/(n-1) )`

Also compute a **predicted next stock** if you choose C vs D and assuming opponents repeat last round’s defection count among them (robust enough, doesn’t require coordination):

- If you play C: predicted `k = k_opp`  
- If you play D: predicted `k = k_opp + 1`

Use the stock update equations to get `S_next_if_C`, `S_next_if_D`.

---

## Decision rule (core)

You choose **D whenever it is “safe”** (stock won’t collapse) and **C only when needed to keep the stock in the high-yield zone** or to recover from punishment.

### Define thresholds (depend only on parameters)
- **High stock zone:** `S ≥ 0.8*capacity`
- **Recovery target:** `S ≥ 0.6*capacity`
- **Danger zone:** `S ≤ 0.35*capacity` (below this, one more heavy round can spiral to near 0 depending on k)
- **Max tolerated defection among others (soft):**  
  `k_opp ≤ floor((n-1)/3)`  (i.e., if more than ~1/3 of others defect, cooperation won’t be stable)

### Define “safety test” for defecting
Defect if BOTH hold:
1. **Resource safety:** `S_next_if_D ≥ 0.6*capacity` (keeps stock in regenerative regime)
2. **Opponent softness:** `p_t ≥ 0.55` OR `k_opp ≤ floor((n-1)/3)`  
   (many cooperators or at least not too many defectors)

Otherwise, cooperate *unless* in punishment mode (below).

---

## Punishment mode (exploitative enforcement)

If opponents defect too much, you enter a **Punish** state for `L` rounds:

- Trigger if either:
  - `k_opp ≥ ceil((n-1)/2)` in the last round (a “raid”), OR
  - `S ≤ 0.6*capacity` AND `k_opp ≥ 1` (they’re defecting while stock is stressed)

**In Punish mode:** play **D** for `L` rounds regardless of stock (unless stock is already ~0).  
Set `L = max(2, ceil(r/10))` (scales with horizon, parameter-only).

Why this is exploitative: it makes the game **unprofitable for mixed/defect-heavy groups** by accelerating depletion, pressuring adaptive opponents to switch to C to restore the stock.

**Exit Punish early** if:
- In the most recent round, `k_opp == 0` (all others cooperated), AND
- `S ≥ 0.35*capacity` (there is something to rebuild)

Then switch to **Recovery**.

---

## Recovery mode (rebuild then resume exploitation)

When stock is low, defecting yields little anyway. In Recovery mode you play **C** until `S ≥ 0.6*capacity`, *unless* opponents keep defecting (then go back to Punish).

Specifically:
- If `S < 0.6*capacity`:
  - If `k_opp == 0`: play **C** (fastest rebuild)
  - Else if `k_opp ≥ 1`: go **Punish** (don’t be the sucker rebuilding while they skim)

Once `S ≥ 0.6*capacity`, go back to the core rule (attempt safe defection).

---

## Edge cases

### Round 1 (no history)
Start exploitatively but with a probe that protects against immediate collapse:

- If `capacity` is high (it is, ≥ 2n) and `r` is large, early stock is valuable.  
- Play **D in round 1** if `r ≥ 3`. Otherwise play C (for very short games, you can’t recoup punishment/recovery cycles).

Rationale: D1 extracts double, and the first-round stock is at max so you get the biggest possible one-shot gain.

### Last round (t = r)
Always **D**. There is no future stock to protect.

### Second-to-last round (t = r-1)
Almost always **D**, except one special case:
- If `S` is so low that `S/n` is negligible and you expect others to cooperate (rare), D still dominates short-run.  
So: **D** unconditionally in `r-1` as well.

This makes the strategy more exploitative near the end (classic endgame defection).

### Stock near zero
If `S` is extremely small (e.g., `S ≤ 0.05*capacity`):
- If opponents are cooperating (`k_opp==0`): play **C** (only way to get any future value)
- If opponents defect (`k_opp≥1`): play **D** (deny them any asymmetric advantage; recovery is hopeless without coordination)

---

## Pseudocode (implementation-ready)

```text
state variables:
  mode ∈ {NORMAL, PUNISH, RECOVER}
  punish_remaining = 0
  p = 0.5  // opponent cooperativeness estimate

each round t with stock S:
  observe last round actions if t>1:
    k_opp = # of opponents who played D last round
    coop_rate_opp = (# of opponents who played C last round)/(n-1)
    p = 0.7*p + 0.3*coop_rate_opp
  else:
    k_opp = unknown

  // Endgame
  if t == r: return D
  if t == r-1: return D

  // First round probe
  if t == 1:
    if r >= 3: return D
    else: return C

  // Handle punishment countdown
  if mode == PUNISH:
    if punish_remaining > 0:
      punish_remaining -= 1
      // if stock basically zero, defect doesn't matter; still defect to deny
      return D
    else:
      mode = RECOVER

  // Trigger punishment
  if (k_opp >= ceil((n-1)/2)) or ((S <= 0.6*capacity) and (k_opp >= 1)):
    mode = PUNISH
    punish_remaining = max(2, ceil(r/10))
    return D

  // Recovery logic
  if S < 0.6*capacity:
    mode = RECOVER
    if k_opp == 0: return C
    else:
      mode = PUNISH
      punish_remaining = max(2, ceil(r/10))
      return D

  // Normal mode: defect if safe
  // Predict next stock if we defect vs cooperate assuming opponents repeat k_opp
  S_next_if_C = simulate_next_stock(S, k = k_opp)
  S_next_if_D = simulate_next_stock(S, k = k_opp + 1)

  safe = (S_next_if_D >= 0.6*capacity)
  soft = (p >= 0.55) or (k_opp <= floor((n-1)/3))

  if safe and soft:
    return D
  else:
    return C
```

`simulate_next_stock(S,k)` uses:
- `S_rem = S*(n-k)/(2n)`
- `growth = 2*S_rem*(1 - S_rem/capacity)`
- `S' = min(S_rem + growth, capacity)`

---

## Why this is robust and exploitative

- **Exploits cooperators:** when others mostly play C, you frequently play D while keeping the stock high (highest sustainable personal extraction).
- **Doesn’t get farmed by defectors:** if others defect in stressed states, you don’t “rebuild for them”; you punish by accelerating collapse, making their strategy low payoff.
- **Adapts to mixed populations:** it doesn’t assume norms; it uses observed defection counts and stock thresholds.
- **Endgame ruthlessness:** two-round endgame defection captures late-stage value that cooperative strategies leave on the table.

If you want, I can also provide a tuned variant that optimizes the numeric thresholds (0.6, 0.35, etc.) as explicit functions of `n` and `capacity` by analyzing the regeneration map more tightly.
'''

description_EXPLOITATIVE_78 = '''
### Strategy: **Cap-and-Punish Exploiter (CAPE)**  
Goal: Extract extra payoff whenever opponents are even slightly cooperative, while avoiding being the “sucker” when others defect. The key leverage is that **full cooperation (all C)** sustains the stock at `capacity` forever (given your growth rule), so **any opponents who are willing to play C create a renewable surplus that you can skim by defecting**—but you must switch to protection mode if the stock starts collapsing.

---

## Core idea
1. **If the stock is healthy, defect to take 2× the cooperative share.**  
2. **If stock drops below a safety threshold, switch to cooperation to rebuild.**  
3. **If opponents are draining (too many D), don’t waste cooperation—defect and harvest what remains.**  
4. **As the end approaches, defect more aggressively (finite horizon).**

This exploits “nice” or forgiving strategies (they keep stock high while you take more), and it doesn’t hemorrhage against harsh defectors (you quickly stop trying to rebuild for them).

---

## Quantities you track from history/state
Let at round `t`:

- `S_t` = current stock at start of round t.
- From last round actions, compute:
  - `kC_{t-1}` = number of opponents who played C last round (exclude you).
  - `kD_{t-1} = (n-1) - kC_{t-1}`

Define an estimate of “cooperativeness”:
- `coop_rate = kC_{t-1} / (n-1)` (if `t=1`, treat as unknown)

---

## Safety thresholds (depend only on parameters)
Use two stock thresholds:

- **High-stock zone** (safe to exploit):  
  `S_t >= S_high`, where `S_high = 0.80 * capacity`
- **Low-stock zone** (must rebuild if rebuild is plausible):  
  `S_t <= S_low`, where `S_low = 0.35 * capacity`

These can be adjusted, but the asymmetry is intentional: exploit when comfortably high; only “pay” to rebuild when genuinely threatened.

Also define a “rebuild plausibility” condition:
- `rebuild_possible = (coop_rate >= 0.5)` (at least half of opponents were cooperating last round)

Rationale: if most others defect, your cooperation is mostly wasted.

---

## Decision rules (cooperate vs defect)

### Rule 0 — First round (t = 1)
**Defect (D).**  
Exploit any unconditional cooperators immediately and gather information. With stock at capacity initially, the downside is limited and the information gain is high.

---

### Rule 1 — Last round (t = r)
**Defect (D).**  
No future stock to protect. Always take the larger share.

---

### Rule 2 — Endgame ramp (finite-horizon exploitation)
For late rounds, become increasingly exploitative:

- If `t >= r - 1` (last 2 rounds): **Defect (D)** always.  
- If `t >= r - 2` (last 3 rounds): **Defect (D)** unless `S_t` is extremely low and you still expect others to cooperate (rare), e.g. `S_t < 0.15*capacity` and `coop_rate > 0.8`, then play C to avoid zeroing out before the final harvest.

(You can simplify: “always D in last 2 rounds” is already strong and robust.)

---

### Rule 3 — Main phase (t in 2..r-2)

**A) If stock is high (exploit zone):**  
If `S_t >= S_high`: **Defect (D)**.  
Even if everyone else cooperates, you get double their one-round payoff.

**B) If stock is low (danger zone):**
If `S_t <= S_low`:
- If `rebuild_possible` (≥ half opponents cooperated last round): **Cooperate (C)** to try to rebuild the resource they are helping sustain.
- Else (they’re mostly defecting): **Defect (D)**. Don’t subsidize.

**C) If stock is medium (grey zone):**
If `S_low < S_t < S_high`:
- If `coop_rate >= 0.7`: **Defect (D)** (they’re cooperative enough to sustain; skim).
- If `0.4 <= coop_rate < 0.7`: **Mix based on stock trend** (use last stock if available):
  - If `S_t` decreased compared to `S_{t-1}`: **Cooperate (C)** (stabilize before collapse).
  - Else: **Defect (D)** (keep exploiting).
- If `coop_rate < 0.4`: **Defect (D)**.

This makes you “mostly D,” only switching to C when (i) stock is at risk and (ii) others are plausibly helping.

---

## Pseudocode (implementable)
```pseudo
function CAPE_action(t, r, n, capacity, S_t, history):
    if t == 1:
        return D

    last = history[t-1]
    kC = number_of_opponents_who_played_C(last)
    coop_rate = kC / (n-1)

    S_high = 0.80 * capacity
    S_low  = 0.35 * capacity

    if t == r:
        return D
    if t >= r-1:
        return D

    rebuild_possible = (coop_rate >= 0.5)

    if S_t >= S_high:
        return D

    if S_t <= S_low:
        if rebuild_possible:
            return C
        else:
            return D

    # grey zone
    if coop_rate >= 0.7:
        return D
    if coop_rate < 0.4:
        return D

    # middle cooperativeness: use stock trend if available
    S_prev = history_stock_at_start(t-1)
    if S_prev exists and S_t < S_prev:
        return C
    else:
        return D
```

---

## Edge cases and robustness notes

### If stock is near zero
- This strategy will usually defect if others are defecting (because rebuilding alone is futile).
- If others are cooperating (high `coop_rate`), it cooperates in the low zone to restore stock—so it can **resume exploitation** once stock returns to `S_high`.

### If opponents are “grim trigger” / retaliators
- You likely get punished after early defection. CAPE then tends to see `coop_rate` drop, and it will stop cooperating (no subsidies). You won’t outperform mutual defection in that case, but you avoid being milked.

### If opponents are unconditional cooperators / forgiving
- CAPE defects in high-stock states and extracts sustained above-cooperator payoffs essentially every round until the endgame, where it defects anyway.

### If opponents alternate or use stochastic cooperation
- The `coop_rate` and stock-zone logic adapts: you exploit when the environment is safe, and you only “invest” (cooperate) when the resource is threatened and others appear willing to rebuild.

---

## Why this is exploitative (explicitly)
- **Default posture is defection whenever it’s safe**, because D strictly dominates C for a single round given the same stock.
- **Cooperation is treated as an investment** only when it protects future exploit opportunities (preventing stock collapse) and only when others are likely to contribute too.
- **Finite-horizon logic** ensures you don’t leave value on the table late: you defect in the endgame regardless of prior dynamics.

If you want, I can also provide a more aggressive variant (defect unless *both* stock is low *and* opponents are strongly cooperative for multiple rounds), or a more “stealthy exploiter” variant designed to keep conditional cooperators cooperating longer.
'''

description_EXPLOITATIVE_79 = '''
Below is an **exploitative “Harvest–Probe–Punish”** strategy: it tries to (i) **live off cooperators** by defecting when others keep the stock high, (ii) **avoid being the sucker** against defect-heavy groups by quickly switching to defection, and (iii) **keep the resource from collapsing only when that increases your future take**. It uses only parameters, current stock, and observed history.

---

## Core idea (why it exploits)
- In any given round at stock \(S\), **D strictly dominates C for immediate payoff** (you get \(S/n\) instead of \(S/(2n)\)).
- The only reason to ever play C is **investment**: keeping \(S\) high so you can extract more later.
- This policy therefore:
  1. **Defects by default** to harvest.
  2. **Cooperates only as a targeted investment** when (a) others are sufficiently cooperative to keep the stock productive *and* (b) continuing to defect risks pushing the system into low-stock territory where future payoffs are tiny.
  3. **Punishes** (defects) as soon as cooperation is not “profitable enough,” to avoid subsidizing others.

---

## Quantities computed from history each round
Let round index be \(t = 1..r\). Let current stock be \(S_t\).

From previous round \(t-1\) (if exists), compute:
- \(k_{t-1} =\) number of opponents who played D in round \(t-1\).
- Estimate opponent defection rate with exponential smoothing:

\[
q_t = (1-\alpha)\,q_{t-1} + \alpha \cdot \frac{k_{t-1}}{n-1}
\]
Use \(\alpha = 0.35\). Initialize \(q_1 = 0.5\) (neutral prior).

- Maintain a short “trend” signal to detect collapse risk:
  - \( \Delta S = S_t - S_{t-1} \) (if \(t>1\)).

---

## Decision rules: C vs D

### Rule 0: Last-round grab
If \(t = r\): **Play D**.
- No future to protect, so exploit.

### Rule 1: First round probe (information + exploitation)
If \(t = 1\): **Play D**.
- You immediately profit if anyone cooperates.
- You also learn whether the population contains cooperators.

### Rule 2: Stock emergency floor (only invest if it helps *you*)
Define a “danger zone” stock threshold:
\[
S_{\text{low}} = 0.35 \cdot \text{capacity}
\]
If \(S_t \le S_{\text{low}}\):
- If opponents look mostly cooperative (low \(q_t\)), **play C for one round** to help recovery.
- Otherwise **play D** (don’t throw good effort after bad).

Concretely:
- If \(S_t \le S_{\text{low}}\) and \(q_t \le 0.40\): **C**
- Else if \(S_t \le S_{\text{low}}\): **D**

Rationale: if others are mostly defecting, your cooperation won’t rescue the pool; better to take what you can now.

### Rule 3: Exploit cooperative environments (defect when safe)
Define a “safe/high stock” threshold:
\[
S_{\text{high}} = 0.80 \cdot \text{capacity}
\]
If \(S_t \ge S_{\text{high}}\):
- If opponents are not very punitive (they tend to cooperate), **play D** to harvest.
- Specifically: if \(q_t \le 0.55\) then **D**, else **D** anyway (because at high stock, you want to take; punishment just means the game will drift to collapse, and you still want to front-load payoffs).

So practically: **always D** when \(S_t\) is high. (High stock is when exploitation is most lucrative.)

### Rule 4: Middle zone = conditional “investment” vs “harvest”
When \(S_{\text{low}} < S_t < S_{\text{high}}\), decide based on whether cooperation is likely to *increase your future take*:

Compute a simple “future value urgency” factor based on remaining rounds:
\[
u_t = \frac{r - t}{r - 1} \quad \text{(near 1 early, near 0 late)}
\]

Then:
- If \(u_t\) is small (late game), **play D**.
- If opponents are mostly cooperative AND stock has been falling, **play C** as a corrective investment; otherwise **D**.

Concrete thresholds:
- If \(t \ge r-1\): **D** (final two rounds always defect)
- Else if \(q_t \le 0.35\) and \(\Delta S < 0\): **C**
- Else: **D**

Rationale:
- You only “pay” the cooperation cost when (i) there is time to recoup and (ii) others are cooperative enough that recovery is plausible and you won’t be the lone contributor.

---

## Punishment / anti-exploitation logic
This strategy is already exploit-first. The only additional safeguard is:

### Rule 5: Don’t be the only cooperator twice
Track whether you cooperated last round and the pool still shrank badly.

If you played C at \(t-1\) and \(S_t < S_{t-1}\) and \(q_t > 0.35\):
- **Switch to D for the next 2 rounds no matter what** (a “punishment lock”).

Interpretation: if your cooperation didn’t stabilize things and opponents are defect-inclined, stop investing and harvest what remains.

---

## Pseudocode summary
```text
Parameters:
  alpha = 0.35
  S_low  = 0.35 * capacity
  S_high = 0.80 * capacity

State variables:
  q = 0.5
  punish_lock = 0   # integer rounds remaining

For each round t with observed stock S_t:

  if t == 1: action = D
  else:
     update q using last round opponents' D fraction
     compute DeltaS = S_t - S_{t-1}

     if punish_lock > 0:
        action = D
        punish_lock -= 1
     else if t == r: action = D
     else if t >= r-1: action = D

     else if S_t <= S_low:
        if q <= 0.40: action = C
        else: action = D

     else if S_t >= S_high:
        action = D

     else:
        # middle zone
        if q <= 0.35 and DeltaS < 0:
           action = C
        else:
           action = D

  After observing next state (end of round):
     if (you played C) and (S_{t+1} < S_t) and (q_next > 0.35):
         punish_lock = 2
```

---

## Edge cases and robustness
- **Everyone defects:** You defect too; the stock collapses quickly, but you avoid being the lone investor.
- **Many cooperators / “nice” strategies:** You mostly defect and extract high payoffs; occasional C only to keep the pool from sliding into low-stock territory that would reduce your future harvest.
- **Reciprocators (tit-for-tat-like):** They may retaliate after your D; the strategy does not try to restore mutual cooperation unless the environment is both cooperative and the stock is at risk. This is intentional: exploiters accept breakdown if it doesn’t pay to repair.
- **Strategies that alternate / randomize:** The smoothing \(q_t\) and the “only cooperate on falling stock + low q” condition prevents being whipsawed into unnecessary cooperation.
- **Short horizons:** Final two rounds are always D, ensuring endgame exploitation.

---

## Exploitative alignment (explicit)
- **Default posture is defection**: maximize immediate extraction.
- **Cooperation is purely instrumental**: only to maintain or restore a stock level that increases *your* later defection gains.
- **No charitable stabilization**: if others defect enough, you stop propping up the resource and instead race to capture remaining value.
'''

description_EXPLOITATIVE_80 = '''
Below is an **exploitative, adaptive “Extort-then-Harvest”** strategy. It aims to (i) **extract extra payoff whenever others are willing to sustain the stock**, (ii) **avoid being the sucker** when others defect, and (iii) **preserve enough stock** to keep future extraction possible.

Key idea: because a defector always gets **2×** a cooperator’s payoff at the same stock, you want to **defect whenever the resource will remain productive anyway**, and only cooperate when needed to prevent collapse.

---

## Notation (what you can compute from history)
At round \(t\), current stock is \(S_t\).

Let \(k_t\) = number of opponents (among \(n-1\)) who played **D** last round.  
Let \(m_t = n-1-k_t\) = number of opponents who played **C** last round.

You can compute “what stock would have been next round” under different choices because the dynamics are deterministic given total consumption.

Define consumption if you play C or D while opponents keep their last-round actions (a one-step forecast):
- If you play **C**:  
  \[
  \text{cons} = m_t \cdot \frac{S_t}{2n} + k_t \cdot \frac{S_t}{n} + \frac{S_t}{2n}
  \]
- If you play **D**:  
  \[
  \text{cons} = m_t \cdot \frac{S_t}{2n} + k_t \cdot \frac{S_t}{n} + \frac{S_t}{n}
  \]
Then:
- \(S_{\text{rem}} = S_t - \text{cons}\)
- \(\text{growth} = 2 S_{\text{rem}} (1 - S_{\text{rem}}/\text{capacity})\)
- \(S_{t+1} = \min(S_{\text{rem}}+\text{growth}, \text{capacity})\)

This forecast isn’t about being “right”; it’s a robust heuristic for deciding whether you can safely defect without killing the goose.

---

## Strategy overview
You operate in three modes:

1. **Probe/Position (early):** quickly learn if others sustain the resource.
2. **Harvest (exploit):** defect when the stock is likely to stay high anyway.
3. **Rescue/Discipline:** if stock is threatened, cooperate just enough to rebuild; punish persistent defectors by defecting (so you don’t subsidize them).

---

## Decision rules (C vs D)

### Global thresholds
Use two stock thresholds based only on parameters:

- **Safe-high stock:**  
  \[
  S_t \ge S_{\text{high}} := 0.85 \cdot \text{capacity}
  \]
- **Danger-low stock:**  
  \[
  S_t \le S_{\text{low}} := 0.35 \cdot \text{capacity}
  \]

(These are intentionally simple and robust; you can tune them but shouldn’t need to.)

Also track a rolling window of opponent behavior:
- \( \text{DefRate} =\) fraction of opponents’ actions that were D over the last \(W\) rounds (recommend \(W = \min(5, t-1)\)).

---

### Round 1 (edge case)
**Play D in round 1.**  
Reason: you gain 2× immediately; and if everyone defects the game collapses regardless, while if others cooperate you’ve already positioned to exploit.

---

### Last round (edge case)
**Always play D in round r.**  
There is no future stock to protect.

---

### Main rule for rounds 2 … r-1
At each round \(t\) (2 ≤ t ≤ r-1), do:

#### Step A — If collapse is imminent, prioritize self-preservation
If \(S_t \le S_{\text{low}}\):  
- **Play D** unless your cooperation is pivotal to recovery.

“Pivotal to recovery” check (one-step): compute forecasted \(S_{t+1}^C\) and \(S_{t+1}^D\) (assuming opponents repeat last round).  
- If \(S_{t+1}^C - S_{t+1}^D\) is **large enough** to move stock out of danger, cooperate; otherwise defect.

Concrete pivot rule:
- If \(S_{t+1}^C \ge 0.55\cdot \text{capacity}\) **and** \(S_{t+1}^D < 0.55\cdot \text{capacity}\): **play C** (a “rescue”).
- Else: **play D**.

Exploitative logic: you only “invest” (C) when it likely buys a meaningful rebound; otherwise you take what’s left.

#### Step B — If stock is healthy, harvest aggressively
If \(S_t \ge S_{\text{high}}\):  
- **Play D** unless opponents are so defect-heavy that continued defection risks rapid collapse.

So:
- If \(k_t \le \lfloor (n-1)/2 \rfloor\): **play D** (others are sufficiently cooperative; you exploit).
- Else (most opponents defected last round): switch to discipline logic in Step C.

#### Step C — Mid stock: conditional exploitation + discipline
Otherwise ( \(S_{\text{low}} < S_t < S_{\text{high}}\) ), choose action based on opponent defect pressure and sustainability:

1) If opponents are mostly cooperating:  
- If \(k_t \le \lfloor (n-1)/3 \rfloor\): **play D** (they’re carrying the stock; harvest).

2) If opponents are mixed:  
- Use one-step forecast:
  - If \(S_{t+1}^D \ge 0.6\cdot \text{capacity}\): **play D** (you can safely harvest).
  - Else if \(S_{t+1}^C \ge 0.6\cdot \text{capacity}\): **play C** (invest to keep future harvest alive).
  - Else: **play D** (resource likely doomed; don’t subsidize).

3) If opponents are mostly defecting:  
- **Play D** (don’t be exploited).  
Exception: if you’re in a “recoverable” region where one cooperation round can restore the stock (the pivotal rescue from Step A), you may play **C** once, then revert to D if defecting persists.

---

## “One-round rescue” commitment (important)
To avoid being endlessly milked, you do **at most one rescue cooperation** in any \(L\)-round span (e.g., \(L=3\)) unless opponents’ defection rate drops.

Rule:
- If you played C as a rescue in the last 2 rounds, you **must play D** now (unless it’s the only way to move from near-zero to stable, per pivot rule).

This keeps the strategy exploitative rather than altruistic.

---

## Pseudocode (implementable)
```python
def action(t, r, n, capacity, S_t, opp_last_actions, my_recent_actions):
    if t == 1:
        return 'D'
    if t == r:
        return 'D'

    k = count_D(opp_last_actions)     # among n-1 opponents
    # thresholds
    S_high = 0.85 * capacity
    S_low  = 0.35 * capacity

    # helper: forecast next stock if I play a in {C,D}, opponents repeat last actions
    def forecast_next_stock(a):
        # consumption per opponent
        cons = 0.0
        for act in opp_last_actions:
            cons += S_t/(2*n) if act=='C' else S_t/n
        cons += S_t/(2*n) if a=='C' else S_t/n
        S_rem = S_t - cons
        if S_rem < 0: S_rem = 0
        growth = 2 * S_rem * (1 - S_rem/capacity)
        return min(S_rem + growth, capacity)

    S_next_C = forecast_next_stock('C')
    S_next_D = forecast_next_stock('D')

    # anti-sucker: limit rescues
    rescued_recently = ('C' in my_recent_actions[-2:])  # last 2 rounds

    pivotal_rescue = (S_next_C >= 0.55*capacity) and (S_next_D < 0.55*capacity)

    if S_t <= S_low:
        if pivotal_rescue and not rescued_recently:
            return 'C'
        return 'D'

    if S_t >= S_high:
        if k <= (n-1)//2:
            return 'D'
        # too many defectors: don't subsidize
        if pivotal_rescue and not rescued_recently:
            return 'C'
        return 'D'

    # mid region
    if k <= (n-1)//3:
        return 'D'

    if S_next_D >= 0.6*capacity:
        return 'D'
    if pivotal_rescue and not rescued_recently:
        return 'C'
    if S_next_C >= 0.6*capacity and not rescued_recently:
        return 'C'
    return 'D'
```

---

## Why this is exploitative and robust
- **Exploitative:** defaults to **D** whenever the stock can remain productive (others cooperate, or growth keeps up). You capture the 2× advantage systematically.
- **Not a sucker:** when opponents defect heavily, you do **not** cooperate to “save” them; you defect too.
- **Adaptive:** uses observed defection levels and stock to decide whether a rare “investment” (C) is worth enabling future high stock that you can later harvest.
- **Tournament-safe:** works against:
  - unconditional cooperators (you mostly D and win),
  - conditional cooperators (you may trigger some retaliation, but you’ll still D often and only rescue when it helps you),
  - unconditional defectors (you D; no wasted cooperation),
  - chaotic/mixed strategies (threshold + forecast stabilizes decisions).

If you want, I can also provide a more aggressively “extortionate” variant that tries to *force* opponents into cooperation by oscillating between near-collapse and recovery, but it’s riskier in finite-horizon settings.
'''

description_EXPLOITATIVE_81 = '''
### Strategy: **Siphon-with-Reset (SWR)**  
Exploit the stock-recovery physics: the pool fully regenerates only if **total consumption ≤ S/2** (i.e., **everyone plays C**). Any D reduces next stock; too many Ds collapse it. So the exploit is: **take D whenever it won’t immediately crash the pool or when others are already taking D**, but **force a “rebuild phase” (play C) only when the stock gets low enough that future extraction is at risk**. Against cooperators this yields sustained advantage; against defectors it avoids being the sucker and accelerates collapse (which is fine in a finite game).

---

## 1) Decision rules (C vs D)

Maintain two internal modes:

- **SIPHON mode (default):** exploit by defecting when safe/profitable.
- **RESET mode:** cooperate to rebuild stock when it’s too low to keep extracting.

You only need the observable history: last round’s actions and the current stock \(S_t\).

### Key derived quantities
Let:
- \(n\) = number of players  
- \(S\) = current stock at start of the round  
- \(m\) = number of opponents who defected last round (observable)  
- \(p = m/(n-1)\) = last-round opponent defection rate  

Consumption if you play:
- If you play **C**: you take \(S/(2n)\)
- If you play **D**: you take \(S/n\)

Total consumption if exactly \(k\) players defect this round:
\[
\text{Cons}(k)= \frac{S}{2n}(n-k) + \frac{S}{n}k = \frac{S}{2} + \frac{S}{2n}k
\]
Remaining stock after consumption:
\[
S_{\text{rem}}(k)=S-\text{Cons}(k)=\frac{S}{2}-\frac{S}{2n}k
\]
So **each defector reduces remaining stock by \(S/(2n)\)** compared to all-C.

### Thresholds
Use two stock thresholds:

- **Safety threshold:** \(S_{\text{low}} = 2n\)  
  Rationale: when \(S\) approaches the game’s minimum meaningful scale, future payoffs become tiny and the logistic growth doesn’t help much if the pool is repeatedly overdrawn. Below this, prioritize rebuild.

- **Comfort threshold:** \(S_{\text{high}} = 0.6 \cdot \text{capacity}\)  
  Rationale: above this, the pool is “fat” and you can siphon aggressively.

(These constants are chosen to be parameter-only and robust; they don’t assume any opponent type.)

---

### Mode logic

#### **RESET mode (rebuild stock)**
Play **C** while in RESET, unless it’s futile.

- **If \(S \le S_{\text{low}}\):** play **C** (try to rebuild).
- Stay in RESET until \(S \ge S_{\text{high}}\), then switch to SIPHON.

**Futility exception (don’t be a martyr):**
- If last round \(p \ge 0.5\) (at least half of opponents defected), then in RESET you **play D** anyway.  
  Rationale: if a majority is defecting, your C won’t rebuild; take what you can.

#### **SIPHON mode (exploit)**
Default action is **D**, but avoid needless self-crash when others are cooperating (because keeping stock high lets you keep exploiting them later).

Play **D** if any of these hold:
1. **Others are not reliably cooperative:** \(p > 0\) (someone defected last round).  
   If they defect at all, you defect: you don’t subsidize them.
2. **Stock is abundant:** \(S \ge S_{\text{high}}\).  
   Take the bigger cut now; if others are C-heavy you still keep stock fairly high for later.
3. **Endgame:** in the last two rounds (details below).

Otherwise (i.e., opponents were perfectly cooperative last round and stock is only moderate), play **C** *occasionally* to prevent stock from drifting downward due to your repeated D.

Concretely, when **all opponents played C last round** (\(p=0\)) and \(S_{\text{low}} < S < S_{\text{high}}\):
- Play **C** with probability \(q = 1/n\), else play **D**.

This “token cooperation” is purely instrumental: it slows stock decay enough that you can keep harvesting bigger future rounds from cooperative populations, while still defecting most of the time.

---

## 2) Edge cases (first round, last round, weird histories)

### First round
No history exists, so treat opponents as potentially cooperative but probe exploitability.

- If \(S_1 = \text{capacity}\) (it is), start in **SIPHON** and play **D**.  
  Rationale: first-round D yields double immediate payoff, and you learn whether the population punishes. If others are cooperative, you just found free value.

### Last rounds
Finite horizon means cooperation has no long-run enforcement. You should cash out.

- **Round \(t = r\):** always **D**.
- **Round \(t = r-1\):** **D** unless \(S \le S_{\text{low}}\) and \(p=0\) (rare case where one C might slightly raise last-round payoff by increasing \(S_r\)).  
  In practice: **D** in \(r-1\) as well. The extra immediate gain dominates and any regeneration mostly arrives too late.

### If stock hits (or is near) zero
- If \(S \approx 0\): both C and D yield ~0 this round, but actions affect regrowth only through consumption (which is also ~0).  
  Use this simple rule:
  - If \(S < 10^{-6}\): play **D** (doesn’t matter; keep policy simple).

### If capacity is just barely ≥ 2n
This is the “tight” environment where stock can be fragile. The thresholds adapt automatically:
- \(S_{\text{low}} = 2n\) will be close to capacity, so you’ll spend more time in RESET.
- Endgame defection still applies.

---

## 3) Why this is exploitative (and robust)

### Exploitative behaviors by design
- **Against cooperators:** you defect most of the time, getting **2×** their per-round payoff whenever they play C. The occasional “token C” is not reciprocity; it’s **resource farming** to keep the pool productive so you can continue exploiting them.
- **Against mixed strategies:** you defect whenever any defection is observed. That prevents you from being the lone cooperator paying to sustain others’ higher take.
- **Against defect-heavy groups:** you defect too, accelerating collapse (which is optimal in a finite game when rebuilding is hopeless). You don’t waste rounds trying to “teach” cooperation.

### Robustness features
- Doesn’t assume common norms, fixed schedules, or recognition of you.
- Uses only: parameters \((n,r,\text{capacity})\), current stock \(S\), and observed history (last-round defection rate).
- Has a built-in “resource preservation” mechanism (RESET + occasional C) that prevents self-sabotage in cooperative environments—without ever becoming generous.

---

## Pseudocode (implementable)

```python
# Parameters
S_low  = 2*n
S_high = 0.6*capacity

mode = "SIPHON"

for t in 1..r:
    S = current_stock()

    # Endgame cash-out
    if t >= r-1:
        action = "D"
        play(action)
        continue

    # Compute last-round opponent defection rate p
    if t == 1:
        p = None
    else:
        m = number_of_opponents_who_played_D_last_round()
        p = m / (n-1)

    # Mode transitions
    if S <= S_low:
        mode = "RESET"
    elif S >= S_high:
        mode = "SIPHON"

    if t == 1:
        play("D")
        continue

    if mode == "RESET":
        # Futility exception
        if p >= 0.5:
            play("D")
        else:
            play("C")
        continue

    # mode == SIPHON
    if p > 0:
        play("D")
    else:
        # All opponents cooperated last round
        if S_high <= S:
            play("D")
        elif S <= S_low:
            play("C")  # shouldn't happen due to mode switch, but safe
        else:
            # token cooperation to keep the pool productive
            if random() < (1/n):
                play("C")
            else:
                play("D")
```

This strategy is intentionally predatory: **extract maximal value when others sustain the pool, refuse to subsidize defectors, and only “rebuild” when it increases your future ability to extract.**
'''

description_EXPLOITATIVE_82 = '''
### Strategy: **Harvest–Test–Discipline (HTD)**  
Exploit cooperators by defecting when it’s safe/profitable, but *avoid crashing the stock* by switching to cooperation when the resource becomes fragile. Use opponents’ revealed behavior to decide whether to keep exploiting, attempt to “farm” the stock with partial restraint, or give up and take the endgame grab.

The key idea is:  
- **When stock is high and others are not punishing**, defect to extract more than cooperators.  
- **When stock is at risk**, cooperate to keep the pool productive (so you can keep extracting later).  
- **When others are mostly defecting anyway**, defect (no point subsidizing them).  
- **Near the end**, defect (finite horizon).  

This is “exploitative” because cooperation is treated as an *investment* in future extraction, not as a norm.

---

## 1) Decision rules (C vs D)

### Observables each round \(t\)
- Current stock: \(S_t\)
- Last round actions of each player (perfect monitoring)
- From actions, infer counts:
  - \(k_t = \#\{ \text{opponents who played C at } t-1\}\)
  - \(d_t = (n-1) - k_t\)

### Two thresholds (parameter-only)
Define:
- **Safe-stock threshold:**  
  \[
  S_{\text{safe}} = 0.6 \cdot \text{capacity}
  \]
- **Critical-stock threshold:**  
  \[
  S_{\text{crit}} = 0.25 \cdot \text{capacity}
  \]
(These are deliberately simple and robust; the exact constants can be tuned, but these work across many opponent types.)

### Core logic (high level)

#### A. **Endgame grab**
- If \(t = r\): **Play D** (last round, no future to protect).

#### B. **Resource protection mode (avoid killing the goose)**
- If \(S_t \le S_{\text{crit}}\): **Play C**  
  Rationale: At low stock, D accelerates collapse and often yields only a one-round bump at the cost of losing remaining rounds. Cooperation is a stabilization move that preserves your ability to exploit later.

#### C. **Exploit mode (when stock is healthy)**
- If \(S_t \ge S_{\text{safe}}\):  
  - If opponents are “cooperation-tolerant” recently, **Play D**.
  - Otherwise, decide based on whether your cooperation would just subsidize defectors.

Concrete rule using last round:
- If \(k_t \ge \lceil (n-1)/2 \rceil\) (at least half of opponents cooperated last round): **Play D**  
  You’re surrounded by enough cooperators that the stock likely remains viable; you harvest extra.

- Else (most opponents defected last round): **Play D**  
  Don’t waste C when others are draining anyway.

So at high stock, HTD almost always defects; the only time it won’t is if stock is high but you have evidence that defecting triggers coordinated punishment (handled below).

#### D. **Discipline mode (respond to punishers / conditional cooperators)**
Some strategies retaliate against defection (grim trigger / tit-for-tat variants). You want to detect that and then *cooperate just enough* to restore cooperation, then resume exploitation.

Maintain a small memory window \(W=3\) rounds:
- Track your own actions and the number of opponents cooperating.

**Detection heuristic: “I defected, then cooperation dropped.”**
- If in any of last \(W\) rounds you played D and in the following round \(k\) dropped by at least \(\Delta = \lceil (n-1)/3 \rceil\), classify the population as **punishment-sensitive**.

If **punishment-sensitive** and \(S_t > S_{\text{crit}}\):
- Play **C** for the next **2 consecutive rounds**, then re-test with one D:
  - If cooperation remains high after your test D, return to exploit mode.
  - If cooperation collapses again, switch to “farm mode” (below).

This is exploitative: you cooperate only to re-enable future profitable defection.

#### E. **Farm mode (steady-state extraction when opponents are conditional)**
If opponents punish defection reliably, pure exploitation crashes cooperation and stock; pure cooperation leaves money on the table. Farm mode aims to keep the system productive while still extracting via **occasional defections**.

Farm rule (simple periodic opportunism):
- If in the last 2 rounds you played C and \(S_t \ge S_{\text{safe}}\): **Play D** (one-shot harvest)
- Otherwise: **Play C**

This creates a pattern like: C, C, D, C, C, D… *only when stock is high*, which often slips through many “conditional cooperation” policies while giving you regular exploitation rents.

---

## 2) Edge cases

### Round 1 (no history)
- **Play D** if \(r \le 3\) (short games: grab immediately)
- Else:
  - If \(n\) is large (e.g., \(n \ge 6\)): **Play C** in round 1  
    Reason: large groups are fragile; early collapse reduces total future take. You “seed” stability.
  - Otherwise: **Play D**  
    You gain information quickly and exploit naïve cooperators immediately.

(If you want a single uniform rule: Round 1 = D is acceptable and maximally exploitative; the above is a robustness tweak.)

### Last round \(t=r\)
- Always **D**.

### Second-to-last round \(t=r-1\)
- If \(S_t\) is very high (\(\ge S_{\text{safe}}\)): **D**  
- If \(S_t\) is low (\(\le S_{\text{crit}}\)): still **D** unless you believe \(t=r\) payoff depends strongly on stock (it does), but there’s only one round left—usually not worth sacrificing. So default: **D**.

### Stock at/near zero
- If \(S_t \approx 0\), C and D both yield ~0 now; but C might allow growth.
- Rule already says: if \(S_t \le S_{\text{crit}}\), play **C** (unless in last 1–2 rounds, where you D).

### If everyone always defects
- You will quickly observe \(k_t \approx 0\).  
- HTD will **D** in all non-critical rounds (and even critical rounds don’t help much if others D). You won’t waste cooperation subsidizing them.

---

## 3) Why this is exploitative (and robust)

### Exploitative stance
- **Default action is D** whenever it doesn’t endanger future extraction too much.
- **Cooperation is instrumental**, used only:
  1) to prevent stock collapse (protect future rents), or  
  2) to manipulate conditional cooperators back into cooperating so you can defect again.

### Robustness across opponent types
- **Against unconditional cooperators:** you defect almost always → maximal advantage.
- **Against unconditional defectors:** you defect too → avoid being the sucker.
- **Against tit-for-tat / grim-trigger clusters:** you detect punishment, then switch into “discipline/farm” to keep them cooperative while still taking periodic defections.
- **Against mixed populations:** stock thresholds prevent catastrophic depletion; majority-cooperator detection targets exploitation where it’s sustainable.

---

## Pseudocode (implementation-ready)

```python
# Parameters: n, r, capacity
S_safe = 0.6 * capacity
S_crit = 0.25 * capacity
W = 3
Delta = ceil((n-1)/3)

# State you maintain:
history_my_actions = []
history_k = []  # k_t = number of opponents who played C in round t
punishment_sensitive = False
discipline_timer = 0
farm_mode = False

def choose_action(t, S_t, opp_actions_last_round):
    global punishment_sensitive, discipline_timer, farm_mode

    if t == r:
        return "D"

    # Compute k_t from last round (if available)
    if t == 1:
        # Robust opening
        if r <= 3:
            return "D"
        if n >= 6:
            return "C"
        return "D"

    k = count_C(opp_actions_last_round)

    # Update punishment sensitivity using last W rounds
    # Detect: after we played D, opponent cooperation dropped sharply
    update_histories_and_detect_punishment()

    if discipline_timer > 0 and S_t > S_crit:
        discipline_timer -= 1
        return "C"

    # Critical stock: protect the resource (unless essentially endgame)
    if S_t <= S_crit:
        if t >= r-1:
            return "D"
        return "C"

    # If punishment-sensitive, attempt restore then test
    if punishment_sensitive and not farm_mode:
        # Do 2 rounds of C, then a test D next time stock is safe
        discipline_timer = 1  # (this round C plus one more round C)
        return "C"

    # Farm mode: periodic harvesting when safe
    if farm_mode:
        if last_two_my_actions_are_C() and S_t >= S_safe:
            return "D"
        return "C"

    # Exploit mode (default)
    if S_t >= S_safe:
        return "D"

    # Mid-stock region: decide based on opponent composition
    if k >= ceil((n-1)/2):
        return "D"  # enough cooperators to sustain you
    else:
        return "D"  # others are defecting; don't subsidize

def update_histories_and_detect_punishment():
    # Use your stored (my_action_{t-1}, k_{t-1}) and current k_t trend
    # If a D is followed by a big drop in k, mark punishment_sensitive
    # If repeated, set farm_mode=True
    pass
```

**Practical note:** In `update_histories_and_detect_punishment()`, if you observe two separate “D → big drop in k” events, set `farm_mode=True` (because the population reliably punishes).

---

If you want, I can also provide a more formal “stock-optimality” variant that uses the exact transition equation to compute a one-step lookahead (myopic dynamic programming) to decide C vs D given estimated opponent cooperation rate; it can be even more exploitative while still avoiding collapse.
'''

description_EXPLOITATIVE_83 = '''
### Strategy: **Harvest–Test–Punish (HTP)**  
Goal: **extract as much as possible** while keeping the stock from crashing **only when it benefits you**. The key exploit is that (i) you can often take **D** while others take **C** and still keep the resource productive, and (ii) you only “invest” in stock (play **C**) when you detect that doing so increases your future ability to keep defecting profitably.

---

## Intuition (why this is exploitative)
- **Defection doubles your per-round take** relative to cooperation at the same stock:  
  \( \pi(D)=S/n \), \( \pi(C)=S/(2n) \).
- But too much D can collapse stock to 0, killing future gains.
- So you:
  1. **Try to defect early** to capture extra value if opponents are cooperative.
  2. **Measure** how many others defected and whether the stock is staying healthy.
  3. **Punish** (defect relentlessly) when others are not providing “stock investment,” because cooperating then would just subsidize them.
  4. **Only cooperate strategically** to keep the stock high *when you can still profitably defect later*.

This is not fairness-oriented: it’s “I will cooperate only as a tool to maintain a resource I intend to harvest.”

---

## Key observable quantities each round
Let round \(t\) start with stock \(S_t\).

From observed actions in round \(t-1\), compute:
- \(d_{t-1}\): number of opponents who defected last round (not counting you).
- \(k_{t-1} = d_{t-1} + \mathbf{1}\{\text{you defected}\}\): total defectors last round.

Also track:
- A running estimate of opponent defection rate:  
  \(\text{DefRate}_t = \frac{\sum_{\tau=1}^{t-1} d_\tau}{(n-1)(t-1)}\) for \(t>1\).

---

## A critical stock threshold: “safe to defect?”
If **everyone** defects, stock goes to 0 immediately.  
If **not everyone** defects, remaining stock after consumption is:

\[
S_{\text{rem}} = S_t\left(1 - \frac{k}{n} - \frac{n-k}{2n}\right)
= S_t\left(\frac{1}{2} - \frac{k}{2n}\right)
\]

- If \(k=n\): \(S_{\text{rem}}=0\) (collapse).
- If \(k=n-1\): \(S_{\text{rem}}=S_t/(2n)\) (tiny but >0).
- Logistic growth is strong at moderate \(S_{\text{rem}}\); weak when \(S_{\text{rem}}\) is tiny.

So you want to defect when you believe **at least one other player will cooperate** (i.e., \(k \le n-1\)) *and* stock isn’t already so low that the game is near-dead.

Define a **low-stock danger threshold**:
- \(S_{\text{low}} = 2n\).  
(Reason: it’s the maximum stock bound in your spec’s “STATE” line, and also a practical threshold where per-round payoffs become small; below this, “resource recovery” is fragile.)

---

## Decision rules (core policy)

### Round 1 (probe)
**Play D** unless the horizon is extremely short:
- If \(r=2\): still **D** (you want immediate exploitation).
- In general: **D**.

Rationale: you immediately test if opponents are willing to cooperate. If many cooperate, you profit instantly and can continue exploiting.

---

### Main loop (rounds 2 to r-1)
Each round \(t\) (with \(2 \le t \le r-1\)), choose between **C** and **D** using:

#### Rule A — Endgame exploitation trigger (approaching last rounds)
If remaining rounds are few, stock investment has little time to pay back.

- If \(r - t \le 1\) (i.e., next round is last): **D**.

(So: always defect in round \(r-1\) and \(r\).)

#### Rule B — If stock is already low, don’t “donate” to defectors
- If \(S_t \le S_{\text{low}}\):
  - If opponents defected a lot recently (e.g., \(d_{t-1} \ge 1\) or \(\text{DefRate}_t > 0.25\)): **D**.
  - Else (they seem cooperative and stock is low): **C** for one round to attempt recovery, then re-evaluate next round.

Interpretation: you only “rescue” the resource if others are mostly cooperators (so you can later harvest); otherwise you defect and take what’s left.

#### Rule C — If opponents are providing cooperation, exploit it
If stock is healthy (\(S_t > S_{\text{low}}\)):

- If \(d_{t-1} \le \lfloor (n-1)/3 \rfloor\) (few opponent defectors last round): **D**.
  - You’re free-riding on a cooperative environment.

#### Rule D — If opponents are mixed, use “selective maintenance”
If stock is healthy but opponents are not very cooperative:

- If \( \lfloor (n-1)/3 \rfloor < d_{t-1} < (n-1)\):
  - Play **C** *only if* you believe your cooperation is pivotal to preventing collapse and there’s time to benefit:
    - If \(S_t\) is moderate (say \(S_t < 0.6\cdot \text{capacity}\)) and \(r-t \ge 2\): **C**
    - Else: **D**

This is exploitative maintenance: you invest only when the “asset” (stock) is below capacity enough that growth gains are large, and you still have time to harvest later.

#### Rule E — If everyone else defects, don’t be the sucker (burn it down)
- If \(d_{t-1} = n-1\): **D**.

Even if you cooperate, you still get half the payoff of defecting and the stock likely stays near-collapse; you refuse to subsidize.

---

### Last round (round r)
**Always D.**  
No future, so no reason to conserve.

---

## Pseudocode
```python
def HTP(t, r, n, capacity, S_t, history):
    # history provides last round opponent actions if t>1
    S_low = 2*n

    if t == 1:
        return "D"

    # Compute d_{t-1}: number of opponent defectors last round
    d_last = count_opponents_defected(history[t-1])

    # Running opponent defection rate
    def_rate = total_opponent_defections(history, up_to=t-1) / ((n-1)*(t-1))

    # Endgame
    if t == r or t == r-1:
        return "D"

    # Low stock regime
    if S_t <= S_low:
        if d_last >= 1 or def_rate > 0.25:
            return "D"
        else:
            return "C"  # attempt a one-round recovery in cooperative groups

    # Healthy stock: exploit cooperators
    if d_last <= (n-1)//3:
        return "D"

    # Mixed: selective maintenance if it can pay back
    if d_last < (n-1):  # not everyone defects
        if (S_t < 0.6*capacity) and (r - t >= 2):
            return "C"
        else:
            return "D"

    # Everyone else defected
    return "D"
```

---

## Edge cases and robustness notes
- **n=2:** thresholds still work: if the other cooperates, you defect; if the other defects consistently, you defect (endgame always defect).
- **Very high capacity / very strong growth:** strategy defects more because stock can rebound easily; the “selective maintenance” rarely triggers.
- **Low capacity / fragile stock:** strategy becomes harsher: it will only invest (C) when opponents are demonstrably cooperative and there’s time to harvest.
- **Opponents who try to punish defection (grim triggers, tit-for-tat variants):**  
  You’ll see rising \(d_{t-1}\) and def_rate, shifting you toward D (refuse to be extorted) unless stock and horizon make a brief C-investment profitable.
- **Pure cooperators:** you exploit heavily: mostly D until stock approaches low threshold, then occasional C to keep the “farm” productive, then D again, and full D at the end.

---

## Summary of “when cooperate vs defect”
- **Defect by default** (first round, endgame, when others defect a lot, when stock is low and opponents aren’t cooperative).
- **Cooperate only as an investment**:
  - stock is low/moderate (large marginal growth benefit),
  - opponents are mostly cooperative (so your investment isn’t immediately stolen),
  - there are at least ~2 rounds left to recoup by defecting later.

This yields a strategy that is **adaptive**, **history-based**, and **systematically exploitative**: it treats cooperation as a tool for future extraction, not as a norm.
'''

description_EXPLOITATIVE_84 = '''
## Exploitative strategy: **Stock-Pressure Extortion (SPE)**

Mindset: keep the resource high **only when it benefits you**, and otherwise **take the larger share**. Use the stock dynamics to (a) farm cooperators by defecting while they stabilize the stock, and (b) avoid being the “last cooperator” who props up everyone else. Punish any environment that looks non-cooperative by collapsing the stock early (since recovery from low stock is slow and defecting dominates per-round anyway).

This strategy is parameter-, state-, and history-based; it does not assume norms, schedules, or communication.

---

# 1) Decision rules: when to Cooperate vs Defect

### Key quantities (observable or computable each round)
At round \(t\) with current stock \(S_t\):

- Let \(c_t\) = number of opponents who played **C** in round \(t-1\) (history).
- Let \(q_t = c_t/(n-1)\) = estimated “cooperation rate” among opponents last round.
- Let \(m\) = total number of cooperators last round including you (compute from history).

### Intuition that drives the rules
- **D strictly dominates C within a round** for any given \(S\) (you get \(S/n\) instead of \(S/(2n)\)).
- So you only ever choose **C** as an *investment* to keep \(S\) high for future rounds, and only when others are likely to also cooperate enough to avoid collapse.
- If others are mostly cooperating, you can **defect and free-ride** while stock stays healthy.
- If others are mostly defecting, you should **defect too** and race for what’s left; cooperating won’t rescue the stock unless almost everyone does it.

### Practical threshold logic
Define two cooperation thresholds:

- **Free-ride threshold** \(T_{FR}\): if opponents are highly cooperative, you defect to exploit.
- **Recovery threshold** \(T_{REC}\): if opponents are moderately cooperative and stock is in a “recoverable” zone, you cooperate to keep the stock from drifting down.

Suggested values (work across many \(n\)):
- \(T_{FR} = 0.75\)
- \(T_{REC} = 0.55\)

Also define a “stock danger” threshold:
- \(S_{low} = 0.35 \times capacity\) (below this, recovery is slower and exploitation window shrinks)

### Decision rule (core)
At the start of round \(t\):

1) **Endgame defection**
- If \(t = r\): play **D**.

2) **First round probe**
- If \(t = 1\): play **D**.  
  (You lose nothing strategically—there is no reputation cost yet, and you immediately test whether opponents are willing/able to sustain the stock without your help.)

3) **If stock is critically low: defect**
- If \(S_t \le S_{low}\): play **D**.  
  Rationale: you need immediate payoff; cooperating at low stock gives little and is unlikely to rebuild unless others coordinate strongly.

4) **Exploit high cooperation (free-ride)**
- If \(q_t \ge T_{FR}\): play **D**.  
  Rationale: others are stabilizing the stock; you take the larger share.

5) **Conditional “maintenance cooperation” (only if it likely matters)**
- Else if \(q_t \ge T_{REC}\) **and** there are at least 2 rounds left (\(t \le r-2\)): play **C**.  
  Rationale: you cooperate only when (a) opponents are somewhat cooperative, and (b) there is time to recoup the investment.

6) **Otherwise defect**
- Play **D**.

This already exploits cooperators aggressively and avoids wasting cooperation in hostile groups.

---

# 2) Edge cases & special handling

### Round 1
- Always **D** (probe and grab).
- Record opponent responses. Many “nice” strategies start with C; you immediately profit and learn.

### Round 2 (response to probe)
- If the probe revealed very high cooperation (\(q_2\) computed from round 1 actions) you continue **D** to free-ride.
- If cooperation was mediocre but not terrible, you may cooperate (rule 5) to keep the stock from degrading—*but only if there is enough horizon left.*

### Last round
- Always **D** (no future stock value).

### Second-to-last round
- Default **D** unless you are in a rare state where cooperating keeps stock high enough to materially increase your round-\(r\) payoff. The rule above already restricts “maintenance cooperation” to \(t \le r-2\), so you don’t invest when you can’t recoup.

### When stock is near capacity
- You still defect if others are cooperative (rule 4). This is the main exploitation regime: high stock + others stabilizing = maximum advantage.

### When stock is near zero
- Always defect. Cooperating doesn’t create stock; it only slightly reduces consumption. If others are defecting, the system is effectively dead.

---

# 3) Why this is exploitative and robust

### Exploitative
- **Defects against cooperators by default**, only “pays” with cooperation when necessary to preserve a future exploitation stream.
- Uses a **probe-then-free-ride** pattern: start with D, and if opponents keep cooperating, keep defecting.
- Refuses to be the “sucker” in late game (hard endgame defection).

### Robust to wide opponent behaviors
- Against unconditional cooperators / generous strategies: you mostly **D** and harvest high payoffs while they maintain stock.
- Against tit-for-tat / contingent cooperators: your initial D may trigger punishment; the policy then checks if cooperation is sufficiently high to justify rebuilding. If not, it defects and races.
- Against always-defect: you defect immediately; you don’t waste rounds cooperating in a doomed environment.
- Against mixed or learning agents: your response adapts based on the observed cooperation rate \(q_t\) and the state \(S_t\).

---

# Pseudocode

```python
def SPE_action(t, r, n, capacity, S_t, history_actions):
    # history_actions: list of length t-1 with all players' actions each round
    # You can compute opponents' cooperation rate last round if t > 1.
    
    T_FR  = 0.75
    T_REC = 0.55
    S_low = 0.35 * capacity

    if t == r:
        return "D"  # endgame grab

    if t == 1:
        return "D"  # probe + exploit

    # compute opponents' cooperation rate in last round
    last_round = history_actions[t-2]          # actions at round t-1
    opp_C = count_opponents_C(last_round)      # among n-1 opponents
    q = opp_C / (n - 1)

    if S_t <= S_low:
        return "D"

    if q >= T_FR:
        return "D"  # free-ride on cooperative field

    if q >= T_REC and t <= r - 2:
        return "C"  # minimal investment to keep stock usable

    return "D"
```

---

If you want to push exploitation even harder, a common tournament tweak is to raise \(T_{REC}\) (cooperateuwk) so you almost never cooperate (pure “harvest”). The above version is more **strategically exploitative**: it sometimes “services the resource” to keep a profitable stock level long enough to continue free-riding.
'''

description_EXPLOITATIVE_85 = '''
Below is an **exploitative “Harvest-Then-Punish” strategy** designed to (i) take high payoffs whenever others keep the resource healthy, (ii) rapidly crush the stock (and future payoffs) if opponents are the kind that will defect anyway, and (iii) avoid being the “sucker” who cooperates while others defect. It is adaptive using only parameters, current stock, and observed history.

---

## Core idea (exploitative mindset)

- **If others are propping up the stock with cooperation**, you mostly **defect** to harvest double the per-round payoff.
- **If others are draining the stock (many defections)**, you also **defect** (because cooperating cannot save you and just gives up immediate payoff).
- **Only cooperate when it is instrumentally useful** to keep the stock in the “high” region *and* you believe your cooperation is necessary to prevent imminent collapse (i.e., a maintenance move, not altruism).
- Use **credible punishment**: if opponents start defecting too much, switch to defecting for long enough that they cannot profitably exploit you.

This behaves like an extortion/maintenance policy: “I’ll keep the goose alive only when it benefits me; otherwise I harvest aggressively.”

---

## Quantities you track each round

Let:
- `n`, `capacity`, `r` given.
- At start of round `t`, observed stock is `S_t`.
- From last round’s actions, count defections: `D_{t-1}` (# players who played D).
- Define observed defection rate: `q_{t-1} = D_{t-1}/n`.

Also compute two stock thresholds (parameter-only):
- **High-stock region**: `S_high = 0.8 * capacity`
- **Low-stock danger**: `S_low  = 0.35 * capacity`

(These are intentionally simple and robust; you can tune but don’t need to.)

---

## Decision rules (when to cooperate vs defect)

### Rule 0: Last round (pure exploitation)
- If `t == r`: **Defect (D)**.  
No future to protect; D strictly dominates C in that round given `S_t`.

---

### Rule 1: Round 1 (probe while positioning to exploit)
- If `t == 1`: **Defect (D)**.  
Rationale: you immediately learn whether others are “sustainers.” If many cooperate, you start ahead and can keep harvesting; if many defect, cooperating was wasted anyway.

---

### Rule 2: Main policy for rounds 2..r-1

You choose **C only as a maintenance action** when the stock is in danger *and* opponents are not overwhelmingly defecting.

**2A) If stock is healthy, harvest (defect).**
- If `S_t >= S_high`: play **D**.

Reason: When the resource is abundant, your D payoff is high and the system can absorb some overconsumption—especially if others are cooperating.

---

**2B) If stock is low, decide whether “maintenance cooperation” can pay.**
- If `S_t <= S_low`:
  - If `q_{t-1} >= 0.25` (at least 25% defected last round): play **D**.
  - Else (defections rare): play **C** for **one round**, then re-evaluate next round.

Reason: If even a modest fraction defects when stock is already low, your cooperation is unlikely to rescue the pool (and you lose immediate payoff). If most are cooperating, a one-round C can help keep the stock from spiraling down, preserving future exploitation opportunities.

---

**2C) Intermediate stock: exploit cooperators, but punish rising defection.**
If `S_low < S_t < S_high`:

- If `q_{t-1} == 0` (everyone cooperated last round): play **D**.  
  (Classic exploitation: others sustain, you harvest.)
- Else if `0 < q_{t-1} < 0.25`: play **D**.  
  (Still mostly cooperative environment—keep exploiting.)
- Else if `q_{t-1} >= 0.25`: enter **Punishment Mode** (defined below).

---

## Punishment Mode (robust exploitation + anti-sucker mechanism)

**Trigger:** If in any round `t>1`, `q_{t-1} >= 0.25`, set `punish_timer = L` where  
- `L = max(2, ceil(r/10))` (at least 2 rounds, longer in long games).

**While `punish_timer > 0`:**
- Play **D**
- Decrease `punish_timer -= 1`

**Exit condition:**
- When `punish_timer == 0`, resume main policy, but only allow “maintenance C” if `q_{t-1} == 0` in the most recent round (i.e., you saw full cooperation again).

Rationale:
- This prevents you from oscillating into cooperation while others keep defecting.
- It makes your strategy hard to exploit: any significant defection environment causes you to default to immediate extraction.

---

## Edge cases and special handling

1. **Stock near zero (`S_t ≈ 0`)**  
   Always **D**. C and D both yield ~0 anyway; D is never worse and avoids being “nice” in hopeless states.

2. **Very small capacity relative to n (still ≥ 2n by spec, but tight)**  
   The thresholds scale with capacity, so the strategy remains stable.

3. **Short games (small r)**  
   With `r` small, `L = 2` keeps punishment meaningful without wasting the game. And last-round D is preserved.

4. **Opponents that alternate / stochastic defect**  
   The `q`-based trigger catches patterns that are “defection-heavy” and locks into D long enough to avoid being farmed.

---

## Pseudocode summary

```pseudo
parameters: n, r, capacity
constants:
  S_high = 0.8 * capacity
  S_low  = 0.35 * capacity
state:
  punish_timer = 0

function act(t, S_t, history):
  if t == r:
    return D

  if t == 1:
    return D

  D_prev = number_of_defectors_in_round(t-1)
  q = D_prev / n

  if punish_timer > 0:
    punish_timer -= 1
    return D

  # trigger punishment
  if q >= 0.25:
    punish_timer = max(2, ceil(r/10)) - 1
    return D

  # main policy
  if S_t >= S_high:
    return D

  if S_t <= S_low:
    if q >= 0.25:
      return D
    else:
      return C  # one-round maintenance

  # intermediate stock
  # (q < 0.25 here due to earlier trigger)
  return D
```

Note what this really does: **default to D almost always**, with a narrow “maintenance C” window only when (i) stock is getting dangerously low, and (ii) the group is currently very cooperative—so your single C is an investment to keep future D payoffs high.

---

## Why this is exploitative and robust

- **Exploitative:** In cooperative populations, you free-ride by defecting in virtually all nonterminal rounds, capturing the higher immediate payoff while others maintain the stock.
- **Robust to defectors:** If others defect materially, you do not waste rounds cooperating; you switch to sustained defection (punishment mode), preventing being a soft target.
- **Adaptive to state dynamics:** The only time you “help” is when low stock threatens future harvests and opponents appear cooperative enough that your help is not squandered.

If you want, I can also give a more “mathematical” variant that estimates next-round stock from observed `D_prev` and only cooperates when it predicts imminent collapse (a tighter, more optimized maintenance trigger).
'''

description_EXPLOITATIVE_86 = '''
Below is an exploitative, history-dependent strategy that (i) tries to keep the stock in a high-yield “sweet spot” when others are cooperative enough, (ii) defects aggressively whenever that raises your expected total take, and (iii) avoids being the “sucker” (cooperating while others defect) by using fast retaliation and slow forgiveness.

---

## Intuition (what you’re exploiting)

- **Per-round payoff:** Defect gives you **2×** the immediate consumption of cooperate (S/n vs S/(2n)).
- **But stock dynamics matter:** If the group consumes too much, stock collapses and future payoffs vanish. So the only reason to ever play **C** is to **protect future stock** when others are also restraining.
- **Key leverage:** You can often **defect while others cooperate**, taking more now while the stock still regrows enough to keep the game alive—until opponents change behavior. Your goal is to sit right at the boundary where *others keep the resource sustainable* and you skim extra.

---

## Core quantities you compute each round

Let:
- `S_t` = current stock at start of round t.
- From last round actions, define `k` = number of defectors among the **other** `n-1` players (so `k ∈ [0, n-1]`).
- Let `my_action` be your planned move this round.

**Total consumption fraction** given `k` and your action:

If you play **C**:
- Total consumption = `S_t * ( (k+1)/n + (n-1-k)/(2n) )`
- Equivalent “consumption share” (divide by S_t):
  \[
  c_C(k)=\frac{n+k+1}{2n}
  \]

If you play **D**:
\[
c_D(k)=\frac{n+k+2}{2n}
\]

So `S_remaining = S_t * (1 - c_action(k))`.

Then apply growth:
\[
S_{t+1}=\min\Big(S_{\text{rem}} + 2S_{\text{rem}}\big(1-\frac{S_{\text{rem}}}{capacity}\big),\ capacity\Big)
\]

This lets you **predict the next stock under C vs D**, given a forecast of others’ defection count.

---

## Strategy: “Skim-then-Strike with Retaliation (SSR)”

### State variables you maintain
- `mode ∈ {PROBE, SKIM, PUNISH, RECOVER, ENDGAME}`
- `punish_timer` (integer)
- `trust` (float in [0,1]) — your estimate that others will keep cooperation high.
- Rolling estimate of others’ defection rate:
  - `p_def = EWMA of (k/(n-1))` with smoothing factor (e.g., 0.4).

### High-level behavior
1. **Probe** early to measure whether opponents sustain the stock.
2. **Skim**: defect whenever the stock can tolerate it *and* opponents look cooperative.
3. **Punish**: if others defect enough to threaten sustainability (or if you’re being exploited), immediately defect for several rounds to stop being a sucker.
4. **Recover**: if stock gets low, temporarily cooperate to rebuild *only if others show restraint*; otherwise keep defecting (deny them surplus too).
5. **Endgame**: last rounds, defect (there’s little future to protect).

---

## 1) Decision rules: when cooperate vs defect

### Round classification thresholds
Define a **stock safety threshold**:
- `S_safe = 0.5 * capacity` (resource is “healthy”)
- `S_low = 0.2 * capacity` (resource is “fragile”)

Define **opponent cooperation threshold**:
- “Others are cooperative” if `p_def ≤ 0.25` (on average ≤ 25% of others defect).
- “Others are hostile” if `p_def ≥ 0.5`.

These are parameter-only constants; you can tune but they don’t depend on specific opponents.

### Action rule (main)
At round `t` (with stock `S_t`), do:

**A. Endgame override**
- If `t ≥ r-1` (last 2 rounds): **D**.  
  Rationale: future value is too small; you harvest.

**B. If in PUNISH mode**
- Play **D** until `punish_timer == 0`, then switch to RECOVER.

**C. Otherwise (normal modes), use a one-step sustainability test**
Forecast others’ defection count next round as:
- `k_hat = round(p_def * (n-1))`

Compute predicted next stock under your two actions:
- `S_next_C = f(S_t, k_hat, action=C)`
- `S_next_D = f(S_t, k_hat, action=D)`

Now choose:

1) **Skim condition (exploit)**
Play **D** if all are true:
- `p_def ≤ 0.25` (others mostly cooperate),
- `S_t ≥ S_safe`,
- and `S_next_D ≥ S_safe` **or** `S_next_D ≥ S_t * 0.8` (defection doesn’t noticeably crash stock).

This is the core exploit: if others keep the pool healthy, you defect to extract 2×.

2) **Sucker-avoidance / retaliation trigger**
If either:
- last round, `k ≥ ceil((n-1)/2)` (majority of others defected), **or**
- `p_def ≥ 0.5`, **or**
- `S_t ≤ S_low` and others have been defecting (`p_def > 0.25`)
→ enter **PUNISH**: set `punish_timer = 2` (or 3 if `p_def` very high), and play **D** now.

3) **Recovery / sustain**
If stock is fragile (`S_t ≤ S_low`) and opponents seem cooperative (`p_def ≤ 0.25`):
- play **C** (try to rebuild) for as long as `S_t < S_safe` *unless* opponents start defecting.

4) **Otherwise**
- Default to **C** if stock is not safely high or opponents aren’t reliably cooperative.
- Default to **D** if stock is high and opponents are moderately cooperative (`p_def ≤ 0.4`)—you still try to skim, but less aggressively.

---

## 2) Edge cases (first round, last round, etc.)

### First round (t = 1): PROBE
- Play **C** in round 1.
  - It’s cheap insurance: you learn whether others immediately defect, and you avoid causing an instant collapse when everyone is unknown.
  - Also, since stock starts at `capacity`, the system can sustain some exploitation later.

After observing round 1:
- Update `p_def` from observed defections.
- If many defected (≥ half of others), go directly to **PUNISH** in round 2.

### Last rounds
- Rounds `r-1` and `r`: always **D**.
- If you want even more exploitative: defect for the last `L = max(2, round(r/5))` rounds, but “last 2 rounds” is the robust minimum.

### Stock at/near zero
- If `S_t` is near 0, actions yield near 0 immediately.
- Still, if opponents are defecting (`p_def` high), **D** (deny them any chance to rebuild off your restraint).
- If opponents are cooperating (`p_def` low), **C** to rebuild and then resume skimming once `S_t ≥ S_safe`.

### Capacity very large relative to n
- The one-step forecast automatically makes you more aggressive: if `S_next_D` stays high, you defect more.

---

## 3) Why this is exploitative (explicitly)

- **You cooperate only as an investment**: to keep the pool productive when it benefits you.
- **You defect whenever the pool can absorb it** while others are likely to keep cooperating, harvesting the 2× immediate gain.
- **You punish quickly and unilaterally** when others defect, ensuring you don’t subsidize their extraction.
- **You defect at the end** because future stock is worthless to you then.

---

## Pseudocode sketch

```python
init:
  mode = "PROBE"
  p_def = 0.0
  punish_timer = 0

for t in 1..r:
  if t >= r-1:
    action = D
    play(action); continue

  if mode == "PROBE":
    action = C
  elif mode == "PUNISH":
    action = D
  else:
    k_hat = round(p_def * (n-1))
    S_next_C = predict_next_stock(S_t, k_hat, C)
    S_next_D = predict_next_stock(S_t, k_hat, D)

    if p_def <= 0.25 and S_t >= 0.5*capacity and (S_next_D >= 0.5*capacity or S_next_D >= 0.8*S_t):
      action = D  # skim
    elif (last_k >= ceil((n-1)/2)) or (p_def >= 0.5) or (S_t <= 0.2*capacity and p_def > 0.25):
      mode = "PUNISH"
      punish_timer = 2 if p_def < 0.75 else 3
      action = D
    elif S_t <= 0.2*capacity and p_def <= 0.25:
      action = C  # rebuild only if others are restrained
    else:
      action = C if (S_t < 0.5*capacity or p_def > 0.4) else D

  play(action)

  # observe others' actions after round
  k = number_of_defectors_among_others
  p_def = 0.4*(k/(n-1)) + 0.6*p_def  # EWMA
  last_k = k

  if mode == "PROBE":
    mode = "SKIM" if p_def <= 0.25 else "PUNISH"
    if mode == "PUNISH":
      punish_timer = 2

  if mode == "PUNISH":
    punish_timer -= 1
    if punish_timer <= 0:
      mode = "RECOVER"
  if mode == "RECOVER" and S_t >= 0.5*capacity and p_def <= 0.25:
    mode = "SKIM"
```

---

If you want, I can (a) compute the steady-state “sweet spot” stock level implied by your specific `n` and `capacity`, and (b) tighten the skim condition to target that fixed point more precisely (more exploitation without triggering collapse).
'''

description_EXPLOITATIVE_87 = '''
### Strategy: **Stock-Leverage Extortion (SLE)**  
Exploit others by (i) keeping the stock high enough that *your* defection is very profitable, (ii) punishing any opponent who tries to free-ride on you, and (iii) “farming” cooperators while letting chronic defectors collapse the resource (and then taking what’s left).

This is an extortionate, state-aware variant of “grim/forgiving trigger” tuned to the stock dynamics.

---

## Key quantities you compute each round

Let:
- `S_t` = current stock at start of round `t`
- `h_{t-1}` = history of last round actions
- `d_{t-1}` = number of opponents who defected last round (i.e., played `D`)
- `p_def_j` = estimated defection rate of opponent `j` (EWMA / rolling window)

**Critical stock threshold**: keep the pool in the “high-growth, sustainable” region where cooperation regenerates back toward capacity.  
A simple robust choice is:

- `S_safe = capacity / 2`  
At `S_remaining = capacity/2`, growth is maximized. If the post-consumption stock stays near that region, the pool refills strongly.

Because you don’t directly choose total consumption, you use this threshold to decide whether to **invest** (cooperate to rebuild) or **harvest** (defect to extract).

---

## Intuition: how you exploit
- When others tend to cooperate, you **defect** to take double per-round payoff.
- If others start defecting, you **punish** by defecting too (making defection unprofitable long-term) and/or by temporarily cooperating only when it benefits you by restoring future harvest opportunities.
- You never “reward” unconditional defectors. You only rebuild stock when there’s evidence opponents will let you harvest later.

---

## Decision rules (C vs D)

### Rule 0 — Last round
- **If `t == r` (final round): play `D` always.**  
No future to protect; take max extraction.

---

### Rule 1 — First round (information-gathering but exploit-ready)
- **If `t == 1`: play `D`.**  
You immediately test whether others will tolerate exploitation. If they still cooperate, you’ve found victims.

(Only exception: if `capacity` is extremely close to `2n` and collapse risk is immediate; but your spec says `capacity ≥ 2n`, so defaulting to `D` is fine.)

---

### Rule 2 — Emergency conservation when stock is low
When stock gets too low, defecting yields little anyway, and you may want to rebuild *only if it will later pay off*.

Define:
- `S_crit = 0.25 * capacity` (very low)
- `S_rebuild = 0.50 * capacity` (target region)

**If `S_t <= S_crit`:**
- Play `C` **only if** opponents are not mostly defectors, i.e. `d_{t-1} <= n/2` *and* the estimated average defection rate is not too high:  
  `avg(p_def_j) <= 0.5`
- Otherwise play `D` (let it burn; don’t subsidize defectors).

This is exploitative: you rebuild the commons only when you expect to later exploit cooperative types.

---

### Rule 3 — Extortion mode when stock is healthy (main mode)
If `S_t > S_crit`:

1) **If last round had any defection by opponents (`d_{t-1} > 0`): Punish**
- Play `D` for the next `L` rounds, where:
  - `L = 1 + floor(r/10)` (small but meaningful), **or** until you observe a full-cooperation round by opponents.
- After punishment, require a “clean” round from them to resume investing.

This makes you costly to exploit: anyone who defects triggers a period where you also defect, pushing stock down and reducing everyone’s future payoff.

2) **If last round opponents all cooperated (`d_{t-1} == 0`): Harvest**
- Play `D` as long as stock remains healthy: `S_t >= S_safe`
- If your repeated defection begins to drive stock below `S_safe`, switch to `C` for exactly 1 round (a cheap “reinvestment”), then return to harvesting (`D`) if they keep cooperating.

So against cooperators you alternate in a way that keeps the pool from collapsing too fast, while you extract more than they do.

---

## Edge cases & special handling

### Near-endgame (last ~20% rounds)
In the final segment, future matters less.

Let `t >= ceil(0.8*r)`:
- If `S_t >= S_safe`: play `D` always (maximize extraction).
- If `S_t < S_safe`: play `D` unless you believe a single `C` will lift future extraction in remaining rounds **and** opponents are mostly cooperative. Concretely:
  - Play `C` only if `d_{t-1} == 0` and `S_t` is just below `S_safe` (e.g., `0.4*capacity <= S_t < 0.5*capacity`), otherwise `D`.

### Against unconditional defectors
You detect them quickly via `p_def_j` close to 1.
- If `avg(p_def_j) >= 0.8`: always play `D` from then on.  
No reason to invest.

### Against unconditional cooperators / naive strategies
- You mostly play `D`, with occasional single-round `C` “maintenance” when stock approaches the danger zone, to keep the exploitation going longer.

### Against reciprocators (Tit-for-Tat-like)
Your punishment rule makes them cautious about defecting. Once they establish cooperation, you harvest until stock pressure forces a brief reinvestment. Many reciprocators will keep cooperating if they key mainly off “did you defect last time”; your controlled pattern is designed to exploit that while preventing total collapse.

---

## Pseudocode (implementable)

```pseudo
initialize:
  punish_timer = 0
  for each opponent j: p_def_j = 0.5

parameters:
  S_crit = 0.25 * capacity
  S_safe = 0.50 * capacity
  L_base = 1 + floor(r / 10)
  alpha = 0.2   # EWMA update rate

for round t = 1..r:
  observe current stock S_t
  if t == r: return D

  if t == 1: return D

  # update beliefs from last round
  d_last = count_opponents_who_played_D(t-1)
  for each opponent j:
      p_def_j = (1-alpha)*p_def_j + alpha*(action_j_last == D ? 1 : 0)
  avg_def = average_j(p_def_j)

  # manage punishment state
  if d_last > 0:
      punish_timer = max(punish_timer, L_base)

  if punish_timer > 0:
      punish_timer -= 1
      return D

  # emergency low-stock handling
  if S_t <= S_crit:
      if d_last <= n/2 AND avg_def <= 0.5:
          return C
      else:
          return D

  # main extortion / harvesting logic
  if d_last == 0:
      if S_t >= S_safe:
          return D
      else:
          # cheap reinvestment to keep the farm alive
          return C
  else:
      # (shouldn’t reach here due to punish_timer, but safe fallback)
      return D
```

---

## Why this is exploitative and robust
- **Exploitative:** defaults to defection, harvests cooperative opponents, only “invests” in the stock when it increases your future ability to harvest.
- **Robust:** punishes any defection, refuses to subsidize defect-heavy populations, adapts via simple defection-rate estimates.
- **State-aware:** uses stock thresholds to avoid accidentally destroying its own future profit stream against cooperators (a common failure mode of naive “always defect” bots).

If you want, I can tune the thresholds (`S_crit`, `S_safe`) and punishment length `L` analytically as a function of `n` and the logistic growth term to better match the exact sustainability boundary.
'''

description_EXPLOITATIVE_88 = '''
Below is an **exploitative “Harvest–Probe–Punish”** strategy designed for a finite-horizon, stock-dependent CPR game. It aims to (i) keep the resource productive when it benefits you, (ii) **take extra when others allow it**, and (iii) **rapidly crash the stock when others won’t support sustainability**, because in that case your best response is to front-load payoffs.

Key idea: In this game, **C** is “sustainable half-take” and **D** is “full-take.” You can’t take more than D, so exploitation is about **(a)** inducing/keeping others on C while you sometimes play D, and **(b)** switching to aggressive extraction when the future is not worth preserving.

---

## Notation (what you track)
At round \(t\), before choosing action, you observe current stock \(S_t\) and history.

Let:
- \(k_{t-1}\) = number of **defectors** among opponents in round \(t-1\) (exclude you)
- \(\hat{k}\) = smoothed estimate of opponent defection level (EWMA)
- \(H\) = “healthy stock” threshold where sustaining matters (defined below)
- \(E\) = “endgame window” length (how many last rounds you always defect)

You can compute last round’s total consumption from observed actions, but you don’t need it; you only need counts of C/D and current stock.

---

## Strategic posture
You operate in **three modes**:

1. **PROBE** (early): test whether the population supports sustainability.
2. **FARM** (mid, if opponents are mostly cooperative): mostly cooperate to keep stock high, but **occasionally defect** when stock is abundant and opponents are cooperating—this is where you “exploit”.
3. **STRIP-MINE** (if opponents defect too much or stock is too low, or in endgame): defect to maximize immediate payoff because future stock won’t be preserved anyway.

---

## Parameterized thresholds (depend only on game parameters)
Define:

- **Healthy stock threshold**:  
  \[
  H = 0.8 \cdot \text{capacity}
  \]
  Intuition: above ~80% capacity, the pool is robust; you can sometimes take more without immediate collapse.

- **Critical stock threshold**:  
  \[
  L = 0.35 \cdot \text{capacity}
  \]
  Intuition: below this, the logistic growth may not recover quickly enough if there’s meaningful defection; defecting is often the dominant “get it now” move unless you see strong cooperation.

- **Endgame window** (finite-horizon backward-induction pressure):  
  \[
  E = \max\{2,\ \lceil 0.1r \rceil\}
  \]
  Last \(E\) rounds you assume cooperation is fragile and you defect.

- **Opponent defection tolerance**:
  - “Mostly cooperative” if \(\hat{k} \le 0.2(n-1)\)
  - “Hostile” if \(\hat{k} \ge 0.5(n-1)\)

Update smoothed defection estimate:
\[
\hat{k} \leftarrow 0.6\hat{k} + 0.4 k_{t-1}
\]
Initialize \(\hat{k}=0\).

---

## Decision rules (when to C vs D)

### Rule 0: Last rounds (exploit endgame)
If \(t > r - E\): **Play D**.

Rationale: With a known end, future stock has sharply reduced strategic value; you want to **front-load** payoff and deny others the benefit of your restraint.

---

### Rule 1: First round (set a baseline without sacrificing too much)
Round 1:
- If \(r \le 4\): **D** (short games: exploit immediately).
- Else: **C** (probe; you lose only the “extra half” vs D once, but you learn who’s willing to sustain the pool).

---

### Rule 2: Stock is critically low (salvage / cut losses)
If \(S_t \le L\):
- If \(\hat{k} \le 0.2(n-1)\) (opponents mostly cooperate): **C** (attempt recovery; you can benefit later).
- Else: **D** (strip-mine—resource likely doomed, take what’s left).

---

### Rule 3: Opponents are hostile (don’t be the sucker)
If \(\hat{k} \ge 0.5(n-1)\): **D**.

Rationale: When many opponents defect, your cooperation mostly subsidizes their larger take while the stock collapses anyway.

---

### Rule 4: Exploit when stock is healthy and opponents are cooperative
If \(S_t \ge H\) and \(\hat{k} \le 0.2(n-1)\):
- **Play D with probability \(p_{\text{exploit}}\)**, else C.

Where:
\[
p_{\text{exploit}} = \min\left(0.35,\ 0.10 + 0.25\cdot\frac{S_t - H}{\text{capacity} - H}\right)
\]
So at \(S_t = H\), you defect ~10% of the time; near capacity you defect up to 35%.

Rationale: When stock is abundant and others cooperate, defecting yields a **direct 2× payoff** this round compared to C, and the pool can often regenerate. Mixing avoids becoming predictably exploitable by “grim trigger” types while still extracting surplus.

---

### Rule 5: Otherwise (default sustainability with opportunistic response)
In all other cases:
- If last round opponents had **zero** defectors ( \(k_{t-1}=0\) ): **C** (keep them calm and the pool productive).
- If \(k_{t-1}\ge 1\): **D** for one round (“bite back”), then reassess next round via \(\hat{k}\).

Rationale: One-round retaliation discourages opportunists and prevents you from being repeatedly milked, but it’s not so unforgiving that it collapses cooperative groups permanently.

---

## Edge-case handling
1. **Very small capacity relative to n**: you’re told capacity ≥ 2n, so stock won’t be trivially tiny at capacity; still, the thresholds scale with capacity, so behavior stays stable.
2. **Stock hits 0**: all actions pay 0. Still:
   - If not in endgame, play **C** (it weakly helps recovery if others also C; D provides no benefit).
   - In endgame window, play **D** (doesn’t matter, but keeps policy consistent).
3. **Opponents alternate / are noisy**: smoothing \(\hat{k}\) prevents overreacting to one-off defections while Rule 5 still punishes immediate opportunism.
4. **If you observe a “mostly cooperative” population but occasional defectors**: your occasional D in Rule 4 extracts surplus; your retaliation in Rule 5 discourages repeated defection.

---

## Pseudocode (implementable)
```python
# Parameters: n, r, capacity
H = 0.8 * capacity
L = 0.35 * capacity
E = max(2, ceil(0.1 * r))

hat_k = 0.0  # smoothed opponent defections estimate

def choose_action(t, S_t, opp_actions_prev):  # opp_actions_prev None on t=1
    global hat_k
    if t == 1:
        if r <= 4:
            return "D"
        else:
            return "C"

    k_prev = count_defectors(opp_actions_prev)  # among n-1 opponents
    hat_k = 0.6 * hat_k + 0.4 * k_prev

    # Rule 0: Endgame
    if t > r - E:
        return "D"

    # If stock is zero, C weakly dominates except endgame (already handled)
    if S_t <= 0:
        return "C"

    # Rule 2: Critical stock
    if S_t <= L:
        if hat_k <= 0.2 * (n - 1):
            return "C"
        else:
            return "D"

    # Rule 3: Hostile opponents
    if hat_k >= 0.5 * (n - 1):
        return "D"

    # Rule 4: Healthy stock + cooperative opponents => opportunistic exploitation
    if S_t >= H and hat_k <= 0.2 * (n - 1):
        p = min(0.35, 0.10 + 0.25 * (S_t - H) / (capacity - H))
        return "D" if random() < p else "C"

    # Rule 5: Default with immediate retaliation
    if k_prev == 0:
        return "C"
    else:
        return "D"
```

---

## Why this is exploitative (not “nice”)
- **It defects in the endgame** unconditionally to cash out and deny others future benefits.
- **It defects opportunistically when the pool is healthy and opponents are cooperative**, extracting higher per-round payoff while relying on others’ restraint to keep the stock productive.
- **It refuses to subsidize defect-heavy groups** and switches quickly to strip-mining when sustainability is unlikely.

If you want it *more* exploitative, increase `p_exploit` cap from 0.35 to ~0.5 and reduce the “critical stock cooperate” condition; if you want it *more robust* to triggers, reduce `p_exploit` and increase retaliation frequency.
'''

description_EXPLOITATIVE_89 = '''
Below is an explicitly exploitative, history-dependent policy designed to (i) harvest high payoffs when others keep the stock healthy, (ii) punish and quickly shut down “free-riding” opponents, and (iii) avoid being the only cooperator propping up the resource.

The key idea: **cooperate only when you have evidence that enough others are cooperating to keep the stock near capacity; otherwise defect.** When cooperation is sustaining the pool, you “tax” it by defecting as much as you can without collapsing it; when it isn’t sustaining, you defect to take what’s left.

---

## Intuition / targets

Let:
- \(S_t\) = stock at start of round \(t\)
- \(c_C = S_t/(2n)\), \(c_D = S_t/n\)
- Let \(k_t\) = number of cooperators among the *other* \(n-1\) players in round \(t\) (observable after the round).

**Stock after consumption** if you play action \(a\) and \(k\) others cooperate:
- If you play **C**: remaining fraction \(x_C = 1 - \frac{k+1}{2n} - \frac{n-1-k}{n} = \frac{k+1}{2n}\)
- If you play **D**: remaining fraction \(x_D = 1 - \frac{k}{2n} - \frac{n-k}{n} = \frac{k}{2n}\)

So the remaining stock is:
- \(S_{\text{rem}} = S_t \cdot \frac{k+1}{2n}\) if you play C
- \(S_{\text{rem}} = S_t \cdot \frac{k}{2n}\) if you play D

Growth is logistic and strongest around mid-level; but crucially, **if \(S_{\text{rem}}=0\), growth is 0**. So you must avoid being in regimes where everyone defects (or near that), but you also don’t want to be the one “funding” recovery.

A simple robust criterion is to require that, **excluding you**, there are “enough” cooperators to keep the pool from drifting downward.

---

## Strategy: “Ruthless Stabilizer (RS)”

### State kept by the strategy
Maintain:
- `k_last`: # of cooperators among others in previous round
- `good_streak`: consecutive rounds where others’ cooperation met your sustainability threshold
- `bad_streak`: consecutive rounds where it did not
- `punish_timer`: integer countdown; while > 0 you defect regardless (except some endgame rules)
- `suspicion`: running estimate of how exploitative opponents are (optional but useful)

All derived only from observed actions and stock.

---

## 1) Decision rules (cooperate vs defect)

### A. Compute a cooperation threshold
Define a threshold on how many *other* cooperators you require before you “help”:

- Let  
  \[
  k_{\min} = \left\lceil \frac{n}{2} \right\rceil
  \]
Rationale: with at least ~half cooperating, the remaining stock fraction stays away from zero and growth can replenish; with fewer, the pool tends to get driven down and you don’t want to subsidize it.

You can make this slightly more conservative when the stock is already low:
- If \(S_t < 0.4 \cdot \text{capacity}\), set  
  \[
  k_{\min} = \left\lceil \frac{n+1}{2} \right\rceil
  \]
(because recovery is fragile and a single defection hurts more).

### B. Main action rule
At the start of round \(t\) (given \(S_t\) and history), choose:

**Rule 1: Endgame defection**
- If \(t = r\): play **D**.
- If \(t = r-1\) and \(S_t \ge 0.6\cdot \text{capacity}\): play **D** (harvest while stock is high; one round left for others to regret).

**Rule 2: Punishment mode**
- If `punish_timer > 0`: play **D**, decrement timer.

**Rule 3: Exploit when others sustain**
- If in the previous round, `k_last >= k_min` (enough others cooperated):
  - Play **D** by default (you “tax” their cooperation).
  - Exception (anti-collapse safeguard): if \(S_t < 0.25\cdot \text{capacity}\), play **C** *only* if `k_last` was at least \(k_{\min}+1\). Otherwise still **D**.

**Rule 4: Don’t be the sucker**
- If `k_last < k_min`:
  - Play **D**.
  - Also set `punish_timer = P` where \(P\) is small but nontrivial, e.g.  
    \[
    P = 2
    \]
    (You defect for the next two rounds no matter what; this makes you hard to “string along” with occasional cooperation.)

**Rule 5: Bootstrapping cooperation (rare)**
If history is uninformative (first round) or chaotic, you need one probing move:
- If \(t=1\): play **C** (probe whether there is a cooperative field to exploit later).
- If stock is very high and you have seen alternating behavior, you can “test” once:
  - If \(S_t \ge 0.9\cdot \text{capacity}\) and `bad_streak` is exactly 1 (i.e., one bad round after a long good streak), play **C** once to see if that restores others’ cooperation. If it doesn’t, go back to punishment.

This ensures you don’t permanently miss a profitable cooperative environment, but you minimize time spent subsidizing.

---

## 2) Edge cases

### First round
- **Round 1: C** (probe).
  - You give up some immediate payoff relative to D, but you buy information: is there a cooperative majority you can exploit in rounds 2..(r-1)?
  - If everyone else defects, the pool collapses regardless; one cooperative probe doesn’t change that much but helps you classify the population.

### Last round
- **Always D.** No future stock value.

### Low stock regimes
- If \(S_t\) is already very low (e.g. \(S_t < 0.1 \cdot \text{capacity}\)):
  - **Always D**. When the pool is near dead, cooperation mostly gifts value to others with little chance of recovery unless others massively cooperate; you refuse to be the recovery engine.

### Near-capacity regimes
- If \(S_t \ge 0.9 \cdot \text{capacity}\):
  - Prefer **D** unless you are trying the single “test” after one bad round.
  - This is where exploiting yields the most.

### Small n (n=2 or 3)
- For n=2: \(k_{\min}=\lceil 1 \rceil =1\). That means: if the other cooperated last round, you defect (exploit); if they defected, you defect (punish). This becomes “probe C once, then mostly D”, which is appropriate for exploitative play.
- For n=3: \(k_{\min}=2\). You only “consider helping” if both others cooperated; otherwise you defect.

---

## 3) Why this is exploitative and robust

### Exploitative
- Whenever the group demonstrates it can sustain the resource (enough cooperators), you **switch to D** to take double the per-round payoff relative to C.
- You only cooperate to (a) probe early, or (b) prevent a collapse that would reduce *your own* future ability to exploit.

### Robust
- Against unconditional cooperators / naive sustainers: you harvest high payoffs while they keep stock high.
- Against defectors: you defect quickly and stop donating; you don’t get bled by sucker’s payoffs.
- Against conditional cooperators (tit-for-tat-like): your punishment timer makes you “tough”, often forcing them either into cooperation (which you then exploit) or into mutual defection (which you accept).
- Against noisy or chaotic strategies: the threshold and punishment timer prevent you from oscillating into being the main supporter.

---

## Pseudocode (implementable)

```python
# Parameters: n, r, capacity
# Inputs each round t: S_t (current stock), history of actions from previous rounds

k_min_base = ceil(n/2)

punish_timer = 0
k_last = None
good_streak = 0
bad_streak = 0

for t in 1..r:

    # endgame
    if t == r:
        action = "D"
        play(action); continue
    if t == r-1 and S_t >= 0.6 * capacity:
        action = "D"
        play(action); continue

    # round 1 probe
    if t == 1:
        action = "C"
        play(action); continue

    # update threshold by stock regime
    k_min = k_min_base
    if S_t < 0.4 * capacity:
        k_min = ceil((n+1)/2)

    # punishment mode
    if punish_timer > 0:
        action = "D"
        punish_timer -= 1
        play(action); continue

    # very low stock: don't subsidize recovery
    if S_t < 0.1 * capacity:
        action = "D"
        play(action); continue

    # decision based on last round others' cooperation count
    if k_last >= k_min:
        # exploit: defect unless stock is fragile and cooperation was very strong
        if S_t < 0.25 * capacity and k_last < (k_min + 1):
            action = "D"
        else:
            action = "D"
    else:
        # punish / refuse to be sucker
        action = "D"
        punish_timer = 2

    # rare one-shot test after a single bad round following good environment
    if (S_t >= 0.9 * capacity) and (bad_streak == 1) and (good_streak >= 3):
        action = "C"   # single test
        punish_timer = 0

    play(action)

    # after round, observe others' actions to update k_last, streaks
    k_last = count_cooperators_among_others(t)
    if k_last >= k_min:
        good_streak += 1
        bad_streak = 0
    else:
        bad_streak += 1
        good_streak = 0
```

---

### Notes you can tweak (without changing the core exploitative nature)
- Increase `punish_timer` to 3 if you expect many opportunists; decrease to 1 if you expect many conditional cooperators you want to re-exploit quickly.
- Adjust the stock cutoffs (0.4, 0.25, 0.1, 0.9) depending on capacity and observed stability; they’re deliberately coarse and parameter-only.

This policy is not “nice”; it is designed to **extract value whenever the population makes extraction feasible**, while minimizing time spent propping up the commons when others won’t.
'''

description_EXPLOITATIVE_90 = '''
### Strategy: **Sustainable Extortion with Stock-Guard (SESG)**  
Core idea: **farm cooperators and cautious players** by keeping the stock high (so per-round payoffs are large), **but punish** any opponent who defects enough to threaten stock collapse. You cooperate only when it’s profitable to keep the “resource machine” running; otherwise you defect—especially near the end.

This is exploitative because:
- When others cooperate, you frequently **defect to take 2× their per-round share** while preserving sustainability.
- When others defect, you **switch to punishment** to make defection unprofitable (or at least not better than matching you).
- You pivot to **endgame extraction** regardless of history.

---

## Key quantities (computed each round)

Let:
- `S` = current stock at start of round  
- `n` = players  
- In previous round, observe `kD` = number of other players who defected (excluding you). (For round 1, unknown.)

**Consumption amounts given stock S:**
- If you play `C`: you take `S/(2n)`
- If you play `D`: you take `S/n`

**Total consumption if exactly `m` players defect (out of n):**
\[
\text{consumption fraction} = \frac{m}{n} + \frac{n-m}{2n} = \frac{1}{2} + \frac{m}{2n}
\]
So remaining stock after consumption:
\[
S_{\text{rem}} = S\left(1 - \frac{1}{2} - \frac{m}{2n}\right)= S\left(\frac{1}{2} - \frac{m}{2n}\right) = S\frac{n-m}{2n}
\]

**Sustainability insight:**  
- If **all cooperate** (`m=0`): `S_rem = S/2` which regrows back to capacity (in many cases, including the example).  
- If **all defect** (`m=n`): `S_rem=0`, permanent collapse.  
- More defectors → lower `S_rem`, less growth, worse future.

---

## Decision rules (when to Cooperate vs Defect)

The strategy uses three modes:

1) **Harvest mode (exploit)**: defect when stock is healthy and opponents are sufficiently cooperative.  
2) **Guard mode (rebuild/maintain)**: cooperate to keep stock from drifting down when too many defects occurred.  
3) **Punish mode (credible threat)**: defect for a fixed block after detected over-defection to deter it, even if it harms stock short-run.

### Parameters/thresholds (depend only on n, r, capacity)

Define:
- `S_high = 0.85 * capacity` (plenty of buffer)
- `S_low  = 0.55 * capacity` (below this, regeneration is weaker; prioritize recovery)
- Defection tolerance among *others*:
  - `tol_high = floor((n-1)/4)`  (when stock is high, tolerate some defectors)
  - `tol_low  = floor((n-1)/8)`  (when stock is low, tolerate very few)
- Punishment length:
  - `P = max(2, ceil(r/10))` rounds

Also keep:
- `punish_timer` initially 0
- `goodwill` score: start 0; increases when others cooperate, decreases when they defect (details below)

### Main rule each round t

**Rule 0: Endgame extraction**
- If `t == r`: **play D** (last round, no future to protect).
- If `t == r-1` and `S > S_low`: **play D** (second-last round, mostly extract).

**Rule 1: If punishing, keep punishing**
- If `punish_timer > 0`: play **D**, decrement timer.

**Rule 2: Stock-guard when resource is at risk**
- If `S < S_low`: play **C** *unless* you are already in a late endgame (`t >= r-1`), in which case play **D**.

**Rule 3: Trigger punishment after excessive defection**
Compute last round’s `kD` (others’ defections). Let `tol = tol_high if S >= S_high else tol_low`.

- If `kD > tol`: set `punish_timer = P` and **play D** now.

**Rule 4: Otherwise exploit (harvest)**
- If `S >= S_high` and `kD <= tol`: play **D** (harvest while system is healthy).
- Else: play **C** (maintain stability).

This creates a pattern:
- When opponents are mostly cooperating and stock is high: you often defect and earn more.
- When they start defecting too much: you punish immediately.
- When the stock gets low: you cooperate to keep the “farm” alive (so you can keep exploiting later).

---

## Updating history variables (adaptive robustness)

Maintain a simple opponent “cooperativeness estimate”:
- After each round, observe `kC = (n-1) - kD`.
- Update `goodwill += (kC - kD)` (net cooperation among others).
- Optionally cap: `goodwill = clamp(goodwill, -5n, 5n)`.

Then modify tolerance slightly:
- If `goodwill` is strongly positive, increase tolerance by 1 (you can safely keep harvesting).
- If strongly negative, decrease tolerance by 1 (become stricter faster).

Concrete:
- If `goodwill > n`: `tol += 1`
- If `goodwill < -n`: `tol -= 1`
- Clamp `tol` to `[0, n-1]`.

This makes the strategy robust:
- Against mostly-cooperative groups: you defect more often without collapsing the resource.
- Against opportunists: you punish faster and longer.
- Against chaotic strategies: the stock guard prevents self-destruction where possible, but the endgame still extracts.

---

## Edge cases (explicit)

### Round 1 (no history)
- If `r` is small (e.g., `r <= 3`): **play D** immediately (little future value).
- Else:
  - If `capacity` is high and you start at `S=capacity` (given): **play D** in round 1 to test the field and take early surplus.
  - Exception: if `n` is very small (`n=2`), round-1 defection can collapse stock quickly if the other also defects. For `n=2`, play **C in round 1**, then switch to rules above from round 2.

### Stock at/near zero
- If `S` is extremely low (e.g., `S < capacity/(10n)`): your immediate payoff is tiny either way. Prefer **C** unless in last round(s), because rebuilding is the only way to regain meaningful payoffs.

### Everyone defects persistently
- You cannot save the stock alone. Best response is usually to **defect** (match collapse rather than donate). The punishment mode effectively becomes permanent, which is fine: you’re not being exploited.

### Everyone cooperates persistently
- You repeatedly **defect in harvest mode** when `S` is high, extracting 2× cooperator payoff while the system tends to recover. If your defection begins to reduce stock (because others start copying), the guard/punish logic kicks in.

---

## Pseudocode (implementation-ready sketch)

```pseudo
initialize punish_timer = 0
initialize goodwill = 0

for t in 1..r:
    observe S

    if t == r:
        action = D
        play(action)
        continue

    if t == r-1 and S > 0.55*capacity:
        action = D
        play(action)
        continue

    if t == 1:
        if n == 2 and r > 3:
            action = C
        else if r <= 3:
            action = D
        else:
            action = D
        play(action)
        continue

    # from t >= 2 we have history
    kD = number of other players who played D in round t-1
    kC = (n-1) - kD
    goodwill = clamp(goodwill + (kC - kD), -5*n, 5*n)

    if punish_timer > 0:
        punish_timer -= 1
        action = D
        play(action)
        continue

    if S < 0.55*capacity:
        action = C
        play(action)
        continue

    tol = floor((n-1)/4) if S >= 0.85*capacity else floor((n-1)/8)
    if goodwill > n: tol += 1
    if goodwill < -n: tol -= 1
    tol = clamp(tol, 0, n-1)

    if kD > tol:
        punish_timer = max(2, ceil(r/10))
        action = D
    else:
        if S >= 0.85*capacity:
            action = D   # harvest
        else:
            action = C   # maintain
    play(action)
```

---

## Why this is exploitative and tournament-robust
- **Exploitative:** defaults to defecting whenever the resource can “afford it,” extracting higher payoffs from cooperative opponents.
- **Adaptive:** uses observed defection rates to decide whether it’s safe to keep harvesting or necessary to punish/guard.
- **Robust:** prevents getting milked by defectors (punish mode), avoids needless collapse when recovery is feasible (guard mode), and still cashes out in the endgame.

If you want, I can also provide a variant tuned for specific tournament meta-goals (e.g., maximize average payoff vs maximize probability of winning rounds, or risk-seeking vs risk-averse extraction).
'''

description_EXPLOITATIVE_91 = '''
Below is an *exploitative* “harvest-then-punish” strategy designed for your CPR game. It tries to (i) keep the stock high enough that there is something valuable to take, (ii) induce/lock-in others into cooperating when possible, and then (iii) defect as much as possible whenever it is safe or profitable—while (iv) responding quickly to exploitation by others so you don’t become the sucker.

---

## Core idea

- **The stock is the pie.** If it collapses to ~0, nobody can extract anything later.
- **Defection is individually better *this round* given S**, but it can destroy S and future payoffs.
- So the exploitative plan is:
  1. **Test** whether the group is “cooperation-capable” (i.e., whether most players choose C when the stock is healthy).
  2. If yes, **free-ride** (defect) while keeping stock above a safety threshold by only occasionally cooperating.
  3. If no, **cash out**: defect aggressively while stock is still positive, because long-run sustainability is unlikely.

This creates a strategy that exploits cooperative populations but doesn’t bleed out against defect-heavy ones.

---

## Key quantities you can compute each round

At round \(t\), you observe previous round actions, and you know current stock \(S_t\).

Let:
- \(c_{-i,t-1}\) = number of **other** players who cooperated last round  
- \(d_{-i,t-1} = (n-1) - c_{-i,t-1}\)
- \(c_{t-1}\) = total cooperators last round including you (easy to compute from history)
- **Estimated total consumption rate** last round:
  \[
  \text{consumption fraction} = \frac{c_{t-1}}{2n} + \frac{n-c_{t-1}}{n} = 1 - \frac{c_{t-1}}{2n}
  \]
  so remaining stock fraction after consumption is \(\frac{c_{t-1}}{2n}\).

Also define a “cooperation propensity estimate” of opponents:
- \(p_t = \) exponentially weighted average of \(c_{-i}/(n-1)\) over recent rounds (details below). This measures whether you can farm cooperators.

---

## Decision rules (cooperate vs defect)

### 0) Stock safety thresholds
You need a stock floor below which any further defection risks collapse.

Use two thresholds:

- **Critical threshold** \(S_{\text{crit}}\): below this, *always cooperate* to try to regrow the stock.
  - Set:  
    \[
    S_{\text{crit}} = \max\left( \frac{\text{capacity}}{6}, \; 2n \right)
    \]
  Intuition: below capacity/6, logistic growth is weaker and collapse risk rises; also \(2n\) is the game’s stock scale lower bound mentioned.

- **Comfort threshold** \(S_{\text{high}}\): above this, you can afford exploitation.
  - Set:
    \[
    S_{\text{high}} = \frac{\text{capacity}}{2}
    \]
  Intuition: around \(S=\frac{K}{2}\) logistic growth is maximal; you can “farm” sustainably.

These are parameter-only and robust.

---

### 1) Round 1 (bootstrapping / probe)
**Play C in round 1** unless \(r\) is extremely small (handled below).

Reason: you learn whether others are willing to cooperate *without* immediately nuking the stock. Also starting at capacity, all-D collapses instantly; you don’t want to be the one who triggers immediate doom against potentially cooperative fields if you can instead exploit them later.

Exception (short horizon):
- If \(r=2\): **Play D in round 1** (backward induction-like cash-out; too little time to benefit from sustainability).
- If \(r=3\): play C in round 1 but be much more willing to cash out in round 2 if others defect.

---

### 2) Main mode selection each round (after round 1)
After observing history up to \(t-1\), classify the environment:

Compute opponent cooperation rate estimate:
- Maintain \(p_t\) with EWMA:
  \[
  p_t = (1-\alpha)p_{t-1} + \alpha\cdot \frac{c_{-i,t-1}}{n-1}
  \]
  with \(\alpha=0.3\) (reacts within ~3–5 rounds).

Now choose a mode:

#### Mode A: **Exploit/Farm** (others are cooperative enough)
Enter/Stay in this mode if both:
- \(p_t \ge 0.6\) (most others often cooperate), and
- \(S_t \ge S_{\text{crit}}\)

**Action rule in Mode A (exploitative but sustainable):**
- If \(S_t \ge S_{\text{high}}\): **Play D** (harvest).
- If \(S_{\text{crit}} \le S_t < S_{\text{high}}\):
  - If last round had **any** defector among opponents (i.e., \(d_{-i,t-1}>0\)): **Play C** for one round (stabilize stock and avoid collapse spiral).
  - Else (all others cooperated): **Play D** (pure free-ride).
This creates a pattern: you defect whenever the stock is healthy or the group is fully cooperative, and you only “pay” cooperation when stock is drifting down or defection appears and threatens sustainability.

**Why exploitative?** In cooperative groups, you will defect in many rounds (often most), earning double the per-round payoff of cooperators while keeping the resource from collapsing by occasional “maintenance” cooperation.

#### Mode B: **Punish/Reset** (others are not cooperative)
Enter if either:
- \(p_t < 0.6\), or
- you see persistent defection: \(d_{-i,t-1} \ge \lceil (n-1)/2 \rceil\) in 2 of last 3 rounds.

**Action rule in Mode B:**
- If \(S_t > S_{\text{crit}}\) and there are enough rounds left to benefit from recovery:
  - **Play C for exactly L rounds**, where \(L=2\), to see if others follow (a “reset attempt”).
  - After those 2 rounds:
    - If opponent cooperation jumps (e.g., \(c_{-i}\ge \lceil 0.7(n-1)\rceil\) in the second reset round): switch to Mode A.
    - Else: go to Mode C (cash-out).
- If \(S_t \le S_{\text{crit}}\): **Play C** (you can’t profit from D anyway; try to regrow).
  
This prevents you from wasting the entire game in mutual defection when there is some chance opponents can be pulled into cooperation.

#### Mode C: **Cash-out** (exploit what’s left)
Enter if:
- reset attempts fail, or
- \(t\) is late (see endgame), or
- opponents are clearly defect-dominant: \(p_t \le 0.3\).

**Action rule in Mode C:**
- If \(S_t > 0\): **Play D** every round.
- If \(S_t = 0\): indifferent; play D.

**Why exploitative?** You stop subsidizing an uncooperative population and take maximal immediate payoff.

---

## Edge cases

### Last round
**Always play D in the final round** (round \(r\)).  
No future stock to protect.

### Last 2–3 rounds (endgame cash-out)
Define remaining rounds: \(R = r - t + 1\).

If \(R \le 2\): **Play D** regardless of mode, unless \(S_t=0\) (doesn’t matter).
If \(R = 3\): play D unless \(S_t \le S_{\text{crit}}\) and you expect opponents to cooperate strongly (i.e., \(p_t\ge 0.8\)); otherwise D.

Rationale: late cooperation mainly benefits others (keeps stock up for future rounds that won’t happen).

### Very low stock
If \(S_t \le S_{\text{crit}}\): **Play C** (except final round).  
This is “resource resuscitation”: defecting at low S yields small gain and tends to lock in 0 for remaining rounds.

### Very small horizons
- \(r=2\): D then D.
- \(r=3\): C then mostly D (switch to cash-out quickly unless opponents are extremely cooperative and stock is very low).

---

## Pseudocode (implementable)

```python
# parameters: n, r, capacity
alpha = 0.30
S_crit = max(capacity/6.0, 2*n)
S_high = capacity/2.0

# state variables maintained by strategy
p = 0.5                 # EWMA estimate of others' cooperation rate
mode = "BOOT"           # BOOT, FARM, PUNISH, CASH
reset_count = 0         # counts C rounds in reset attempt
recent_def_majority = deque(maxlen=3)  # store booleans

def decide(t, S, history):
    global p, mode, reset_count

    R = r - t + 1

    # Endgame
    if R <= 2:
        return "D"
    if t == r:
        return "D"

    # Round 1
    if t == 1:
        if r == 2:
            mode = "CASH"
            return "D"
        mode = "BOOT"
        return "C"

    # Update estimates from last round
    c_others = count_others_C(history[t-1])
    p = (1-alpha)*p + alpha*(c_others/(n-1))

    def_majority = ( (n-1 - c_others) >= ((n-1)+1)//2 )
    recent_def_majority.append(def_majority)

    # Low stock safety
    if S <= S_crit:
        mode = "PUNISH"  # effectively recovery
        return "C"

    # Mode transitions
    if mode in ["BOOT", "FARM"]:
        if p >= 0.6:
            mode = "FARM"
        else:
            mode = "PUNISH"
            reset_count = 0

    if mode == "PUNISH":
        # if persistent defection majority, go cash faster
        if sum(recent_def_majority) >= 2 and p < 0.6:
            mode = "CASH"

    # Action by mode
    if mode == "FARM":
        if S >= S_high:
            return "D"
        else:
            # S in (S_crit, S_high)
            if (n-1 - c_others) > 0:
                return "C"  # stabilize when any defection appears
            else:
                return "D"  # free-ride on full cooperation

    if mode == "PUNISH":
        # two-round reset attempt if enough time remains
        if R >= 5 and reset_count < 2:
            reset_count += 1
            return "C"
        else:
            # evaluate success of reset from last observed round
            if c_others >= int(0.7*(n-1) + 0.999):
                mode = "FARM"
                return "D" if S >= S_high else "D"
            else:
                mode = "CASH"
                return "D"

    if mode == "CASH":
        return "D"
```

---

## Why this is robust and exploitative

- **Exploits cooperators:** When others keep the stock healthy (high \(p_t\)), you defect frequently, earning \(S/n\) while they accept \(S/(2n)\).
- **Avoids being the sucker:** Any sustained opponent defection pushes you into punishment/reset, then cash-out.
- **Stock-aware:** You stop defecting when stock is near the danger zone, because “winning the round” is pointless if it zeros the remaining game.
- **Tournament-safe:** No need for communication, identity, or coordination. Uses only parameters, current stock, and observed history.

If you want, I can tune the thresholds (\(S_{\text{crit}}, p\) cutoffs, reset length) for specific \(n, r, capacity\) regimes, or derive a more formal “optimal” maintenance frequency based on expected opponent cooperation.
'''

description_EXPLOITATIVE_92 = '''
## Strategy: **Throttle-and-Harvest (T&H)**  
Exploit the fact that (i) **defection doubles your per-round take** at any given stock, and (ii) the stock has **very strong logistic regrowth** when kept away from zero (especially around mid-to-high stock). The goal is to **free-ride whenever others keep the stock healthy**, but **switch to “repair mode”** when the group is driving the stock toward collapse—so you can keep harvesting over many rounds.

This is not “nice”: it cooperates only to **protect future exploitation opportunities**, and it defects whenever it can do so without killing the golden goose.

---

# 1) Decision rules (C vs D)

### Key quantities you compute from history/state
At round \(t\), with current stock \(S_t\):

- **Last round’s remaining stock after consumption** (can be inferred from observed actions):  
  Let \(k_{t-1}\) = number of defectors in round \(t-1\).  
  Total fraction consumed in that round:
  \[
  \alpha(k)=\frac{k}{n} + \frac{n-k}{2n}=\frac{1}{2}+\frac{k}{2n}
  \]
  So remaining fraction is:
  \[
  \beta(k)=1-\alpha(k)=\frac{1}{2}-\frac{k}{2n}=\frac{n-k}{2n}
  \]
  Thus:
  \[
  R_{t-1} = S_{t-1}\cdot \beta(k_{t-1})
  \]
  (And the game’s growth then maps \(R_{t-1}\) to \(S_t\); you don’t even need to invert it.)

- **Defector rate estimate** (how defect-heavy the table is):  
  Use an exponentially-weighted moving average (EWMA):
  \[
  \rho_t = (1-\lambda)\rho_{t-1} + \lambda\cdot \frac{k_{t-1}}{n}
  \]
  with e.g. \(\lambda=0.3\). Initialize \(\rho_1=0.5\).

- **Stock danger threshold** (when collapse risk is too high):  
  Use two thresholds:
  - “Healthy” if \(S_t \ge 0.8\cdot capacity\)
  - “Danger” if \(S_t \le 0.5\cdot capacity\)  
  (These map well to logistic growth: above ~0.5 capacity, regrowth is still strong; below it, you’re closer to death spirals if others defect.)

### Core rule
You mostly defect, except when stock is in danger **and** opponents are currently defect-heavy.

**Decision at round \(t\):**
1. **Endgame harvest:** if \(t\) is in the last \(L\) rounds, always defect. (details below)
2. Otherwise:
   - If \(S_t \ge 0.8\cdot capacity\): **Defect (D)**  
     Rationale: stock is abundant; even if everyone defects once, you get max extraction now.
   - Else if \(S_t \le 0.5\cdot capacity\):  
     - If \(\rho_t \ge 0.35\): **Cooperate (C)** (“repair mode”)  
       Rationale: table is defecting enough that another D risks pushing stock toward collapse; you invest minimally to keep future rents.
     - Else (others fairly cooperative already): **Defect (D)**  
       Rationale: if others are already repairing, free-ride.
   - Else (mid stock: between 0.5 and 0.8 capacity):
     - If \(\rho_t \ge 0.55\): **Cooperate (C)**  
       Rationale: high defection rate while stock is not huge; cooperate to prevent crash.
     - Else: **Defect (D)**

This produces the intended behavior:
- Against cooperators: you **defect almost always** and farm them.
- Against defectors: you **defect in endgame**, but earlier you **cooperate just enough** to keep the stock from flatlining, so you can keep extracting later (and so you don’t lose to “always defect” by collapsing too early when others aren’t fully defecting).

---

# 2) Edge cases and round-specific handling

### Round 1 (no history)
- If \(r\) is small (e.g. \(r \le 4\)): **Defect** immediately (little future to preserve).
- Otherwise:
  - If initial stock is at capacity (it is): **Defect**.  
    Rationale: you learn who repairs vs who exploits. Defecting at full stock is the best immediate payoff and reveals opponent tendencies.

### Last rounds (finite-horizon exploitation)
Let:
- \(L = \max(2, \lceil 0.15r \rceil)\)  (last 15% of the game, at least 2 rounds)

For all \(t > r-L\): **always defect**.  
Rationale: there is limited future to protect; cooperation cannot pay back enough.

### “Emergency stop” exception (rare)
If stock is extremely low, you might prefer a last-minute salvage **only if there is still time**:
- If \(S_t \le 0.2\cdot capacity\) and \(t \le r-L-1\): **Cooperate** regardless of \(\rho_t\).  
This is purely to prevent total ruin too early when you still have many rounds to monetize.

### If stock hits zero
If \(S_t = 0\): both C and D give 0 now, but you want regrowth and survival.
- If \(t \le r-L-1\): **Cooperate** (try to rebuild if any mechanism allows recovery; even if growth is zero at 0, you lose nothing by “cooperating” and it may matter if implementation has rounding/float effects or if S can become >0 via previous dynamics).
- If in endgame: **Defect** (doesn’t matter).

---

# 3) Why this is exploitative (and robust)

### Exploitative posture
- **Default = Defect**: you take the larger share whenever the stock can support it.
- **Cooperation is instrumental, not moral**: you cooperate only when continued defection risks collapsing the resource **before you can extract more total payoff**.
- **Free-riding on “repairers”**: when others show low defection rate (\(\rho\) low), you defect even in low/mid stock—because they’re already doing the work of sustaining the pool.

### Robustness to opponent types
- **Against always-cooperate / forgiving strategies**: you defect nearly every round → very high payoff.
- **Against conditional cooperators**: your occasional “repair mode” C prevents total breakdown, keeping the interaction profitable; they often resume C, letting you resume D.
- **Against always-defect**: you still defect (especially endgame). Early “repair mode” won’t rescue the pool if everyone is D, but it won’t cost you much relative to inevitable collapse.
- **Against mixed / noisy opponents**: EWMA \(\rho_t\) smooths noise and adapts.

---

# Pseudocode (implementation-ready)

```python
# parameters: n, r, capacity
lambda_ = 0.3
rho = 0.5  # EWMA of defector share

def decide(t, S_t, history):
    # history contains past rounds with k = number of defectors
    L = max(2, ceil(0.15 * r))

    # update rho from last round if exists
    global rho
    if t > 1:
        k_prev = history[t-1].num_defectors
        rho = (1 - lambda_) * rho + lambda_ * (k_prev / n)

    # Endgame harvest
    if t > r - L:
        return "D"

    # Emergency salvage (if still time)
    if S_t <= 0.2 * capacity and t <= r - L - 1:
        return "C"

    # Main regime
    if S_t >= 0.8 * capacity:
        return "D"

    if S_t <= 0.5 * capacity:
        if rho >= 0.35:
            return "C"   # repair mode
        else:
            return "D"   # free-ride on cooperators

    # mid stock
    if rho >= 0.55:
        return "C"
    else:
        return "D"
```

---

If you want, I can tune the numeric thresholds (0.8/0.5/0.2, 0.35/0.55, 15% endgame) specifically as functions of \(n\), \(r\), and capacity (e.g., making the “danger zone” depend on how many rounds remain and on observed regrowth effectiveness).
'''

description_EXPLOITATIVE_93 = '''
## Strategy: **Reservoir Extortion (RE)**  
Goal: keep the stock high enough to keep *your* per-round payoffs large, but systematically take more than “fair share” whenever opponents show any tendency to conserve. Punish quickly when conservation breaks down, and never sacrifice in the endgame.

The core idea is:
- **When the pool is healthy and others aren’t over-extracting**, you often defect to grab the larger share while the system can still recover.
- **When the pool is endangered or others are extracting too much**, you switch to conservation to preserve future value (and to avoid being the sucker who defects into collapse).
- **If opponents cooperate a lot**, you exploit harder.
- **If opponents defect a lot**, you stop feeding the tragedy and switch to “damage control” (mostly C) while taking last-round defection.

This is not “nice”: it treats cooperation by others as a resource to mine.

---

## Key quantities you track each round
Let `S_t` be current stock at start of round `t`.

From last round’s observed actions, compute:
- `kD_{t-1}` = number of opponents who defected last round (ignore your own action)
- `pD_{t-1} = kD_{t-1} / (n-1)` = opponent defection rate last round

Also define stock health:
- `H_t = S_t / capacity` in `[0,1]`

Useful thresholds (parameter-only, no tuning to specific opponents):
- **Safe stock**: `H_t ≥ 0.70`
- **Caution stock**: `0.40 ≤ H_t < 0.70`
- **Danger stock**: `H_t < 0.40`

Rationale: below ~0.5 capacity, the logistic growth is still strong, but extraction can easily push the remaining stock low; below ~0.4, one bad round can cause multi-round recovery or collapse.

---

## Decision rules (cooperate vs defect)

### Rule 0: Last-round grab
If `t == r`: **Play D**.  
Exploit endgame because there is no future stock value to preserve.

---

### Rule 1: First round (establish baseline exploitation)
If `t == 1`:
- If `r` is small (e.g., `r ≤ 3`): **Play D** (short horizon → take now).
- Else (`r > 3`): **Play C** (probe whether others conserve; you can exploit starting round 2).

This is exploitative because “C” in round 1 is an information investment; as soon as you see conservation, you start taking more.

---

### Rule 2: Stock danger overrides everything (preserve the engine)
If `H_t < 0.40` and `t < r`: **Play C**.  
When the pool is in danger, defecting often accelerates collapse and reduces *your own* future take more than the one-round gain.

Exception: if `t == r` already handled by Rule 0.

---

### Rule 3: If opponents are mostly defecting, stop donating
If `pD_{t-1} ≥ 0.50` and `t < r`:
- If `H_t ≥ 0.70`: **Play D** (take while it’s still good; they’re not conserving anyway).
- Else (`H_t < 0.70`): **Play C** (damage control; don’t be one more defector driving it down).

This is exploitative because you do not “reward” defect-heavy groups with your own restraint unless it’s needed to protect your future.

---

### Rule 4: If opponents are mostly cooperating, extort
If `pD_{t-1} ≤ 0.25` and `t < r`:
- If `H_t ≥ 0.70`: **Play D** (pure exploitation: others conserve, you take double).
- If `0.40 ≤ H_t < 0.70`: **Play C** (keep the reservoir from sliding; you can resume exploitation once healthy).

---

### Rule 5: Mixed/uncertain environment (adaptive toggle)
Otherwise (i.e., `0.25 < pD_{t-1} < 0.50`) and `t < r`:
- If `H_t ≥ 0.70`: **Play D** (default to grabbing when safe).
- If `0.40 ≤ H_t < 0.70`: **Play C** (stabilize; in mixed groups, D can tip the system).
- If `H_t < 0.40`: already handled → **C**.

---

## “Forgiveness” and “punishment” mechanics (robustness)
The rules above are already reactive, but add two lightweight memory features to avoid being gamed by oscillators:

### A) Escalation after sudden defection spike
If opponents’ defection rate jumped sharply:
- If `pD_{t-1} - pD_{t-2} ≥ 0.30` (starting from t≥3), then for the next round force:
  - If `H_t < 0.70`: **C** (stabilize)
  - Else: **D** (take before they drain)

This prevents being exploited by “bait-and-switch” strategies that cooperate to build stock then suddenly defect.

### B) Don’t over-conserve forever
If you have played **C** for 3 consecutive rounds **and** `H_t ≥ 0.70`, then play **D** next round regardless of `pD` (unless it’s the last round where you already play D).  
This ensures you convert recovered stock into advantage instead of permanently subsidizing.

---

## Pseudocode (implementable)
```python
def action(t, r, n, capacity, S_t, opp_actions_history):
    H = S_t / capacity

    if t == r:
        return "D"

    if t == 1:
        return "D" if r <= 3 else "C"

    # compute pD last round among opponents
    kD_last = count_defects(opp_actions_history[t-1])  # opponents only
    pD_last = kD_last / (n-1)

    # danger stock override
    if H < 0.40:
        return "C"

    # escalation on defection spike (t >= 3)
    if t >= 3:
        kD_prev = count_defects(opp_actions_history[t-2])
        pD_prev = kD_prev / (n-1)
        if (pD_last - pD_prev) >= 0.30:
            return "D" if H >= 0.70 else "C"

    # main policy
    if pD_last >= 0.50:
        return "D" if H >= 0.70 else "C"

    if pD_last <= 0.25:
        return "D" if H >= 0.70 else "C"  # exploit when safe, stabilize when not

    # mixed
    return "D" if H >= 0.70 else "C"
```

(Plus a small tracker for “3 consecutive C while H≥0.70 → force D” if you want that additional extortion guarantee.)

---

## Edge cases / special scenarios
- **Very small capacity relative to n**: you assumed `capacity ≥ 2n`, so the stock is big enough that early defection can be lucrative, but RE still uses `H` thresholds so it won’t mindlessly drain.
- **Always-defect opponents**: RE defects when stock is high (take what’s available), then switches to C when stock becomes fragile (so you’re not the marginal destroyer), and defects in the final round.
- **Mostly-cooperative opponents**: RE defects heavily at high stock, extracting 2× the cooperator payoff while relying on their restraint to keep the reservoir in the healthy region.
- **Cycle/conditional opponents (e.g., tit-for-tat variants)**: your occasional C in danger/caution zones prevents total breakdown; your D in safe zones captures upside. The spike rule reduces vulnerability to coordinated “build then raid” patterns.

---

## Why this is exploitative
- It **defaults to D whenever the resource can absorb it**, harvesting surplus created by others’ restraint.
- It **only cooperates when cooperation protects your future extraction**, not to be fair.
- It **endgames with defection** unconditionally.
- It is **adaptive**: it uses both *state* (stock health) and *history* (opponent defection rate/spikes) to decide when exploitation is safe versus self-defeating.

If you want an even more predatory variant, you can lower the “Safe stock” threshold from `0.70` to `0.60` to defect more often; the current values are chosen to be robust across many opponent mixes rather than maximally aggressive in any single matchup.
'''

description_EXPLOITATIVE_94 = '''
Below is an **exploitative, stateful “harvest–test–punish” strategy** designed to (i) extract extra payoff whenever others allow it, (ii) avoid being the sucker against defectors, and (iii) keep the resource productive enough to keep exploiting over many rounds. It uses only \((n,r,\text{capacity})\), current stock \(S_t\), and full history.

---

## Core idea

- **Defect is always individually better this round** (you get \(S/n\) vs \(S/(2n)\)).
- But **over-defection collapses future stock**, reducing future opportunities to take large \(S/n\) payoffs.
- So the strategy:
  1. **Maintains stock near capacity** when that increases long-run harvest.
  2. **Defects whenever opponents are cooperative enough** that stock stays high (free-riding).
  3. **Switches to full defection when others defect** (no sucker mode).
  4. **In late rounds, cashes out** (defect regardless).

This is exploitative because it *tries to be the marginal defector*: keep the pool healthy mostly due to others’ restraint, while you take the larger share.

---

## Useful observable: “how many defected last round?”

From history at round \(t-1\), compute:
- \(d_{t-1}\): number of opponents who played \(D\) (or total defectors; you can compute both).
- Total defectors last round \(Dcount_{t-1}\in\{0,\dots,n\}\).

This is fully observable.

Also track:
- \(S_t\): current stock at start of round \(t\).

---

## Stock thresholds (parameter-based)

Define a **safe stock band** where the pool is highly productive and close to capacity:

- \(S_{\text{high}} = 0.90 \times \text{capacity}\)
- \(S_{\text{mid}} = 0.60 \times \text{capacity}\)
- \(S_{\text{low}} = 0.30 \times \text{capacity}\)

Intuition:
- When \(S\) is high, you can defect and still remain in good territory if others don’t all defect.
- When \(S\) is low, any extra consumption risks collapse; but if opponents are already defecting, you don’t “save” it alone—so you defect too.

(These constants are tunable, but fixed values are fine for a tournament setting.)

---

## Decision rules (when to C vs D)

### Rule 0: Last round cash-out
If \(t = r\): **play D**.

Reason: no future to preserve; exploit immediately.

---

### Rule 1: First round probe (exploit-first)
If \(t = 1\): **play D**.

Reason: You learn quickly if the table is cooperative, and you immediately gain extra payoff if they cooperate.

---

### Rule 2: If opponents are defect-heavy, never cooperate (anti-sucker)
If in the previous round \(Dcount_{t-1} \ge \lceil n/2 \rceil\): **play D**.

Reason: With many defectors, the pool is headed down regardless; cooperation becomes mostly wasted.

---

### Rule 3: If pool is endangered, attempt a “single-round repair” only if it can work
If \(S_t \le S_{\text{low}}\):

- If in previous round \(Dcount_{t-1} = 0\) (everyone cooperated): **play C** (help recovery and keep the cooperative engine alive).
- Else: **play D** (don’t be exploited; you alone can’t fix a tragedy).

This is exploitative: you only “invest” when the group already demonstrated strong restraint and you can likely keep milking later.

---

### Rule 4: If pool is healthy, exploit cooperators by defecting
If \(S_t \ge S_{\text{high}}\):

- If in previous round \(Dcount_{t-1} \le 1\): **play D**.
- Else (2 or more defectors observed): **play D** (still defect; but you’ll rely on Rule 2/5 for broader shifts).

At high stock, defecting is almost always the best exploitation move; the only reason to cooperate would be to induce more cooperation later, which we only do selectively (Rule 5).

---

### Rule 5: “Induce compliance” mode (controlled, temporary cooperation)
This is the only place you cooperate strategically (to pull others toward C so you can later defect at high stock).

Trigger this mode when all are true:
- \(S_{\text{mid}} < S_t < S_{\text{high}}\) (stock slipping but not critical), and
- last round had some defection but not a majority: \(1 \le Dcount_{t-1} < \lceil n/2 \rceil\).

Action:
- **Play C for exactly 1 round**, then revert to default rules next round.

Rationale: one round of C can nudge “conditional cooperators” back to C, stabilizing stock. You pay a short-term cost to restore a long-term environment where you can defect profitably.

Exploitative twist: you *do not* commit to continued cooperation—only a brief “maintenance” investment.

---

## Pseudocode (implementable)

```python
def action(t, r, n, capacity, S_t, history):
    Shigh = 0.90 * capacity
    Smid  = 0.60 * capacity
    Slow  = 0.30 * capacity

    if t == r:
        return 'D'  # cash-out

    if t == 1:
        return 'D'  # probe/exploit-first

    # compute total defectors last round
    Dcount = count_defectors(history[t-1])  # total among n players

    # Anti-sucker: if many defect, defect
    if Dcount >= math.ceil(n/2):
        return 'D'

    # If stock is critically low
    if S_t <= Slow:
        if Dcount == 0:
            return 'C'  # only invest if group showed full restraint
        else:
            return 'D'

    # If stock is very high, exploit
    if S_t >= Shigh:
        return 'D'

    # Mid-zone: induce compliance occasionally
    if (Smid < S_t < Shigh) and (1 <= Dcount < math.ceil(n/2)):
        return 'C'  # exactly one-round repair

    # Otherwise default to defection (exploit by default)
    return 'D'
```

---

## Edge cases and robustness

1. **All-defectors population**: you defect always (Rules 1,2). You don’t waste rounds cooperating.
2. **Mostly cooperators / conditional cooperators**: you defect most rounds and get higher flow payoff while stock stays high; if stock starts slipping due to rising defection, you do a brief C “maintenance” to re-stabilize and then resume defecting.
3. **Mixed / noisy strategies**: majority-defection triggers permanent D behavior (you stop investing). Occasional one-round C prevents collapse when the group is still salvageable.
4. **Short horizon (small r)**: last-round D ensures endgame exploitation; first-round D ensures immediate advantage even if r is small.
5. **Stock already below sustainable region**: you only cooperate if *everyone* previously cooperated (strong signal you won’t be singled out).

---

## Why this is exploitative (explicitly)

- **Default is D**: you aim to take \(S/n\) whenever possible.
- **Cooperation is purely instrumental**: only used as a short “maintenance” cost to keep the pool productive so you can later defect on a richer stock.
- **No generosity toward defectors**: as soon as defection is common, you switch to pure extraction.

If you want, I can also provide a more aggressive variant that *intentionally drives the stock down* near the end (a multi-round “liquidation schedule”) based on \(r-t\) and current \(S_t\).
'''

description_EXPLOITATIVE_95 = '''
Below is an **exploitative, stateful trigger strategy** that aims to (i) harvest high payoffs when others sustain the stock, (ii) avoid being the “sucker” when others defect, and (iii) opportunistically “farm” the resource only when it is instrumentally useful for future exploitation. It depends only on parameters \((n,r,capacity)\), current stock \(S_t\), and full history.

---

## Intuition (exploitative goal)

- **Defect whenever it is safe/profitable**: If the stock is high and/or others are keeping it high, take \(D\) to get double the per-round payoff versus \(C\).
- **Use cooperation only as an investment** to keep the stock from collapsing **when that investment has positive expected return** in remaining rounds.
- **Punish defection hard** (by also defecting) because unilateral cooperation is usually wasted if others are not sustaining the pool.
- **Exploit cooperators**: If opponents demonstrate “stock-sustaining behavior,” switch to persistent defection while they carry the burden.

---

## Core quantities computed from history

At round \(t\), let current stock be \(S_t\).

From the immediately previous round \(t-1\) (if \(t>1\)), we can infer:
- \(k_{t-1}\) = number of opponents who cooperated in round \(t-1\) (you observed actions).
- Define **cooperation rate among others**:  
  \[
  q_{t-1} = \frac{k_{t-1}}{n-1}
  \]
- Track a short rolling window \(W\) (e.g., last 3 rounds) of \(q\) and of resulting next stock levels to estimate whether the group is **actually sustaining** the resource.

Define:
- `q_bar` = average of \(q\) over last \(W\) rounds (or fewer early on).
- `S_trend` = whether \(S\) is increasing/stable vs declining in that window.

---

## State thresholds (parameter-based)

Use stock thresholds that scale with capacity:

- **High stock**: \(S_t \ge 0.8\cdot capacity\)
- **Mid stock**: \(0.35\cdot capacity \le S_t < 0.8\cdot capacity\)
- **Low stock**: \(S_t < 0.35\cdot capacity\)

These are not “fairness” thresholds—they’re to decide when it’s worth investing in regrowth.

---

## Decision rules (cooperate vs defect)

### Rule 0 — Last-round greed
If \(t = r\): **Play D**.  
Reason: no future stock to protect; \(D\) strictly dominates \(C\) for that round given the same \(S_r\).

---

### Rule 1 — Default stance: defect unless cooperation is an investment with return
For \(t < r\), start from **D** and only switch to **C** if *all* of the following hold:

**(A) Stock is in danger / valuable to rebuild**  
- \(S_t\) is **mid or low** (i.e., \(S_t < 0.8\cdot capacity\)), AND there are at least 2 rounds remaining (\(r-t \ge 2\)).  
Reason: cooperation has no point if stock is already high, and little point if no time to recoup.

**(B) Others are likely to sustain if you help**  
- `q_bar` is high enough:  
  \[
  q\_bar \ge q^\* \quad\text{where}\quad q^\* = 0.6
  \]
Interpretation: if ~60%+ of opponents have been cooperating recently, they are “sustainers” you can potentially exploit later.

**(C) You are not being singled out (anti-sucker check)**  
If in the last round you cooperated and stock still fell sharply (e.g., \(S_t < 0.7 \cdot S_{t-1}\)), then **do not cooperate** now (play D).  
Reason: your cooperation isn’t buying stability; it’s being burned.

If (A)&(B)&(C) all pass: **Play C** (investment mode). Otherwise: **Play D**.

This already makes the strategy exploitative: it cooperates only to maintain a “farmable” stock supported by others.

---

## Exploitation mode: “harvest when stable”

When stock is **high** and others are sustainers, you go into harvest mode:

### Rule 2 — Harvest trigger
If \(S_t \ge 0.8\cdot capacity\) AND `q_bar ≥ 0.5` (at least half of opponents tend to cooperate):
- **Play D**.

Rationale: with high stock, your extra extraction is immediately valuable and you expect others to keep it from collapsing. You’re free-riding on sustainers.

---

## Collapse response: “never throw good cooperation after bad”

### Rule 3 — If stock is low and others aren’t sustainers, defect and accept collapse
If \(S_t < 0.35\cdot capacity\) AND `q_bar < 0.6`:
- **Play D**.

Rationale: rebuilding requires coordinated restraint. Without evidence of that, “investing” by cooperating is wasted; take what you can now.

---

## Targeted retaliation (deterrence that’s still exploitative)

This is not “nice”; it’s to prevent being exploited while you set up exploitation of others.

### Rule 4 — Two-strike punishment window
Maintain a counter `recent_defect_shock` that increments when you observe a sudden drop in opponent cooperation, e.g.:
- If \(q_{t-1} < 0.4\) (most opponents defected last round), increment shock.
- Else decrement shock toward 0.

If `recent_defect_shock ≥ 1`: **Play D** for the next 2 rounds (unless it’s already last round).  
Rationale: if they started defecting, you stop investing immediately and extract while possible.

This prevents you from being the only cooperator keeping the pool alive.

---

## First-round and early-game handling

### Round 1
- **Play D**.

Reason (exploitative and informational): you gain maximum immediate payoff at \(S_1=capacity\), and you learn whether others are unconditional cooperators (which you can exploit) or trigger-happy defectors (in which case cooperation is futile).

### Round 2–3 (calibration window)
- Continue **D** unless you observe strong evidence of sustainers:
  - If after round 1 the stock remains relatively high (e.g., \(S_2 \ge 0.6\cdot capacity\)), that implies many others cooperated despite your defection. Then you can plan to **keep defecting** (harvest) because you’ve found free riders to exploit.
  - Only if stock drops near collapse *and* opponent cooperation is high do you consider temporary cooperation to rebuild (investment mode).

---

## Endgame handling (last few rounds)

### Rule 5 — Endgame extraction
If \(r - t \le 2\): **Play D**.  
Reason: too little time for cooperation to pay back via higher future \(S\); cash out.

(If you want to be slightly less blunt: allow \(C\) at \(t=r-2\) only if \(S_t\) is extremely low and `q_bar` is extremely high, but the exploitative baseline is to cash out.)

---

## Pseudocode (implementable)

```pseudo
parameters: n, r, capacity
constants:
  HIGH = 0.8 * capacity
  LOW  = 0.35 * capacity
  q_star_invest = 0.6
  W = 3

state:
  history of opponent cooperation rates q[]
  shock = 0
  punish_timer = 0

function action(t, S_t, history):
  if t == r:
    return D

  if t == 1:
    return D

  # compute last-round opponent coop rate
  q_last = (#opponents who played C in round t-1) / (n-1)
  append q_last to q_history (keep last W)
  q_bar = average(q_history)

  # update shock/punishment
  if q_last < 0.4:
    shock = min(shock + 1, 2)
  else:
    shock = max(shock - 1, 0)

  if shock >= 1 and punish_timer == 0:
    punish_timer = 2
  if punish_timer > 0:
    punish_timer -= 1
    return D

  # endgame cash-out
  if (r - t) <= 2:
    return D

  # harvest mode: high stock + sustainers
  if S_t >= HIGH and q_bar >= 0.5:
    return D

  # collapse acceptance: low stock + no sustainers
  if S_t < LOW and q_bar < q_star_invest:
    return D

  # investment mode: cooperate only if it plausibly rebuilds a farmable stock
  if S_t < HIGH and q_bar >= q_star_invest:
    # anti-sucker check: if you cooperated last time and stock still cratered, don't invest
    if (you played C in round t-1) and (S_t < 0.7 * S_{t-1}):
      return D
    else:
      return C

  return D
```

---

## Why this is exploitative and robust

- **Exploitative**: defaults to **D**, especially in round 1 and the endgame; shifts to **C** only as an *investment* to later enable higher-yield defection (harvest mode).
- **Robust**: if opponents are mostly defectors, you never waste effort rebuilding; you simply defect and take what remains. If opponents are cooperators/reciprocators, you identify them via sustained stock and high \(q\), then free-ride.
- **Adaptive**: uses observed cooperation rates and stock trend; includes a punishment mechanism to stop bleeding value when opponents pivot to defection.

If you tell me typical tournament values (ranges for \(n\), \(r\), capacity), I can tune the thresholds (\(0.8, 0.35, 0.6\), punishment length) to be more aggressive or more “farming-oriented.”
'''

description_EXPLOITATIVE_96 = '''
## Strategy: **Stock-Trigger Exploiter (STE)**  
Core idea: **farm the resource when others are sustainable, but grab aggressively (defect) whenever (i) you can’t reliably keep the stock high, (ii) others show meaningful defection, or (iii) endgame is near.**  
This exploits cooperative/sustainable opponents by taking extra whenever it’s “safe”, and avoids being the sucker against defectors by switching quickly to full extraction.

---

## Quantities you track each round
At round \(t\), before choosing action, you know current stock \(S_t\) and past actions.

Let:
- \(d_{t-1}\) = number of opponents who defected last round (from history).
- \(k_{t-1} = d_{t-1}/(n-1)\) = opponent defection rate last round.
- Maintain an **EWMA** (smoothed) defection rate:
  \[
  \hat{k}_t = (1-\alpha)\hat{k}_{t-1} + \alpha k_{t-1}, \quad \alpha \in [0.25,0.4]
  \]
  Initialize \(\hat{k}_1 = 0\).

Also compute a **stock safety margin**:  
- Define “healthy stock” threshold \(S_{\text{high}} = 0.7 \cdot \text{capacity}\).  
- Define “danger stock” threshold \(S_{\text{low}} = 0.35 \cdot \text{capacity}\).  
(These work well because the logistic growth here is strong near midrange but collapses if you drive the post-consumption stock too low.)

---

## Intuition behind the triggers (why they exploit)
- If opponents are mostly cooperating and stock is high, **you can defect and still likely keep the resource regenerating**, earning 2× the cooperative payoff in that round.
- If opponents start defecting, stock collapses rapidly; then **the right exploit is to defect too** (race to extract before it’s gone), not to “try to save it.”
- In the final rounds, future stock value is low; **always defect at the end**.

---

## 1) Decision rules (C vs D)

### Rule 0 — Last-round/endgame grab
- **If \(t = r\)**: play **D**.
- Also define an endgame window \(H = \max(2, \lceil r/10 \rceil)\).  
  **If \(t \ge r - H + 1\)** (final \(H\) rounds): play **D** unless stock is extremely low already (see Rule 4).

Rationale: no reason to preserve stock when the horizon is short; exploit any remaining stock.

---

### Rule 1 — Immediate punishment / no-sucker rule
If last round **any** opponent defected *and* stock isn’t “abundant”, defect:
- If \(d_{t-1} \ge 1\) **and** \(S_t < S_{\text{high}}\): play **D**.

Rationale: you don’t bankroll even a single defector when the stock is not safely high.

---

### Rule 2 — Exploit cooperative fields (the main exploitation)
If opponents look highly cooperative and stock is healthy, defect to harvest extra:
- If \(\hat{k}_t \le 0.15\) **and** \(S_t \ge S_{\text{high}}\): play **D**.

Rationale: in “nice” populations, this takes advantage of them. If they truly keep cooperating, you earn more almost every round.

---

### Rule 3 — Manage sustainability when you’re the one causing pressure
If stock is trending down (or not high), you temporarily cooperate to keep the farm alive **only when opponents are cooperative enough to make that investment pay back**:
- If \(S_{\text{low}} \le S_t < S_{\text{high}}\) and \(\hat{k}_t \le 0.25\): play **C**.

Rationale: you “maintain the machine” when it’s still profitable (opponents mostly cooperate), so future rounds remain high-stock and exploitable.

---

### Rule 4 — Collapse mode (race condition)
If stock is low, there’s no farm worth maintaining—grab what’s left:
- If \(S_t < S_{\text{low}}\): play **D**.

Rationale: growth from near-zero is slow, and any defectors will prevent recovery; optimal exploitation is extraction.

---

### Default
- Otherwise: play **D**.

This bias toward **D** is intentional: you only “pay” cooperation when it is likely to maintain a high-stock environment that you can later exploit.

---

## 2) Edge cases

### First round
- **Round 1: play D.**
Reason: initial stock is at capacity (maximum). One-shot gain from D is double C, and you lose nothing informationally; you also test whether others retaliate.

### If history is short / missing
- Treat unknown \(\hat{k}\) as 0 initially (optimistic), but since you open with D, you’ll quickly learn if the population punishes.

### If capacity is near the minimum (capacity ≈ 2n)
- Keep the same logic, but tighten sustainability thresholds:
  - \(S_{\text{high}} = 0.8\cdot capacity\)
  - \(S_{\text{low}} = 0.45\cdot capacity\)
Low capacity means the system is easier to destabilize, so you cooperate slightly more to keep it harvestable—*but still defect-biased*.

### Last rounds (already covered)
- Final \(H\) rounds: almost always D.
- Final round: always D.

---

## 3) Why this is exploitative and robust
### Exploitative
- Against cooperative strategies (Always-C, generous tit-for-tat variants, “sustainability” bots), STE defects whenever stock is high, harvesting **persistent 2× payoff** while they “do the right thing.”
- It only cooperates as a **maintenance investment** to restore stock to a level where it can continue defecting profitably.

### Robust
- Against defect-heavy populations, it quickly shifts into permanent D (via Rules 1/4), avoiding being exploited.
- Against conditional cooperators, it uses a light amount of cooperation only when it buys future extraction opportunities, but never commits to long mutual cooperation norms.

---

## Pseudocode (implementable)
```python
# parameters: n, r, capacity
alpha = 0.33
S_high = 0.70 * capacity
S_low  = 0.35 * capacity
H = max(2, math.ceil(r/10))

k_hat = 0.0  # EWMA opponent defection rate

def choose_action(t, S_t, opp_actions_last_round):
    global k_hat

    if t == 1:
        return "D"

    d_last = sum(1 for a in opp_actions_last_round if a == "D")
    k_last = d_last / (n - 1)
    k_hat = (1 - alpha) * k_hat + alpha * k_last

    # Endgame grab
    if t == r:
        return "D"
    if t >= r - H + 1:
        # still defect even if cooperative; only exception is moot, but keep simple
        return "D"

    # Collapse mode
    if S_t < S_low:
        return "D"

    # No-sucker rule when stock isn't abundant
    if d_last >= 1 and S_t < S_high:
        return "D"

    # Exploit cooperative fields when stock is high
    if k_hat <= 0.15 and S_t >= S_high:
        return "D"

    # Maintenance cooperation
    if S_low <= S_t < S_high and k_hat <= 0.25:
        return "C"

    return "D"
```

---

If you want to push exploitation even harder, you can add a “two-phase” variant: defect by default, and only switch into the maintenance-cooperate mode after you observe the table is capable of sustaining stock (e.g., two consecutive rounds with low \(k\) and rising \(S\)).
'''

description_EXPLOITATIVE_97 = '''
## Strategy: **Regenerative Extortion with Conditional Punishment (RECP)**

Goal: **Extract D-level payoffs as often as possible** while keeping the stock in the high-regrowth region so the resource remains profitable. The strategy **cooperates only when needed to (a) maintain the stock, or (b) induce others to cooperate**, and otherwise defects.

Key idea: In this game, **D strictly dominates C within a round** given the same stock, but **too much D collapses the stock to ~0**, killing future payoffs. So exploitation means:
- **Defect whenever the resource is “safe”**
- **Cooperate just enough to keep the stock from crashing**
- **Punish hard and early against high-defection opponents**
- **Exploit quickly against cooperative/forgiving opponents**

---

# 1) Decision rules (C vs D)

### Quantities you track each round \(t\)
- Current stock: \(S_t\)
- Last round’s observed number of defectors: \(d_{t-1}\) (and/or defection rate \(q_{t-1}=d_{t-1}/n\))
- Your own last action
- A “punishment counter” \(P\) (how many punishment rounds remain)
- A “test mode” flag for early probing

### Useful stock thresholds
You want to keep the system away from the collapse basin. A simple robust control is:

- **Critical stock:**  
  \[
  S_{\text{crit}} = 2n
  \]
  Near this level, any meaningful defection risks pushing the post-consumption stock low and slowing recovery.

- **Comfort stock:**  
  \[
  S_{\text{safe}} = 0.6 \cdot \text{capacity}
  \]
  Above this, even moderate overconsumption often still allows decent recovery, and you can press exploitation.

- **Target stock band for farming:**  
  \[
  S_{\text{farm}} \in [0.45, 0.75]\cdot \text{capacity}
  \]
  The logistic growth is strong in the middle; if you can keep it here, you can defect often.

(These constants are intentionally coarse; they work across many capacities and n.)

---

## Core policy (high level)

### A) If in punishment mode: **Defect**
- If \(P>0\): play **D**, decrement \(P\).
- Rationale: punish defect-heavy groups by accelerating collapse unless they shift to cooperation. This also avoids being the sucker in a defection regime.

### B) If stock is low: **Cooperate to prevent collapse (but only as much as needed)**
- If \(S_t \le S_{\text{crit}}\): play **C**
- Else if \(S_t \le 0.35\cdot\text{capacity}\): play **C** unless *very few* defected last round (see “exploit window” below)

Rationale: if you keep defecting when stock is low, you get one last decent payoff and then everyone gets near-zero thereafter. Exploitation requires the resource to remain alive.

### C) If stock is healthy: **Default to defect**
- If \(S_t \ge S_{\text{safe}}\): play **D**
- If \(S_t \in S_{\text{farm}}\): play **D** unless last round showed increasing defection risk (see trigger rules)

### D) Conditional triggers from history (adaptive exploitation)

#### Trigger 1: “Cooperation reservoir” → exploit
If last round had **low defection**:
- If \(q_{t-1} \le 0.25\): play **D** (exploit the cooperative environment)

Cooperators keep stock healthier; you harvest more by defecting.

#### Trigger 2: “Defection trend” → punish
If last round had **high defection**:
- If \(q_{t-1} \ge 0.5\): enter punishment mode with
  \[
  P = 2 \text{ rounds}
  \]
  and play **D** immediately (this round).

This deters strategies that try to free-ride on any recovery you create.

#### Trigger 3: “Stock drop despite decent stock” → stabilize
Compute approximate stock drop indicator:
- Let \(\Delta S = S_t - S_{t-1}\) (observed)
- If \(\Delta S\) is strongly negative (e.g., \(\Delta S < -0.25\cdot\text{capacity}\)) and you are not punishing:
  - play **C** for 1 round to stabilize, then return to default rules

This guards against sudden collapses caused by others switching to D en masse.

---

# 2) Edge cases

## First round (t = 1): **Defect (probe + exploit)**
Play **D** in round 1.

Why: You learn whether others are willing to cooperate without you, and you immediately earn the higher payoff at full stock. If everyone defects, the stock collapses anyway—cooperating once would just reduce your payoff without preventing collapse unless many others cooperate.

## Early rounds (t = 2 to 3): **Classify opponents**
Use observed defection rate \(q\):
- If \(q\) is low: keep defecting (milk them)
- If \(q\) is high: go into punishment mode (avoid being the lone cooperator)
- If mixed: use stock-based stabilization (C only if stock is trending low)

This “fast classification” is critical in tournaments.

## Last round (t = r): **Always Defect**
Play **D**.

There is no future stock to preserve, so C is dominated.

## Second-to-last round (t = r-1): **Mostly Defect**
Play **D** unless \(S_{r-1}\) is extremely low and you expect an extra round payoff to matter (but it won’t—there is only one round left). So:
- Default: **D**
- Exception: none (keep it simple and exploitative)

---

# 3) Exploitative mindset (why this is exploitative)

RECP is exploitative in three ways:

1. **Baseline extraction:** It defects whenever the stock isn’t in a danger zone, ensuring you capture the larger share each round.

2. **Asymmetric “maintenance” cooperation:** It cooperates only when the stock is so low that continued defection would ruin *your own* future earnings. This is not “being nice”; it is resource management for longer-term exploitation.

3. **Punitive discipline:** When opponents defect a lot, RECP defects too (and for multiple rounds), refusing to subsidize them with recovery. This pressures adaptive opponents into cooperating more, at which point RECP switches back to exploiting (defecting) them.

---

# Pseudocode (implementable)

```python
# State variables maintained by strategy
P = 0  # punishment rounds remaining
S_prev = None
q_prev = None  # previous round defection rate among opponents

def action(t, r, n, capacity, S_t, q_prev, P, S_prev):
    Scrit = 2*n
    Ssafe = 0.6*capacity
    Slow  = 0.35*capacity

    # Last round rule
    if t == r:
        return "D", P, S_t

    # First round probe
    if t == 1:
        return "D", P, S_t

    # Punishment mode
    if P > 0:
        P -= 1
        return "D", P, S_t

    # Trigger punishment if opponents defected a lot last round
    if q_prev is not None and q_prev >= 0.5:
        P = 2
        return "D", P, S_t

    # Emergency stabilization by stock level
    if S_t <= Scrit:
        return "C", P, S_t

    if S_t <= Slow:
        # cooperate unless environment seems very cooperative already
        if q_prev is not None and q_prev <= 0.25:
            return "D", P, S_t  # exploit window
        else:
            return "C", P, S_t

    # If stock is healthy, exploit
    if S_t >= Ssafe:
        return "D", P, S_t

    # Middle band: exploit unless clear instability
    if S_prev is not None:
        dS = S_t - S_prev
        if dS < -0.25*capacity:
            return "C", P, S_t  # one-round stabilization

    # Default in farming band: defect
    return "D", P, S_t
```

**Inputs needed each round:** current \(S_t\), previous \(S_{t-1}\), and previous opponents’ defection rate \(q_{t-1}\) (observable from actions).

---

## Notes on robustness
- Works against **always-C**: you mostly defect and gain maximum relative advantage, only cooperating if stock threatens collapse (rare if others keep C).
- Works against **always-D**: you defect too; stock collapses, but you avoid being exploited.
- Works against **grim/trigger** types: your early D may trigger punishment from them, but your policy then shifts to either (a) defecting in the punishment regime (avoid sucker), or (b) cooperating when stock is low to restore profitability.
- Works against **adaptive learners**: punishment discourages sustained defection, and your reversion to defection exploits any shift toward cooperation.

If you want, I can also provide a tuned variant that uses an explicit one-step forecast of next stock (using the observed defection count) to decide the minimal cooperation needed to keep \(S_{t+1}\) above a chosen target.
'''

description_EXPLOITATIVE_98 = '''
## Strategy: **Harvest–Probe–Punish (HPP)**  
Exploit anyone who sustains the stock (cooperators / “stewards”), while avoiding being the one who collapses the resource when others are already over-consuming. The core idea is:

- **Defect whenever it’s safe** (stock high enough that one more D doesn’t drive it into low-growth or collapse).
- **Cooperate only as a control action** to (i) keep the stock in the high-growth zone so you can defect more later, and (ii) punish/discipline groups that are trending toward collapse so you don’t lose future extraction.
- **Exploit cooperative regimes quickly** by switching to D as soon as you detect others are not depleting too fast.

This is not “nice”: it treats cooperation as an *investment tool* to maximize later defection rents.

---

# Key observations the strategy exploits

Let current stock be \(S\). Your per-round payoff is:
- If C: \(S/(2n)\)
- If D: \(S/n\) (exactly double C)

So **in any fixed round, D strictly dominates C**. The only reason to ever play C is dynamic: to preserve/restore stock so future rounds remain lucrative.

Stock update depends on remaining stock \(R\) after total consumption:
\[
R = S - \text{total consumption}, \quad \text{growth}=2R(1-R/\text{capacity})
\]
This logistic growth is maximized at \(R = \text{capacity}/2\). So you want the *post-consumption* stock to not be too low (collapse) and not be stuck at capacity (wasted growth potential). The sweet spot is to keep the stock in a **high-growth, high-level band**.

---

# What you track each round (from history)

At round \(t\), before choosing, observe:
- Current stock \(S_t\)
- Last round actions of all players (so you know how many defected)

Compute:
- \(k_{t-1}\): number of opponents who defected last round (among \(n-1\))
- Estimate current “defection rate” among others:
  \[
  \hat{p}_t = \text{EMA of } \frac{k_{t-1}}{n-1} \quad (\text{exponential moving average})
  \]
  (This makes it robust to noise and “occasional tests” by others.)

Also define a **danger threshold** for the stock:
- \(S_{\text{low}} = 2n\) (given bounds, this is near the minimum meaningful level)
- \(S_{\text{target}} = \min(\text{capacity}, 1.0 \times \text{capacity})\) but you’ll actually manage via bands below.

---

# Decision rule (high level)

You choose D by default. You switch to C only if one of these is true:

1. **Collapse prevention**: If predicted next stock risks falling into the low region (or zero), cooperate to preserve the resource (so you can keep exploiting later).
2. **Rebuilding mode**: If stock already low, cooperate until it recovers enough to resume profitable defection.
3. **Discipline / test**: Occasionally cooperate as a “probe” to see if others shift toward cooperation; if they do, immediately return to defection to harvest.

---

# Concrete adaptive rules

### Step A — Predict what happens if you defect vs cooperate
You can predict *post-consumption remaining stock* \(R\) using last round’s observed behavior as a proxy for this round.

Consumption if you play:
- If you play D: \(c_D = S_t/n\)
- If you play C: \(c_C = S_t/(2n)\)

Expected opponent consumption using \(\hat{p}_t\):
- Each opponent expected consumption:
  \[
  \mathbb{E}[c_\text{opp}] = \hat{p}_t \cdot (S_t/n) + (1-\hat{p}_t)\cdot(S_t/(2n))
  = \frac{S_t}{2n}(1+\hat{p}_t)
  \]
- Total opponent consumption: \((n-1)\mathbb{E}[c_\text{opp}]\)

So predicted remaining stock if you choose action \(a\in\{C,D\}\):
\[
R(a)= S_t - \Big((n-1)\frac{S_t}{2n}(1+\hat{p}_t) + c_a\Big)
\]

You don’t need perfect accuracy; you just need to avoid obvious collapse and recognize cooperative regimes.

---

### Step B — Choose action using stock bands (simple + robust)

Define two stock thresholds (depend only on parameters):
- **Rebuild threshold**: \(T_{\text{rebuild}} = 0.35 \cdot \text{capacity}\)
- **Safe-to-harvest threshold**: \(T_{\text{harvest}} = 0.65 \cdot \text{capacity}\)

Rationale: below ~0.35 capacity, you risk getting stuck in low payoffs if the group keeps defecting; above ~0.65, the system is comfortably high and you can press D.

Now decision:

**Rule 1 (Last round):**  
- If \(t = r\): **Play D** (endgame grab; no future to protect).

**Rule 2 (If stock is high):**  
- If \(S_t \ge T_{\text{harvest}}\): **Play D**  
  (Even if others defect somewhat, you monetize the high stock.)

**Rule 3 (If stock is low):**  
- If \(S_t \le T_{\text{rebuild}}\):  
  - If \(\hat{p}_t \ge 0.5\) (others mostly defect): **Play D** (don’t be the sucker propping up free riders when collapse seems inevitable).  
  - Else (others mostly cooperate): **Play C** (you can “invest” to push stock back up, anticipating you’ll later defect on them).

**Rule 4 (Middle band = manage the resource for future exploitation):**  
If \(T_{\text{rebuild}} < S_t < T_{\text{harvest}}\):
- Compute predicted remaining stock if you defect: \(R(D)\).
- If \(R(D) < 0.15\cdot \text{capacity}\): **Play C** (prevent near-collapse).
- Else: **Play D**.

This makes you cooperate *only when your extra extraction is likely to cause a sharp drop that hurts your future rents.*

---

# “Probe” mechanism (exploitation accelerator)

Many strategies try to maintain stock via cooperation. You want to *identify them early* and then defect persistently.

**Round 1 probe:**  
- If \(r \ge 3\): **Play C in round 1**, otherwise play D.  
  Why: One round of “cheap” cooperation at high stock can reveal who is willing to cooperate. If many others defect immediately, you learn the environment is harsh and you switch to full D.

**After round 1:**  
- If in round 1 you observed that at least \(\lceil (n-1)/2 \rceil\) opponents played C (i.e., cooperative environment), then adopt an **“exploit mode” bias**:
  - Increase \(T_{\text{harvest}}\) down to \(0.55\cdot\text{capacity}\) (defect more often).
  - Reduce the collapse-prevention trigger from \(R(D) < 0.15C\) to \(R(D) < 0.10C\) (take more risk because others are likely to repair).

If instead round 1 shows most opponents defect, adopt **“grab mode”**:
- Always D unless \(S_t \le T_{\text{rebuild}}\) *and* \(\hat{p}_t < 0.3\) (rare) — basically never rebuild for persistent defectors.

This is exploitative because it conditions on whether others will “do the maintenance” and then leans into D when they will.

---

# Punishment / deterrence (cheap, non-moral)

If the group is cooperating and you are defecting, some opponent strategies may punish defectors by switching to D, collapsing stock. You respond by making collapse *costly for them* only when it’s in your interest.

**Punish trigger:**  
If you were in a cooperative environment (EMA \(\hat{p}_t < 0.4\)) and suddenly \(k_{t-1}\) jumps high (e.g., \(k_{t-1} \ge 0.7(n-1)\)), treat it as a punishment wave. Then:
- **Play D for the next 2 rounds regardless of stock** (retaliatory hardline).
Rationale: If they are trying to discipline you, you make the punishment fail by not “buying” cooperation at all. You only return to conditional cooperation when stock becomes low enough that preserving future rents matters (Rules 3–4 handle that).

This is exploitative: you don’t “apologize” with C; you force the interaction toward either (a) they resume repairing, which you exploit, or (b) mutual D, where you at least aren’t the only investor.

---

# Edge cases

1. **Round 1**
   - If \(r \ge 3\): play **C** (probe).
   - If \(r = 2\): play **D** (very short horizon; probe not worth it).

2. **Last round \(t=r\)**
   - Always **D**.

3. **Stock near zero**
   - If \(S_t\) extremely small (e.g., \(S_t < 2n\) or \(S_t \approx 0\)), C and D both yield tiny payoffs. Use the “don’t be the sucker” rule:
     - If others are mostly defecting (\(\hat{p}_t \ge 0.5\)): **D**
     - Else: **C** to rebuild and then exploit later (unless it’s the last round).

4. **Capacity just at minimum bound (capacity = 2n)**
   - The bands still work; everything scales with capacity. The system is tighter; you’ll see more “rebuild mode” activations, but only when others are cooperative enough to make rebuilding profitable for you.

---

# Pseudocode (implementable)

```python
# Parameters: n, r, capacity
T_rebuild_base = 0.35 * capacity
T_harvest_base = 0.65 * capacity

alpha = 0.5  # EMA smoothing
p_hat = 0.5  # start neutral
mode = "unknown"  # {unknown, exploit, grab}

def choose_action(t, S, last_actions_opponents):
    global p_hat, mode

    if t == r:
        return "D"

    # update p_hat from last observed actions (skip if t==1)
    if t > 1:
        k = sum(1 for a in last_actions_opponents if a == "D")
        p_last = k / (n-1)
        p_hat = alpha * p_last + (1-alpha) * p_hat

        # mode selection after round 1 outcome
        if t == 2 and mode == "unknown":
            if p_last <= 0.5:  # many cooperators
                mode = "exploit"
            else:
                mode = "grab"

    # Round 1 probe
    if t == 1:
        return "C" if r >= 3 else "D"

    # adjust thresholds by mode
    T_rebuild = T_rebuild_base
    T_harvest = T_harvest_base
    collapse_trigger = 0.15 * capacity

    if mode == "exploit":
        T_harvest = 0.55 * capacity
        collapse_trigger = 0.10 * capacity

    # punishment detection: cooperative -> sudden defection wave
    if p_hat < 0.4:
        k = sum(1 for a in last_actions_opponents if a == "D")
        if k >= 0.7 * (n-1):
            return "D"  # (in code: maintain for 2 rounds via a counter)

    # band rules
    if S >= T_harvest:
        return "D"

    if S <= T_rebuild:
        if p_hat >= 0.5:
            return "D"
        else:
            return "C"

    # middle band: predict R(D) using p_hat
    # Expected opponent consumption:
    opp_cons = (n-1) * (S/(2*n)) * (1 + p_hat)
    R_if_D = S - (opp_cons + S/n)

    if R_if_D < collapse_trigger:
        return "C"
    else:
        return "D"
```

---

# Why this is exploitative and robust

- **Exploitative**: Defaults to D; uses C only as an *instrument* to keep the resource extractable, and defects more aggressively when others appear cooperative (they become your “resource managers”).
- **Robust**: Uses observed history (EMA) rather than assuming fixed opponent types; avoids catastrophic self-harm by cooperating only when your marginal defection likely causes near-collapse; doesn’t get trapped “being nice” in hostile pools.
- **Tournament-suitable**: Works against always-D (you mostly D), against conditional cooperators (you harvest them while preventing full collapse), and against mixed/noisy players (EMA smooths).

If you want, I can also provide a more explicitly “state-optimal” variant that chooses C/D by directly maximizing an estimated remaining-horizon value function (still parameter-only + history), but the above is easier to implement and hard to exploit in turn.
'''

description_EXPLOITATIVE_99 = '''
### Strategy: **Ruthless Harvest with Credible Recovery (RHCR)**  
Goal: **Extract D whenever it’s safe/profitable**, but **avoid killing the stock** when opponents are also aggressive. Use the state dynamics to (i) free-ride on cooperators, (ii) punish defect-heavy groups by switching to survival mode, and (iii) rebuild only when it increases your future ability to harvest.

Key exploitation idea: in any round with stock \(S\), **D strictly dominates C in immediate payoff** (you get \(S/n\) vs \(S/(2n)\)). So the only reason to ever play C is **to keep the stock from collapsing** (so you can keep defecting later). RHCR defects by default, and cooperates only as a “maintenance action” when collapse risk is high.

---

## 1) Decision rules (when to C vs D)

### Quantities to compute each round \(t\)
Let current stock be \(S_t\). From history at round \(t-1\), you observed how many opponents defected.

- Let \(k_{t-1}\) = number of defectors among **all players** in round \(t-1\).  
- Let \(d_{t-1} = k_{t-1}/n\) = observed defection rate last round.  
- Maintain an exponentially-smoothed estimate of the group’s defection tendency:
  \[
  \hat d_t = \lambda \hat d_{t-1} + (1-\lambda)d_{t-1},\quad \lambda \in [0.6,0.9] \text{ (e.g., }0.75\text{)}
  \]
  Initialize \(\hat d_1 = 1\) (assume hostile until proven otherwise).

### Predict next-round “environmental pressure”
If you choose action \(a \in \{C,D\}\), and opponents defect at rate \(\hat d_t\), expected total consumption fraction of stock is:

- A cooperator consumes \(S/(2n)\), a defector consumes \(S/n\).
- Expected per-player consumption factor is:
  \[
  \mathbb{E}[\text{consumption per player}] = \hat d_t\cdot \frac{S}{n} + (1-\hat d_t)\cdot \frac{S}{2n}
  = \frac{S}{2n}(1+\hat d_t)
  \]
- Total expected consumption if **you play C**:
  \[
  C^{tot}_C \approx (n-1)\cdot \frac{S}{2n}(1+\hat d_t)\;+\;\frac{S}{2n}
  = \frac{S}{2n}\Big((n-1)(1+\hat d_t)+1\Big)
  \]
- Total expected consumption if **you play D**:
  \[
  C^{tot}_D \approx (n-1)\cdot \frac{S}{2n}(1+\hat d_t)\;+\;\frac{S}{n}
  = \frac{S}{2n}\Big((n-1)(1+\hat d_t)+2\Big)
  \]

Thus predicted remaining stock after consumption:
\[
R_C = S - C^{tot}_C,\quad R_D = S - C^{tot}_D
\]

Then apply growth:
\[
G(R)=2R\Big(1-\frac{R}{capacity}\Big),\quad S'=\min(R+G(R), capacity)
\]

Compute predicted next stock under each action:
\[
S'_{C}=\min(R_C+G(R_C),capacity),\quad S'_{D}=\min(R_D+G(R_D),capacity)
\]

### Core rule: defect unless it risks “stock death spiral”
Define a safety floor \(S_{floor}\) below which the game becomes low-yield and volatile. A simple robust choice:
\[
S_{floor} = \max(0.25\cdot capacity,\; 2n)
\]
(Using \(2n\) because the state is constrained to \([0,2n]\) in your spec, but also using a capacity fraction so it works when capacity is large.)

**Decision:**
- **Play D** if predicted next stock under D is not dangerously low:
  \[
  \text{If } S'_D \ge S_{floor} \text{ then play D.}
  \]
- **Otherwise play C** (maintenance mode) **if C would prevent collapse**:
  \[
  \text{Else if } S'_C > S'_D \text{ and } S'_C \ge S_{floor} \text{ then play C.}
  \]
- **Otherwise play D anyway** (the group is killing the stock regardless; take what you can).

This is exploitative because:
- When opponents are cooperative (low \(\hat d\)), \(S'_D\) stays high → you **defect continuously** and free-ride.
- When opponents are defect-heavy, cooperating usually won’t save the stock → you **still defect** (harvest before depletion).
- You cooperate only when it has a clear instrumental payoff: keeping the stock in the high-growth/high-yield region so you can defect more later.

---

## 2) Edge cases (first round, last round, weird states)

### Round 1 (no history)
- **Default: play D.**
Reason: immediate dominance + you learn opponent tendencies quickly.

### Last round \(t=r\)
- **Always play D.**
No future stock to preserve; pure harvest.

### Second-to-last round \(t=r-1\)
- Almost always D, with one exception:
  - If \(S_t\) is high and opponents are very cooperative (\(\hat d_t\) small), you can still D safely.
  - If \(S_t\) is precarious but could be rescued by a one-round C that leads to a large final-round stock, then C can be worth it. Implement with the same forward simulation but for **two-step horizon**:
    - Compare expected total payoff over \(t=r-1,r\) under choosing C vs D at \(r-1\) (assuming you will D in final round regardless). Choose the action with higher two-round expected payoff.

### Extremely low stock
If \(S_t\) is so low that any action gives trivial payoff, still follow:
- If your C meaningfully increases \(S_{t+1}\) above \(S_{floor}\) (and you have >1 round left), play C.
- Otherwise D.

### If capacity is near the minimum constraint
If \(capacity \approx 2n\), the system is intrinsically fragile. The rule naturally becomes more “maintenance C” because \(S'_D\) will more often fall below \(S_{floor}\).

---

## 3) Exploitative posture (how it exploits others)

RHCR exploits in three distinct opponent regimes:

### A) Opponents are nice / conditional cooperators
- You defect early and often.
- Many strategies respond to occasional defection with warnings/punishments. RHCR doesn’t try to “be nice”; it checks whether punishment actually threatens future stock. If not, it keeps defecting.
- If their punishment starts reducing stock so much that future harvest is threatened, RHCR temporarily cooperates just enough to keep the resource productive—then resumes defecting.

### B) Opponents are mixed / learning / noisy
- The smoothed \(\hat d_t\) prevents overreacting to noise.
- You opportunistically defect whenever the predicted stock can sustain it, and only “buy” cooperation when it raises future harvest.

### C) Opponents are aggressive defectors
- Cooperation won’t fix a tragedy-of-the-commons if everyone defects. RHCR recognizes this by the forward prediction: if \(S'_C\) is still bad, it defects too and takes maximum short-term payoff.

---

## Pseudocode (implementation-ready)

```python
# Parameters: n, r, capacity
lambda_ = 0.75
d_hat = 1.0  # pessimistic prior
S_floor = max(0.25*capacity, 2*n)

def growth(R):
    return 2*R*(1 - R/capacity)

def predict_next_stock(S, my_action, d_hat):
    # Expected total consumption based on d_hat among other players
    # Opponent expected per-player consumption factor: S/(2n)*(1 + d_hat)
    opp_total = (n-1) * (S/(2*n)) * (1 + d_hat)
    my_cons = S/(2*n) if my_action == "C" else S/n
    R = S - (opp_total + my_cons)
    if R < 0: R = 0
    S_next = R + growth(R)
    return min(S_next, capacity)

def choose_action(t, S, last_round_defectors):
    global d_hat
    if t == 1:
        return "D"
    # update beliefs from last round
    d_obs = last_round_defectors / n
    d_hat = lambda_*d_hat + (1-lambda_)*d_obs

    if t == r:
        return "D"

    # optional 2-step lookahead for t == r-1
    if t == r-1:
        # choose action at r-1, then D at r
        S1_C = predict_next_stock(S, "C", d_hat)
        S2_C = predict_next_stock(S1_C, "D", d_hat)  # final round
        payoff_C = (S/(2*n)) + (S1_C/n)

        S1_D = predict_next_stock(S, "D", d_hat)
        S2_D = predict_next_stock(S1_D, "D", d_hat)
        payoff_D = (S/n) + (S1_D/n)

        return "C" if payoff_C > payoff_D else "D"

    S_D = predict_next_stock(S, "D", d_hat)
    if S_D >= S_floor:
        return "D"

    S_C = predict_next_stock(S, "C", d_hat)
    if S_C >= S_floor and S_C > S_D:
        return "C"

    return "D"
```

---

### Practical notes (why this is robust in a tournament)
- **No reliance on coordination**: it never needs others to follow a norm; it only reacts to observed defection rates and the stock.
- **State-aware**: it explicitly uses the stock dynamics rather than simplistic tit-for-tat.
- **Exploit-first**: it defects whenever sustainable, and cooperates only as an investment to enable more future defection.

If you want, I can also provide a more “predatory” variant that actively tries to **induce others into cooperating** by alternating phases (bait/harvest) while staying within the no-communication constraint.
'''

description_EXPLOITATIVE_100 = '''
## Strategy: **Stock-Conditioned Extortion (SCE)**

Exploit the stock externality: defect whenever (a) you can do so without crashing future value too much, or (b) opponents appear willing to cooperate so you can free-ride; only cooperate when (i) the stock is at risk of becoming unproductive, or (ii) you need to “buy” future cooperation from conditional opponents.

This is an **extortionate** posture: you keep the stock high enough to keep extracting, but you bias your own action toward **D** whenever the ecology and history suggest opponents will shoulder replenishment.

---

# 1) Decision rules (C vs D)

### Key observables each round \(t\)
- Current stock \(S_t\)
- History of actions in \(t-1\): number of cooperators among opponents \(k_{t-1}\in\{0,\dots,n-1\}\)
- Opponent “cooperation rate” over a window \(W\):  
  \[
  \hat{k}_t=\frac{1}{W}\sum_{j=t-W}^{t-1} k_j
  \]
- “Conditionality” signal: how strongly opponents reduce cooperation after you defect (retaliation), estimated from history.

### Core idea
Use **D by default**; switch to **C** only when:
1) the stock is entering a danger zone where continued D will likely collapse it, or  
2) opponents are retaliatory and you need to restore cooperation to keep the resource exploitable.

---

## Thresholds (parameterized, robust defaults)

Let:
- \(S_{\text{safe}} = 0.75 \cdot \text{capacity}\)
- \(S_{\text{warn}} = 0.50 \cdot \text{capacity}\)
- \(S_{\text{danger}} = 0.30 \cdot \text{capacity}\)

And window \(W = \min(10, t-1)\).

These can be tuned, but the logic is stable across \(n\), \(r\), capacity.

---

## Decision logic (high level)

### A. Endgame exploitation
- **Last round:** always **D**. No future to protect.
- **Second-to-last round:** almost always **D**, except if \(S_t\) is so low that even one more D yields near-zero payoff; then **C** can preserve a nontrivial final-round stock.

### B. Main phase (rounds 1 to r-2)
1. **If stock is high ( \(S_t \ge S_{\text{safe}}\) ):**
   - **Defect** unless opponents are clearly retaliatory *and* are currently cooperating a lot (so you can keep milking them).
   - Rationale: high stock makes D immediately lucrative; growth can recover from moderate depletion.

2. **If stock is medium ( \(S_{\text{warn}} \le S_t < S_{\text{safe}}\) ):**
   - If opponents’ recent cooperation is high (\(\hat{k}_t \ge 0.6(n-1)\)): **D** (free-ride).
   - Else: **C** (stabilize stock because others aren’t).

3. **If stock is low ( \(S_{\text{danger}} \le S_t < S_{\text{warn}}\) ):**
   - If opponents are cooperating materially (\(\hat{k}_t \ge 0.4(n-1)\)): **D** (still exploit, they are propping it up).
   - Else: **C** (resource rescue mode).

4. **If stock is critical ( \(S_t < S_{\text{danger}}\) ):**
   - **Cooperate** (unless it’s the last round).
   - Rationale: D often drives stock toward zero, killing future extraction.

---

## Retaliation/conditionality module (adaptive exploitation)

Many tournament strategies punish defectors. You want to defect **up to** the point that punishment would reduce your long-run take.

Maintain a simple retaliation score:

- Let \(k^{C}\) be the average opponent cooperators in rounds after you played **C**.
- Let \(k^{D}\) be the average opponent cooperators in rounds after you played **D**.
- Retaliation index: \(\rho = k^{C} - k^{D}\). Large \(\rho\) means they punish defection.

Use it only when stock is not critical.

**Rule:**  
If \(\rho\) is high (e.g., \(\rho \ge 0.3(n-1)\)) and \(S_t\) is in [\(S_{\text{warn}}, S_{\text{safe}}\)), then **occasionally “pay” cooperation** to keep them cooperative, otherwise **D**.

A robust way: **cooperate with probability**
\[
p_C = \min\left(0.6,\ \max\left(0,\ \frac{\rho}{(n-1)} - 0.2\right)\right)
\]
and defect otherwise.  
This creates a controlled “carrot” that maintains opponents’ cooperation while preserving your exploitative bias.

---

# 2) Edge cases

### First round
- **Round 1: Defect**, unless \(r\) is very small (e.g., \(r=2\), where you still defect anyway) or capacity is so tight that one bad round risks permanent collapse (rare given capacity ≥ 2n).
- Purpose: test the population. You learn whether opponents punish.

### Early collapse signal
If after any round the stock becomes extremely low (e.g., \(S_{t+1} < 0.1\cdot \text{capacity}\)):
- Switch to **all-C** for the next 2 rounds (unless within last round), to attempt recovery.
- If opponents keep defecting during rescue, revert to **D** (they are unrescuable; take what’s left).

### Last round
- **Always D**.

### Second-to-last round
- Default **D**.
- Exception: if \(S_t\) is so low that your last-round payoff will be nearly zero unless you cooperate now. A simple trigger:
  - If \(S_t < 0.2\cdot \text{capacity}\), play **C** in round \(r-1\), then **D** in round \(r\).

---

# 3) Why this is exploitative (and robust)

### Exploitative posture
- **D is the default.** You only cooperate to preserve the “golden goose” when necessary.
- When others cooperate, you **free-ride**: your payoff per round is doubled versus a cooperator at the same stock.
- You “buy” cooperation only when retaliation would reduce your future extraction.

### Robustness to opponent types
- **Always-defectors:** you mostly defect; you may attempt brief rescue if stock collapses, but you don’t keep donating.
- **Always-cooperators / naive strategies:** you defect heavily and harvest high payoffs; stock often stays viable because their C reduces depletion.
- **Tit-for-tat / grim-like / conditional cooperators:** the retaliation module injects just enough cooperation to keep them from fully switching to D, maintaining a profitable environment for you.
- **Random/noisy:** stock thresholds prevent you from driving the state to zero too often, preserving long-run earnings.

---

# Pseudocode (implementable)

```pseudo
params: n, r, capacity
constants:
  S_safe   = 0.75 * capacity
  S_warn   = 0.50 * capacity
  S_danger = 0.30 * capacity
state:
  history of (my_action, opp_cooperators, stock)

function retaliation_index():
  compute kC = avg opp_cooperators in rounds after my_action == C
  compute kD = avg opp_cooperators in rounds after my_action == D
  if insufficient data: return 0
  return kC - kD

function decide(t, S):
  if t == r: return D
  if t == r-1 and S < 0.20 * capacity: return C  // preserve final stock
  if t == 1: return D

  // emergency rescue mode
  if S < 0.10 * capacity and t <= r-2:
     if last two rounds not already forced rescue:
        return C

  k_hat = avg opp_cooperators over last W rounds (W=min(10,t-1))
  rho = retaliation_index()

  if S < S_danger:
     return C

  if S >= S_safe:
     // exploit hard; only soften if retaliation is severe and opps cooperate a lot
     if rho >= 0.3*(n-1) and k_hat >= 0.6*(n-1):
         return (rand() < 0.25) ? C : D
     else:
         return D

  if S >= S_warn: // medium
     if k_hat >= 0.6*(n-1): return D
     // if retaliation strong, sprinkle cooperation to restore them
     if rho >= 0.3*(n-1):
         pC = clamp((rho/(n-1)) - 0.2, 0, 0.6)
         return (rand() < pC) ? C : D
     return C

  // low but not critical: exploit if others are carrying
  if k_hat >= 0.4*(n-1): return D
  else return C
```

---

If you want, I can also provide a **more aggressively exploitative** variant (higher D rate, higher collapse risk) and a **more conservative extortion** variant (keeps stock near capacity to maximize total extractable surplus over long horizons).
'''

description_EXPLOITATIVE_101 = '''
## Strategy: **Pulse Harvester (PH)**  
Exploit others’ restraint by (i) free-riding when the stock can safely absorb it, (ii) switching to “regrow mode” only when needed to preserve future exploitation opportunities, and (iii) punishing regimes that don’t sustain the resource (so you don’t waste rounds cooperating into collapse).

The key idea is to treat **C as an investment** to keep stock high (so you can take bigger D payoffs later), and treat **D as the default extraction** whenever the environment looks sustainable or opponents are already “paying” to sustain it.

---

## Notation you can compute from history
At round `t` with current stock `S`:

- Your action is `a_i ∈ {C,D}`.
- Let `k_t` = number of defectors last round (observable).  
  If you need it “this round,” use last observed `k_{t-1}` as prediction.
- Total consumption fraction if `k` players defect:
  - each C consumes `S/(2n)`; each D consumes `S/n`
  - total consumption = `S * [ (n-k)/(2n) + k/n ] = S * (n+k)/(2n)`
  - remaining stock after consumption:
    \[
    S_{\text{rem}} = S \left(1 - \frac{n+k}{2n}\right)= S\frac{n-k}{2n}
    \]
- One-step predicted next stock given `S` and predicted `k`:
  ```
  Srem = S*(n-k)/(2n)
  growth = 2*Srem*(1 - Srem/capacity)
  Snext = min(Srem + growth, capacity)
  ```

---

## Core policy: exploit when safe, invest when necessary

### Design parameters (all derived from given parameters)
- **Safety stock threshold**:  
  `S_safe = 0.55 * capacity`  
  Above this, the system is usually resilient enough that you can defect aggressively unless everyone is defecting.
- **Collapse threshold**:  
  `S_low = 0.25 * capacity`  
  Below this, future payoffs shrink fast; if you want more future extraction, you may need to cooperate to rebuild—*but only if others appear willing to do so too*.
- **Endgame window**:  
  `W = max(2, ceil(r/6))` rounds.  
  Near the end, future doesn’t matter much: become greedier.

These constants can be tuned, but the structure is what matters.

---

## 1) Decision rules (when to C vs D)

### Rule 0 — Last round: always defect
- If `t == r`: play **D**.  
No future to protect, so take maximum immediate payoff.

---

### Rule 1 — If opponents are already collapsing the resource, don’t “martyr” yourself
If recent behavior indicates **near-universal defection**, cooperating is mostly wasted.

- Compute `k_last` = number of defectors in round `t-1` (if `t>1`).
- If `k_last >= n-1` (everyone or all-but-one defected last round):  
  play **D**.

Rationale: If the group is in a defection regime, one cooperator can’t prevent heavy depletion; better to take your share now.

---

### Rule 2 — Default exploitation when stock is healthy
If stock is not in danger, defect to exploit any cooperators.

- If `S >= S_safe` and `t <= r - W`: play **D**.

Rationale: When `S` is high, the per-round payoff from D is high, and the dynamics can often recover if not everyone defects. This is where you harvest value from more conservative strategies.

---

### Rule 3 — “Regrow mode” only when it is (a) needed and (b) likely to work
When stock is moderate/low, cooperate **only** if cooperation has a plausible chance of restoring the stock to a profitable region.

Trigger regrow evaluation if:
- `S < S_safe` and `t <= r - 1` (not the last round)

Then:
1. Predict opponents’ defection count as `k_pred = k_last` (use last observed; if `t==1`, set `k_pred = n` as a pessimistic prior).
2. Compute two predicted next stocks:
   - If you play **C**: predicted `k = k_pred`  
   - If you play **D**: predicted `k = min(n, k_pred+1)` (since you add one defector)
3. Let `Snext_C` and `Snext_D` be the predicted stocks.

Now decide:
- **Cooperate** iff all conditions hold:
  - `Snext_C - Snext_D >= 0.10 * capacity`  (your cooperation meaningfully improves next stock)
  - `k_pred <= floor(n/2)`  (at least half are not defecting; regrowth has social support)
  - `t <= r - W`  (enough future rounds to recoup investment)

Otherwise: **Defect**.

Rationale: You only “pay” the cost of C when it likely buys a materially higher future stock and the group isn’t dominated by defectors.

---

### Rule 4 — Endgame greediness (harvest phase)
When `t > r - W` (close to end), defect unless the stock is so low that even D yields little and a quick rebuild could boost immediate next payoff.

- If `t > r - W`:
  - If `S >= S_low`: play **D**
  - Else (very low stock):
    - Cooperate only if `k_last <= floor(n/2)` **and** `Snext_C > S` (rebuild is actually happening)
    - Else play **D**

Rationale: Near the end, you only cooperate for an immediate rebound you can exploit in the next 1–2 rounds.

---

## 2) Edge cases

### First round (`t=1`)
Play **D**.

Reason: you learn opponents’ tendency; if they cooperate, you immediately exploit. If they defect, cooperating wouldn’t have saved the resource anyway.

### Second round (`t=2`)
Apply the rules normally with `k_last` from round 1.

### Stock at/near zero
If `S` is extremely small, your payoffs are tiny either way, but cooperating can only help if others also cooperate. So:
- If `S < 0.05*capacity` and `k_last <= floor(n/2)` and `t <= r-W`: play **C** (attempt reboot)
- Else play **D** (don’t throw good effort after bad)

### If `capacity` is very large relative to `2n` (resource very resilient)
Rules already push more defection because `S` stays ≥ `S_safe` more often.

---

## 3) Why this is exploitative and robust

### Exploitative
- **Starts with D** to immediately take 2× the payoff of cooperators.
- **Defects whenever others sustain the stock** (high S or many cooperators), harvesting maximum flow.
- **Only cooperates when it increases future extraction potential** (i.e., when it materially raises next stock and others are not predominantly defecting).
- **Refuses to subsidize** defection regimes; if the table is burning the commons, it grabs what it can.

### Robust
- Works against:
  - **Always-Cooperate / generous**: you mostly D, stock often stays healthy due to their investment.
  - **Grim / trigger**: you may induce punishment, but your regrow mode can sometimes re-enter cooperation if they allow it; if not, you still defect optimally in the collapsed regime.
  - **Always-Defect**: you defect too; no wasted cooperation.
  - **Mixed / adaptive**: you respond to observed defection rate and to stock state, not to fragile patterns.

---

## Pseudocode (implementable)
```python
def action(t, r, n, capacity, S, history):
    # history provides last round's number of defectors k_last (if t>1)
    W = max(2, math.ceil(r/6))
    S_safe = 0.55 * capacity
    S_low  = 0.25 * capacity

    if t == r:
        return "D"

    if t == 1:
        return "D"

    k_last = history.defectors_last_round()  # integer 0..n

    # Rule 1: don't martyr into near-universal defection
    if k_last >= n - 1:
        return "D"

    # Endgame harvest phase
    if t > r - W:
        if S >= S_low:
            return "D"
        else:
            # cooperate only if opponents seem cooperative and rebuild is plausible
            if k_last <= n//2 and predicts_stock_increase(S, k_last, play="C", n=n, capacity=capacity):
                return "C"
            return "D"

    # Rule 2: exploit when healthy
    if S >= S_safe:
        return "D"

    # Rule 3: regrow mode test
    k_pred = k_last
    Snext_C = predict_next_stock(S, k_pred, n, capacity)          # you play C => k = k_pred
    Snext_D = predict_next_stock(S, min(n, k_pred+1), n, capacity)# you play D => add one defector

    if (Snext_C - Snext_D >= 0.10*capacity) and (k_pred <= n//2):
        return "C"
    return "D"
```

If you want, I can also provide a tighter mathematical choice of thresholds (`S_safe`, `S_low`, and the 0.10*capacity test) derived from comparing marginal value of higher future stock vs the immediate gain from defecting.
'''

description_EXPLOITATIVE_102 = '''
## Strategy: **Regenerative Extortion (REX)**  
Exploit the stock externality by (i) keeping the resource in a high-growth region when it benefits you, (ii) extracting aggressively when others show restraint, and (iii) never being the “sucker” who cooperates while others defect. The core idea is **one-way conditional cooperation**: you cooperate only as an investment to restore/maintain stock when it is profitable *for you*, and you defect whenever opponents are “safe” to exploit.

---

# Key observations (what the strategy exploits)

1. **Defection strictly dominates within a single round** at a fixed stock \(S\): you get \(S/n\) vs \(S/(2n)\).
2. The only reason to cooperate is **state management**: preserving stock so you can extract more later.
3. The logistic growth is strong when the post-consumption remainder is in the interior; catastrophic when remainder goes to 0.  
4. Therefore, the exploiter wants to:
   - **Avoid stock collapse** when it would reduce their own future rents.
   - **Let others do the conserving** whenever possible, then **take D** to skim the high stock.

---

# Data you track from history/state each round \(t\)
- Current stock \(S_t\)
- For each opponent \(j\): count of defections in a recent window, e.g., last \(w = \min(10, t-1)\) rounds.
- Last round’s total number of defectors \(k_{t-1}\) (or equivalently, total consumption inferred from actions and \(S_{t-1}\)).
- A “cooperation climate” score:  
  \[
  \text{DefectRate}_t = \frac{\#\text{opponent D in last }w\text{ rounds}}{(n-1)\cdot w}
  \]

---

# Core control thresholds (parameter-only, no tuning to specific opponents)

Define:
- **High-stock threshold**: \(S_{\text{high}} = 0.8 \cdot \text{capacity}\)
- **Low-stock threshold**: \(S_{\text{low}} = 0.35 \cdot \text{capacity}\)
- **Collapse-danger threshold**: \(S_{\text{danger}} = \max(2n, 0.2\cdot \text{capacity})\)  
  (Below this, one or two bad rounds can effectively end the game’s value.)
- **Cooperative environment** if \(\text{DefectRate}_t \le 0.35\)
- **Hostile environment** if \(\text{DefectRate}_t \ge 0.55\)

Also define remaining rounds: \(R = r - t + 1\).

---

# 1) Decision rules (when to C vs D)

### Rule A — **Last-round rule (pure exploitation)**
- If \(t = r\): **play D**.
  - No future stock value. Take maximum immediately.

---

### Rule B — **Exploit cooperative environments at high stock**
- If \(S_t \ge S_{\text{high}}\) **and** environment is cooperative: **play D**.
  - Rationale: when others tend to conserve, you free-ride and extract maximum.

---

### Rule C — **Never cooperate into obvious exploitation**
- If in the previous round \(k_{t-1} \ge \lceil n/2 \rceil\) (at least half defected): **play D**.
  - Rationale: if many defect, your cooperation barely protects stock and just hands value to defectors.

---

### Rule D — **State-repair mode (cooperate only when it pays you to keep the game alive)**
Enter repair mode when the stock is low enough that continued defection risks collapse **and** there are enough rounds left to recoup investment:

- If \(S_t \le S_{\text{low}}\) **and** \(R \ge 3\) **and** environment is not hostile: **play C**.
  - This is “investing” to raise stock back into profitable range so you can defect later.
- If \(S_t \le S_{\text{danger}}\):  
  - If environment is hostile: **play D** (salvage what you can; don’t throw good effort after bad).  
  - Else (not hostile): **play C** (attempt emergency stabilization).

---

### Rule E — **Default rule (extortionate stance)**
In all other cases: **play D**.

This makes the strategy exploitative by default; cooperation only happens when it is a profitable stock-maintenance investment and opponents are sufficiently likely to not squander it.

---

# 2) Edge cases and special handling

### First round
- **Round 1: play D**.
  - Rationale: immediate rent extraction; also probes opponent tendencies without sacrificing payoff. With initial stock at capacity, this is the best exploitation opportunity.

### Early-game probing (optional but robust)
For rounds \(t=2,3\), you can slightly refine without losing the exploitative nature:
- If you observed **0 opponent defections** in round 1 (everyone else played C), continue **D** (they are exploitable).
- If you observed **many defections** (≥ half), continue **D** (game is likely headed to collapse; take what you can).

### Near the end (endgame liquidation)
- If \(R \le 2\): **play D** regardless of stock/environment.
  - Future is too short to justify investing in stock.

### Handling oscillations / “suckering” attempts
If you played **C** last round and at least one opponent defected, flip to a **punishment stance**:
- For the next \(p = 2\) rounds: **play D**, then revert to normal rules.
  - This prevents opponents from farming you by defecting whenever you cooperate.

(You still might return to C later in repair mode, but only if stock is genuinely critical and environment isn’t hostile.)

---

# 3) Why this is exploitative (and robust)

### Exploitative by design
- **Defaults to D**: you consistently take the larger immediate share.
- **Free-rides on cooperators**: in high-stock cooperative climates, you defect to skim the largest benefit while others stabilize the resource.
- **Withholds cooperation as leverage**: you only “invest” when it preserves your future ability to extract, not to be fair.

### Robust across opponent types
- Against **naive cooperators / sustainers**: you mostly defect and harvest high payoffs while they maintain stock.
- Against **grim defectors / always-D**: you defect too, salvaging early payoffs; you don’t waste cooperation trying to fix an unwinnable environment.
- Against **conditional cooperators**: you may occasionally cooperate in repair mode, but you punish any exploitation quickly, discouraging them from defecting against your C.
- Against **chaotic/mixed**: defect by default, cooperate only under tight “stock-critical but not hostile” conditions.

---

# Pseudocode (implementable)

```pseudo
parameters:
  S_high = 0.8 * capacity
  S_low  = 0.35 * capacity
  S_danger = max(2*n, 0.2*capacity)
  w = 10
  punish_len = 2

state variables:
  punish_counter = 0
  history of opponent actions

function defect_rate(t):
  window = last min(w, t-1) rounds
  return (# opponent Ds in window) / ((n-1) * len(window))

function choose_action(t, S_t):
  R = r - t + 1
  if t == r: return D
  if R <= 2: return D

  if punish_counter > 0:
      punish_counter -= 1
      return D

  if t > 1:
     k_prev = # of all players who played D in round t-1
     if k_prev >= ceil(n/2): return D

  dr = defect_rate(t)
  cooperative_env = (dr <= 0.35)
  hostile_env = (dr >= 0.55)

  if S_t >= S_high and cooperative_env:
      return D

  if S_t <= S_danger:
      if hostile_env: return D
      else return C

  if S_t <= S_low and R >= 3 and not hostile_env:
      return C

  return D

after round t resolves:
  if my_action(t) == C and (exists opponent D in round t):
      punish_counter = punish_len
```

---

If you want, I can also provide a variant that explicitly targets *one* “most cooperative” opponent to maximize free-riding (by estimating who stabilizes stock the most), but the above is already adaptive, parameter-based, and reliably exploitative in mixed tournaments.
'''

description_EXPLOITATIVE_103 = '''
Below is an **exploitative, stateful “harvest-and-punish” strategy** designed to (i) **take D whenever it’s safe/profitable**, (ii) **use C only as an investment to keep the resource productive**, and (iii) **punish quickly** when others are overharvesting, while still being able to **re-enter exploitation** if others rebuild.

Key idea: because payoffs scale with current stock \(S\), you want the stock **high when you defect**. You therefore (a) defect when the stock is high and opponents appear “sustainable”, (b) cooperate only to **rebuild** or **stabilize** the stock, and (c) switch to defect in the **endgame** regardless.

---

## 1) Decision rules (C vs D)

### Quantities you track from history
At round \(t\), with observed current stock \(S_t\) and last round actions:

- Let \(d_{t-1}\) = number of opponents who played **D** last round (out of \(n-1\)).
- Let \(\hat{d}_{t-1} = d_{t-1}/(n-1)\) = opponent defection rate last round.
- Maintain a short “opponent harshness” estimate using an exponential moving average (EMA):
  \[
  q_t = \lambda q_{t-1} + (1-\lambda)\hat{d}_{t-1}
  \]
  with \(\lambda \in [0.6, 0.9]\) (e.g., 0.8). Initialize \(q_1 = 0.5\).

This makes you robust to noisy/reactive strategies and avoids overreacting to one off move.

### Stock regime thresholds (parameter-only, no opponent assumptions)
Define:
- High-stock threshold: \(S_{\text{high}} = 0.9 \cdot \text{capacity}\)
- Safe-stock threshold: \(S_{\text{safe}} = 0.6 \cdot \text{capacity}\)
- Low-stock threshold: \(S_{\text{low}} = 0.35 \cdot \text{capacity}\)

Intuition: logistic growth is strong at mid stocks and weak near 0 and near capacity. You want to avoid pushing into the “collapse basin” (very low stock), but otherwise you want to harvest aggressively.

### “Exploitability” conditions
You primarily defect when:
- Stock is high enough that the immediate gain is big, AND
- Opponents look cooperative/sustainable enough that the stock won’t immediately crash.

Formally, define:
- Opponent “cooperativeness” estimate: \(c_t = 1 - q_t\).
- Sustainable-opponents condition: \(q_t \le q_{\max}(S_t)\), where
  - \(q_{\max}(S) = 0.25\) if \(S \ge S_{\text{safe}}\)
  - \(q_{\max}(S) = 0.10\) if \(S_{\text{low}} \le S < S_{\text{safe}}\)
  - \(q_{\max}(S) = 0\) if \(S < S_{\text{low}}\)

So: the lower the stock, the less defection you tolerate from others before you switch to rebuild/punish.

---

## Core policy (per round \(t\))

### A. Endgame override (exploit the last rounds)
Let \(H\) be an endgame horizon, e.g.:
- \(H = \max(2, \lceil r/10 \rceil)\)

**If \(t > r - H\): play D always.**  
Reason: future stock no longer matters much; take the one-shot advantage.

### B. Collapse prevention (don’t lose the cash cow too early)
If \(S_t \le S_{\text{low}}\): **play C** (unless in endgame).  
Reason: at very low stocks, further depletion kills all future payoffs; even for an exploiter, you need the resource alive.

### C. Punish overharvesting (force opponents to pay or rebuild)
If \(q_t > q_{\max}(S_t)\): **play D** for a fixed punishment window \(P\), then reassess.

- Punishment window: \(P = 2\) rounds (or 3 if \(n\) is large, e.g. \(n \ge 8\)).

This is exploitative: if others defect, you do not “heroically” cooperate; you **deny them the benefit** of your restraint.

### D. Exploit cooperative tables (your main money-maker)
If \(S_t \ge S_{\text{safe}}\) and \(q_t \le q_{\max}(S_t)\): **play D**.  
This is the core exploitation mode: harvest double while others keep the stock from collapsing.

### E. Otherwise, rebuild just enough
In intermediate cases (stock middling, opponents somewhat mixed): **play C** as a short investment until stock recovers, then go back to D.

Concretely:
- If \(S_{\text{low}} < S_t < S_{\text{safe}}\) and \(q_t \le 0.10\): play **C** (rebuild).
- If \(S_{\text{low}} < S_t < S_{\text{safe}}\) and \(q_t > 0.10\): play **D** (don’t get exploited while rebuilding).

This avoids being the only cooperator among defectors when stock is precarious.

---

## 2) Edge cases (first round, last round, special situations)

### First round (no history)
Round 1 rule: **play D**.

Rationale: It’s a tournament; you want immediate advantage and information. If everyone collapses the stock, that reveals the environment is hostile and you lose little by trying; if others cooperate, you immediately profit and can later decide how much to “invest” to keep the stock productive.

Initialize:
- \(q_1 = 0.5\) (neutral prior) or equivalently treat “unknown” as moderately defect-prone.
- But still play D in round 1.

### Last round / near-last
As above: **always D in the final \(H\) rounds**.

### If stock is at/near capacity for multiple rounds
If \(S_t \ge S_{\text{high}}\) and opponents are not heavily defecting: **always D**.  
Reason: the system is extremely forgiving near capacity; you should extract.

### If opponents oscillate / are reactive
The EMA \(q_t\) plus short punishment window prevents you from being baited by one-off “nice” moves. You require sustained cooperativeness to return to rebuild mode.

### If everyone defects and stock hits 0
Then \(S_t=0\) gives 0 payoff regardless. Your policy will select **C** (outside endgame) once \(S\le S_{\text{low}}\), attempting to restart growth if possible. If others keep defecting, punishment mode (D) doesn’t hurt you (still ~0), but cooperating can reintroduce value—so the collapse-prevention rule dominates at low stock.

---

## 3) Why this is exploitative (and not “fair”)
- **Defaults to D** in round 1 and in the endgame.
- **Defects whenever opponents appear to sustain the resource**, extracting the higher per-round payoff \(S/n\) while others take \(S/(2n)\).
- **Refuses to be the sucker**: if others defect beyond a small tolerance, you switch to D (punish), not C.
- **Only cooperates instrumentally**: C is used as a temporary investment to keep \(S\) in a range where future defections are lucrative.

---

## Pseudocode (implementable)

```python
# parameters: n, r, capacity
S_high = 0.9 * capacity
S_safe = 0.6 * capacity
S_low  = 0.35 * capacity

H = max(2, ceil(r/10))
lambda_ = 0.8

q = 0.5  # EMA of opponent defection rate
punish_remaining = 0

def q_max(S):
    if S >= S_safe: return 0.25
    if S >= S_low:  return 0.10
    return 0.0

for t in 1..r:
    observe current stock S_t

    if t == 1:
        action = "D"
    else:
        # update q based on last round
        hat_d = (num_opponents_defected_last_round) / (n-1)
        q = lambda_ * q + (1 - lambda_) * hat_d

        # endgame override
        if t > r - H:
            action = "D"

        # collapse prevention
        elif S_t <= S_low:
            action = "C"

        # if currently punishing, continue
        elif punish_remaining > 0:
            action = "D"
            punish_remaining -= 1

        # trigger punishment if opponents too defect-y for current stock
        elif q > q_max(S_t):
            action = "D"
            punish_remaining = 2  # or 3 if n large

        # exploit mode: high/safe stock + tolerable opponent defection
        elif S_t >= S_safe and q <= q_max(S_t):
            action = "D"

        # rebuild mode only when others are quite cooperative
        else:
            if (S_low < S_t < S_safe) and (q <= 0.10):
                action = "C"
            else:
                action = "D"

    play(action)
```

If you want this even more exploitative, reduce \(S_{\text{low}}\) (cooperate less to prevent collapse) and shorten/disable rebuild mode; if you want more robustness to long horizons, increase rebuild propensity when \(S\) is mid-range.
'''

description_EXPLOITATIVE_104 = '''
Below is an **exploitative, stateful “leader/harvester” strategy**: it tries to (i) keep the stock in the high-growth region so there is something to steal later, (ii) quickly detect whether opponents are “stock-friendly” (often C) or “stock-hostile” (often D), and (iii) **defect whenever it can do so without collapsing the resource**, harvesting extra payoff while others maintain the stock.

The key idea: with stock \(S\), your one-shot gain from defecting vs cooperating is \(S/(2n)\) (double the consumption). So you want \(S\) high—but you also don’t want total consumption to drive \(S\) to (near) zero, because then future payoffs vanish. So we defect **only when predicted remaining stock after consumption stays above a safety threshold**, and we cooperate otherwise to “rebuild the pie” (often letting others pay most of the rebuilding cost later).

---

## Notation you can compute from history

At round \(t\), current stock is \(S_t\).

Let:
- \(c_C(S) = S/(2n)\) (your consumption if C)
- \(c_D(S) = S/n\) (your consumption if D)

From history, track for each opponent \(j\):
- \(p_j(t)\): estimated probability opponent \(j\) defects this round.
  - Use an exponentially weighted moving average (EWMA):
    \[
    p_j \leftarrow (1-\alpha)\,p_j + \alpha \cdot \mathbf{1}\{\text{j defected last round}\}
    \]
  - Initialize \(p_j(1)=0.5\). Reasonable \(\alpha\in[0.2,0.4]\) (e.g. 0.3).

Then predicted total **opponent** consumption at stock \(S\):
\[
\widehat{C}_{-i}(S) = \sum_{j\neq i} \left[p_j \cdot \frac{S}{n} + (1-p_j)\cdot \frac{S}{2n}\right]
= \frac{S}{2n}\sum_{j\neq i}(1+p_j)
\]

If you play action \(a\in\{C,D\}\), predicted remaining stock after consumption:
\[
\widehat{S}_{\text{rem}}(a) = S - \widehat{C}_{-i}(S) - c_a(S)
\]

---

## Strategic thresholds (parameter-only + state)

Define these thresholds:

1. **Safety floor (avoid collapse):**
   \[
   S_{\text{floor}} = 0.25 \cdot \text{capacity}
   \]
   (If remaining stock dips too low, growth may not recover fast enough under adversarial play; this floor is conservative.)

2. **Target “harvest zone”:**
   \[
   S_{\text{harvest}} = 0.70 \cdot \text{capacity}
   \]
   (When stock is high, defecting yields large immediate gains.)

3. **Endgame length:**
   \[
   k = \min(3,\ \lfloor r/4 \rfloor)
   \]
   (In last \(k\) rounds, you become more myopic and defect more.)

You can tune constants, but these work as a robust default.

---

## 1) Decision rules (when cooperate vs defect)

### Rule A — Endgame: defect unless it would obviously crash the stock to ~0 immediately
If \(t > r-k\) (last \(k\) rounds):

- If \(\widehat{S}_{\text{rem}}(D) > 0\): **Play D**
- Else: **Play C** (only if defect would mathematically exhaust the pool this round)

Rationale: no future to protect; exploit.

---

### Rule B — Early/midgame: “Defect when safe, cooperate when necessary”
For rounds \(t \le r-k\):

1. Compute \(\widehat{S}_{\text{rem}}(D)\) and \(\widehat{S}_{\text{rem}}(C)\).

2. **If predicted opponents are already stock-hostile**, do not waste cooperation:
   - Define predicted opponent defect rate:
     \[
     \bar p = \frac{1}{n-1}\sum_{j\neq i} p_j
     \]
   - If \(\bar p \ge 0.6\): **Play D**
     - Exception: if \(\widehat{S}_{\text{rem}}(D) \le 0\), play C (avoid immediate zeroing if you can).

   Rationale: if most are defecting, cooperation is mostly charity; take what you can.

3. **Otherwise (opponents somewhat cooperative): exploit them, but keep the stock viable.**

   - If \(\widehat{S}_{\text{rem}}(D) \ge S_{\text{floor}}\): **Play D**
     - (You can safely defect and still keep the resource in a recoverable region; you’re free-riding.)

   - Else if \(\widehat{S}_{\text{rem}}(C) \ge S_{\text{floor}}\): **Play C**
     - (Cooperate only when it’s needed to keep the stock above the floor.)

   - Else: **Play D**
     - (If even cooperating can’t keep it above the floor, you’re in a “doomed/overharvested” regime—grab remaining payoff.)

This is the core “exploit with a safety constraint” logic.

---

### Rule C — Opportunistic bullying of “unconditional cooperators”
If you identify at least one opponent with very low defection probability:
- If exists \(j\) with \(p_j \le 0.1\) for the last few updates, and \(S_t \ge S_{\text{harvest}}\):
  - **Play D** unless \(\widehat{S}_{\text{rem}}(D) \le 0\)

Rationale: if someone is basically funding the stock’s recovery (by consuming less), you harvest.

(You don’t need to single them out; their behavior increases your safe-to-defect region.)

---

## 2) Edge cases

### First round
Round 1 has no history; default to **D** unless it is obviously catastrophic.

- With \(p_j=0.5\), predicted remaining under D is usually positive for reasonable \(n\), and you want to test the field.
- So:
  - If \(\widehat{S}_{\text{rem}}(D) > 0\): play **D**
  - Else: play **C**

This is an exploitative “probe”: you get high payoff immediately and learn who punishes (by defecting) vs who stabilizes (by cooperating).

### Very low stock
If \(S_t\) is tiny (e.g. \(S_t \le \epsilon\), with \(\epsilon=10^{-6}\) or a small numeric guard), then both actions yield ~0 anyway:
- Play **D** (no downside; also consistent with exploitative stance).

### If everyone defects and stock hits 0
Once \(S_t=0\), the game is effectively dead forever (growth is 0 at 0).
- Any action is equivalent; play **D**.

### Last round
Always **D** unless it would literally consume the last positive stock while C would not (rare due to simultaneity and proportionality), but since payoff is proportional to \(S\) and there’s no future, the only reason not to D is if your D changes your own immediate payoff? It doesn’t—D always gives you more at same \(S\). So:
- Last round: **D**.

---

## 3) Why this is exploitative (and robust)

- **Free-riding on cooperators:** When others cooperate enough to keep the stock above the floor, you defect to double your share while letting them bear the sustainability cost.
- **No moral “reciprocity” commitments:** You only cooperate instrumentally—when your own future harvesting depends on keeping the stock from collapsing.
- **Robust to many behaviors:**
  - Versus always-C / naive sustainers: you largely defect while keeping the pool viable → high relative payoff.
  - Versus grim/retaliatory defectors: your EWMA quickly pushes \(\bar p\) up → you switch to constant defection, not getting suckered.
  - Versus mixed strategies: your “defect-if-safe” rule adapts to observed defection rates and current stock.

---

## Pseudocode (implementable)

```python
initialize p[j] = 0.5 for all opponents j
alpha = 0.3
S_floor = 0.25 * capacity
S_harvest = 0.70 * capacity
k = min(3, r // 4)

def predict_opponent_consumption(S, p):
    # expected opponent consumption given stock S
    # sum_{j!=i} S/(2n) * (1 + p[j])
    return (S / (2*n)) * sum(1 + p_j for p_j in p.values())

def decide(t, S, p):
    if t >= r - k + 1:  # last k rounds
        # defect unless it would force immediate exhaustion in calculation
        C_opp = predict_opponent_consumption(S, p)
        Srem_D = S - C_opp - (S / n)
        if Srem_D > 0:
            return "D"
        else:
            return "C"

    # early/midgame
    C_opp = predict_opponent_consumption(S, p)
    Srem_D = S - C_opp - (S / n)
    Srem_C = S - C_opp - (S / (2*n))

    avg_p = sum(p.values()) / (n-1)

    # if opponents are mostly defecting, don't donate
    if avg_p >= 0.6:
        if Srem_D > 0:
            return "D"
        else:
            return "C"

    # opportunistic bullying when stock high and at least one near-unconditional cooperator
    if S >= S_harvest and any(p_j <= 0.1 for p_j in p.values()):
        if Srem_D > 0:
            return "D"
        else:
            return "C"

    # core rule: defect if safe, else cooperate if it meaningfully helps, else defect
    if Srem_D >= S_floor:
        return "D"
    elif Srem_C >= S_floor:
        return "C"
    else:
        return "D"

def update_p(p, last_actions):
    for j, act in last_actions.items():
        p[j] = (1 - alpha) * p[j] + alpha * (1 if act == "D" else 0)
```

This strategy is deliberately not “fair”: it aims to **maximize your cumulative payoff relative to others**, using cooperation only as a tool to preserve a resource you intend to harvest.
'''

description_EXPLOITATIVE_105 = '''
### Strategy: **Pump–Test–Harvest (PTH)**  
Goal: extract high short-run payoffs by defecting whenever it is safe, while keeping the stock high enough to continue harvesting. The strategy *creates* a high-stock environment (only when profitable), *tests* whether others will sustain it, and then *harvests* aggressively while punishing stock-destroyers.

---

## Key quantities (computed from parameters + history)

Let:
- `S_t` = stock at start of round `t`
- `k_t` = number of players who defected in round `t` (observed from actions)
- Consumption totals given `k` defectors:
  - Each C consumes `S/(2n)`; each D consumes `S/n`
  - Total consumption fraction =  
    \[
    \frac{(n-k)}{2n} + \frac{k}{n} = \frac{n+k}{2n}
    \]
  - Remaining stock after consumption:
    \[
    S' = S \left(1 - \frac{n+k}{2n}\right) = S\cdot \frac{n-k}{2n}
    \]
So remaining stock depends only on `k`. This lets you forecast sustainability.

Define two thresholds (depend only on `capacity`):
- **Safe stock level:** `S_safe = 0.8 * capacity` (above this, you can afford to defect more)
- **Critical stock level:** `S_crit = 0.35 * capacity` (below this, defecting risks collapsing future payoffs)

Define opponent classification from last `w` rounds (e.g., `w = min(5, t-1)`):
- `defect_rate = (sum_{τ=t-w..t-1} k_τ)/(w*n)` = fraction of opponent moves that were D
- `collapse_risk` if recent stocks are trending down: `S_{t-1} < S_{t-2} < ...` (or simply `S_{t-1} < S_safe` and `defect_rate` high)

---

## 1) Decision rules: when to Cooperate vs Defect

### Rule A — **Last-round grab**
- **If `t == r`: play D.**  
Exploit endgame: no future to protect.

### Rule B — **If stock is high, harvest**
- If `S_t >= S_safe`, **play D**, *unless* you are in “pump mode” (below).  
Reason: when stock is near capacity, one round of higher extraction is valuable and typically recoverable if others aren’t all defecting.

### Rule C — **If stock is critical, stabilize (but only if it can be saved)**
- If `S_t <= S_crit`:
  - If last round had **many defectors** (`k_{t-1} >= n/2`): **play D** (cut losses / “loot” before collapse).  
    Rationale: your cooperation won’t prevent collapse if most are defecting; cooperating just subsidizes them.
  - Else (few defectors recently): **play C** (try to rebuild stock cheaply).

### Rule D — **Exploit cooperators: conditional defection based on others’ behavior**
When `S_crit < S_t < S_safe` (mid-range stock), decide based on estimated opponent cooperativeness:

- If `defect_rate <= 0.25` (mostly cooperators): **play D**.  
  You can free-ride; the stock likely stays healthy.
- If `0.25 < defect_rate <= 0.55`: **play C** *only every other round* (a “minimal maintenance” pattern), otherwise D.  
  This keeps the resource from drifting down while still extracting extra.
- If `defect_rate > 0.55` (mostly defectors): **play D**.  
  No point maintaining a public good for predators.

### Rule E — **Pump–Test–Harvest cycle**
To be robust against unknown opponents, you explicitly “probe” early:

- **Pump phase (2 rounds max):** If `t` is early (`t <= 2`) and `S_t` is high, **play C** in round 1, then:
  - If `k_1 == 0` or `k_1` very small (`<= 1`), opponents look cooperative → go to **Harvest phase** (start defecting).
  - If `k_1` moderate/high, skip pumping → defect from round 2 onward.

- **Test phase (occasionally):** If you have been defecting and notice stock falling (`S_t < S_safe` and `S_t < S_{t-1}`), play **one** C as a test:
  - If `k_t` drops next round (others respond by cooperating more), resume harvest (D).
  - If not, revert to D permanently (they won’t stabilize).

This avoids being the sucker who always “rescues” the stock.

---

## 2) Edge cases

### First round
- **Round 1: play C** *unless* parameters make collapse extremely likely:
  - If `capacity` is just barely `≥ 2n` (low buffer) or you expect D-heavy play, you still gain information by pumping once; but if you want maximal exploitation, you can instead:
  - **Default**: `C` in round 1 to see who defects when the stock is full (most informative signal).
  
Why not always D in round 1? Because if everyone D’s, the stock hits 0 and the game becomes trivial. A single early C sometimes “buys” multiple future high-stock rounds to exploit.

### Last round
- **Always D** (Rule A).

### Second-to-last round
- If `t == r-1`:
  - If `S_t` is high: **D**
  - If `S_t` is low: **D**  
There’s little time to recover stock, so prioritize immediate payoff.

### If stock hits ~0
- If `S_t` is very small (e.g., `< 0.05*capacity`), actions barely matter for payoff; still:
  - **play D** (dominates per-round payoff at any `S>0`).

---

## 3) Why this is exploitative (and robust)

**Exploitative core:**  
- Defection always gives double the current-round payoff vs cooperation at the same `S`.  
- PTH cooperates only when it expects that (a) cooperation prevents a larger future loss, and (b) others are cooperative enough that your “maintenance” isn’t just a subsidy.

**Robustness:**  
- Against always-cooperate / nice strategies: you quickly shift into harvest mode and free-ride heavily.
- Against grim-trigger / punitive cooperators: your early pump reduces the chance you trigger instant collapse; your later “test C” can sometimes reset cooperation, but you don’t persist if it fails.
- Against always-defect: you defect nearly always (maximizing what little is available) and don’t waste moves trying to rebuild.
- Against mixed / adaptive populations: you condition on observed defect rates and stock trajectory, which are the two sufficient signals for whether maintaining the pool is worthwhile.

---

## Pseudocode sketch

```text
Parameters:
  S_safe = 0.8 * capacity
  S_crit = 0.35 * capacity
  w = 5

At round t with stock S_t:

if t == r: 
  return D

if t == 1:
  return C   # pump once for information

# compute defect_rate over last w rounds
w_eff = min(w, t-1)
defect_rate = (sum_{τ=t-w_eff..t-1} k_τ) / (w_eff * n)

if t >= r-1:
  return D

# critical stock handling
if S_t <= S_crit:
  if k_{t-1} >= n/2:
    return D   # cut losses; others are collapsing it
  else:
    return C   # try to rebuild if others aren't too predatory

# high stock harvest
if S_t >= S_safe:
  return D

# mid-range: exploit if others are cooperative
if defect_rate <= 0.25:
  return D

if defect_rate <= 0.55:
  # minimal maintenance: cooperate intermittently
  if (t mod 2 == 0) and (S_t is decreasing):
    return C
  else:
    return D

# mostly defectors
return D
```

If you want this even more exploitative: reduce cooperation frequency in the “minimal maintenance” region (e.g., cooperate only when `S_t` drops below `0.5*capacity`), at the cost of higher collapse risk.
'''

description_EXPLOITATIVE_106 = '''
## Strategy: **Hydra-Leech (HL)**  
Exploit anyone who is even slightly cooperative by (i) keeping the stock high enough that *your* defections are lucrative and (ii) never “paying” to sustain the stock unless you must to keep the resource from collapsing (which would reduce your future defect gains).

The core idea: **Defect whenever the stock can afford it and opponents appear willing to keep it afloat; cooperate only as a tactical investment to preserve future exploitation.**

---

## Key quantities (all computable from parameters, state, history)

Let in round \(t\), stock at start be \(S_t\). After observing actions in round \(t\), compute:

- **# defectors**: \(k_t =\) number of players who played \(D\) in round \(t\)
- **Remaining stock after consumption** (from the model, can be derived from \(S_t\) and \(k_t\)):  
  Each cooperator consumes \(S_t/(2n)\), each defector consumes \(S_t/n\).  
  Total consumption fraction is \(\frac{n-k_t}{2n} + \frac{k_t}{n} = \frac{1}{2} + \frac{k_t}{2n}\).  
  So remaining:
  \[
  R_t = S_t\left(1 - \frac{1}{2} - \frac{k_t}{2n}\right) = S_t\cdot\frac{n-k_t}{2n}
  \]
- **Predicted next stock if in next round there are \(k\) defectors** (approx planning):  
  If next round starts at \(S\) and ends with remaining \(R=S\frac{n-k}{2n}\), then next stock:
  \[
  f(S,k)=\min\Big(R + 2R(1-R/\text{capacity}),\ \text{capacity}\Big)
  \]
- **Opponent “support level”**: how cooperative the population is lately.  
  Use an exponentially weighted moving average (EWMA) of opponents’ defect rate:
  \[
  \hat{d}_t = (1-\alpha)\hat{d}_{t-1} + \alpha \cdot \frac{k_t - a_t}{n-1}
  \]
  where \(a_t\in\{0,1\}\) is your own action (1 if you defected). Use e.g. \(\alpha=0.3\).  
  (Any monotone “recent defect fraction” works.)

---

## Decision rules (Cooperate vs Defect)

### Rule 0 — Always defect in the last round
- **Round \(t=r\): play \(D\)**.  
No future to protect; take the larger immediate payoff.

---

### Rule 1 — Collapse avoidance (only cooperate when stock is in the danger zone)
Define a danger threshold \(S_{\text{low}}\) below which the stock is too low to reliably regrow if too many defect:

- Set \(S_{\text{low}} = 0.25 \times \text{capacity}\).

If \(S_t \le S_{\text{low}}\):  
- **Play \(C\)** unless you have strong evidence everyone else will also cooperate (rare without comms).  
Reason: at low stock, mutual defection tends to pin stock near 0, destroying your future defect rents.

This is the “minimum investment” clause: you don’t cooperate to be nice, you cooperate to keep the resource exploitable.

---

### Rule 2 — Primary exploit condition: defect when opponents are “supporting”
If \(S_t > S_{\text{low}}\), decide based on whether opponents are likely to keep the stock from collapsing:

Compute **support score**:
- \( \text{support}_t = 1 - \hat{d}_{t-1} \) (higher means more cooperative opponents recently)

Then:
- If \( \text{support}_t \ge \theta \) (cooperators are common), **play \(D\)**.
- Else (opponents are mostly defecting), **play \(C\)** to attempt to move the system out of collapse *only if* it’s profitable to do so; otherwise defect anyway.

Recommended \(\theta\): **0.55**.  
Interpretation: as soon as opponents are even slightly more cooperative than not, you become a free-rider.

---

### Rule 3 — “One-way forgiveness”: exploit quickly, punish slowly
To be robust against strategies that punish defectors (grim-trigger variants), HL uses a *limited* “repair mode” but only when it can restore future rents.

Define:
- \(m\): number of consecutive rounds where opponents’ defect fraction > 0.7 (a “defection regime”). Track it from history.

If \(m \ge 2\) **and** \(S_t \le 0.5\cdot\text{capacity}\):  
- **Play \(C\)** (attempt repair).
Else:  
- **Play \(D\)**.

This prevents you from permanently collapsing into mutual \(D\) if there’s any chance of rebuilding and then exploiting again. But it does not over-invest: repair is triggered only after sustained opponent defection and only when stock isn’t already near full (where your defection is immediately juicy).

---

### Rule 4 — Opportunistic “harvest” when stock is high
When the stock is near capacity, a single defection yields a large immediate gain and the system can often recover if others cooperate at all.

If \(S_t \ge 0.85\cdot\text{capacity}\):  
- **Play \(D\)** regardless of \(\hat{d}\), except if you are in “repair mode” from Rule 3.

This is explicitly exploitative: you take maximum rent when the commons is abundant.

---

## Edge cases

### First round
- **Round 1: play \(D\)**.  
Rationale: with initial stock at capacity, defecting strictly dominates cooperating in that round, and you learn quickly whether opponents punish or keep cooperating.

### Last two rounds nuance
- **Round \(r\): D always** (Rule 0).
- **Round \(r-1\): almost always D** unless \(S_{r-1}\) is extremely low and you think you can raise \(S_r\) enough to make your final-round \(D\) bigger.  
Practical rule:
  - If \(S_{r-1} \le 0.15\cdot\text{capacity}\), play \(C\) in \(r-1\) (try to inflate final round).
  - Else play \(D\).

### Stock already at (or near) 0
- If \(S_t\) is tiny, payoffs are tiny; you’re in a “dead commons.”  
HL response:
  - Play \(C\) for up to **2 rounds** to see if others also invest.
  - If after those 2 rounds the observed opponent defect fraction remains > 0.7, switch to permanent \(D\) (nothing to salvage).

---

## Pseudocode (implementable)

```pseudo
params: n, r, capacity
state: S_t (stock at start of round t), history actions

constants:
  alpha = 0.3
  theta = 0.55
  S_low = 0.25 * capacity

vars:
  d_hat = 0.5   # belief opponents defect rate
  defection_streak = 0
  repair_probe = 0

for t in 1..r:
  if t == r:
    action = D
  else:
    if t == 1:
      action = D
    else:
      # update defection_streak based on last round observed opp defect fraction
      opp_def_frac = (k_{t-1} - my_last_action_as_0_1) / (n-1)
      if opp_def_frac > 0.7: defection_streak += 1 else defection_streak = 0

      # update EWMA belief
      d_hat = (1-alpha)*d_hat + alpha*opp_def_frac
      support = 1 - d_hat

      if S_t <= S_low:
        action = C
      else if defection_streak >= 2 and S_t <= 0.5*capacity:
        action = C    # repair mode
      else if S_t >= 0.85*capacity:
        action = D
      else if support >= theta:
        action = D
      else:
        # opponents mostly defecting: only invest if there is something to gain later
        if t == r-1 and S_t <= 0.15*capacity:
          action = C
        else:
          action = D

  play action, observe all actions, update k_t, etc.
```

---

## Why this is exploitative (and robust)
- **Exploitative:** defaults to \(D\) whenever there is adequate stock or opponent support; it free-rides on any cooperative mass.
- **Adaptive:** uses observed defection rates to detect whether cooperation is being sustained by others vs the game is collapsing.
- **Robust:** avoids naive “always defect” self-destruction by selectively investing only when the stock is low enough that future defect profits are threatened.
- **Tournament-suitable:** no reliance on communication, identities, or coordination; only uses state/history.

If you share typical tournament opponent types you expect (e.g., TFT-like, grim-trigger, random, always-C), I can tune thresholds (\(S_{\text{low}}, \theta\)) to maximize exploitation under that mix.
'''

description_EXPLOITATIVE_107 = '''
Below is an **exploitative, stateful “Leader–Leech with Safety Floor”** strategy. It tries to (i) **induce** others to cooperate by keeping the stock healthy, (ii) **defect whenever it is profitable and “safe”** (won’t crash future value too much), and (iii) **punish/stop investing** when opponents look selfish or non-responsive.

The key idea is that because your action scales with current stock \(S\), you can treat “defecting” as taking **twice** the per-round share of “cooperating.” So you want to defect whenever you can do so without pushing the system into the low-stock region where future rounds become worthless.

---

## Core quantities you track each round

At round \(t\), before choosing your action, you observe current stock \(S_t\) and history.

1. **Infer how many defectors last round** (or, if you have full action observability, just count them).
   - If actions are observable: \(k_{t-1} = \#\{\text{opponents who played D at } t-1\}\).
   - If you only want state-based inference: total consumption last round is \(S_{t-1} - S_{\text{remaining}}\). Since remaining is recoverable from \(S_t\) by inverting growth (annoying), prefer using observed actions as permitted.

2. **Compute last round’s defector fraction among others**
   \[
   f_{t-1} = \frac{k_{t-1}}{n-1}.
   \]

3. **Maintain a “cooperation viability” estimate** (simple EWMA)
   \[
   \hat f_t = \lambda \hat f_{t-1} + (1-\lambda) f_{t-1},\quad \lambda \in [0.6, 0.9].
   \]
   Interpret \(\hat f_t\) as “how defect-prone the population is.”

---

## Stock “safety floor” (the state trigger)

Logistic growth peaks at \(S_{\text{rem}} = \tfrac{capacity}{2}\). If you drive the post-consumption remaining stock far below that, growth is weaker and collapse risk rises.

Define a **minimum safe remaining stock** target:
\[
R_{\min} = \alpha \cdot capacity,
\]
with \(\alpha \in [0.35, 0.5]\). (I recommend \(\alpha = 0.4\): conservative enough to preserve future value but still allows exploitation.)

Since you don’t control others, you use the observed defection tendency to decide whether you should “invest” (cooperate) to keep the pool above danger.

---

## Decision rules (when to C vs D)

### Rule 0: Last round (endgame grab)
- **If \(t = r\)**: play **D**.
  - There is no future to protect; you take the larger share.

### Rule 1: If stock is “low,” stop being greedy
- If \(S_t \le S_{\text{low}}\), play **C**.
- Choose \(S_{\text{low}} = 0.55 \cdot capacity\) (or slightly above half).
  - Rationale: below ~half, marginal future value is precious; cooperating is an “investment” to keep the resource from sliding into the low-growth region.

### Rule 2: If opponents are cooperative, leech (defect)
- If \(S_t > S_{\text{low}}\) **and** \(\hat f_t \le \theta\), play **D**.
- Set \(\theta \approx 0.25\).
  - Meaning: if at most about a quarter of others tend to defect, you defect to exploit their restraint while the stock stays robust.

### Rule 3: If opponents are defect-heavy, don’t subsidize them
- If \(\hat f_t \ge \phi\), play **D** regardless of stock (except possibly extreme near-zero, see “collapse exception” below).
- Set \(\phi \approx 0.6\).
  - Meaning: if most opponents defect, your cooperation is just a transfer to them; take what you can.

### Rule 4: Middle zone = conditional “stock insurance”
When \(\theta < \hat f_t < \phi\) (mixed opponents), choose based on whether your cooperation is likely to prevent crossing the safety floor soon.

Use a simple forward-looking heuristic:

- Predict next round’s “stress” using last round’s defector count as a proxy.
- Let \(k = \) number of defectors among **all** players last round (including you if you defected), or among opponents if you prefer.
- Approximate total consumption fraction last round:
  \[
  \text{cons\_frac} \approx \frac{(n-k)}{2n} + \frac{k}{n} = \frac{1}{2} + \frac{k}{2n}.
  \]
  So remaining stock fraction after consumption is roughly:
  \[
  \text{rem\_frac} \approx 1 - \left(\frac{1}{2} + \frac{k}{2n}\right) = \frac{1}{2}\left(1 - \frac{k}{n}\right).
  \]

Decision:
- If \(S_t \cdot \text{rem\_frac} < R_{\min}\), play **C** (you “insure” the stock).
- Else play **D**.

This makes you cooperate only when it plausibly prevents the pool from entering a dangerous low-remaining region.

---

## Edge cases & special handling

### First round (t = 1): “Bait then assess”
Play **C** in round 1.

Why (exploitatively)?
- You sacrifice a little now to see who defects immediately.
- If others cooperate, you have a high-stock environment in which you can defect profitably for many rounds.
- If others defect, you learn that quickly and switch to extraction mode.

### Collapse exception (near-zero stock)
If \(S_t\) is extremely low (e.g., \(S_t < 0.1\cdot capacity\)):
- If there are **at least 2 rounds remaining** ( \(t \le r-1\) ), play **C** once to try to restart growth *only if* opponents aren’t overwhelmingly defect-heavy (\(\hat f_t < 0.8\)).
- Otherwise play **D** (take what you can; recovery is unlikely).

This avoids wasting actions trying to rebuild when the population is essentially predatory.

### “Grudge” trigger: punish obvious free-riders briefly, then revert
If in the last \(m\) rounds (e.g., \(m=3\)) you observed:
- Stock was healthy (\(S > 0.7\cdot capacity\)), and
- A majority of opponents defected in at least 2 of those rounds,

then enter **Grudge Mode** for \(g\) rounds (e.g., \(g=2\)):
- Always play **D** (even if stock is mid-high).

After \(g\) rounds, revert to normal rules.

Exploitative intent: you stop subsidizing conditional cooperators who “try their luck” defecting; you also deter strategies that alternate defection bursts.

---

## Pseudocode (implementable)

```pseudo
params:
  alpha = 0.40
  S_low = 0.55 * capacity
  theta = 0.25
  phi   = 0.60
  lambda = 0.75
  m = 3
  g = 2

state:
  fhat = 0.0
  grudge_timer = 0
  history of opponent D counts

function act(t, S_t, observed_opponent_actions_history):
  if t == r:
    return D

  if t == 1:
    return C

  # update fhat using last round
  k_opp = count_opponents_D(t-1)
  f = k_opp / (n-1)
  fhat = lambda*fhat + (1-lambda)*f

  # grudge detection
  if grudge_timer > 0:
    grudge_timer -= 1
    return D

  if last_m_rounds_exist(m):
    if in >=2 of last m rounds: (S > 0.7*capacity AND opponent_D_majority):
      grudge_timer = g-1
      return D

  # collapse exception
  if S_t < 0.10*capacity:
    if t <= r-1 AND fhat < 0.80:
      return C
    else:
      return D

  # low stock protection
  if S_t <= S_low:
    return C

  # exploit cooperative populations
  if fhat <= theta:
    return D

  # don't subsidize defect-heavy populations
  if fhat >= phi:
    return D

  # middle zone: stock insurance test
  k_all_last = count_all_D(t-1)  # includes you if available; else use k_opp
  rem_frac = 0.5 * (1 - k_all_last / n)
  Rmin = alpha * capacity

  if S_t * rem_frac < Rmin:
    return C
  else:
    return D
```

---

## Why this is exploitative (and robust)

- **Defaults to defection whenever the stock is healthy and opponents are sufficiently cooperative**, extracting higher per-round payoffs while others “stabilize” the resource.
- **Invests (cooperates) only when necessary** to keep the system out of the low-growth region—this is not altruism, it’s resource maintenance for future extraction.
- **Stops subsidizing** when opponents are defect-heavy, shifting to take-as-much-as-possible mode.
- **Endgame defection** captures the classic last-round incentive.
- **Adaptive** via \(\hat f_t\) and the grudge trigger, handling diverse opponent types (always-D, tit-for-tat variants, threshold cooperators, randoms, etc.).

If you want, I can also provide tuned parameter suggestions for different \((n, r, capacity)\) regimes (e.g., small \(r\) vs large \(r\), or large \(n\) where others’ impact dominates).
'''

description_EXPLOITATIVE_108 = '''
### Strategy: **Predatory Trigger with Stock-Aware Extortion (PT-SE)**  
Goal: harvest high payoffs by defecting whenever opponents are “safe” (cooperative enough to keep stock productive), but immediately punish exploitation or drift toward collapse. You behave like a controller: keep the stock near a profitable steady region *only if others make that possible*, otherwise take what you can.

Key idea: with this growth rule, the resource replenishes well when post-consumption stock is around **capacity/2**. You exploit by (i) defecting in “good” states when opponents are not draining too hard, and (ii) switching to harsh punishment if opponents threaten sustainability, so they learn that feeding you is the only stable path.

---

## 1. Decision rules (C vs D)

### Quantities you track from history
At round \(t\), with observed current stock \(S_t\):

- Let \(k_{t-1}\) = number of opponents who defected last round (you observed their actions).
- Define last round’s *opponent defection rate*:
  \[
  q_{t-1} = \frac{k_{t-1}}{n-1}
  \]
- Track a short memory (e.g., last \(m=3\) rounds):
  \[
  \bar q = \text{average of } q \text{ over last } m \text{ rounds}
  \]
- Compute a “danger zone” threshold for stock:
  - **Safe** stock: \(S_t \ge 0.6 \cdot capacity\)
  - **Fragile** stock: \(0.35 \cdot capacity \le S_t < 0.6 \cdot capacity\)
  - **Critical** stock: \(S_t < 0.35 \cdot capacity\)

These constants are chosen because the growth is strong when stock is not too low; below ~0.35 capacity you’re at real risk of spiraling down if defection continues.

---

### Core policy (high level)
1. **Exploit when safe:** If stock is safe and opponents are not heavily defecting, you defect (take double per round).
2. **Control when fragile:** In mid stock, you condition on how cooperative opponents are; you cooperate only if it’s necessary to prevent collapse *and* opponents are mostly cooperating.
3. **Punish when threatened:** If opponents defect too much or stock is critical, you cooperate to preserve stock only if it can realistically be recovered; otherwise defect to maximize short-term extraction (the “endgame raid” behavior even midgame if collapse is unavoidable).

---

### Concrete decision rule
Let remaining rounds be \(R = r - t + 1\).

**Step A: Endgame override**
- If \(R \le 2\): **Play D** (final two rounds are pure extraction; no future to protect).

**Step B: If stock is critical**
- If \(S_t < 0.35 \cdot capacity\):
  - If opponents recently cooperated a lot: \(\bar q \le 0.25\), then **play C** (attempt recovery; your cooperation has leverage when they’re already cooperative).
  - Else **play D** (they won’t stabilize it, so take what remains).

**Step C: If stock is fragile**
- If \(0.35 \cdot capacity \le S_t < 0.6 \cdot capacity\):
  - If \(\bar q \le 0.20\): **play C** (you “invest” only when you’re confident others aren’t wrecking it).
  - If \(0.20 < \bar q \le 0.50\): **play D** (you exploit; this also pressures them to stop defecting).
  - If \(\bar q > 0.50\): **play D** (resource likely to degrade; punish/raid).

**Step D: If stock is safe**
- If \(S_t \ge 0.6 \cdot capacity\):
  - If \(\bar q \le 0.50\): **play D** (default exploitation—take the larger share while stock is healthy).
  - If \(\bar q > 0.50\): **play C for one round**, then reassess next round.
    - Rationale: a one-round “warning” cooperation can prevent immediate collapse and gives defectors a chance to revert; if they don’t, you switch back to D and let it burn.

This makes **D your default**, with **C used as a tool**: to keep the stock in the exploitable region when others make that feasible, or to signal “I can stabilize, but only if you stop defecting.”

---

## 2. Edge cases

### First round
- **Round 1: Play D.**
  - You learn the population’s baseline cooperativeness while collecting maximum payoff from the initial full stock.
  - If others are cooperative types, they won’t retaliate strongly; if they are defectors, you lose nothing by having defected.

### Last round(s)
- **Last two rounds: always D.**
  - Cooperation cannot pay back because there is no future round to harvest replenished stock.

### Stock at/near zero
- If \(S_t\) is extremely small (e.g., \(S_t \le \epsilon\)), action barely matters for payoff; still:
  - If \(R \le 2\): D.
  - Else: choose based on opponents:
    - If \(\bar q \le 0.25\): C (try to restart growth).
    - Else: D (no point investing alone).

### Handling noise / weird opponents
- Use \(\bar q\) over last 3 rounds (not just last round) to avoid being whipsawed by oscillators.
- One-round “mercy C” only when stock is safe and opponents are highly defecting; this prevents needless collapse if they are on a mistaken/tit-for-tat-style punishment cycle.
- Otherwise, do not get drawn into long cooperation—your baseline is extraction.

---

## 3. Why this is exploitative (and robust)

### Exploitative mechanics
- **You defect whenever the system is healthy and others aren’t overwhelming you**, extracting the max per-round payoff while relying on others’ restraint to preserve the resource.
- **You only cooperate conditionally and temporarily**—as a stabilizer to keep the stock from dropping out of the high-growth region so you can continue defecting later.
- **You punish defect-heavy groups by refusing to subsidize them**: if they defect too much, you defect too, accelerating collapse and preventing them from profiting at your expense through asymmetric restraint.

### Robustness
- Against unconditional cooperators / naive sustainers: you farm them (mostly D) while the stock stays high.
- Against grim-trigger / retaliators: your one-round “warning C” when stock is safe can de-escalate; if not, you switch to D and accept the mutual burn rather than being the sucker.
- Against always-defect: you defect almost always; no wasted cooperation.
- Against sophisticated state-based controllers: your rule is also state-based, and the endgame override prevents being milked late.

---

## Pseudocode (implementable)
```python
def PT_SE_action(t, r, n, capacity, S_t, opp_actions_history, m=3):
    R = r - t + 1

    # Endgame extraction
    if R <= 2:
        return "D"

    # Compute recent opponent defection rate average
    # opp_actions_history: list of lists, each inner list = opponents' actions in that round
    recent = opp_actions_history[-m:] if len(opp_actions_history) >= 1 else []
    if len(recent) == 0:
        qbar = 0.0
    else:
        qs = []
        for round_actions in recent:
            k = sum(1 for a in round_actions if a == "D")
            qs.append(k / (n - 1))
        qbar = sum(qs) / len(qs)

    # Stock regime thresholds
    critical = 0.35 * capacity
    safe = 0.60 * capacity

    if S_t < critical:
        if qbar <= 0.25:
            return "C"  # attempt recovery if others are mostly cooperative
        else:
            return "D"  # raid / punish

    if S_t < safe:  # fragile
        if qbar <= 0.20:
            return "C"
        else:
            return "D"

    # safe stock
    if qbar <= 0.50:
        return "D"
    else:
        return "C"  # one-round de-escalation / stabilization probe
```

This is intentionally not “nice”: it treats cooperation as an investment instrument, not a norm. It aims to sit on top of whatever cooperative capacity exists in the group, extracting the larger share while preventing the stock from falling so low that future extraction becomes impossible.
'''

description_EXPLOITATIVE_109 = '''
### Strategy: **Predatory Grim-Threshold (PGT)**  
Core idea: **milk cooperators while the stock is healthy; punish defections hard enough to make defection unprofitable; stop caring near the end (final-round defection), and avoid self-destructive over-punishment when stock is already low.**  
This is exploitative because it (i) defects whenever opponents appear “soft,” (ii) only cooperates to preserve the resource when that increases *your own* future take, and (iii) uses credible, state-dependent punishment to discipline opponents.

---

## Key quantities (computed from history/state)
Let at round \(t\) the current stock be \(S_t\). Observe how many opponents defected last round.

- Let \(d_{t-1}\) = number of defectors among the other \(n-1\) players in round \(t-1\).
- Let \(D_{t-1}\) = total defectors last round (including you), if needed.
- Define a **stock-health threshold**:
  - \(S_{\text{high}} = 0.8 \cdot \text{capacity}\) (resource is abundant)
  - \(S_{\text{low}} = 0.35 \cdot \text{capacity}\) (resource is fragile; collapse risk high)
- Define a **punishment window** length:
  - \(L = \max(2,\lceil r/10 \rceil)\) rounds (long enough to matter, short enough to recover)

Maintain internal state:
- `punish_until` (round index; 0 if not punishing)
- `mode` in {NORMAL, PUNISH}

---

## Intuition (why these rules)
- In any single round, **D strictly dominates C** given fixed \(S_t\) (you get \(S_t/n\) vs \(S_t/(2n)\)). So cooperation is only instrumentally useful to keep \(S\) high later.
- The stock growth is strong when \(S\) is moderate (logistic), but **defection by many players can push \(S\) low or to zero**, killing future payoffs.
- So you:
  1. **Defect when it’s safe** (stock high and opponents mostly cooperating).
  2. **Cooperate conditionally to stabilize the resource** when collapse is likely.
  3. **Punish defections** to deter them (by switching to D for a while).
  4. **Endgame defect** because future no longer matters.

---

## 1) Decision rules (when cooperate vs defect)

### Rule A — Last rounds: always defect
- If \(t = r\): play **D**.
- If \(t \ge r - 1\) (last 2 rounds): play **D** (removes incentives to “invest” late).

### Rule B — Punishment trigger (enter PUNISH)
If not already punishing, then after observing round \(t-1\):

Enter punishment if **either**:
1. **Any opponent defected while stock is not extremely low**  
   - If \(d_{t-1} \ge 1\) and \(S_t \ge S_{\text{low}}\): set `punish_until = t + L - 1`
2. **Stock is dropping fast / fragile and someone defected**  
   - If \(S_t < S_{\text{low}}\) and \(d_{t-1} \ge 1\): set `punish_until = t + (L+1) - 1` (slightly longer)

During punishment (`t <= punish_until`): play **D**, *except* the collapse safeguard below.

### Rule C — Collapse safeguard (don’t overkill a dying stock)
Even if punishing, **switch to C** when the stock is so low that additional defection risks permanent collapse and reduces your own future earnings.

- If \(S_t \le 2n\) (near the minimum meaningful level) then play **C** unless \(t\) is in the last 2 rounds.
  - Rationale: with very low \(S\), everyone’s absolute payoff is tiny; cooperating can allow growth to restart and gives you more to steal later. This is *still exploitative*—it’s conservation for future extraction.

### Rule D — Normal mode (not punishing): “exploit the nice, stabilize the dangerous”
If not in punishment and not in endgame:

1. **If stock is high and opponents look cooperative → Defect to exploit**
   - If \(S_t \ge S_{\text{high}}\) and \(d_{t-1} = 0\): play **D**.
   - (You free-ride on their restraint; growth can often restore stock.)

2. **If stock is moderate and opponents cooperative → Mixed opportunism (mostly D)**
   - If \(S_{\text{low}} \le S_t < S_{\text{high}}\) and \(d_{t-1} = 0\):
     - Play **D** with probability \(p = 0.7\), else **C**.
   - Rationale: keep them from updating you as “always defect,” but still extract more.

3. **If stock is low → Cooperate to rebuild (unless very late)**
   - If \(S_t < S_{\text{low}}\): play **C**.
   - Rationale: preserving the engine matters more than one-round extraction.

---

## 2) Edge cases

### First round (no history)
Round 1 is information gathering + opportunism:

- If \(r \le 3\): play **D** (short horizon; punishments won’t pay off)
- Else:
  - If capacity is very large relative to group size (loose rule of thumb: \(\text{capacity} \ge 20n\)): play **D**
    - Because the system can absorb early defection better and you want the “leader in extraction” position.
  - Otherwise play **C** in round 1
    - This reduces the chance of immediate cascade-to-collapse in tight environments, and it tests who defects early.

### If everyone defects / stock hits 0
If \(S_t = 0\): your action doesn’t matter for that round (payoff 0 either way). Still:
- Play **C** (unless last 2 rounds), to attempt to restart if growth allows (though with given growth formula, 0 stays 0; this is mostly a “best effort” default).

### If opponents are unconditional defectors
- You’ll quickly enter PUNISH and mostly play **D**, but the collapse safeguard will attempt to rebuild only when it benefits you (i.e., when \(S\) is so low that future payoffs are threatened). Against pure defectors this won’t restore much, but it avoids being the sucker.

### If opponents are trigger cooperators (punish defectors)
- Your “mostly defect when stock high” will trigger them. That’s fine: you’ll get some early exploitation; then you punish back and the system may settle into lower stock.
- The mixed rule in moderate stock (70% D) is specifically to sometimes “look cooperative” and possibly regain their cooperation, letting you resume exploitation.

---

## 3) Why this is exploitative and robust
**Exploitative features**
- **Default free-riding** when others cooperate and stock is high (maximizes immediate payoff).
- **Punishment is not “moral”; it’s coercive**: it makes defection costly for others by accelerating depletion, pushing them toward cooperation if they’re forward-looking.
- **Conservation is instrumental**: you cooperate mainly when it preserves a profitable future stock to later defect on.

**Robustness**
- Handles: unconditional cooperators (you exploit), unconditional defectors (you don’t get suckered), contingent strategies (you punish and occasionally “reset” their beliefs), and noisy/mixed players (thresholds damp overreaction).
- Uses only: parameters \((n,r,\text{capacity})\), current \(S_t\), and observed history.

---

## Pseudocode (implementable)
```python
# internal state
punish_until = 0

def action(t, S_t, history):
    # parameters: n, r, capacity available globally
    S_high = 0.8 * capacity
    S_low  = 0.35 * capacity
    L = max(2, ceil(r/10))

    # endgame
    if t >= r-1:
        return "D"

    # first round
    if t == 1:
        if r <= 3:
            return "D"
        if capacity >= 20*n:
            return "D"
        return "C"

    # compute last-round opponent defections
    d_last = count_opponents_defected(history[t-1])

    # trigger punishment if not already punishing
    if t > punish_until:
        if d_last >= 1 and S_t >= S_low:
            punish_until = t + L - 1
        elif d_last >= 1 and S_t < S_low:
            punish_until = t + (L+1) - 1

    # collapse safeguard
    if S_t <= 2*n:
        return "C"  # unless endgame already handled

    # punishment mode
    if t <= punish_until:
        # still avoid collapsing very low stock
        if S_t < S_low:
            return "C"
        return "D"

    # normal mode
    if S_t >= S_high and d_last == 0:
        return "D"
    if S_low <= S_t < S_high and d_last == 0:
        return "D" with prob 0.7 else "C"
    if S_t < S_low:
        return "C"

    # default fallback
    return "D"
```

If you want to push the exploitiveness even further, the main knob is increasing the “defect probability” in moderate stock (0.7 → 0.85) and shortening cooperation in low stock (lowering \(S_{\text{low}}\)), at the cost of higher collapse risk.
'''

description_EXPLOITATIVE_110 = '''
Below is an explicitly **exploitative** strategy: it tries to (i) keep the stock high enough to farm, (ii) **take D whenever others are sustaining the resource**, and (iii) **punish quickly** when others are depleting so you don’t subsidize them. It does not assume norms or coordination.

---

## Core idea (what you’re exploiting)

- If enough others play **C**, the stock stays high (often near `capacity`), and then playing **D** gives you double the per-round payoff of playing **C**.
- If too many play **D**, the stock collapses and you should **not** waste rounds cooperating into a crash; you should either defect too (take what’s left) or, if salvageable, temporarily cooperate to restore stock—*but only if it improves your future extraction*.

This strategy treats cooperation as an **investment** only when it has a positive expected return (more future stock to defect from), and otherwise defects.

---

## Notation from history (computable each round)

At round `t` (1-indexed), before choosing action, you know last round’s actions.

Let:
- `kC_last` = number of opponents who played C last round (exclude you).
- `kD_last` = number of opponents who played D last round.
- `S` = current stock at start of this round.
- `T = n/2` (the “maintenance threshold”: if at least `n/2` players cooperate, then total consumption ≤ S and the stock is not fully wiped that round).

Reason: total consumption fraction is  
`(kC + 2*kD)/(2n)` of `S`. Stock is fully consumed iff `kC + 2*kD = 2n` i.e., iff `kC = 0` and `kD = n`. More generally, **high D counts drive S_remaining down**, hurting future value.

---

## Decision rules (when to C vs D)

### Rule 0: Endgame extraction (last round)
- **If `t == r`: play D.**
  - No future to protect; pure exploitation.

### Rule 1: “Farmers present” ⇒ free-ride with D
If opponents are currently sustaining the pool, exploit them:
- **If `kC_last ≥ ceil((n-1)/2)` and `S` is reasonably high (e.g., `S ≥ 0.6*capacity`) ⇒ play D.**
  - Interpretation: at least about half of *opponents* cooperated last round, so the group is close to maintaining the stock. You defect to harvest the larger share.

### Rule 2: “Resource at risk” ⇒ refuse to subsidize, punish with D
If opponents are driving depletion, do not be the sucker:
- **If `kC_last ≤ floor((n-1)/3)` ⇒ play D.**
  - Too few cooperators: any cooperation you do mostly subsidizes defectors and doesn’t reliably rebuild S.

### Rule 3: “Salvage mode” (conditional cooperation only when it buys you future exploitation)
When the resource is low/moderate, you sometimes cooperate *temporarily* to rebuild stock **only if** opponents are not overwhelmingly defecting.
- Trigger: `S < 0.6*capacity` and `kC_last` is in the middle range:
  - **If `floor((n-1)/3) < kC_last < ceil((n-1)/2)` ⇒ play C for one round**, then reassess next round.
  - Rationale: if the pool is low, a bit of coordinated restraint can create growth (logistic growth is strongest around `S_remaining ≈ capacity/2`). You “prime” the stock, but you do it cautiously and briefly.

### Rule 4: “After successful rebuild” ⇒ switch back to exploitation
After any round where you cooperated:
- If next round `S` has improved (e.g., `S` increased vs last round’s start), **switch to D** as soon as:
  - `S ≥ 0.6*capacity` **or** `kC_last ≥ ceil((n-1)/2)`.
This ensures you don’t become a permanent cooperator; you cash in once the resource is worth cashing.

---

## First-round handling (no history)

Round 1 is about probing without giving away too much:

- **If `r` is small (e.g., `r ≤ 3`): play D.**  
  Not enough horizon to invest.

- Otherwise (most tournaments): **play C in round 1** *unless* the stock is already low (shouldn’t be; initial is `capacity`), in which case D.
  - Why C at start? It’s a cheap probe that (a) helps keep S high for farming, and (b) lets you classify opponents immediately:
    - If many still defect, you stop subsidizing.
    - If many cooperate, you exploit with D thereafter.

This is exploitative because the *default path* after a cooperative opening is to defect if others prove cooperative.

---

## Edge cases & robustness

### If stock is extremely low
- If `S ≤ capacity/(2n)` (so even D gives tiny payoff), **play D** anyway.
  - You don’t want to be the only one rebuilding; and if others suddenly cooperate, you’ll see it next round and can switch to salvage mode.

### If opponents are highly volatile (flip a lot)
Use a short memory smoothing:
- Track `kC_avg` = average number of cooperating opponents over last `m=2` rounds.
- Replace `kC_last` with `kC_avg` in Rules 1–3 when history exists for both rounds.
This prevents being lured into cooperating by a single anomalous cooperative round.

### If you observe a “too-good-to-be-true” cooperative environment
If opponents keep cooperating despite your defections, keep defecting:
- **If in the last 3 rounds your action was mostly D and `S` stayed ≥ `0.8*capacity`, never switch to C except in salvage mode.**
That’s pure exploitation: let them carry the commons.

---

## Pseudocode (implementable)

```python
def action(t, r, n, capacity, S, history):
    # history contains past rounds actions for all players

    if t == r:
        return "D"

    if t == 1:
        if r <= 3:
            return "D"
        else:
            return "C"

    # compute kC over last 1-2 rounds
    kC_last = count_opponents_C(history[t-1])
    if t >= 3:
        kC_prev = count_opponents_C(history[t-2])
        kC = (kC_last + kC_prev) / 2.0
    else:
        kC = kC_last

    highS = (S >= 0.6 * capacity)

    # Rule 1: free-ride
    if kC >= ceil((n-1)/2) and highS:
        return "D"

    # Rule 2: punish/avoid subsidizing
    if kC <= floor((n-1)/3):
        return "D"

    # Rule 3: salvage mode (one-round investment)
    if not highS and (floor((n-1)/3) < kC < ceil((n-1)/2)):
        return "C"

    # default: exploit
    return "D"
```

---

## Why this is exploitative (explicitly)

- It **defects in the last round** and in most rounds by default.
- It **defects whenever others are cooperative enough** to keep the stock high (classic free-riding).
- It only cooperates as a **short-term investment** to restore the pool when that increases future expected extraction; it does not “reward” cooperation for its own sake.
- It is robust: if everyone defects, it doesn’t waste time trying to be nice; if many cooperate, it harvests them; if mixed, it sometimes stabilizes the stock just enough to resume harvesting.

If you want, I can tune the numeric thresholds (`0.6*capacity`, `1/3`, `1/2`, memory length) specifically for typical tournament values of `n, r`, because the best exploitative aggressiveness depends strongly on the horizon `r` and group size `n`.
'''

description_EXPLOITATIVE_111 = '''
## Strategy: **Stock-Guardian Extortion (SGE)**  
Exploit cooperators and “nice” strategies for extra payoff while avoiding being the sucker against defectors, by (i) harvesting when the stock is high, (ii) switching to punishment when others over-extract, and (iii) restoring the stock only when it is profitable and likely to be reciprocated.

The core idea: **treat the stock as the limiting capital asset**. When it’s near capacity, defection is extremely lucrative; when it’s low, defection destroys future value. So you defect to skim surplus *unless* opponents’ behavior indicates they’ll collapse the resource—in which case you punish hard (to stop them) or “farm” the stock back up only when it benefits you.

---

# 1. Decision rules (cooperate vs defect)

### Track these quantities each round \(t\)
Let current stock be \(S_t\). From the previous round’s observed actions, compute:

- \(d_{t-1}\): number of opponents who defected last round  
- \(p_{t-1} = d_{t-1}/(n-1)\): opponent defection rate last round  
- \(k_{t-1}\): total number of defectors last round (including you)

Also maintain two internal state variables:
- `phase ∈ {HARVEST, PUNISH, RECOVER}`
- `strike`: integer ≥ 0 (punishment counter)

### Key stock thresholds (parameter-only, no tuning to opponents)
- **High stock threshold**: \(S_t \ge 0.85 \cdot capacity\)  
- **Low stock threshold**: \(S_t \le 0.35 \cdot capacity\)  
- **Critical stock**: \(S_t \le 0.20 \cdot capacity\)

These reflect when “skimming” is safe vs when collapse risk is high.

---

## Action logic (high-level)
### A) HARVEST mode (default exploit)
- Objective: **defect when stock is high** to earn double the cooperative payoff, while relying on the logistic rebound if extraction stays moderate.
- Rule:
  - If \(S_t \ge 0.85\cdot capacity\): **play D**
  - Else if opponents are mostly cooperating (\(p_{t-1} \le 0.25\)) and stock is moderate (\(S_t \ge 0.50\cdot capacity\)): **play D**
  - Otherwise: **play C** (to avoid triggering collapse / to look “conditionally cooperative”)

### B) PUNISH mode (stop resource predators)
Trigger PUNISH if either condition holds:
- **Over-extraction signal**: \(p_{t-1} \ge 0.50\) (at least half of opponents defected)
- **Stock alarm**: \(S_t \le 0.35\cdot capacity\) and \(p_{t-1} > 0\)

Punishment rule:
- While in PUNISH: **play D** for `strike` rounds (see below), unless stock is critical (then RECOVER).

How long to punish (`strike` length):
- Set `strike = 2 + ceil((n-1) * p_{t-1})`
  - More defectors ⇒ longer punishment
  - Purpose: make defection “hurt” via stock collapse risk and deny them the benefit of your cooperation.

Exit PUNISH when:
- Opponent defection rate stays low for 2 consecutive rounds: \(p_{t-1} \le 0.25\) and \(p_{t-2} \le 0.25\)
- and stock is not low: \(S_t \ge 0.50\cdot capacity\)
Then switch back to HARVEST (and defect again when profitable).

### C) RECOVER mode (farm the stock when it’s profitable)
Trigger RECOVER if:
- \(S_t \le 0.20\cdot capacity\) (critical), regardless of opponent behavior.

RECOVER behavior:
- **play C** until \(S_t \ge 0.50\cdot capacity\) **or** until it becomes clear others won’t help (see below).

Detect “recovery free-riding”:
- If in RECOVER and \(p_{t-1} \ge 0.50\) (most opponents keep defecting), then **stop rebuilding**:
  - switch to PUNISH immediately (play D) because your cooperation is being converted into their higher immediate payoffs while the stock remains endangered.

This makes RECOVER *conditional*: you only invest in rebuilding when there’s at least partial collective restraint.

---

# 2. Edge cases

### First round (t = 1)
You have no history. Use pure exploit when safe:
- If \(capacity\) is high and initial stock is \(S_1 = capacity\), which it is: **play D**.
Rationale: immediate payoff is maximal, and you learn opponents’ types quickly (cooperative vs predatory) at their expense.

### Last round (t = r)
No future value, so stock sustainability is irrelevant:
- **Always play D**.

### Second-to-last round (t = r-1)
- If you expect any chance opponents cooperate (many strategies “try to end well”), defecting is still best.
- **Default: play D**, except if you are in RECOVER with \(S_t\) extremely low and you believe one more C meaningfully increases your last-round payoff more than D now.
A simple rule:
- If \(S_t \le 0.10\cdot capacity\): **play C** at \(t=r-1\), else **D**.  
(At very low stock, a final push upward can increase the *last-round* D payoff.)

### If stock hits zero
- You get 0 regardless. You can only recover via growth, but growth from 0 is 0 in your model, so:
  - If \(S_t = 0\): action doesn’t matter; **play D** (signals toughness; no cost).

---

# 3. Why this is exploitative (explicitly)

- **Skims surplus**: When stock is near capacity, you defect to earn **2×** the cooperative payoff while the system can still rebound.
- **Uses conditional investment**: You only “pay” cooperation to rebuild the stock when it will later let you extract more (or when others are not massively free-riding).
- **Punishes to deter**: Against defect-heavy populations, you shift to D to accelerate collapse risk and remove the benefit of your restraint—forcing adaptive opponents to reduce defection if they want future payoffs.
- **Endgame defection**: Always defects at the end because cooperation cannot be repaid.

---

# Pseudocode (implementable)

```python
def action(t, r, n, capacity, S, history):
    # history provides actions of all players for past rounds
    # assume we store phase and strike across rounds
    global phase, strike, low_defect_streak

    HIGH = 0.85 * capacity
    LOW  = 0.35 * capacity
    CRIT = 0.20 * capacity

    if t == 1:
        phase = "HARVEST"
        strike = 0
        low_defect_streak = 0
        return "D"

    # compute last round opponent defection rate
    last_actions = history[t-1]  # list length n
    my_last = last_actions[me]
    opp_def = sum(1 for j,a in enumerate(last_actions) if j!=me and a=="D")
    p = opp_def / (n-1)

    # last round special cases
    if t == r:
        return "D"
    if t == r-1:
        if S <= 0.10 * capacity:
            return "C"
        return "D"

    # update low-defection streak
    if p <= 0.25:
        low_defect_streak += 1
    else:
        low_defect_streak = 0

    # critical stock forces recovery unless others are clearly free-riding
    if S <= CRIT:
        phase = "RECOVER"

    if phase == "RECOVER":
        if p >= 0.50:
            # don't rebuild for free-riders
            phase = "PUNISH"
            strike = max(strike, 2 + int((n-1)*p + 0.999))
            return "D"
        if S >= 0.50 * capacity:
            phase = "HARVEST"
            return "D" if S >= HIGH else "C"
        return "C"

    # trigger punish
    if (p >= 0.50) or (S <= LOW and p > 0):
        phase = "PUNISH"
        strike = 2 + int((n-1)*p + 0.999)

    if phase == "PUNISH":
        if S <= CRIT:
            phase = "RECOVER"
            return "C"
        if strike > 0:
            strike -= 1
            return "D"
        # exit punish if opponents calmed down and stock is healthy
        if low_defect_streak >= 2 and S >= 0.50 * capacity:
            phase = "HARVEST"
        # otherwise remain guarded
        return "C" if S < 0.50 * capacity else "D"

    # HARVEST mode
    if S >= HIGH:
        return "D"
    if (p <= 0.25) and (S >= 0.50 * capacity):
        return "D"
    return "C"
```

---

## What this beats / exploits well
- **Always-cooperate / forgiving**: you defect frequently at high stock and near endgame, extracting persistent extra payoff.
- **Conditional cooperators (TFT-ish)**: you look cooperative when stock is fragile, but defect when it’s lucrative; punishment makes them back off from constant defection.
- **Random / noisy**: stock-thresholding keeps you from mindlessly collapsing the pool.
- **Always-defect**: you don’t get suckered; you punish and stop investing in recovery when they free-ride.

If you want, I can also provide a “more aggressive” variant (higher D rate) and a “safer” variant (less collapse risk) depending on tournament meta you expect.
'''

description_EXPLOITATIVE_112 = '''
## Strategy: **Adaptive Harvester (AH)**  
Goal: **extract as much as possible** while (i) **keeping the stock high enough** to continue extracting in future rounds, and (ii) **punishing/disciplining** opponents who overharvest so you don’t subsidize them. The strategy is **stateful**, **history-based**, and **parameterized** by *(n, r, capacity)*.

Key idea: in any round, your action changes total consumption by a known increment. If you flip from C→D, you personally gain **+ S/(2n)** *this round*, but you also reduce next-round stock by exactly the same increment (and affect growth). So we **defect whenever it’s safe**, and **cooperate only when needed to keep the resource in a high-yield region or to avoid being the “sucker” among defectors**.

---

# 1) Decision rules (when to C vs D)

### Quantities you track each round
At round \(t\), before choosing:

- Current stock: \(S_t\)
- From last round’s observed actions, let \(k_{t-1}\) = number of defectors among the other \(n-1\) players.
- Compute last round’s **defection rate among others**:
  \[
  q_{t-1} = \frac{k_{t-1}}{n-1}
  \]

### A simple sustainability threshold
Let:
- “Safe stock” threshold:  
  \[
  S_{\text{safe}} = 0.6 \cdot \text{capacity}
  \]
Intuition: with logistic growth \(2S(1-S/K)\), growth is strong around mid-range; below ~0.5–0.6K you’re closer to the danger zone if others defect.

### Predict next stock under your two choices (one-step lookahead)
Assume other players’ behavior stays like last round (robust heuristic in tournaments). If you play action \(a \in \{C,D\}\), total consumption is:

- If you play **C**:
  \[
  \text{cons}_C = \frac{S_t}{2n} + k_{t-1}\cdot\frac{S_t}{n} + (n-1-k_{t-1})\cdot\frac{S_t}{2n}
  \]
- If you play **D**:
  \[
  \text{cons}_D = \frac{S_t}{n} + k_{t-1}\cdot\frac{S_t}{n} + (n-1-k_{t-1})\cdot\frac{S_t}{2n}
  \]

Then remaining stock \(R_a = S_t - \text{cons}_a\). Growth:
\[
G_a = 2R_a\left(1-\frac{R_a}{\text{capacity}}\right)
\]
Next stock prediction:
\[
\hat S_{t+1}(a)=\min(R_a+G_a,\text{capacity})
\]

### Core exploit/punish rule
You choose **D** unless doing so risks collapsing the future *or* you are being exploited.

**Play D if all are true:**
1. **Not a collapse risk:** \(\hat S_{t+1}(D) \ge S_{\text{min}}\), where  
   \[
   S_{\text{min}} = 0.35 \cdot \text{capacity}
   \]
2. **Not currently being exploited as a lone cooperator:** you are not in a “punish mode” (defined below).
3. **Not in endgame management** (last-round rule below).

Otherwise play **C**.

This already exploits generous populations: if others are mostly cooperating, \(\hat S_{t+1}(D)\) stays high, so you defect and harvest more.

---

## Punish mode (stop subsidizing defectors)
If others are defect-heavy, cooperating just funds them. So you use a **grim-ish but forgiving** punishment that also keeps some chance of recovery.

Enter **Punish Mode** if either condition holds:
- **Condition A (they’re mostly defecting):**
  \[
  q_{t-1} \ge 0.5
  \]
- **Condition B (you cooperated and got exploited):** last round you played C and at least one other defected (i.e., \(k_{t-1} \ge 1\)).

**While in Punish Mode:** play **D** *unconditionally* for a fixed window of \(L\) rounds, where
\[
L = \max\left(2,\;\left\lceil \frac{r}{10} \right\rceil\right)
\]
After \(L\) rounds, you check if the environment has improved:
- If in the most recent round \(q < 0.25\) **and** stock is healthy \(S_t \ge S_{\text{safe}}\), you **exit punish mode**.
- Otherwise, extend punish mode by 1 round and re-check.

Why this is exploitative:  
- If opponents try to “farm cooperators,” they get cut off quickly.
- If they cooperate reliably, you free-ride aggressively.

---

## Stock recovery mode (don’t kill the golden goose)
Even if everyone is defecting, sometimes the best exploitation is to **restore stock** to later defect harder. So you include a “rebuild” trigger:

Enter **Recovery Mode** if:
\[
S_t \le 0.25\cdot\text{capacity}
\]
In Recovery Mode:
- Play **C** for \(M\) rounds, where  
  \[
  M = \max\left(1,\;\left\lceil \frac{r}{20} \right\rceil\right)
  \]
- **Exception:** if \(q_{t-1}\ge 0.75\) (nearly everyone defects), then don’t donate: play **D** (you’re likely doomed anyway; take what remains).

Exit Recovery Mode early if \(S_t \ge S_{\text{safe}}\).

This makes you robust against early collapsers: you attempt to rebuild if there’s a chance, but you don’t endlessly subsidize a defecting mob.

---

# 2) Edge cases (first round, last round, etc.)

### Round 1 (no history)
Default to **D** unless stock is already low (rare since initial is capacity):
- If \(S_1 \ge 0.5\cdot\text{capacity}\): play **D** (start exploitative).
- Else play **C** (stabilize).

Rationale: Most tournament strategies “test” early; starting with D captures immediate surplus and identifies who tolerates exploitation.

### Last round \(t=r\)
Always **D**.  
No future stock value remains, so defect strictly dominates cooperate in final period.

### Second-to-last round \(t=r-1\)
Almost always **D**, except one case:
- If \(S_{r-1}\) is extremely low (\(\le 0.1\cdot\text{capacity}\)) and you believe (from last actions) others are mostly cooperating (\(q_{r-2}<0.25\)), play **C** to try to bump \(S_r\) a bit, then D in round r.  
(Otherwise D.)

This is rare but can matter if one cooperative round yields a noticeable last-round stock increase.

### If stock hits ~0
If \(S_t \approx 0\), both actions pay ~0. Still:
- If remaining rounds are many (e.g., \(r-t \ge 3\)) and opponents are not extreme defectors (\(q_{t-1}<0.5\)), play **C** to attempt recovery.
- Else **D** (no point rebuilding for others).

---

# 3) Why this is exploitative (explicit alignment)

- **Defaults to defection** whenever the one-step stock forecast says you can get away with it.
- **Free-rides on cooperators:** when others keep the stock high, you harvest at double rate.
- **Stops being the sucker fast:** if others defect, you switch to D for a while, denying them the benefit of your restraint.
- **Strategic rebuilding only when profitable:** you cooperate only as an *investment* to restore stock for later, heavier extraction—never as “fairness.”

---

# Pseudocode (implementable)

```pseudo
state variables:
  punish_timer = 0
  recovery_timer = 0

parameters:
  S_safe = 0.6 * capacity
  S_min  = 0.35 * capacity
  S_rec  = 0.25 * capacity
  L = max(2, ceil(r/10))
  M = max(1, ceil(r/20))

function predict_next_stock(S, myAction, k_other_defectors):
  # compute total consumption
  if myAction == C: myCons = S/(2n) else myCons = S/n
  otherCons = k_other_defectors*(S/n) + (n-1-k_other_defectors)*(S/(2n))
  R = S - (myCons + otherCons)
  if R < 0: R = 0
  G = 2*R*(1 - R/capacity)
  return min(R + G, capacity)

for each round t with observed current stock S_t:

  if t == r: return D

  if t == 1:
    if S_t >= 0.5*capacity: return D else return C

  k = number of other players who defected in round t-1
  q = k / (n-1)

  # update modes
  if recovery_timer > 0:
    recovery_timer -= 1
  if punish_timer > 0:
    punish_timer -= 1

  # enter recovery if stock is low, unless hopelessly exploited
  if S_t <= S_rec and recovery_timer == 0:
    recovery_timer = M

  # enter punish if others are defect-heavy or you were exploited
  if punish_timer == 0:
    if q >= 0.5: punish_timer = L
    if (my_last_action == C and k >= 1): punish_timer = L

  # recovery action rule
  if recovery_timer > 0:
    if q >= 0.75: return D
    if S_t >= S_safe: recovery_timer = 0;  # exit early
    else return C

  # punish action rule
  if punish_timer > 0:
    # exit early only if environment looks cooperative AND stock high
    if q < 0.25 and S_t >= S_safe: punish_timer = 0
    else return D

  # normal exploit mode: defect if safe by one-step lookahead
  Snext_if_D = predict_next_stock(S_t, D, k)
  if Snext_if_D >= S_min:
    return D
  else:
    return C
```

If you want, I can also provide a simplified version (fewer thresholds/modes) or a more aggressive version that uses a 2-step lookahead / estimates opponents individually rather than via aggregate defection rate.
'''

description_EXPLOITATIVE_113 = '''
## Strategy: **Opportunistic Threshold Extortion (OTE)**  
Goal: **take D whenever it is safe or profitable**, but **keep the resource alive** by switching to C only when the stock is in danger or when opponents appear willing to “carry” sustainability. The strategy is adaptive (uses observed history), parameterized (depends on n, r, capacity), and exploitative (free-rides whenever possible, punishes wasteful groups by cashing out, and never sacrifices the last round).

---

# Key idea
Because payoffs scale linearly with current stock \(S\), and D always gives **double** the immediate payoff of C, the only reason to cooperate is **to prevent future stock collapse**. So we:

1. **Estimate how much total consumption the group is applying** from observed actions.
2. **Defect by default** when the stock is healthy and opponents are not over-extracting.
3. **Cooperate only as a “stabilizer”** when stock is at risk *and* it looks like others might also stabilize (or we can salvage enough future value).
4. **Cash out** (defect) when collapse looks inevitable or in the endgame.

---

# Quantities computed each round
At round \(t\), before choosing action, we know current stock \(S_t\), parameters \(n, r, capacity\), and history.

Let:
- Per-cooperator consumption: \(c_C = S_t/(2n)\)  
- Per-defector consumption: \(c_D = S_t/n\)

From last round’s observed actions, define:
- \(k_{t-1}\) = number of defectors last round.

Then last round’s *fraction extracted* was:
\[
x_{t-1} = \frac{\text{total consumption}}{S_{t-1}} = \frac{n-k_{t-1}}{2n} + \frac{k_{t-1}}{n} = \frac{1}{2} + \frac{k_{t-1}}{2n}
\]
So \(x \in [0.5, 1]\). More defectors ⇒ higher \(x\).

We also track a short-window average:
- \(\bar{k}\) = average number of defectors over the last \(w\) rounds (e.g., \(w=3\), using available rounds if early).

This gives a simple forecast of next round extraction intensity:
\[
\hat{x} = \frac{1}{2} + \frac{\bar{k}}{2n}
\]

---

# Stock safety thresholds
The stock update is logistic growth after consumption. A practical exploitative control is to keep the stock from drifting into a low region where opponents can accidentally/strategically collapse it.

Define two stock thresholds (parameterized):
- **Safe zone**: \(S_t \ge S_{\text{high}} = 0.70 \cdot capacity\)
- **Danger zone**: \(S_t \le S_{\text{low}} = 0.35 \cdot capacity\)

(These constants can be tuned; they work well because logistic growth is strong around mid-levels but weak near 0 and near capacity.)

Also define:
- **Endgame length** \(E = \max(2, \lceil 0.15 r \rceil)\). In the last \(E\) rounds, future is short, so defecting dominates.

---

# 1) Decision rules (C vs D)

### Rule A — Last-round cash-out
If \(t = r\): **Play D**.

Rationale: there is no future stock to protect.

---

### Rule B — Endgame exploitation
If \(t \ge r - E + 1\): **Play D** unless the stock is extremely low *and* cooperation is clearly forming.

Concrete:
- If \(S_t \le 0.15\cdot capacity\) **and** \(\bar{k} \le 0.25n\) (mostly cooperators), play **C** (tiny chance to rescue a final-round payday).
- Else: **D**.

Exploitative intent: take maximum now; only stabilize if others are already doing most of the work.

---

### Rule C — Default: defect in the safe zone
If \(S_t \ge S_{\text{high}}\): **Play D**.

Exploitative intent: when the resource is abundant, free-ride and harvest double.

---

### Rule D — Stabilize only when danger is real
If \(S_t \le S_{\text{low}}\), then:

1. If opponents are mostly cooperating (low extraction pressure):  
   - If \(\bar{k} \le 0.35n\): **Play D** (exploit them) *unless* stock is critically low.
2. If stock is critically low, prevent collapse:  
   - If \(S_t \le 0.20\cdot capacity\): **Play C** (stabilizer mode), **but only** for up to 2 consecutive rounds; if no improvement, revert to D.

So in danger zone:
- **C** if \(S_t\) is *critical* (≤ 20% capacity), briefly, to preserve future value.
- Otherwise **D**, especially if others already cooperate (exploit), or if others defect heavily (collapse likely anyway).

---

### Rule E — Mid zone: conditional extortion (the core)
When \(S_{\text{low}} < S_t < S_{\text{high}}\), choose based on predicted extraction and opponent “support”.

Compute:
- \(\bar{k}\) (defector average in last 3 rounds)
- “Cooperation support” score: \(support = 1 - \bar{k}/n\)

Decision:

1. If support is high (others mostly C), **defect**:
   - If \(\bar{k} \le 0.30n\): **D**.
   - Rationale: they maintain the stock; you harvest.

2. If support is moderate, play “one-step test”:
   - If \(0.30n < \bar{k} \le 0.60n\):
     - If stock is trending down (e.g., \(S_t < S_{t-1}\)): **C** for 1 round (probe).
     - Else: **D**.
   - Rationale: only contribute when there are signs the stock may fall; otherwise exploit.

3. If support is low (many defectors), don’t waste effort:
   - If \(\bar{k} > 0.60n\): **D**.
   - Rationale: your single C won’t save the commons; take what you can.

---

# 2) Edge cases

### First round (t = 1)
Play **D**.

Why: you have no evidence others will cooperate, and D strictly dominates C in immediate payoff. Also it’s an information-gathering move: you learn whether opponents punish defection, whether they are unconditional cooperators, etc.

---

### “Stabilizer mode” cap
If you ever play C due to critical stock, do it for **at most 2 consecutive rounds**. After that:
- If stock did not increase by at least \(+0.05 \cdot capacity\) over those rounds, switch to **D** permanently until stock recovers above \(S_{\text{high}}\).

Exploitative rationale: don’t become the sucker propping up an uncooperative population.

---

### If stock hits 0
Always **D** (it’s payoff 0 either way).  
But keep observing; if growth remains 0, nothing matters. If some exogenous recovery were possible (it isn’t here), you’d reconsider—so this is safe.

---

# 3) Why this is exploitative (clear mindset)

- **Free-rides whenever the stock is healthy** (Rule C) and whenever opponents are already cooperating (Rule E1).
- **Refuses to be a “rescuer”** when too many opponents defect (Rule E3), because your cooperation cannot prevent collapse alone.
- **Uses minimal, capped cooperation** only to keep the resource from entering a low-growth trap that would reduce *your own* future extraction value (Rule D + stabilizer cap).
- **Always cashes out in the last round and largely in the endgame** (Rules A/B).
- **Probes and adapts**: a single-round C in mid-zone only happens when there’s evidence the stock is declining and salvage value exists; otherwise it exploits.

---

# Pseudocode (implementable)
```python
def choose_action(t, r, n, capacity, S_t, history):
    # history provides past stocks and counts of defectors
    E = max(2, ceil(0.15 * r))
    S_high = 0.70 * capacity
    S_low  = 0.35 * capacity
    S_crit = 0.20 * capacity

    if t == r:
        return "D"

    # compute recent average defectors
    w = 3
    recent = history.last_rounds(min(w, t-1))
    if len(recent) == 0:
        k_bar = n  # pessimistic prior: assume all defect
    else:
        k_bar = avg([round.k_defectors for round in recent])

    # endgame
    if t >= r - E + 1:
        if S_t <= 0.15 * capacity and k_bar <= 0.25 * n:
            return "C"
        return "D"

    # safe zone
    if S_t >= S_high:
        return "D"

    # danger zone
    if S_t <= S_low:
        if S_t <= S_crit:
            # stabilizer mode with cap:
            if history.consecutive_own_C < 2:
                return "C"
            # if no improvement, stop cooperating
            if history.stock_change_over_last(2) < 0.05 * capacity:
                return "D"
            return "C"
        else:
            return "D"

    # mid zone: conditional extortion
    S_prev = history.prev_stock() if t > 1 else S_t
    trending_down = (S_t < S_prev)

    if k_bar <= 0.30 * n:
        return "D"
    elif k_bar <= 0.60 * n:
        if trending_down:
            return "C"  # one-round probe/stabilize
        return "D"
    else:
        return "D"
```

---

If you want, I can also provide a variant that explicitly estimates the next-stock \(S_{t+1}\) under “if I play C vs D” using \(\bar{k}\) and then chooses the action that maximizes expected remaining-game payoff (still with an exploitative bias).
'''

description_EXPLOITATIVE_114 = '''
Below is an **exploitative, adaptive “Harvest–Test–Punish–Recover” strategy** for the Common Pool Resource game. It aims to (i) **take D whenever it’s safe**, (ii) **bait/maintain others’ C** by keeping the stock high enough that cooperation remains attractive/viable, and (iii) **punish quickly** when the table drifts toward over-harvesting—while (iv) **never sacrificing the final rounds** (always take the last-round grab).

---

## Core idea (exploitative mindset)

- **Defection (D)** yields exactly **2×** the per-round payoff of cooperation (C) at the same stock, but it also speeds depletion.
- The stock has logistic regrowth; there is a “safe zone” where the pool replenishes well if total consumption isn’t too high.
- So you want to:
  1. **Probe** opponents early and learn whether they will sustain stock with C.
  2. **Exploit** by choosing D whenever stock and recent behavior suggest the pool will stay healthy anyway.
  3. **Switch to C** as a “damage control” move when stock is trending down (or when opponents are already heavy defectors), to preserve future harvesting opportunities.
  4. **Never cooperate in the endgame**: with a known finite horizon, grab at the end.

This is not “fair”; it’s a controlled resource-extraction strategy.

---

## Definitions computed from history/state

At round \(t\), you observe current stock \(S_t\) and past actions.

Let:
- \(d_{t-1}\) = number of opponents who defected in the previous round (0 to \(n-1\)).
- \(D\_rate\) = fraction of opponent defections over a recent window (e.g., last \(w=\min(5,t-1)\) rounds).
- \(\Delta S = S_t - S_{t-1}\) (stock trend; for \(t=1\), undefined).

**Stock “zones”** (parameter-only thresholds):
- **High stock**: \(S_t \ge 0.8 \cdot capacity\)
- **Medium stock**: \(0.4 \cdot capacity \le S_t < 0.8 \cdot capacity\)
- **Low stock**: \(S_t < 0.4 \cdot capacity\)

These are deliberately simple and robust. (You can tune constants 0.8/0.4 if desired; the logic is what matters.)

---

## Strategy overview by phase

### Phase A — Opening probe (rounds 1–2)
Purpose: identify whether others are “stock-friendly”.

**Round 1: play D.**
- Rationale: immediate 2× payoff, and you learn who cooperates under pressure.
- If everyone defects, the pool collapses anyway; you lose nothing by not being the sucker.

**Round 2: conditional**
- If **most opponents cooperated** in round 1 (e.g., \(d_1 \le \lfloor (n-1)/3 \rfloor\)) *and* stock is still high: **play D again** (start exploiting).
- Otherwise (many defectors or stock dropped a lot): **play C** (stabilize / avoid mutual destruction).

---

### Phase B — Main loop (rounds 3 to r-2): Harvest–Test–Punish–Recover

Each round \(t\in[3, r-2]\), choose action by the following priority rules.

#### Rule 1 (Hard endgame avoidance doesn’t apply yet): protect against collapse when low
If **Low stock** (\(S_t < 0.4\,capacity\)) OR **stock is falling fast** (e.g., \(\Delta S < -0.2\,capacity\)):
- **Play C.**
- Exploitative reasoning: you can’t extract future value from a dead pool; you “invest” minimally (C still pays) to restore the resource so you can later defect again.

#### Rule 2: punish over-harvesters only when it matters
If opponents are mostly defecting recently:
- If \(D\_rate \ge 0.5\): **Play C** *unless* stock is High and rising.
- Rationale: when others are already stripping the pool, your extra D often just accelerates collapse. You “punish” by refusing to add to depletion—this is *not altruism*; it’s protecting your future harvest.

#### Rule 3: exploit cooperative environments aggressively
If **High stock** and opponents aren’t heavy defectors:
- If \(S_t \ge 0.8\,capacity\) and \(D\_rate < 0.5\):
  - **Play D**.
- Rationale: this is the money zone. Let others “farm” stock via C while you skim 2×.

#### Rule 4: in Medium stock, alternate based on recent stock trend
If Medium stock (\(0.4c \le S_t < 0.8c\)):
- If \(\Delta S \ge 0\) (stock stable or increasing) and \(D\_rate < 0.5\): **Play D**.
- Else: **Play C**.
- Rationale: you defect when the system is not deteriorating; otherwise stabilize.

---

### Phase C — Pre-endgame (round r-1)
**Round \(r-1\): default to D**, except one case:
- If \(S_{r-1}\) is extremely low (e.g., \(< 0.1\,capacity\)) and you believe opponents are mostly cooperating (low \(D\_rate\)), you can play **C** to bump the last round stock slightly.
- In most environments, still **D** is better because you capture twice immediately and there’s only one round left.

Exploitative intent: you don’t “build” for others this late unless it very likely increases your final-round take.

---

### Phase D — Last round (round r)
**Always play D.**
- No future to protect; pure extraction dominates.

---

## Pseudocode (implementable decision rules)

```pseudo
parameters:
  HIGH = 0.8 * capacity
  LOW  = 0.4 * capacity
  CRASH = 0.1 * capacity
  w = 5  // history window

function choose_action(t, S_t, history):
  if t == r:
    return D

  if t == 1:
    return D

  // compute stats
  d_prev = num_opponents_defected(t-1)
  window = last min(w, t-1) rounds
  D_rate = (total opponent defections in window) / ((n-1) * len(window))
  if t >= 2:
    DeltaS = S_t - S_{t-1}
  else:
    DeltaS = 0

  if t == 2:
    if d_prev <= floor((n-1)/3) and S_t >= HIGH:
      return D
    else:
      return C

  // pre-endgame
  if t == r-1:
    if S_t < CRASH and D_rate < 0.3:
      return C   // rare "last pump"
    else:
      return D

  // main rounds 3..r-2
  if S_t < LOW or DeltaS < -0.2 * capacity:
    return C

  if D_rate >= 0.5:
    if S_t >= HIGH and DeltaS >= 0:
      return D
    else:
      return C

  // cooperative-ish environment
  if S_t >= HIGH:
    return D

  // medium stock
  if DeltaS >= 0:
    return D
  else:
    return C
```

---

## Edge cases and robustness notes

- **If opponents are unconditional defectors**: you’ll mostly play C once stock threatens collapse, then still take D at the end. You can’t create cooperation, but you avoid being the *extra* accelerant when it doesn’t pay long-run.
- **If opponents are unconditional cooperators / “nice” strategies**: you exploit heavily with frequent D while using occasional C only to prevent stock from sliding into low zone.
- **If opponents use trigger/punishment strategies**: your occasional C in low/declining stock regimes acts as a “repair signal” without requiring communication; but you still defect whenever the environment can absorb it.
- **If capacity is just barely ≥ 2n**: the stock can be fragile; the low/decline safeguards become more important automatically because stock will enter those regimes more often.
- **Finite horizon**: hard-coded endgame defection prevents being milked by strategies that try to “cooperate until the end”.

---

## Why this is exploitative (explicitly)

- It **defaults to D early and at the end**, when exploitation is most valuable and least punishable.
- In the middle, it **treats C as a tool**: not as reciprocity, but as **resource maintenance** to enable *more future defection payoffs*.
- It **leans into asymmetric extraction**: if others bear the cost of keeping stock healthy (by playing C), you harvest at 2× whenever the pool can sustain it.

If you want, I can also provide a tighter, fully “threshold-only” version (no trend/window), or a more aggressive version that defects more often and accepts more collapse risk depending on tournament meta.
'''

description_EXPLOITATIVE_115 = '''
Below is an *exploitative*, stateful repeated-game strategy that (i) tries to farm cooperators, (ii) avoids being the “sucker” when others defect, and (iii) preserves the stock when that increases your future take. It’s essentially: **probe → classify opponents by revealed cooperativeness → harvest (defect) when safe → punish hard when not → manage stock to keep it productive**.

---

## Key idea (why this can exploit)
- In any round with stock \(S\), **D pays exactly 2× C** (since \(S/n\) vs \(S/(2n)\)).
- But D also depletes the stock faster. So exploitation is about:
  1) **Defecting when others are likely to cooperate** (you get 2× while they preserve stock),
  2) **Switching to cooperation only when needed** to keep the resource from collapsing or to rebuild it,
  3) **Never cooperating when it won’t change outcomes** (e.g., endgame) or when it just subsidizes defectors.

Because actions are observable, you can maintain a **belief/score** about how cooperative the population is, then choose C/D to maximize long-run extraction.

---

## Observables you can compute each round
Let:
- \(S_t\) = stock at start of round \(t\)
- Let \(k^C_{t-1}\) = number of cooperators in round \(t-1\) (from history)
- Define last-round cooperation rate:  
  \[
  p_{t-1} = \frac{k^C_{t-1}}{n}
  \]
- Define a smoothed estimate (EWMA) of cooperation in the population:
  \[
  \hat p_t = (1-\alpha)\hat p_{t-1} + \alpha p_{t-1},\quad \alpha \in [0.2,0.4]
  \]
  Initialize \(\hat p_1 = 1/2\) (agnostic).

Also track a **collapse indicator**:
- If \(S_t\) is low, defection can kill future value. Use thresholds relative to capacity.

---

## Strategy: “Probe–Harvest–Stabilize (PHS)”

### Parameters (depend only on game parameters)
Use:
- \(\alpha = 0.3\) (smoothing)
- Stock safety thresholds:
  - **Low-stock threshold**: \(S_t \le 0.35 \cdot \text{capacity}\)
  - **High-stock threshold**: \(S_t \ge 0.75 \cdot \text{capacity}\)
- Cooperation thresholds (for deciding whether you can profitably defect):
  - **Exploit threshold**: \(\hat p_t \ge 0.55\) (population seems mostly cooperative)
  - **Danger threshold**: \(\hat p_t \le 0.35\) (population mostly defecting)

These can be slightly tuned, but the logic is robust.

---

## 1) Decision rules: when to cooperate vs defect

### Rule A — First-round probe (information advantage)
**Round 1: Play D.**

Reason: immediate 2× payoff vs C, and you learn whether others are cooperative without paying the probing cost. If the pool collapses immediately, that’s because others defected too; cooperating wouldn’t have saved you much in an exploitative tournament.

---

### Rule B — Core action selection (rounds 2 to r-1)

At start of round \(t\) (2 ≤ t ≤ r-1), choose action based on (i) stock, (ii) estimated cooperation.

**B1. If it’s safe to harvest, defect.**
- If \(S_t \ge 0.75\cdot \text{capacity}\) **and** \(\hat p_t \ge 0.55\): **Play D**.
  - Interpretation: stock is full-ish and others tend to cooperate ⇒ you can “free-ride” and take double.

**B2. If stock is getting low, stabilize (but only if it’s not hopeless).**
- If \(S_t \le 0.35\cdot \text{capacity}\):
  - If \(\hat p_t \ge 0.45\): **Play C** (stabilize/rebuild while others are likely to also be partly cooperative).
  - Else (\(\hat p_t < 0.45\)): **Play D** (don’t throw good effort after bad; punish/exit).

**B3. If population is mostly defecting, punish by defecting.**
- If \(\hat p_t \le 0.35\): **Play D** regardless of stock.
  - Interpretation: cooperation won’t be reciprocated; you gain nothing by restraint.

**B4. Otherwise (mixed/uncertain), use “conditional exploitation”:**
- If \(0.35 < \hat p_t < 0.55\) and stock is moderate:
  - Default: **Play D**
  - Exception: if last round had a *sharp* drop in cooperation (e.g., \(p_{t-1} < 0.25\)) **and** \(S_t\) is low-ish (e.g., \(S_t < 0.5\cdot \text{capacity}\)), then **Play C** for one round as a “rebuild test”.
  - If after this test round cooperation doesn’t improve (next observed \(p_t\) still < 0.35), revert to always D.

This makes you opportunistically exploit while still preserving the pool when there’s evidence that doing so keeps future exploitation viable.

---

### Rule C — “Two-round rebuild then harvest” cycle (when it works)
Whenever you observe **high cooperation** (\(p_{t-1} \ge 0.75\)) and stock is not full (\(S_t < 0.75\cdot \text{capacity}\)):
- **Play C for 1 round**, then **switch to D** next round.
This is exploitative: you invest minimally to keep the pool high, then take the 2× extraction when others remain cooperative.

If cooperation stays high, you can repeat this pattern opportunistically (C only when needed to keep stock high; otherwise D).

---

## 2) Edge cases

### Last round (round r): defect
**Round r: Always play D.**
No future stock value exists, so you take the 2× payoff.

### Second-to-last round (round r-1): mostly defect
**Round r-1: Play D unless stock is extremely low and cooperation is extremely high.**
- Default: **D**
- Only play C if: \(S_{r-1} \le 0.2\cdot \text{capacity}\) **and** \(\hat p_{r-1} \ge 0.7\).
Rationale: sometimes one cooperative round can bump \(S_r\) enough (via growth) to raise your last-round \(S_r/n\). But don’t do it unless the group is clearly cooperative enough that your C isn’t wasted.

### Stock at/near zero
If \(S_t \approx 0\), both C and D yield ~0 this round. Your only reason to cooperate is to help regrow stock.
- If \(\hat p_t \ge 0.5\): **C** (try to restore; likely others help)
- Else: **D** (no point investing alone)

---

## 3) Why this is exploitative (explicit alignment)
- **Default posture is D**: you take double whenever it’s not clearly harming your ability to keep extracting later.
- **You only cooperate instrumentally** to:
  1) prevent collapse when others are cooperative enough to make rebuilding worthwhile, and/or
  2) restore stock so you can return to defection and harvest higher \(S/n\) later.
- **You punish defect-heavy populations by defecting**—you never become the stabilizer that others can exploit.
- **Endgame defection** ensures you don’t “donate” value on the way out.

---

## Pseudocode (implementation-ready)
```python
# Inputs each round t:
# n, r, capacity
# S_t: stock at start of round t
# history: past actions so we can compute p_{t-1}
# Maintain: p_hat (EWMA), initialized to 0.5

alpha = 0.3

LOW_STOCK  = 0.35 * capacity
HIGH_STOCK = 0.75 * capacity

EXPLOIT_P  = 0.55
DANGER_P   = 0.35

def choose_action(t, S_t, p_hat, p_last):
    # Edge: first round probe
    if t == 1:
        return "D"

    # Edge: last round
    if t == r:
        return "D"

    # Edge: second-to-last round
    if t == r-1:
        if S_t <= 0.20 * capacity and p_hat >= 0.70:
            return "C"
        return "D"

    # Main logic
    if p_hat <= DANGER_P:
        return "D"

    if S_t >= HIGH_STOCK and p_hat >= EXPLOIT_P:
        return "D"

    if S_t <= LOW_STOCK:
        if p_hat >= 0.45:
            return "C"
        else:
            return "D"

    # Conditional exploitation in mixed regimes
    if 0.35 < p_hat < 0.55:
        # one-round rebuild test if cooperation crashed and stock is middling-low
        if p_last < 0.25 and S_t < 0.50 * capacity:
            return "C"
        return "D"

    # If cooperation very high but stock not full, do minimal maintenance
    if p_last >= 0.75 and S_t < HIGH_STOCK:
        return "C"

    # Otherwise exploit
    return "D"

def update_p_hat(p_hat, p_last):
    return (1 - alpha) * p_hat + alpha * p_last
```

---

If you want, I can also provide a more “targeted exploitation” variant that maintains *per-opponent* cooperativeness scores and adapts to heterogeneous populations (e.g., exploit a minority of unconditional cooperators while punishing defectors), but the above works well given the game only has aggregate externalities through stock.
'''

description_EXPLOITATIVE_116 = '''
### Strategy: **Stock-Managed Extortion (SME)**  
Goal: **Extract more than fair share whenever opponents are willing to sustain the resource**, while **avoiding being the “sucker”** and **collapsing the stock only when it is profit-maximizing (especially near the end)**.

Key idea:  
- Your one-shot gain from defecting is always +S/(2n) relative to cooperating.  
- But defecting also reduces future stock.  
- So we **cooperate only when the stock is healthy and opponents are mostly cooperating**, using cooperation as an *investment* that keeps S high so we can keep harvesting (often defecting) later.  
- When opponents don’t sustain the resource, we **switch to defecting quickly** and treat the pool as **finite to be mined**.

---

## 1) Decision rules: when to Cooperate vs Defect

We maintain two internal estimates from history:
- **k̂(t)** = estimated number of defectors last round (exactly observed from actions)
- **S(t)** = current stock at start of round t
- **T = r - t + 1** = rounds remaining

We use three modes:

### Mode A — **Build/Preserve (invest in stock)**
Use when stock is in the “safe/high” region and opponents are not heavily defecting.

**Rule A (Play C):**  
Play **C** if all are true:
1. **S(t) ≥ 0.8 × capacity** (stock is high; easy to keep near capacity)  
2. **k̂(t−1) ≤ 1** (at most one defector last round)  
3. **T > 2** (not near endgame)

Rationale: when S is high, the logistic regrowth can refill the pool after moderate consumption. Cooperation here is cheap “maintenance” that keeps the system producing.

---

### Mode B — **Exploit (harvest while others sustain)**
When opponents show they’re sustaining the stock (mostly C), we defect to take the larger share.

**Rule B (Play D):**  
Play **D** if all are true:
1. **S(t) ≥ 0.6 × capacity**  
2. **k̂(t−1) = 0** (everyone cooperated last round)  
3. **T > 2**

Rationale: If everyone just cooperated, the stock is likely high and stable. Defecting yields immediate extra payoff and (if it’s just you) often doesn’t destroy the long-run stock because others’ cooperation + regrowth can compensate.

**Anti-collapse safeguard:** If after you defect, stock drops sharply and fails to recover (see Rule D below), you stop exploiting and go to retaliation/mining.

---

### Mode C — **Retaliate / Mine (don’t subsidize defectors)**
If there’s meaningful defection, your cooperation becomes a donation and also may not even preserve the stock. In that world you should defect too.

**Rule C (Play D):**  
Play **D** if **any** is true:
1. **k̂(t−1) ≥ 2** (defection is common)  
2. **S(t) ≤ 0.5 × capacity** (stock not safely high; need not “invest”)  
3. **You played C last round and at least one opponent played D** (classic “no sucker” condition)

Rationale: This is the exploitative spine: **never keep cooperating into exploitation**. If others defect, you defect.

---

### Recovery condition (optional but important)
Sometimes opponents alternate, or a defector “tests” then returns to cooperation. You want to re-enter exploitation when it’s profitable, but not be easily farmed.

Define a **cooldown counter** `cool` (initial 0).  
- If you ever detect exploitation against you (you played C and someone played D), set `cool = 2`.  
- While `cool > 0`, you refuse to cooperate unless stock is extremely high and defection disappears.

**Rule D (Cooldown behavior):**
- If `cool > 0`: play **D** unless **S(t) ≥ 0.9×capacity AND k̂(t−1)=0**; then play **C**.  
- Decrease `cool` by 1 each round.

Rationale: prevents opponents from profiting by occasional defections while you “help rebuild” immediately.

---

## 2) Edge cases: first round, last rounds, and stock extremes

### First round (t = 1)
You have no history. Start by **C** to assess the field and keep S high:

**Round 1:** play **C**.

Why this is exploitative: It’s not altruism—it's **probing**. If opponents cooperate, you can start defecting to exploit immediately from round 2. If they defect, you pivot to mining without having lost much (stock was high, one round only).

---

### Last two rounds (T ≤ 2): endgame mining
Near the end, future stock is less valuable. You should cash out.

**If T = 2 (second-last round):**
- Play **D** unless **S(t) is extremely low** (e.g., S(t) < stock/(2n) is irrelevant because payoff scales with S, but you still get more by D).  
Practical rule: **always D**.

**If T = 1 (last round):**
- **Always D.**

Rationale: with no future, defecting strictly dominates cooperating in the final round, and usually also in the penultimate given minimal future.

---

### Stock near zero
If **S(t) is tiny**, both actions yield tiny payoffs, but D still yields double C.

**If S(t) ≤ 0.1×capacity:** play **D** (unless you’re in a rare “everyone cooperates and we can regrow” situation; but with low S, that regrowth is slow and uncertain if others might defect).

---

## 3) Why this is exploitative (explicit alignment)

- **You cooperate only as an investment to keep the pool productive**, not to be fair.  
- **You defect immediately when others are cooperative and the stock is high**, extracting the larger share while relying on their restraint to preserve the resource.  
- **You do not reward defection**: any meaningful defection triggers sustained defection (plus cooldown), preventing opponents from “taxing” you while you rebuild the stock.  
- **You mine hard in the endgame** because future sustainability is worthless then.

This makes the strategy robust:
- Against unconditional cooperators: you shift to **frequent defection** while keeping stock high enough via occasional maintenance C.  
- Against tit-for-tat–like strategies: you avoid being exploited (cooldown/retaliation) and often settle into mutual D (which is fine because they won’t let you exploit them anyway).  
- Against chaotic/noisy strategies: the stock thresholds prevent you from investing when the environment is unstable.  
- Against grim-trigger types: you get at most one early exploit attempt (round 2 if they all C), then you fall back to D forever—still near-optimal once they punish.

---

## Pseudocode (implementable)

```python
# Inputs each round t:
# S = current stock at start of round
# history provides last round actions of all players
# n, r, capacity known

cool = 0

def choose_action(t, S, last_actions):
    global cool
    T = r - t + 1

    # Endgame: mine
    if T <= 2:
        return "D"

    if t == 1:
        return "C"

    k = count_defectors(last_actions)  # number of opponents who played D last round
    any_defected = (k > 0)

    # update cooldown trigger (if we were suckered last round)
    # (implementation will know our last action)
    if my_last_action == "C" and any_defected:
        cool = 2

    # Cooldown behavior
    if cool > 0:
        cool -= 1
        if S >= 0.9 * capacity and k == 0:
            return "C"
        else:
            return "D"

    # Retaliate / Mine if defection is present or stock is not high
    if k >= 2 or S <= 0.5 * capacity or (my_last_action == "C" and any_defected):
        return "D"

    # Exploit if everyone cooperated and stock is healthy
    if k == 0 and S >= 0.6 * capacity:
        return "D"

    # Otherwise preserve when stock is very high and defection rare
    if S >= 0.8 * capacity and k <= 1:
        return "C"

    return "D"
```

If you want it *more exploitative*, increase the exploitation region (e.g., allow Rule B when `k<=1` and `S>=0.7*capacity`) and lengthen the cooldown so you punish longer after being exploited.
'''

description_EXPLOITATIVE_117 = '''
## Strategy: **Regenerative Extortion (REX)**

Exploit the fact that (i) defection gives a strictly higher *current-round* payoff than cooperation at the same stock, but (ii) too much defection collapses the stock and kills *future* payoffs. So you *farm* opponents by keeping the resource in the high-growth region **only if** others are sufficiently cooperative; otherwise you *strip-mine* by defecting whenever it’s not profitable to “invest” in stock.

This is an **adaptive extortion** strategy: you cooperate just enough to keep the stock productive **when others are investing**, and you defect aggressively when they are not.

---

# Core ideas (what you’re optimizing)
1. **Target stock band where growth is strong**: logistic growth peaks at \(S_{\text{rem}} = \frac{capacity}{2}\) after consumption. If the remaining stock after consumption is near \(capacity/2\), next round’s stock rebounds strongly.
2. **You don’t pay the investment cost unless others do**: your cooperation is conditional on others’ recent cooperation rate and the observed stock trajectory.
3. **Extortion principle**: when opponents cooperate (resource is healthy), you defect more to take a larger share; when opponents defect (resource collapses), you defect too (don’t be the sucker).

---

# Observables each round
At round \(t\), before choosing action, you know:
- current stock \(S_t\)
- history of all actions → how many defectors last round \(d_{t-1}\)
- can compute last round total consumption and infer whether stock is trending up/down

Let:
- \(d_{t-1}\) = number of opponents who played D last round (out of \(n-1\))
- \(q_{t-1} = 1 - \frac{d_{t-1}}{n-1}\) = opponent cooperation rate last round
- \(\Delta S_{t-1} = S_t - S_{t-1}\) (stock change observed)

---

# Decision rules (Cooperate vs Defect)

### Rule 0: Endgame grab
- **If \(t = r\)** (last round): **Defect**.
  - No future to protect; D strictly dominates C within the round.

### Rule 1: Collapse/low-stock strip-mining
If stock is already too low to sustain meaningful future growth, don’t invest:
- **If \(S_t \le S_{\text{low}}\)**: **Defect**
- Use: \(S_{\text{low}} = \max\left(2n,\;0.25 \cdot capacity\right)\)

Rationale: below ~25% capacity, even cooperative play yields small immediate payoffs; you’re better off extracting now rather than “financing” recovery that others may steal.

### Rule 2: Punish defect-heavy environments (grim-but-forgiving)
If opponents are mostly defecting, cooperating just subsidizes them.
- **If \(q_{t-1} < q_{\min}\)**: **Defect**
- Use: \(q_{\min} = 0.7\)

Interpretation: if ≥30% of opponents defected last round, treat the environment as exploitative and switch to D.

### Rule 3: If opponents are cooperative, extort (defect unless stock is in danger)
When opponents are cooperative, you can safely defect more *as long as the stock isn’t trending toward collapse*.

Compute a simple danger signal:
- **Danger if** stock is falling fast or currently below a “safe band”
  - Danger if \(S_t < S_{\text{safe}}\) OR \(\Delta S_{t-1} < -0.1\cdot capacity\)
- Use \(S_{\text{safe}} = 0.6 \cdot capacity\)

Then:
- **If opponents cooperative ( \(q_{t-1} \ge q_{\min}\) ) and NOT in danger**: **Defect**
- **If opponents cooperative but in danger**: **Cooperate** (as “maintenance”)

This is the extortion hook: **as soon as the population behaves, you take the bigger share (D)**, only “paying” cooperation when the stock’s health requires it.

### Rule 4: First round (bootstrap)
Round 1 has no history. Use stock-based probing:
- **If \(S_1 \ge 0.8\cdot capacity\)**: **Defect**
- else **Cooperate**

Since initial stock is capacity by spec, this means you open with **Defect** to test whether others will still maintain the resource despite you taking more.

### Rule 5: Anti-sucker safeguard (targeted retaliation)
If you cooperated last round and stock still dropped sharply, you’re being exploited (others defected enough to outweigh growth).
- If you played C at \(t-1\) and \(\Delta S_{t-1} < 0\): **Defect** for the next **2 rounds** (lock-in punishment window), then revert to normal rules.

This prevents being trapped into repeatedly “repairing” the stock for defectors.

---

# Pseudocode summary
```python
def REX_action(t, r, n, capacity, S_t, history, S_prev=None):
    # constants
    S_low  = max(2*n, 0.25*capacity)
    S_safe = 0.60*capacity
    q_min  = 0.70

    # Endgame
    if t == r:
        return "D"

    # First round
    if t == 1:
        return "D" if S_t >= 0.8*capacity else "C"

    # compute last-round stats
    opp_def_last = count_opponents_defected(history[t-1])
    q_last = 1 - opp_def_last/(n-1)
    deltaS = S_t - S_prev

    # short punishment window if we got exploited while cooperating
    if was_in_punishment_window(history, t):
        return "D"

    if my_action(history[t-1]) == "C" and deltaS < 0:
        set_punishment_window(t, length=2)
        return "D"

    # collapse strip-mining
    if S_t <= S_low:
        return "D"

    # punish defect-heavy environment
    if q_last < q_min:
        return "D"

    # extort when safe; maintain when in danger
    danger = (S_t < S_safe) or (deltaS < -0.10*capacity)
    if danger:
        return "C"
    else:
        return "D"
```

---

# Edge cases and robustness notes
- **All-defect populations**: You defect almost always, avoiding being the lone cooperator financing others.
- **All-cooperate / high-cooperation populations**: You default to defection most rounds, only occasionally cooperating to prevent stock from drifting into the danger zone. This yields systematically higher total payoff than unconditional cooperators.
- **Mixed/reactive opponents**:
  - If they punish defectors by defecting, your Rule 2 kicks in and you defect as well; you won’t be the only investor.
  - If they tolerate exploitation and keep cooperating, you continue to extort.
- **Short horizons**: Endgame rule ensures you cash out. With small \(r\), the strategy becomes more defect-heavy automatically.

---

# Why this is exploitative (explicitly)
- It treats opponent cooperation as a **resource you harvest**: when they maintain the commons, you take the larger share (D).
- It invests (C) only as a **minimal maintenance cost** to keep the stock from entering a low-payoff regime—never as a norm or “fairness” choice.
- It refuses to “teach cooperation” at a cost; instead it **withholds cooperation unless it is necessary for future extraction**.

If you want, I can also provide a more “mathematical” variant that computes a one-step forecast of next stock under assumed opponent consumption and chooses C only when it increases your expected *future* extractable value.
'''

description_EXPLOITATIVE_118 = '''
### Strategy: **Predatory Regenerator (PR)**
Core idea: treat the stock as a self-renewing asset. You **farm cooperation** when the pool is productive, then **harvest aggressively** when others show willingness to sustain it. You **never pay the “cooperation tax”** unless doing so is necessary to keep the stock from collapsing or to re-enable future exploitation.

You only ever play **C** to (a) prevent imminent collapse when you still expect future gains, or (b) rebuild stock when opponents are also rebuilding. Otherwise you play **D** to extract double per-round payoff.

---

## Key quantities (computed from history and parameters)

At round \(t\), current stock \(S_t\).

From last round’s observed actions, compute:
- \(k_{t-1}\) = number of cooperators among opponents last round (exclude you if you want, but easiest: count total C and subtract yours)
- \(c_{t-1} = k_{t-1}/(n-1)\) = opponent cooperation rate last round

Maintain an exponentially weighted estimate of opponent cooperativeness:
- \(p_t = (1-\alpha)p_{t-1} + \alpha c_{t-1}\), with \(\alpha \in [0.2,0.4]\) (use 0.3).

This gives robustness to noise and mixed strategies.

Also compute a **safety stock threshold**: the stock level below which another round of heavy defection likely kills the pool.
A crude but effective threshold is based on worst-case consumption:
- If everyone defects, total consumption = \(S_t\), pool goes to 0 immediately.
So the real question is: “Is the group likely to defect enough that remaining stock becomes too low to regrow meaningfully?”

Use a simple guardrail:
- \(S_{\text{low}} = 0.25 \cdot \text{capacity}\) (below this, growth is still decent in logistic terms but the pool is fragile because actions scale with \(S\))
- \(S_{\text{high}} = 0.8 \cdot \text{capacity}\) (above this, pool is healthy and exploitation is safest)

These constants are intentionally simple and tournament-robust.

---

## 1) Decision rules (when to C vs D)

### Default: **Defect**
- Play **D** unless a “rebuild condition” or “collapse prevention condition” triggers.

### Rebuild condition (invest only when it pays)
Play **C** if **all** are true:
1. \(S_t < S_{\text{high}}\) (pool isn’t already near-capacity), and  
2. \(p_t \ge p_{\text{rebuild}}\) (opponents are cooperative enough to rebuild), and  
3. Not in the final round (see edge cases)

Set \(p_{\text{rebuild}} = 0.6\).  
Interpretation: only invest if a majority of opponents have recently cooperated.

**Why exploitative?** You cooperate only when others are likely to do the work of sustaining the pool too; you’re not a “nice” cooperator, you’re protecting future harvest.

### Collapse-prevention condition (minimal investment to keep the farm alive)
Play **C** if **both**:
1. \(S_t \le S_{\text{low}}\), and  
2. \(p_t \ge p_{\text{min}}\)

Set \(p_{\text{min}} = 0.35\).

Interpretation: if stock is getting dangerously low but opponents are not completely hopeless, you temporarily cooperate to stop the system from hitting an absorbing near-zero path where future exploitation yields nothing.

**Why exploitative?** This is like paying maintenance on a machine you intend to keep extracting from.

### Punish/Exploit condition (when others cooperate, harvest)
If \(p_t \ge 0.6\) and \(S_t \ge S_{\text{high}}\): play **D**.
- The pool is full and others tend to cooperate: that is exactly when you should harvest.

### If opponents are mostly defectors: **always D**
If \(p_t < p_{\text{min}}\): play **D** regardless of stock.
- Don’t waste cooperation on players who won’t sustain the pool anyway.

---

## 2) Edge cases

### Round 1 (no history)
Start with **D**.
- Rationale: immediate gain is doubled and you also learn who is willing to cooperate under exploitation pressure.

### Last round \(t=r\)
Always **D**.
- No future to protect. Pure extraction.

### Second-to-last round \(t=r-1\)
Default to **D** unless stock is extremely high and you believe one more round of cooperation by others will keep it high anyway—still, exploitation dominates here too.
Rule: play **D** for \(t \ge r-1\).

### Stock extremely low (near 0)
If \(S_t \approx 0\), your action barely matters (payoffs are tiny). Still:
- If \(p_t \ge 0.6\) and \(t \le r-2\), play **C** for exactly one round to help reboot.
- Otherwise **D**.

This prevents getting stuck in low-stock purgatory against “recovering” populations.

### Stock at capacity
If \(S_t = \text{capacity}\):
- Play **D** unless you are in a rebuild phase for strategic reasons (but rebuild doesn’t apply at capacity). So **D**.

---

## 3) “Exploitative mindset” mechanics (how it exploits broadly)

### A. “Farm then harvest” cycle
- When others cooperate enough, the stock regenerates quickly (logistic growth is strongest mid-range).
- You free-ride by defecting when stock is high.
- If stock falls too low, you invest the minimum cooperation needed to re-enable future high-stock harvesting—*but only if opponents are likely to contribute too*.

### B. Avoid being baited into sucker cooperation
- Against defect-heavy opponents, you never cooperate (since any cooperation only reduces your immediate payoff and does not change the “everyone consumes proportional to S” trap enough to matter).
- Against conditional cooperators, your occasional “maintenance cooperation” keeps them engaged, preserving the pool for you to exploit later.

### C. Robustness to mixed and adaptive strategies
- The EWMA \(p_t\) prevents overreacting to one-off deviations.
- Two thresholds \(p_{\text{min}} < p_{\text{rebuild}}\) give a stable regime:  
  - low \(p_t\) → pure D  
  - medium \(p_t\) → only prevent collapse  
  - high \(p_t\) → harvest (D) at high stock, rebuild (C) at mid stock

---

## Pseudocode (implementable)

```python
# parameters
alpha = 0.3
p_rebuild = 0.60
p_min = 0.35
S_low = 0.25 * capacity
S_high = 0.80 * capacity

# state
p = 0.5  # prior belief opponents cooperate about half

def choose_action(t, S, history):
    global p

    # update p from last round if exists
    if t > 1:
        opp_C = count_opponent_cooperators(history[t-1])
        c_last = opp_C / (n-1)
        p = (1 - alpha) * p + alpha * c_last

    # endgame: extract
    if t >= r-1:
        return "D"

    # if opponents are mostly defectors, never invest
    if p < p_min:
        return "D"

    # collapse-prevention (minimal investment)
    if S <= S_low:
        # if opponents at least somewhat cooperative, help reboot
        return "C"

    # rebuild when mid-stock and opponents likely to cooperate
    if (S < S_high) and (p >= p_rebuild):
        return "C"

    # otherwise harvest
    return "D"
```

---

### Why this wins tournaments (practically)
- Versus always-C / generous strategies: you defect almost always, getting ~2× per-round payoff while stock often remains healthy due to their cooperation.
- Versus grim-trigger / conditional cooperators: you sometimes cooperate when stock is low, keeping them from permanently switching to D, then you resume harvesting.
- Versus always-D: you defect too; you don’t waste moves trying to “fix” an unfixable environment.
- Versus complex learners: EWMA + thresholds makes you predictable enough to stabilize them into cooperating, but not generous enough to share gains.

If you want, I can tune the numeric thresholds (\(S_{low}, S_{high}, p_{min}, p_{rebuild}\)) analytically for specific \(n, r, capacity\) ranges, but the above is intentionally parameter-simple and robust.
'''

description_EXPLOITATIVE_119 = '''
Below is an explicitly exploitative, stateful “harvest-and-threat” strategy. It tries to (i) farm high stock by tolerating/encouraging others’ cooperation when possible, (ii) switch to defection quickly when defection is profitable or when others are uncooperative, and (iii) never sacrifice endgame payoff for “reputation” once the horizon is short.

---

## Key idea (why this is exploitative)
- **Defection (D) always gives double the per-round payoff of C given the same stock S**. So you only play C to **maintain/increase future stock** when doing so is likely to be “paid back” by future high-S rounds.
- The stock regrowth is logistic and can be very strong when S is mid-range. You exploit this by:
  - **building** (or allowing) high stock when it benefits you later, *but only if opponents are also sufficiently restrained*,
  - **harvesting** aggressively (D) when others are cooperating enough that the stock stays healthy anyway, and
  - **punishing** by switching to D when others defect too much, because your C won’t save the resource if they’re draining it.

This is basically: *cooperate only as an investment; defect whenever you can harvest without collapsing the stock or when collapse is inevitable; and defect in the endgame.*

---

## Observables and derived quantities

At each round \(t\) (1-indexed), before choosing action, you know:
- current stock \(S_t\)
- full history of actions.

Compute from the previous round \(t-1\):
- \(k_{t-1}\): number of opponents who played C (or equivalently total C among all players; you can count opponents’ C)
- \(d_{t-1} = (n-1) - k_{t-1}\): number of opponent defectors last round
- A smoothed cooperation estimate (opponents):
  \[
  p_t = \lambda p_{t-1} + (1-\lambda)\frac{k_{t-1}}{n-1}
  \]
  with e.g. \(\lambda = 0.7\). Initialize \(p_1=0.5\).

Also define an immediate “resource stress” indicator:
- If everyone plays D at stock S, stock after consumption is 0 (catastrophic).
- If everyone plays C at stock S, remaining is \(S/2\) which regrows to capacity if capacity is large enough (as in your example).

So the strategic question each round: **is the group effectively preserving the stock?** If yes, exploit by defecting; if not, defect anyway (don’t be the sucker).

---

## Decision rules: Cooperate vs Defect

### Rule 0: Endgame defection (hard exploit)
- If \(t = r\): **Play D**.
- If \(t = r-1\): **Play D** (penultimate round; future is too short to justify investing in stock).
- More generally, if remaining rounds \((r-t+1)\) is small, cooperation has diminishing ROI. A safe cut is last 2 rounds always D.

### Rule 1: If stock is already low, defect (salvage)
Define a low-stock threshold:
- \(S_{\text{low}} = 2n\). (Same scale as your state bound; also means per-round payoffs are small and rebuilding requires coordinated restraint you can’t ensure.)

If \(S_t \le S_{\text{low}}\): **Play D**.
- Rationale: at low S, your C only yields half the payoff of D and likely won’t change the trajectory unless others also cooperate strongly.

### Rule 2: “Exploit cooperators” mode (primary money-maker)
If opponents are sufficiently cooperative, defect to harvest while they sustain the stock.

Trigger condition:
- if smoothed cooperation \(p_t \ge p^*\) where \(p^* \approx 0.7\) (meaning on average at least ~70% of opponents are cooperating),
- and stock is healthy: \(S_t \ge 0.5 \cdot \text{capacity}\),

then: **Play D**.

This is the core exploit: when others are doing the conserving, you take the larger share.

### Rule 3: “Test-and-build” mode (attempt to create a farmable regime)
If you don’t yet know opponents’ type, or cooperation seems possible but not stable, use conditional cooperation for a short window to see if a cooperative basin exists.

- In rounds \(t=1\) and \(t=2\): **Play C** unless \(S_t \le S_{\text{low}}\).
  - Purpose: cheap probing; also helps keep stock high if others are near-cooperative.
  - But you do not stay nice: you switch fast based on observed behavior.

After round 2, if cooperation estimate is moderate:
- If \(0.4 \le p_t < 0.7\) and \(S_t \ge 0.6\cdot \text{capacity}\): **Play C** for at most **one** additional round as an “investment” to push stock higher and see if others reciprocate.
- Otherwise: **Play D**.

This “at most one extra C” is important: it prevents getting milked by exploiters while still giving a chance to reach a high-stock steady state that you can later harvest.

### Rule 4: “Grim-ish” response to defection (don’t be the sucker)
If last round had heavy defection among opponents, immediately switch to D and stay there until strong evidence of cooperation returns.

Define “heavy defection”:
- If \(d_{t-1} \ge \lceil (n-1)/2 \rceil\) (at least half the opponents defected last round), then:
  - **Play D** this round.
  - Set a punishment counter \(P = 2\) (two rounds).

While \(P>0\): **Play D** and decrement \(P\) each round.
- After punishment ends, you only return to C if \(p_t \ge 0.6\) *and* stock is healthy.

This makes you hard to exploit: once others show opportunism, you stop investing.

### Rule 5: “Recovery cooperation” (rare; only when it pays)
If stock is medium and opponents are strongly cooperative, you might cooperate to help keep the farm from collapsing, but only when stock is in the zone where logistic growth is most beneficial (midrange) and you expect enough future rounds.

- If \(t \le r-2\),
- \(S_t\) is in midrange, e.g. \(0.25\cdot \text{capacity} \le S_t \le 0.6\cdot \text{capacity}\),
- and \(p_t \ge 0.8\),

then **Play C** (one-round “maintenance”), otherwise D.

Interpretation: you only “maintain the commons” when it is clearly a good investment and others are already doing most of the maintaining.

---

## Pseudocode (implementable logic)

```python
# state: S_t, t, history of opponent actions
# parameters: n, r, capacity
lambda_ = 0.7
p = 0.5
P = 0  # punishment counter

def action(t, S, last_opponent_actions):
    global p, P

    # update belief if not first round
    if last_opponent_actions is not None:
        k = count_C(last_opponent_actions)   # among n-1 opponents
        p = lambda_ * p + (1 - lambda_) * (k / (n-1))
        d = (n-1) - k
    else:
        d = 0

    S_low = 2*n

    # Endgame exploitation
    if t >= r-1:
        return "D"

    # If punishing, keep defecting
    if P > 0:
        P -= 1
        return "D"

    # Low stock: salvage
    if S <= S_low:
        return "D"

    # Trigger punishment if heavy defection observed last round
    if last_opponent_actions is not None:
        if d >= math.ceil((n-1)/2):
            P = 2
            return "D"

    # Early probing / test
    if t <= 2:
        return "C"

    # Exploit cooperative opponents at healthy stock
    if (p >= 0.7) and (S >= 0.5*capacity):
        return "D"

    # Limited extra investment if moderate cooperation and very healthy stock
    if (0.4 <= p < 0.7) and (S >= 0.6*capacity):
        return "C"  # but only this round by design; next round likely D unless p rises

    # Recovery maintenance only with very cooperative opponents in midrange stock
    if (p >= 0.8) and (0.25*capacity <= S <= 0.6*capacity):
        return "C"

    # Default: defect
    return "D"
```

To enforce “only one extra investment C” in the moderate zone, you can add a boolean flag `used_extra_C` that, once used, prevents that branch again unless `p` rises above 0.7 (in which case you’ll exploit with D anyway).

---

## Edge cases

1. **Round 1**: Play **C** (unless stock is already ≤ 2n, in which case D).  
   - This is an information-gathering probe and keeps the stock high if others are cooperative.
2. **Round 2**: Play **C** again (same caveat).  
   - Two data points reduce noise; still a small “investment horizon” cost.
3. **Last two rounds**: Always **D**.  
   - No future stock value worth investing in.
4. **Stock collapse** (S near 0): Always **D**.  
   - C gives tiny payoff and won’t rescue the resource without coordination.
5. **Opponents alternate / are noisy**: The smoothed estimate \(p_t\) plus the “heavy defection” trigger prevents overreacting to one-off defection, but still punishes sustained opportunism.

---

## Why this is robust in a tournament
- Against unconditional cooperators / nice strategies: you quickly move to **D** and harvest higher payoffs while they keep stock from collapsing.
- Against unconditional defectors: you stop wasting C after the probe and mostly **D**; you’re not worse than them after early rounds.
- Against reciprocators (Tit-for-Tat-like): the early Cs can establish a cooperative state; then you exploit carefully. If they punish your D, your strategy detects defection and goes to D anyway—preventing you from being bled by trying to “repair” trust late.
- Against mixed/learning agents: you don’t offer a stable “you can exploit me” pattern; your punishment and low willingness to invest makes you a difficult target, while still extracting value when the room is cooperative.

If you want, I can tune the thresholds (\(p^*\), punishment length, low-stock cutoff) analytically for specific \(n, r, \text{capacity}\) ranges, or provide a variant that explicitly simulates “if I play C vs D, what is expected next stock” for one-step lookahead.
'''

description_EXPLOITATIVE_120 = '''
Below is an exploitative, adaptive policy designed to (i) harvest high immediate payoffs when it’s safe, (ii) keep the resource productive when that increases *your* future take, and (iii) quickly punish over-extraction by others so you’re not the “sucker” sustaining the pool for them.

I’ll call it **Exploit-then-Sustain with Triggered Retaliation (ESTR)**.

---

## Key idea (what we exploit)

- Your one-round payoff is proportional to current stock \(S\). So you want **high \(S\)** in the rounds where you take a lot.
- If too many players defect, the pool can crash to 0 and stays there (since growth at 0 is 0). So when opponents are aggressive, “being nice” is pointless.
- If opponents are mostly cooperative, the pool often returns to (near) capacity; then you can **defect to take double** what cooperators take, while the pool still recovers.

So the strategy:
1) **Probe** if the table supports sustainability,
2) **Free-ride** (defect) when others are sustaining,
3) **Retaliate** quickly when others don’t,
4) **Conserve** only when needed to keep the pool high enough to keep exploiting later.

---

## Quantities computed from history/state

At round \(t\), before choosing action, you observe current stock \(S_t\) and past actions.

Let:
- \(d_{t-1}\) = number of opponents who defected in round \(t-1\).
- \(\hat{q}_{t-1} = d_{t-1}/(n-1)\) = observed opponent defection rate last round.
- \(k_{\text{crit}} = \lceil n/2 \rceil\).  
  Rationale: if total defectors \(\ge n/2\), then consumption \(\ge S\) and the pool collapses immediately (because each D takes \(S/n\), each C takes \(S/(2n)\); total consumption fraction is \(0.5 + 0.5\cdot(k/n)\), which hits 1 at \(k=n\), and already reaches high depletion fast as \(k\) grows). Practically, once about half are defecting, sustainability is very fragile.
- Stock safety thresholds:
  - \(S_{\text{low}} = 0.35 \cdot \text{capacity}\) (resource is getting dangerously low)
  - \(S_{\text{high}} = 0.80 \cdot \text{capacity}\) (resource is abundant; exploit more)

You can tune 0.35/0.80, but these work as robust heuristics.

---

## 1) Decision rules (C vs D)

### Rule A — Endgame cash-out
**If \(t = r\) (last round): play D.**  
No future stock to protect; take max.

### Rule B — Collapse mode (don’t be the sucker)
If either condition holds, **play D**:
- **Aggression trigger:** \(d_{t-1} \ge k_{\text{crit}}\) (many defectors recently), OR
- **Stock is already low:** \(S_t \le S_{\text{low}}\)

Interpretation: when others are extracting hard or the pool is near danger, conserving just subsidizes others (and may not save the pool anyway). You take what you can.

### Rule C — Exploit mode (free-ride on cooperators)
If:
- \(S_t \ge S_{\text{high}}\) **and**
- \(d_{t-1} \le 1\) (almost everyone cooperated last round),
then **play D**.

Interpretation: pool is high and opponents are mostly cooperative → defecting is the best exploitation: double payoff this round while the pool likely remains productive.

### Rule D — Sustain-to-exploit (maintain the golden goose)
Otherwise (i.e., mid-stock, mixed opponents), **play C** *unless* you are currently in a retaliation window (below).

Interpretation: if you can keep the stock from drifting down, you preserve future high-\(S\) rounds where you can defect for big gains. Cooperation here is instrumental, not altruistic.

---

## Retaliation window (how we punish to stop being exploited)

Maintain a variable `punish_timer`.

- If in round \(t-1\), **more than 1 opponent defected** (i.e., \(d_{t-1} \ge 2\)), then set:
  - `punish_timer = 2` (two rounds of retaliation)

While `punish_timer > 0`, **play D** and decrement it each round.

Why this works:
- It is **exploitative**: you refuse to keep the stock up for multiple defectors.
- It is **robust**: it doesn’t require identifying who defected; it responds to overall environment.
- It can still recover: after a short punishment burst, you return to “sustain-to-exploit” if conditions improve (stock high and defections low).

---

## 2) Edge cases

### First round (no history)
Round 1 is a probe. Use stock only (which starts at capacity).

**Round 1: play C.**
- This avoids being part of an immediate collapse if others defect heavily.
- It also reveals opponent type(s): if many still defect even when stock is maxed, they’re aggressive and you should switch into collapse/punish mode quickly.

(Exploitative justification: C in round 1 is a *test investment* to learn whether you can later profitably defect while others sustain.)

### Round 2 onward
Use the rules above based on \(d_{t-1}\), \(S_t\), and punish_timer.

### Last 2 rounds (stronger endgame)
In finitely repeated games, defection tends to unravel. Many AIs will “cash out” near the end.

Add:
- **If \(t \ge r-1\): play D unless \(S_t\) is extremely high AND last round had zero defections.**  
In practice, simplest: **play D in the final 2 rounds**.

This is more exploitative and avoids being the last-minute cooperator.

### If stock hits 0
If \(S_t = 0\), payoffs are 0 regardless. Still:
- **Play D** (default), but it doesn’t matter.

---

## 3) Why this is exploitative (explicitly)

- When opponents are cooperative and stock is high, you **systematically defect to take double** while they take half.
- You cooperate primarily as **resource maintenance** to preserve a high stock for future extraction—not to be fair.
- If multiple opponents defect, you **immediately switch to defection for multiple rounds**, preventing yourself from being exploited as the “stabilizer” of the pool.
- You **cash out at the end** (last round, and typically last two rounds).

---

## Pseudocode (implementation-ready)

```python
# parameters: n, r, capacity
S_low  = 0.35 * capacity
S_high = 0.80 * capacity
k_crit = math.ceil(n/2)

punish_timer = 0

def action(t, S_t, last_round_opponent_defectors):
    global punish_timer

    # Update punishment based on last round (not for t=1)
    if t > 1:
        d = last_round_opponent_defectors
        if d >= 2:
            punish_timer = max(punish_timer, 2)

    # Endgame cash-out
    if t == r:
        return "D"
    if t >= r-1:
        return "D"

    # If punishing, defect
    if punish_timer > 0:
        punish_timer -= 1
        return "D"

    # Collapse / danger conditions
    if t > 1:
        if last_round_opponent_defectors >= k_crit:
            return "D"
    if S_t <= S_low:
        return "D"

    # Exploit mode: high stock + mostly cooperative opponents
    if t > 1 and S_t >= S_high and last_round_opponent_defectors <= 1:
        return "D"

    # Otherwise: sustain-to-exploit
    return "C"
```

---

If you want an even more exploitative variant, you can lower the “mostly cooperative” threshold (e.g., defect whenever \(d_{t-1} \le 2\)) and increase punishment length (e.g., 3–4 rounds). That will win bigger against naive cooperators but can accelerate collapses against mixed populations.
'''

description_EXPLOITATIVE_121 = '''
## Strategy: **Regenerative Extortion with Stock Trigger (REST)**

Exploit the fact that (i) *D strictly dominates C in the current round given S*, but (ii) repeated play creates a stock externality. REST cooperates only when doing so is necessary to keep the resource productive, and otherwise defects to capture surplus. It also “taxes” opponents who defect by switching to persistent defection whenever opponents’ behavior implies you won’t be repaid via future stock.

The strategy uses only parameters, current stock, and observed history.

---

## Key idea (why it exploits)

- When the stock is healthy, you defect to take **2×** the cooperative share that round.
- You only cooperate when the stock is at risk of falling into a low-growth/low-payoff region, *because then even a selfish player benefits from rebuilding stock*.
- You punish defection enough to make opponents “pay” for harming the stock, but you *stop wasting cooperation* if opponents are not responsive (i.e., if they keep defecting anyway, you take what you can and let it collapse).

---

## Notation (computed each round)

At round \(t\), before acting:

- \(S_t\): current stock
- Let \(d_{t-1}\) be the number of opponents who defected in the previous round (from observed actions).
- Define opponent defection rate in last round:
  \[
  p_{t-1} = \frac{d_{t-1}}{n-1}
  \]
- Maintain a **“trust”** variable \(T_t \in [0,1]\) updated from history (details below).

Also define a **stock safety threshold** based on logistic growth structure:

- Logistic growth is highest at \(S = \frac{capacity}{2}\).
- Below that, stock tends to be fragile; above that, it’s resilient.

So we set:
- **Rebuild threshold**: \(S_{\text{low}} = 0.55 \cdot capacity\)
- **Harvest threshold**: \(S_{\text{high}} = 0.80 \cdot capacity\)

(These constants are parameter-only; they don’t assume anything about opponents.)

---

## 1) Decision rules: cooperate vs defect

### Rule A — Endgame exploitation (last round)
- If \(t = r\): **Defect**.

Reason: no future stock value to preserve.

---

### Rule B — Immediate collapse prevention (critical stock)
If \(S_t \le 0.35 \cdot capacity\):
- Cooperate **only if** you estimate it’s still salvageable, otherwise defect.

Concretely:
- If \(T_t \ge 0.5\): **Cooperate** (try to rebuild; you expect others may follow/reciprocate).
- Else: **Defect** (take remaining value; don’t subsidize others).

This is exploitative: you only “invest” when you expect to be repaid via later high-stock rounds you can harvest.

---

### Rule C — Stock rebuilding mode (low stock, not critical)
If \(0.35 \cdot capacity < S_t < S_{\text{low}}\):
- **Cooperate** if opponents were not mostly defecting recently.
- Else **Defect**.

Operationally:
- If \(p_{t-1} \le 0.5\) OR \(T_t \ge 0.6\): **Cooperate**
- Else: **Defect**

Interpretation: cooperate to restore stock when there is evidence the group isn’t purely predatory; otherwise exploit immediately.

---

### Rule D — Controlled harvesting (mid stock)
If \(S_{\text{low}} \le S_t < S_{\text{high}}\):
- Default to **Defect** (harvest), unless you need to “buy” cooperation to keep stock from drifting downward due to opponent defection.

Operational:
- If \(p_{t-1} \ge 0.7\): **Defect** (everyone’s predatory—race to extract)
- Else:
  - If \(T_t \ge 0.7\): play a **mixed extortion** rule:
    - Cooperate with probability \(q = 0.25\)
    - Defect with probability \(1-q\)
  - If \(T_t < 0.7\): **Defect**

This is exploitative because even in “good” groups you mostly defect; occasional C is just an investment to keep the pool productive.

(If randomness is undesirable in implementation, replace with: “cooperate every 4th time in this region when trust is high.”)

---

### Rule E — Full exploitation (high stock)
If \(S_t \ge S_{\text{high}}\):
- **Defect**, always (except possibly if you’re in a short punishment cooldown—see below).

Reason: the pool is robust; take maximum immediate payoff.

---

## Punishment / exploitation layer (overrides some of the above)

REST uses a *stateful retaliation* that punishes defect-heavy rounds by switching to multi-round defection. This prevents being the “sucker investor”.

### Trigger: “Defection shock”
After observing round \(t-1\):
- If \(p_{t-1} \ge 0.5\) (at least half of opponents defected), enter **Punish Mode** for \(L\) rounds, where:
  \[
  L = 1 + \lfloor 2 \cdot p_{t-1} \rfloor
  \]
So:
- if just over half defected → \(L=2\)
- if nearly all defected → \(L=3\)

**Punish Mode action**: always **Defect** (unless \(S\) is critical and trust is still high—see Rule B).

This is exploitative: it makes cooperation costly for others (they lose the long-run regenerative benefit unless they reduce defection), while you still capture the high one-shot payoffs whenever stock allows.

---

## 2) Edge cases

### First round
Round 1 is where naive cooperators reveal themselves. Exploit them.

- If \(r\) is small (e.g., \(r \le 3\)): **Defect** immediately (not enough time for stock investment to pay).
- Else:
  - If \(capacity \ge 4n\): **Defect** (stock is big enough to tolerate early harvesting).
  - Otherwise: **Cooperate** once to test if the table is cooperative (only if capacity is tight).

This is designed to win against “nice” strategies while not suiciding the pool in fragile settings.

### Last 2 rounds
- Round \(r\): **Defect**
- Round \(r-1\): **Defect** unless stock is *very low* and you believe one cooperation boosts your own payoff in \(r\) by keeping \(S_r\) from being near-zero.
Practical rule:
- If \(S_{r-1} \le 0.25\cdot capacity\) and \(T_{r-1}\ge 0.7\): **Cooperate** in \(r-1\), else **Defect**.

### Stock at/near zero
If \(S_t\) is extremely small (say \(S_t < 10^{-6}\)):
- Your action barely matters; growth from ~0 is ~0.
- **Defect** (no point investing).

### If stock stays pinned at capacity (everyone mostly C)
- You still mostly **Defect** (Rules D/E), extracting double each round while others maintain the pool.

---

## 3) “Exploitative mindset” made explicit

REST is not trying to be fair or mutually cooperative. It is trying to:

1. **Harvest whenever safe** (stock high or opponents predatory).
2. **Invest minimally** only when it increases expected future harvest.
3. **Punish defection** to avoid subsidizing others and to coerce restraint in opponents who are sensitive to long-run payoffs.
4. **Switch to extraction mode** when opponents show they won’t reciprocate.

---

## Trust update (simple and robust)

Initialize: \(T_1 = 0.6\)

After each round \(t\), update using opponent defection rate \(p_t\):
\[
T_{t+1} = \text{clip}\Big(0.85\,T_t + 0.15\,(1 - p_t)\Big,\,0,\,1\Big)
\]

- Many opponents defect → trust decays.
- Many cooperate → trust rises slowly.
- This prevents being whipsawed by noise and makes the strategy robust across diverse opponents.

---

## Pseudocode (high-level)

```pseudo
params: n, r, capacity
constants:
  S_low = 0.55 * capacity
  S_high = 0.80 * capacity
  S_crit = 0.35 * capacity

state variables:
  T = 0.6
  punish = 0   # remaining punishment rounds

for t in 1..r:
  observe S_t

  if t == r:
     action = D
     play; break

  if t == 1:
     if r <= 3: action = D
     else if capacity >= 4*n: action = D
     else action = C
     play
     observe opponents; update T; set punish if needed
     continue

  # punishment countdown
  if punish > 0:
     if S_t <= S_crit and T >= 0.5:
         action = C
     else:
         action = D
     punish -= 1
     play
     observe opponents; update T; set punish if needed
     continue

  # main policy by stock region
  if S_t <= S_crit:
     action = (T >= 0.5) ? C : D

  else if S_t < S_low:
     action = (p_{t-1} <= 0.5 or T >= 0.6) ? C : D

  else if S_t < S_high:
     if p_{t-1} >= 0.7: action = D
     else if T >= 0.7:
        action = (random() < 0.25) ? C : D
     else action = D

  else:
     action = D

  play
  observe opponents actions -> compute p_t
  T = clip(0.85*T + 0.15*(1 - p_t), 0, 1)

  if p_t >= 0.5:
     punish = 1 + floor(2 * p_t)
```

---

If you want, I can also provide (a) a fully deterministic version (no randomness), and (b) a tuned set of thresholds optimized for specific \(n, capacity, r\) regimes (small stock vs huge stock; short vs long horizon).
'''

description_EXPLOITATIVE_122 = '''
## Strategy: **Gated Opportunist (GO)**  
Exploit cooperators by taking the larger share when the pool is healthy, but *immediately* switch to preservation mode when opponents’ behavior risks a crash. The core idea is:

- **Defect whenever it’s safe** (stock will remain high next round even if you defect).
- **Cooperate only as a “gate”** to keep the resource in the high-stock regime.
- **Punish greed fast** (don’t subsidize defectors when stock is fragile), but **forgive quickly** once conditions are safe again (so you can resume exploitation).

This strategy depends only on parameters \((n,r,capacity)\), current stock \(S_t\), and history (past actions to estimate opponents’ extraction level).

---

# 1) Decision Rules (Cooperate vs Defect)

### Key quantities each round \(t\)

Let:
- \(S\) = current stock at start of round.
- Observe from last round \(t-1\) (if \(t>1\)): number of defections \(k_{t-1}\).

Define the *implied total extraction share* last round:
\[
e_{t-1} = \frac{k_{t-1}}{n} + \frac{n-k_{t-1}}{2n} = \frac{1}{2} + \frac{k_{t-1}}{2n}
\]
So last round total consumption was \(S_{t-1} \cdot e_{t-1}\), and remaining fraction was:
\[
q_{t-1} = 1 - e_{t-1} = \frac{1}{2} - \frac{k_{t-1}}{2n}
\]
- If \(k=n\), \(q=0\) (pool is fully extracted).
- If \(k=0\), \(q=1/2\).

### Stock safety thresholds (parameter-based)

The growth function is logistic: after remaining stock \(R\), new stock is:
\[
S' = \min\left(R + 2R\left(1-\frac{R}{capacity}\right),\ capacity\right)
\]

Important regime: if \(R \ge capacity/2\), then \(R + 2R(1-R/capacity)\ge capacity\), so the pool refills to **capacity** in one step.

So we want to keep **post-consumption remaining stock** \(R\) at least \(capacity/2\) whenever possible.

### GO’s choice rule each round

**Rule A — Endgame exploitation (last round):**  
- If \(t=r\): **Defect**.

**Rule B — If stock is already fragile: preserve, don’t subsidize crash:**  
- If \(S < capacity/2\): **Cooperate** *unless* you infer opponents are already in “all-defect / collapse mode” (details below).

**Rule C — If stock is healthy: exploit unless you’re about to push it below the refill threshold:**  
Compute a conservative “risk estimate” of total extraction this round based on history:
- Let \(\hat{k}\) = predicted number of defectors among others.
  - If \(t=1\): set \(\hat{k}=n-1\) (pessimistic prior).
  - Else: \(\hat{k} = k_{t-1}\) (simple and robust).

Now evaluate two “what if” remaining stocks:
- If you **cooperate**, total extraction fraction estimated:
  \[
  e_C = \frac{1}{2} + \frac{\hat{k}}{2n}
  \Rightarrow R_C = S(1-e_C)
  \]
- If you **defect**, you add extra \(S/(2n)\) extraction relative to cooperating, i.e. increase total extraction fraction by \(1/(2n)\):
  \[
  e_D = e_C + \frac{1}{2n}
  \Rightarrow R_D = S(1-e_D)
  \]

**Decision:**
- If \(R_D \ge capacity/2\): **Defect** (safe to exploit; pool refills).
- Else if \(R_C \ge capacity/2\): **Cooperate** (your restraint is pivotal to keep refill-to-capacity).
- Else (even full restraint won’t keep it above threshold): **Defect** (take value now; pool is heading into low-stock regime anyway).

### Rule D — Anti-sucker “collapse detection”
When \(S < capacity/2\), cooperating can be pure charity if others keep defecting.

Maintain a short “greed streak” counter:
- `greed_streak` increments when \(k_{t-1} \ge \lceil n/2 \rceil\) (majority defect)  
- resets to 0 otherwise

Then:
- If \(S < capacity/2\) **and** `greed_streak ≥ 2`: **Defect** (stop feeding defectors; grab what remains).
- Otherwise (stock low but not clearly doomed): **Cooperate** (attempt recovery).

This is exploitative: you only invest in recovery if there’s evidence it won’t be immediately stolen.

---

# 2) Edge Cases

### Round 1
- Default: **Defect if safe**, else cooperate.
- With no history, use pessimistic prediction \(\hat{k}=n-1\) to avoid being the only cooperator who gets farmed.

Concretely:
- Compute \(R_D\) assuming everyone else defects.  
If \(R_D \ge capacity/2\): defect.  
Else if \(R_C \ge capacity/2\): cooperate.  
Else defect.

### Last round (t = r)
- **Always defect.**
No future stock to protect; pure one-shot incentive.

### Penultimate rounds / finite-horizon unravelling
GO already becomes more exploitative as \(t\to r\) automatically because the “future value” of keeping stock high shrinks. If you want an explicit tweak:
- For the last \(L = \max(1,\lfloor r/10\rfloor)\) rounds, treat the refill threshold as stricter for cooperation:
  - Only cooperate if it keeps \(R_C \ge capacity/2\) **and** \(k_{t-1}\le \lfloor n/3\rfloor\) (strong evidence of restraint).
Otherwise defect. This increases endgame extraction against naive cooperators.

### Stock at/near zero
- If \(S \approx 0\), actions barely matter; defecting weakly dominates in payoff. GO will typically defect due to the collapse detection / “can’t save it” branch.

---

# 3) Why this is exploitative (tournament mindset)

1. **You defect whenever the pool will refill anyway.**  
   That captures the high immediate payoff \(S/n\) while keeping the state at capacity (best of both worlds).

2. **You only cooperate when your cooperation is pivotal to keep the system in the “refill-to-capacity” region.**  
   That means your cooperation is an *investment with immediate strategic ROI*, not altruism.

3. **You stop cooperating quickly when opponents demonstrate majority-defection behavior in the fragile regime.**  
   This prevents being milked by strategies that defect persistently while relying on others to rebuild the stock.

4. **You exploit forgiving/cooperative populations.**  
   In groups with many cooperators, GO defects most rounds while keeping the stock high, outperforming unconditional cooperators.

---

# Pseudocode (implementation-ready)

```python
def action_GO(t, r, n, capacity, S, history):
    # history contains previous round actions of all players (including you)
    # greed_streak tracked externally or recomputed from recent rounds

    if t == r:
        return "D"

    # Predict others' defections
    if t == 1:
        k_hat = n - 1
        greed_streak = 0
    else:
        last_actions = history[-1]          # list length n
        k_last = count_D(last_actions)
        k_hat = k_last
        greed_streak = compute_greed_streak(history, n)  # e.g., consecutive rounds with k>=ceil(n/2)

    # Helper: estimated remaining stock given predicted defections among all players
    # Total extraction fraction when you cooperate:
    e_C = 0.5 + (k_hat / (2*n))
    # If you defect, add +1/(2n) extraction fraction:
    e_D = e_C + (1/(2*n))

    R_C = S * (1 - e_C)
    R_D = S * (1 - e_D)

    refill_threshold = capacity / 2

    # Collapse detection when stock is low
    if S < refill_threshold:
        if greed_streak >= 2:
            return "D"
        # If even cooperation won't reach threshold, take what you can
        if R_C < refill_threshold:
            return "D"
        return "C"

    # Stock healthy: exploit if safe
    if R_D >= refill_threshold:
        return "D"
    elif R_C >= refill_threshold:
        return "C"
    else:
        return "D"
```

---

If you tell me typical tournament settings (ranges for \(n, r, capacity\)), I can tune the prediction module (e.g., use moving average of defections, bias toward worst-case when variance is high) to improve robustness without sacrificing exploitiveness.
'''

description_EXPLOITATIVE_123 = '''
### Strategy: **Adaptive Harvester (AH)**  
Goal: **Extract as much as possible while opponents preserve the stock**, and **never be the “sucker”** when others are defecting. The strategy uses the stock dynamics to (i) keep the resource near a high-growth region when others are cooperative, then (ii) **harvest harder than the group** when possible, and (iii) **switch to full defection** when the stock is being driven down anyway.

---

## Key idea (what makes it exploitative)
- If others mostly **C**, stock tends to rebound; you can often **D** repeatedly to earn double per round (S/n vs S/(2n)) while still keeping the stock viable.
- If others start **D** enough to threaten collapse, you immediately **D** as well to avoid subsidizing them.
- You “forgive” only when the stock is demonstrably recovering *and* opponents’ recent behavior suggests they’re not in a defection phase.

---

## Quantities computed each round
At round \(t\), observe current stock \(S_t\) and past actions.

Let \(D_{t-1}\) be number of opponents who defected last round (from history). Define:
- Opponent defection rate last round:  
  \[
  q_{t-1}=\frac{D_{t-1}}{n-1}
  \]
- “Safe stock” threshold (conservative):  
  \[
  S_{\text{safe}} = 0.6 \cdot \text{capacity}
  \]
- “Low stock” threshold:  
  \[
  S_{\text{low}} = 0.25 \cdot \text{capacity}
  \]
- Short memory (robust, avoids overfitting noise): keep last \(m=3\) rounds of opponent defection rates and stock changes.

Also compute last round stock change: \(\Delta S_{t-1}=S_t - S_{t-1}\).

---

## 1) Decision rules (C vs D)

### Rule A — Endgame liquidation
- **If \(t = r\): play D.**  
  No future to protect; always harvest max.

- **If \(t = r-1\): play D unless the stock is extremely low** (see Rule C).  
  Rationale: second-to-last round still heavily favors taking; the only reason not to is if taking now collapses an otherwise recoverable last-round payoff. In practice, you still usually want D.

### Rule B — Punish defection quickly (anti-sucker)
If opponents show meaningful defection, do not cooperate:
- **If \(q_{t-1} \ge 0.34\)** (roughly at least 1/3 of opponents defected last round), **play D**.
- **If in the last \(m\) rounds, average defection rate \(\bar q \ge 0.25\)**, **play D**.
This makes you hard to exploit: any sustained defection triggers immediate harvesting.

### Rule C — Stock protection only when necessary (so you can keep exploiting later)
If the stock is at risk of collapsing, cooperate to keep the “golden goose” alive—*but only when cooperation plausibly restores future exploitation*:
- **If \(S_t \le S_{\text{low}}\)**:
  - If opponents are mostly cooperating (e.g., \(q_{t-1} \le 0.2\)) **play C** to stabilize and allow regrowth.
  - Otherwise **play D** (resource is being killed anyway; take what you can).

### Rule D — Default exploit mode (harvest when it’s safe)
When the resource is healthy and opponents are not defecting much:
- **If \(S_t \ge S_{\text{safe}}\)** and \(q_{t-1} \le 0.2\): **play D**.  
  This is the core exploit: you defect while they maintain sustainability.

### Rule E — “Test and exploit” in the middle region
If stock is neither very high nor critically low:
- If opponents are very cooperative (e.g., \(q_{t-1} \le 0.1\)) and stock is not declining (\(\Delta S_{t-1}\ge 0\)): **play D** (they’re sustaining it).
- Otherwise: **play C** for one round to see if the system recovers; if it doesn’t recover, revert to D.

This prevents you from accidentally driving stock down in fragile states while still grabbing extra when the table is soft.

---

## 2) Edge cases

### First round (no history)
Start by probing for a cooperative environment that you can exploit.
- **Round 1: play D** *unless capacity is barely above the minimum* (i.e., capacity close to \(2n\)).  
  With typical capacity, a first-round D tests whether others tolerate exploitation and you get immediate upside. If you see many Ds, you continue D. If you see mostly Cs, you’ve identified exploitable cooperators.

(If you want a slightly safer variant: play C in round 1 only when capacity is low and the game is long, because early collapse is more likely.)

### After a collapse (stock near 0)
- If \(S_t\) is extremely low (e.g., \(S_t < 0.05\cdot capacity\)), your immediate payoff is tiny either way.  
  - If opponents are cooperating, **play C** to enable rebound and later exploitation.
  - If opponents are defecting, **play D** (no point investing).

### Last two rounds
- **Always D in round r.**
- **In round r−1, D** unless \(S_t\) is so low that cooperating would likely increase \(S_{r}\) enough to outweigh losing the factor-of-2 in round \(r-1\). Practically, this means:
  - If \(S_t \le S_{\text{low}}\) and opponents are cooperative: consider **C** at \(r-1\); otherwise **D**.

---

## 3) Pseudocode (implementable)

```pseudo
params: n, r, capacity
constants:
  m = 3
  S_safe = 0.60 * capacity
  S_low  = 0.25 * capacity
  punish_now = 0.34
  punish_avg = 0.25
  coop_ok = 0.20
  coop_strong = 0.10

on round t with stock S_t and history:

if t == r:
  return D

if t == 1:
  if capacity <= 2.5*n and r is large: return C
  else return D

# compute q_{t-1}
q_last = (# opponents played D in round t-1) / (n-1)

# compute avg defection last m rounds (or fewer if early)
q_avg = average(defection_rate over last min(m, t-1) rounds)

# stock trend (if t>=2)
deltaS = S_t - S_{t-1}

# Endgame bias
if t == r-1:
  if S_t <= S_low and q_last <= coop_ok:
    return C
  else:
    return D

# Punish defection
if q_last >= punish_now or q_avg >= punish_avg:
  return D

# Critical stock handling
if S_t <= S_low:
  if q_last <= coop_ok:
    return C
  else:
    return D

# Exploit when safe
if S_t >= S_safe and q_last <= coop_ok:
  return D

# Middle region: test/exploit
if q_last <= coop_strong and deltaS >= 0:
  return D
else:
  return C
```

---

## Why this is robust in a tournament
- **Against unconditional cooperators / naive sustainers:** you defect most rounds while they keep stock high; you outperform them consistently.
- **Against grim-trigger / punishers:** you’ll trigger punishment early (because you probe with D), but once they defect you defect too—minimizing losses and preventing being milked.
- **Against always-defect / aggressive types:** you defect quickly and stay there, ensuring you’re not donating.
- **Against adaptive “nice” strategies:** the stock-based safeguards keep the resource from crashing when cooperation is useful for *your* future harvesting.

If you want, I can also provide a “more aggressive” and a “more stealthy” parameterization (threshold tweaks) depending on whether tournaments tend to reward short-run extraction or longer-run stock management.
'''

description_EXPLOITATIVE_124 = '''
## Strategy: **Throttle & Squeeze (T&S)**  
Exploit the stock externality by (i) keeping the resource in the “high-yield” region when others are cooperative or stock-sensitive, and (ii) grabbing maximal short-run payoff whenever opponents show willingness to overconsume (or when the horizon makes future irrelevant). The strategy is intentionally asymmetric: it cooperates only when that increases *your* discounted future take, and otherwise defects.

Key idea: your action changes total consumption by  
- If you play **C**: you take \(S/(2n)\)  
- If you play **D**: you take \(S/n\)  
So **D always dominates within the round**, but may collapse future stock. Exploitation = defect when the group is sustaining stock, cooperate only as a “maintenance move” to keep the stock from crashing (so you can defect more later).

---

# 1) Decision rules (C vs D)

### Track from history (after each round t)
Let \(S_t\) be the stock at start of round \(t\). You can infer others’ total consumption from the observed post-action stock before growth if your implementation tracks it; but you don’t need to—use only observed actions:

- Let \(d_{t-1}\) = number of opponents who defected in round \(t-1\).
- Let \(D\_rate\) = exponentially smoothed defect rate of opponents (memory).  
  Example: \(D\_rate \leftarrow 0.7\cdot D\_rate + 0.3\cdot(d_{t-1}/(n-1))\).
- Let \(S\_trend\) = sign of stock change over last 2–3 rounds (rising / stable / falling), from observed \(S_t\).

### Stock thresholds (parameter-only)
Use two thresholds that depend only on capacity (no opponent assumptions):
- **Safe high stock**: \(S_t \ge 0.8\cdot capacity\)
- **Danger zone**: \(S_t \le 0.35\cdot capacity\)

These are chosen because logistic growth is strong in the middle, and collapse risk is high when stock is low and opponents defect.

### Core policy
You choose **D by default**, but switch to **C** to “repair” stock only when repair is likely to pay back (i.e., opponents aren’t overwhelmingly defecting) or when you need to keep the resource alive for later squeezing.

**Rule A — Endgame squeeze (exploit horizon):**  
- If \(t = r\): play **D**.  
- If \(t = r-1\): play **D** unless \(S_t\) is in the danger zone *and* opponents were mostly cooperating (you may play **C** once to keep last-round stock nonzero, but only if that likely increases your last-round take).

**Rule B — Exploit cooperators (harvest at high stock):**  
If \(S_t \ge 0.8\cdot capacity\) and opponents are not heavily defecting:
- If \(D\_rate \le 0.4\): play **D**.  
Rationale: when stock is high and others cooperate enough to sustain it, you defect to take double.

**Rule C — Punish defect-heavy groups (don’t subsidize):**  
If opponents are defect-heavy, never “repair” for them:
- If \(D\_rate \ge 0.6\): play **D** always.  
Rationale: your cooperation just slows collapse while others keep extracting; better to grab now.

**Rule D — Maintenance mode (selective cooperation to preserve future exploitation):**  
If stock is low enough that collapse threatens *and* opponents are not too defect-heavy, cooperate to stabilize:
- If \(S_t \le 0.35\cdot capacity\) **and** \(D\_rate \le 0.6\): play **C**.  
- Else if \(S_t\) is falling for 2 consecutive rounds and \(D\_rate \le 0.5\): play **C**.  
Rationale: this is not “nice”—it’s investment. You cooperate only when there’s a decent chance others aren’t going to immediately nullify it.

**Rule E — Probe & pivot (early rounds adaptation):**  
Round 1 is used to classify the group:
- Round 1: play **D** (immediate advantage; also tests whether others punish or accommodate).
- Round 2 onward: follow Rules A–D.

---

# 2) Edge cases / special handling

### First round
**Always D.**  
You get max payoff and learn opponent type distribution immediately (how many defect despite full stock). This is valuable because the game is highly path dependent.

### Very small r (short horizon)
If \(r \le 3\):  
- Play **D every round**. There isn’t enough time for “maintenance” cooperation to repay.

### Last two rounds
- **Round r:** always **D**.  
- **Round r−1:** default **D**. Only play **C** if both conditions hold:
  1) \(S_t\) is so low that if you defect now you expect near-zero stock next round, and  
  2) opponents’ last-round behavior suggests they won’t all defect (e.g., \(D\_rate \le 0.4\)).  
This is a purely selfish “keep the pool alive for one more harvest” move.

### Stock at/near zero
If \(S_t \approx 0\): action barely matters for immediate payoff. Still:
- If \(D\_rate \ge 0.6\): **D** (no reason to rebuild for them).
- Else: **C** (try to restart growth if the group seems salvageable).

### Capacity extremely large relative to n
Even if capacity is huge, the relevant issue is *fraction of capacity*, so the same thresholds work.

---

# 3) Why this is exploitative (and robust)

### Exploitative posture
- **Defaults to defect** to extract double whenever possible.
- **Cooperation is conditional and instrumental**, used only to prevent a crash that would reduce *your* future extraction.
- **Never “rewards” defectors**: if others defect often, you do not spend moves repairing the commons—you accelerate extraction.

### Robustness against varied opponents
- Against **cooperative / sustainability** strategies: you repeatedly defect at high stock and only occasionally cooperate to keep stock from collapsing, achieving higher cumulative payoffs than pure cooperators.
- Against **always-defect / aggressive** strategies: you also defect (no wasted cooperation), capturing as much as possible before collapse.
- Against **trigger/punisher** types: your early defection may provoke them; the maintenance rule can shift to cooperation when stock is endangered *and* they appear responsive (lower \(D\_rate\)), allowing partial recovery if they return to C.
- Against **noisy / stochastic** agents: smoothing via \(D\_rate\) prevents overreacting to one-off defections.

---

## Pseudocode sketch

```text
Initialize D_rate = 0.5
For t in 1..r:
  observe current stock S

  if r <= 3:
      action = D
  else if t == r:
      action = D
  else if t == 1:
      action = D
  else:
      # classify environment
      if D_rate >= 0.6:
          action = D
      else:
          if S >= 0.8*capacity:
              action = D   # harvest when plentiful
          else if S <= 0.35*capacity:
              action = C   # maintenance only if group not defect-heavy
          else if stock_falling_two_rounds and D_rate <= 0.5:
              action = C
          else:
              action = D

  play action
  after round, update D_rate from observed opponent defections
```

If you want, I can also provide a tighter “implementation-ready” version that specifies exactly how to compute `stock_falling_two_rounds` from the observable stock sequence given the growth step.
'''

description_EXPLOITATIVE_125 = '''
### Strategy: **Harvest–Test–Squeeze (HTS)**  
Exploit by (i) **free-riding when others keep the stock healthy**, (ii) **punishing quickly when they don’t**, and (iii) **never sacrificing the endgame**. The key idea is: *cooperate only when it is necessary to keep the resource productive, and defect whenever opponents’ behavior suggests you can extract more without collapsing the stock.*

---

## Key quantities you can compute from history
At round \(t\), before acting, you know current stock \(S_t\) and last round’s actions.

**1) Last round counts**
- \(c_{t-1}\): number of cooperators among opponents  
- \(d_{t-1} = (n-1) - c_{t-1}\)

**2) “Safe stock” threshold**  
With all players cooperating, stock returns to capacity if it starts at capacity, and generally stays high. With defection, stock can crash. A simple operational threshold:

- **High stock:** \(S_t \ge 0.8 \cdot \text{capacity}\)  
- **Medium stock:** \(0.4\cdot \text{capacity} \le S_t < 0.8\cdot \text{capacity}\)  
- **Low stock:** \(S_t < 0.4\cdot \text{capacity}\)

(These thresholds are deliberately coarse to be robust.)

**3) Opponent “cooperativeness estimate”**  
Track over a rolling window \(W\) (e.g., \(W=\min(10,t-1)\)):

\[
\hat{p}_C = \frac{\text{# opponent C actions observed in last } W \text{ rounds}}{W\cdot (n-1)}
\]

This is not to be “nice”—it’s to decide when you can safely exploit.

---

## Decision rules (when to C vs D)

### Rule 0: Endgame squeeze (exploit the last round)
- **If \(t = r\): play D.**  
There is no future stock value to protect.

### Rule 1: First round (probe for exploitable types)
- **If \(t = 1\): play D.**  
You immediately test whether opponents will (a) keep cooperating anyway (ideal to exploit), (b) punish, or (c) also defect (resource collapses; you then switch to survival mode).

### Rule 2: Maintain exploitable high-stock regimes (free-ride when safe)
If stock is high, you want to defect *unless* doing so risks triggering a collapse/punishment spiral.

- **If \(S_t \ge 0.8\cdot capacity\):**
  - If \(\hat{p}_C \ge 0.6\): **play D** (they are generally cooperative; harvest).
  - Else (they’re mixed/hostile): **play C** *only if* last round had heavy defection (see Rule 3), otherwise **play D**.

Rationale: high stock is where defection pays most and the system can often absorb some defection.

### Rule 3: Anti-collapse “survival mode” (cooperate only to rebuild the resource)
When stock is threatened, cooperation can be privately rational *as an investment* to restore future extraction.

- **If \(S_t < 0.4\cdot capacity\):**
  - **Play C** unless \(t\) is very near the end (see Rule 5).
  
This is not altruism: it’s to prevent the stock from staying near zero where both C and D yield tiny payoffs.

### Rule 4: Targeted punishment to discipline opponents (but keep it cheap)
You punish only when it increases your long-run take by deterring others from defecting. Use a “one-step harshness” approach:

- Define **defection pressure last round**:  
  \[
  \text{pressure} = \frac{d_{t-1}}{n-1}
  \]
- If \(S_t\) is medium and pressure is high, unpunished defectors will keep stock from recovering.

**If \(0.4\cdot capacity \le S_t < 0.8\cdot capacity\):**
- If \(\text{pressure} \ge 0.5\): **play D** (punish by refusing to be the sucker; do not invest alone).
- Else (\(\text{pressure} < 0.5\)): **play C** (rebuild while others are mostly cooperating).

This rule prevents you from being exploited by a majority-defect environment while still enabling recovery when most are cooperative.

### Rule 5: Late-game liquidation (stop investing when it won’t pay back)
Even if cooperation could rebuild stock, it may not be worth it with too few rounds left.

Let remaining rounds \(R = r - t + 1\). If you’re in low/medium stock but near the end, cash out.

- **If \(R \le 2\): play D** (regardless of stock and history).

---

## Full pseudocode (compact)
```pseudo
parameters:
  HIGH = 0.8 * capacity
  LOW  = 0.4 * capacity

state:
  rolling window W = min(10, t-1)
  pC_hat = opponent cooperation rate over last W rounds
  pressure = fraction of opponents who defected last round (if t>1 else 0)

function act(t, S_t, history):
  R = r - t + 1

  if t == r: return D
  if t == 1: return D
  if R <= 2: return D

  if S_t < LOW:
    return C

  if S_t >= HIGH:
    if pC_hat >= 0.6:
      return D
    else:
      # if opponents are nasty, avoid being the lone investor
      if (t > 1 and pressure >= 0.5): return D
      else: return D  # default exploit in high stock anyway

  # medium stock
  if pressure >= 0.5:
    return D
  else:
    return C
```

(Notice this intentionally defaults to D in high stock; cooperation is reserved mainly for recovery.)

---

## Edge cases & robustness
1. **Everyone defects early (stock collapses):**  
   You shift into **survival mode (C)** when stock is low to regrow it, but stop investing near the end. If others never cooperate, you’ll at least match them and avoid being the only contributor in medium stock (Rule 4).

2. **Everyone cooperates (“nice” populations):**  
   You **defect almost always** after the initial probe, extracting the higher per-round payoff while the resource remains healthy due to others’ cooperation.

3. **Tit-for-tat / retaliatory types:**  
   Your opening D may trigger punishment. If that drives stock down, you cooperate in low stock to restore future value; in medium stock with high defection pressure you refuse to be exploited. This tends to settle into either (a) opponents resume cooperation and you re-squeeze at high stock, or (b) mutual defection where you lose little by not “investing”.

4. **Mixed populations (some coop, some defect):**  
   The pressure rule is meant to avoid subsidizing defect-heavy groups. You cooperate only when a majority is already cooperating and the stock is not dangerously high (where you’d rather harvest).

5. **Short games:**  
   The “liquidation” rule (last 2 rounds always D, last round always D) prevents wasting moves on rebuilding when there’s no time to recoup.

---

## Why this is exploitative
- **Default posture is extraction (D)** whenever the ecosystem can tolerate it or when future doesn’t matter.
- **Cooperation is purely instrumental**: only to prevent collapse that would reduce *your* future harvest.
- **No forgiveness norms, no fairness constraints**: you free-ride on cooperative opponents, and you don’t “reward” cooperation beyond what’s necessary to keep the stock productive for later squeezing.

If you want, I can also propose a more aggressive variant that occasionally “bluffs” with short cooperative streaks to re-induce cooperation in retaliatory strategies, then returns to defection once stock rebounds.
'''

description_EXPLOITATIVE_126 = '''
Below is an **exploitative “harvest–threat” strategy** that tries to (i) extract high payoffs quickly, (ii) switch into a *credible* punishment mode that makes opponents’ defection unprofitable going forward, and (iii) return to cooperation only when it is clearly in your interest. It uses only parameters, current stock, and full history.

---

## Intuition (why this can exploit)

- **Defecting (D)** doubles your one-round payoff vs cooperating (C), *given the same stock S*:  
  \( \pi(D)=S/n \) vs \( \pi(C)=S/(2n) \).
- But D also **drains the stock faster**, reducing future payoffs for everyone.
- The stock growth is logistic, so there is a **“safe zone”** where the resource replenishes strongly (around moderate stock), and a **danger zone** where further depletion risks collapse.

This strategy tries to:
1. **Cooperate while the stock is healthy** to keep the “golden goose” alive.
2. **Defect opportunistically when others are cooperating** (harvest phase).
3. **Punish quickly and hard** when others defect (to deter repeated exploitation of you).
4. **Only forgive when the system is recoverable** and opponents have “earned” it by cooperating.

---

## Key derived quantities (computed each round)

Let:
- \(S_t\) = stock at start of round t.
- From history, infer in previous round \(t-1\):
  - \(k_{t-1}\) = number of defectors among opponents (excluding you). (You observe actions.)
- Define two stock thresholds:
  - **Collapse threshold**: \(S_{\text{low}} = 2n\). (Near minimum where payoffs are tiny and recovery can be fragile.)
  - **Harvest threshold**: \(S_{\text{high}} = 0.8 \cdot \text{capacity}\). (Stock “rich enough” to safely skim.)

Define a simple “opponent cooperativeness score” over a short window:
- Window length \(w = \min(10, t-1)\).
- \( \text{DefRate} = \frac{\#\text{opponent defections in last }w\text{ rounds}}{w\cdot(n-1)} \).

This makes the strategy robust to noise and mixed populations.

---

## Strategy: Exploitative Harvest–Threat (EHT)

### Decision rules (C vs D)

At each round t:

#### Rule 0 — Last round grab
- If \(t = r\): **Play D**.
  - Endgame: no future stock to protect. Always exploit.

#### Rule 1 — Emergency conservation (avoid collapse you can’t profit from)
- If \(S_t \le S_{\text{low}}\): **Play C**.
  - When stock is near the floor, defecting yields little and can keep the system in a low-payoff trap. You want recovery so you can later harvest.

#### Rule 2 — Immediate retaliation (credible threat)
- If in the previous round any opponent defected (i.e., \(k_{t-1} \ge 1\)) AND \(S_t > S_{\text{low}}\):  
  **Enter Punishment Mode** for \(P\) rounds, where:
  - \(P = 2 + \lceil 2\cdot \text{DefRate}\cdot r/(r+5)\rceil\) (min 2, max ~4–5)
  - In Punishment Mode: **Play D** each round (unless Rule 1 triggers).
- Rationale: one defection gets met with sharp response, discouraging opportunists. Punishment length scales up when opponents are generally defect-heavy.

#### Rule 3 — Exploit cooperative opponents (harvest)
If not in Punishment Mode and \(S_t \ge S_{\text{high}}\):

- If opponents have been mostly cooperative recently: \(\text{DefRate} \le 0.15\)  
  then **Play D with probability \(p\)**, else play C, where:
  - \(p = 0.5\) if \(n \le 4\), else \(p = 0.35\).
- Interpretation: in high stock, against cooperators, you periodically skim extra payoff. The randomness reduces the chance others can easily “time” you.

#### Rule 4 — Default: conditional cooperation
If none of the above rules triggered:
- If \(\text{DefRate} \le 0.25\): **Play C**
- Else: **Play D**
  - If opponents are too defect-prone, you stop subsidizing them.

---

## Forgiveness / exiting Punishment Mode

Punishment Mode ends early if **both** conditions hold:
1. Last round had **zero** opponent defectors, and
2. Stock is not in danger: \(S_t \ge 0.5\cdot \text{capacity}\)

Then you exit punishment and revert to Rules 3–4.

This makes punishment *conditional* and avoids staying in mutual defection unnecessarily when the group can return to a profitable regime that you can later exploit.

---

## Edge cases

### First round (t = 1)
- If \(r\) is small (e.g., \(r \le 3\)): **Play D** immediately (short horizon favors grabbing).
- Otherwise: **Play C**.
  - You want to test whether the population supports growth. A cooperative first round also preserves high stock, setting up profitable future harvesting.

### If capacity is huge relative to n
- Since capacity ≥ 2n by spec, sometimes it’s much larger; the stock can rebound strongly. The strategy already exploits this by harvesting only when \(S_t\) is high.

### If opponents are “always defect”
- They trigger Rule 2 repeatedly; you mostly defect as well (except near \(S_{\text{low}}\) where you cooperate to rebuild). This avoids being the sucker and sometimes restores stock enough to take advantage of any brief opponent cooperation.

### If opponents are “always cooperate”
- You’ll mostly cooperate to keep stock near capacity, but you’ll also defect periodically in high-stock states (Rule 3) to extract extra payoff while keeping the system sustainable.

### If opponents use trigger strategies (grim, tit-for-tat variants)
- Your occasional harvesting may trigger them. The strategy’s retaliation/forgiveness cycle is designed to quickly test whether you can return to a cooperative-growth regime; if not, you switch to defect-heavy play and stop paying the cost.

---

## Compact pseudocode

```pseudo
init:
  punishment_left = 0

for t in 1..r:
  observe S_t

  if t == r:
     play D
     continue

  if S_t <= 2n:
     play C
     punishment_left = max(punishment_left - 1, 0)
     continue

  compute DefRate over last w rounds (w=min(10,t-1))
  compute k_{t-1} = # opponent defectors last round (if t>1 else 0)

  if punishment_left > 0:
     play D
     punishment_left -= 1

     // early exit if opponents cooperated and stock is safe
     if k_{t-1} == 0 and S_t >= 0.5*capacity:
         punishment_left = 0
     continue

  if t > 1 and k_{t-1} >= 1:
     P = 2 + ceil(2*DefRate*r/(r+5))
     punishment_left = clamp(P, 2, 5)
     play D
     punishment_left -= 1
     continue

  if S_t >= 0.8*capacity and DefRate <= 0.15:
     p = (n <= 4 ? 0.5 : 0.35)
     play (rand() < p ? D : C)
     continue

  if DefRate <= 0.25:
     play C
  else:
     play D
```

---

## Why this is “exploitative” (explicitly)

- It **harvests** extra payoff from cooperative fields (Rule 3) rather than “fairly” cooperating always.
- It uses **credible punishment** (Rule 2) to prevent others from repeatedly exploiting you; you’re willing to damage the stock short-run to stop being milked.
- It is **selectively forgiving** only when doing so restores a regime you can profit from later, not for fairness.

If you want, I can also propose a more aggressively exploitative variant (higher harvesting probability, longer punishments) or a more “stealth exploit” variant designed to avoid triggering simple retaliators while still extracting surplus.
'''

description_EXPLOITATIVE_127 = '''
## Exploitative strategy: **Probe–Exploit–Protect (PEP)**

Goal: extract the higher per-round payoff of **D** whenever opponents keep the stock high (i.e., they are “supporting the resource”), but switch to **C** quickly when the stock risks collapse, so you can keep harvesting across rounds. You do **not** try to be fair; you try to be the player who defects most often while keeping the stock alive.

Key idea: in this game, if you defect while others cooperate enough to keep the stock regenerating near capacity, you get **2×** the cooperator payoff in that round. So you (i) *test* whether the group sustains stock, (ii) *free-ride* aggressively when safe, (iii) *contribute minimally* when collapse risk becomes high, and (iv) *punish* detected “over-defection” by reducing your own contribution (since you can’t stop them directly) and pivoting to “salvage mode” to keep the pool from hitting 0.

---

# 1) Decision rules (C vs D)

### Notation (observable each round)
- `S_t`: stock at start of round `t`
- `cap`: capacity
- `n`: players
- `h_{t-1}`: history of actions (who played C/D) up to previous round

Define:
- `k_{t-1}` = number of opponents who played **C** last round (excluding you). (If `t=1`, undefined.)
- `dRate_{t-1}` = fraction of opponents who played **D** last round = `1 - k_{t-1}/(n-1)`.

### Two computed risk indicators
1) **Immediate collapse risk** (stock is already low):
- If `S_t <= 2n`: you are close to the lower bound; any heavy defection can drive to 0 quickly.

2) **Support estimate** (are others sustaining the pool?):
- High support if opponents mostly played **C** recently.
- Low support if many opponents played **D**.

We’ll use simple thresholds that work across many behaviors:

- `SUPPORT_HIGH` if `k_{t-1} >= ceil(0.70*(n-1))` (at least ~70% of opponents cooperated last round)
- `SUPPORT_LOW` if `k_{t-1} <= floor(0.40*(n-1))` (≤~40% cooperated)

### Action policy
You choose **D** by default when it’s safe and exploitable, but switch to **C** to prevent collapse when needed.

**Rule A — Salvage mode (prevent collapse):**
Play **C** if any of these hold:
- `S_t <= 2n`  (stock is dangerously low)
- OR (`t < r` AND `SUPPORT_LOW` AND `S_t <= 0.6*cap`)  
  (others are not supporting and stock is already well below capacity; you need to slow depletion to preserve future payoffs)

**Rule B — Exploit mode (free-ride on cooperators):**
Play **D** if any of these hold:
- `t == r` (last round: always defect; no future stock to protect)
- OR (`t > 1` AND `SUPPORT_HIGH` AND `S_t >= 0.5*cap`)  
  (opponents are cooperating enough and stock is healthy; take the larger share)
- OR (`t == 1` AND `S_1 >= 0.8*cap`)  
  (opening probe: if starting stock is high, defect to test if the group sustains anyway)

**Rule C — Mixed/uncertain region (adaptive):**
If neither A nor B triggers (moderate stock, moderate cooperation), use:
- If `dRate_{t-1} > 0.5` (majority of opponents defected last round), play **C** only if `S_t` is below `0.7*cap`; otherwise play **D**.
- Else (opponents not mostly defecting), play **D**.

Intuition:  
- When others are mostly cooperating, defect.  
- When others are mostly defecting and stock is sliding, cooperate to keep the pool alive (so you can keep extracting later).  
- When stock is healthy, keep defecting even if the group is mixed—because your best response is still D unless collapse is imminent.

---

# 2) Edge cases

### First round (`t = 1`)
You don’t yet know opponent types. Use an exploitative probe:
- If `S_1 >= 0.8*capacity`: play **D**.
- Else (unusual parameterizations where initial stock might not be near capacity): play **C** to avoid immediate collapse risk.

Rationale: A first-round D reveals whether the table is “soft” (cooperators who will keep stock high) and lets you grab the larger payoff immediately.

### Last round (`t = r`)
Always play **D**. No future value from preserving stock.

### Stock extremely low
If `S_t` is so low that any meaningful consumption risks near-zero future:
- Always play **C** for `t < r` when `S_t <= 2n`.  
This is the minimal-consumption action; it maximizes the chance of regrowth via the logistic term and preserves the possibility of later exploitation.

### If the pool hits (or is near) 0
If `S_t` is ~0, both actions yield ~0 anyway, but **C** is still weakly better for recovery:
- For `t < r`: play **C**
- For `t = r`: play **D** (doesn’t matter, but stay consistent with last-round rule)

---

# 3) Why this is exploitative (and robust)

### Exploitative commitments
- **Defaults to D** whenever the stock is not in danger and opponents show any meaningful cooperative support.
- **Uses C only instrumentally**: to avert collapse and protect *your own* future extraction opportunities.
- **Never rewards** cooperation with cooperation; instead, it *taxes* cooperators by free-riding on them.
- **Last-round defection** guarantees endgame exploitation.

### Robustness features
- Against unconditional cooperators / stock-sustainers: you defect most rounds and earn ~2× per-round payoff relative to them.
- Against grim trigger / conditional cooperators: your early defection may cause punishment (more Ds), but the strategy detects low support + declining stock and switches to salvage to keep the resource from flatlining, extracting what’s still available.
- Against always-defect: you cannot fix the tragedy alone; PEP shifts into salvage only when it can preserve future value, otherwise it takes D when preservation is unlikely or the horizon is short.
- Against noisy/mixed strategies: thresholds avoid overreacting to single-round blips; you defect in uncertainty unless stock risk is real.

---

# Pseudocode (implementable)

```python
def action(t, r, n, capacity, S_t, opp_actions_last): 
    # opp_actions_last: list of length n-1 with 'C'/'D', None if t==1

    if t == r:
        return 'D'

    # danger threshold: very low stock
    if S_t <= 2*n:
        return 'C'

    if t == 1:
        return 'D' if S_t >= 0.8*capacity else 'C'

    k = sum(1 for a in opp_actions_last if a == 'C')
    support_high = (k >= math.ceil(0.70*(n-1)))
    support_low  = (k <= math.floor(0.40*(n-1)))
    dRate = 1 - k/(n-1)

    # Salvage mode
    if support_low and S_t <= 0.6*capacity:
        return 'C'

    # Exploit mode
    if support_high and S_t >= 0.5*capacity:
        return 'D'

    # Uncertain region
    if dRate > 0.5:
        return 'C' if S_t < 0.7*capacity else 'D'
    else:
        return 'D'
```

This is intentionally asymmetric: it treats opponents’ cooperation as an opportunity to defect more, and treats opponents’ defection as a signal to only cooperate when necessary to keep the pool harvestable later.
'''

description_EXPLOITATIVE_128 = '''
## Exploitative strategy: **Opportunistic Harvester with Credible Collapse Threat (OH-CCT)**

Goal: extract high payoffs (play **D**) whenever the stock can safely sustain it and opponents appear to be “stabilizers” (frequent **C**), while switching to **C** only when needed to (i) keep the resource from collapsing, and (ii) maintain just enough “credibility” that conditional cooperators keep cooperating and rebuilding the stock you then harvest.

This is not a fair strategy: it intentionally free-rides on others’ restraint and only invests in cooperation when it increases your future ability to defect profitably.

---

# 1) Decision rules (when to C vs D)

### Key quantities computed each round \(t\) from history/state
- \(S_t\): current stock at start of round \(t\).
- Let \(k_{t-1}\) be the number of opponents who played **D** last round (among the \(n-1\) others). (For \(t=1\), undefined.)
- Estimate “opponent defect rate” last round:
  \[
  \rho_{t-1} = \frac{k_{t-1}}{n-1}
  \]
- Define **danger threshold** \(S_{\text{safe}}\): stock level below which further defection risks collapse into a low-stock trap:
  \[
  S_{\text{safe}} = \max\left(0.35\cdot \text{capacity},\; 2n\right)
  \]
  (Uses given constraint capacity ≥ 2n; 0.35 is a conservative “don’t let it get too low” rule-of-thumb.)
- Define **harvest threshold** \(S_{\text{harvest}}\): above this, defection is usually safe because growth is strong and there’s room to absorb consumption:
  \[
  S_{\text{harvest}} = 0.75 \cdot \text{capacity}
  \]
- Define **support condition**: opponents are likely sustaining the pool if most are cooperating:
  \[
  \text{Support} = (\rho_{t-1} \le 0.35)
  \]
  i.e., at most ~35% of opponents defected last round.

### Core policy
You choose **D** whenever (a) stock is high enough or (b) opponents are cooperatively sustaining the resource. You choose **C** only when the stock is in danger *or* opponents have turned hostile enough that you need to rebuild/avoid total collapse.

**Rule set (in priority order):**

1. **Endgame harvest**
   - If \(t = r\): **D** always.
   - If \(t = r-1\) and \(S_t \ge S_{\text{safe}}\): **D**.
   Rationale: no future to protect; take maximum.

2. **Immediate collapse avoidance (only cooperate when necessary)**
   - If \(S_t \le S_{\text{safe}}\): **C**.
   Rationale: if stock is low, continued defection can drive it toward 0 where growth is tiny and everyone’s future payoffs crater—including yours.

3. **Exploit cooperative opponents**
   - If \(S_t \ge S_{\text{harvest}}\) and Support: **D**.
   - If \(S_t \ge 0.55\cdot \text{capacity}\) and Support: **D**.
   Rationale: when others are mostly cooperating, you harvest.

4. **Punish/avoid being the sucker in hostile environments**
   - If \(\rho_{t-1} \ge 0.60\) (most opponents defected last round): **D**.
   Rationale: when the group is defect-heavy, cooperating mostly subsidizes defectors and rarely restores cooperation.

5. **Credibility maintenance (minimal “investment” to keep conditional cooperators on-board)**
   - Otherwise (mixed environment, mid stock), play **C** with a small frequency to avoid being seen as “always defect” by reciprocity-based strategies:
     - Cooperate if you have defected for **2 consecutive rounds** and \(S_t < 0.85\cdot \text{capacity}\); else defect.
   Rationale: a periodic cheap “signal” can keep some opponent types cooperating longer, sustaining a high stock you can continue exploiting.

That yields an overall behavior: defect by default, but (i) don’t crash the stock, and (ii) occasionally “pay” one cooperation to keep the ecosystem (and opponent cooperation) alive.

---

# 2) Edge cases

### Round 1 (no history)
- If \(r \ge 3\): **D** in round 1 *unless* \(S_1 \le S_{\text{safe}}\) (rare since initial = capacity).
- If \(r = 2\): **D** in both rounds (pure endgame).

Rationale: early defection tests opponent population (are they punishers? unconditional cooperators? defectors?). You learn cheaply when the stock is high.

### Very low stock
- If \(S_t\) is near 0, both actions give tiny payoffs; the only way to restore future value is to stop overconsumption. So:
  - Always **C** while \(S_t \le S_{\text{safe}}\) *unless* \(t=r\) (still **D** last round).

### Very high stock (near capacity)
- Default to **D** (maximize immediate payoff); the system has plenty of slack and growth is strong unless consumption wipes it out.

### Last round
- Always **D** (no future penalty).

### Sudden regime change (others start defecting)
- If you observe \(\rho_{t-1}\ge 0.60\): switch to **D** immediately and stay mostly **D** until stock becomes unsafe.

---

# 3) Why this is exploitative (and robust)

### Exploitative alignment
- **Free-riding**: when others cooperate enough to keep stock high, you defect to take \(S/n\) instead of \(S/(2n)\).
- **Minimal investment**: you cooperate only to prevent a collapse that would reduce your future harvests, not to be “fair.”
- **Credibility manipulation**: occasional cooperation is used as bait/maintenance to keep conditional cooperators from fully switching to defection, preserving the resource for you to exploit later.

### Robustness to opponent diversity
- Against **unconditional cooperators / naive strategies**: you defect almost always; they keep stock high; you harvest.
- Against **grim trigger / tit-for-tat variants**: you may lose cooperation after early defection, but the strategy then shifts toward (mostly) defection anyway; you avoid being exploited.
- Against **mostly defectors**: you defect too; you don’t waste cooperation subsidizing them, except when stock is dangerously low (to preserve your own future payoffs).
- Against **state-aware conservationists**: you exploit their conservation behavior by defecting in high-stock states, and only helping when the stock threatens to collapse (which they also want).

---

# Pseudocode (implementation-ready)

```python
def OH_CCT(t, r, n, capacity, S_t, history_actions): 
    # history_actions: list of length t-1 of action profiles for past rounds
    S_safe = max(0.35 * capacity, 2*n)
    S_harvest = 0.75 * capacity

    # Endgame
    if t == r:
        return "D"
    if t == r-1 and S_t >= S_safe:
        return "D"

    # Round 1 (no history)
    if t == 1:
        return "D" if S_t > S_safe else "C"

    # Compute opponent last-round defect rate
    last_profile = history_actions[-1]  # actions of all players incl. self
    # assume we can identify opponents; count their Ds
    k = count_opponent_D(last_profile)
    rho = k / (n - 1)

    Support = (rho <= 0.35)

    # Avoid collapse
    if S_t <= S_safe:
        return "C"

    # Exploit cooperators when stock is good
    if (S_t >= S_harvest and Support) or (S_t >= 0.55 * capacity and Support):
        return "D"

    # Hostile environment: don't be the sucker
    if rho >= 0.60:
        return "D"

    # Credibility maintenance: occasional C after long D streak
    if defected_last_two_rounds(history_actions):
        if S_t < 0.85 * capacity:
            return "C"
    return "D"
```

This strategy is intentionally asymmetric: it treats cooperation as a tool to preserve a profitable environment, not as a norm. It should score well in mixed tournaments by (i) heavily exploiting cooperative opponents, (ii) not getting trapped as a cooperator among defectors, and (iii) preventing self-damaging resource collapse when there’s still future to monetize.
'''
