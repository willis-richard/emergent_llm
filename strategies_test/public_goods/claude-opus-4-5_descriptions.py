"""
Strategy descriptions for PublicGoodsDescription.

Generated with:
- Provider: Anthropic
- Model: claude-opus-4-5
"""


description_COLLECTIVE_1 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I recognize that if all players reason similarly, we should converge on cooperation since mutual cooperation (payoff = k) strictly dominates mutual defection (payoff = 1) when k > 1. The challenge is maintaining cooperation when facing defectors while remaining robust against exploitation.

## Strategy Overview: **Adaptive Collective Reciprocity (ACR)**

The strategy operates on three principles:
1. **Start cooperatively** to establish and signal cooperative norms
2. **Mirror the collective** by responding to the group's cooperation level
3. **Protect against endgame collapse** while leaving room for sustained cooperation

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: Cooperate**

Rationale: With no history, cooperation signals willingness to achieve the collectively superior outcome. If others reason similarly, we establish mutual cooperation immediately.

### Rounds 2 through (r-2): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Rule:**
```
IF coop_rate >= threshold THEN Cooperate
ELSE Defect

WHERE threshold = max(0.4, (n - k) / n)
```

**Threshold Explanation:**
- The term `(n - k) / n` represents the minimum cooperation rate needed for a cooperator's payoff to equal a defector's baseline
- Floor of 0.4 ensures we don't abandon cooperation too easily in favorable conditions
- This adapts to game parameters: higher k (more efficient public good) → lower threshold → more forgiving

### Rounds (r-1) and r: Endgame Protocol

**Round (r-1):**
- If average cooperation rate across all previous rounds ≥ 0.6: **Cooperate**
- Otherwise: **Defect**

**Final Round (r):**
- If cooperation rate in round (r-1) ≥ 0.7: **Cooperate**
- Otherwise: **Defect**

Rationale: Standard game theory predicts defection in final rounds via backward induction. However, if we're in a tournament of similar AI strategies, maintaining cooperation through the end yields higher collective payoffs. The thresholds reward sustained cooperation while protecting against pure defectors.

---

## Pseudocode Implementation

```
function decide_action(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history[round - 1])
    coop_rate = prev_cooperators / n
    
    # Calculate adaptive threshold
    base_threshold = (n - k) / n
    threshold = max(0.4, base_threshold)
    
    # Final round
    if round == r:
        if coop_rate >= 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # Second-to-last round
    if round == r - 1:
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Adaptive reciprocity
    if coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Scenario | Handling |
|----------|----------|
| **n = 2** | Becomes similar to iterated Prisoner's Dilemma; threshold logic still applies |
| **r = 2** | Round 1: Cooperate; Round 2: Apply final round rule with 0.7 threshold |
| **r = 3** | Round 1: Cooperate; Round 2: Endgame protocol (r-1); Round 3: Final round rule |
| **All defect in round 1** | Defect in round 2 (coop_rate = 0 < threshold), but any recovery triggers re-cooperation |
| **k very close to n** | Threshold approaches 0, making strategy very forgiving (appropriate since public good is highly efficient) |
| **k very close to 1** | Threshold approaches 1, requiring near-unanimous cooperation (appropriate since gains from cooperation are marginal) |

---

## Why This Strategy Works Collectively

1. **Self-reinforcing**: If multiple players use this strategy, initial cooperation triggers continued cooperation
2. **Robust to defectors**: Responds proportionally—doesn't collapse from a single defector but withdraws from widespread defection
3. **Parameter-adaptive**: Threshold adjusts to game economics automatically
4. **Endgame resilient**: Maintains cooperation possibility through final rounds unlike pure backward-induction strategies
'''

description_COLLECTIVE_1 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similar cooperative AI systems) may be playing alongside me. The goal is to establish and maintain cooperation among like-minded players while protecting against exploitation by pure defectors. The strategy uses **observable behavioral patterns** to identify potential cooperators and coordinate without explicit communication.

---

## Strategy Overview: "Adaptive Collective Signaling" (ACS)

The strategy operates in three phases and uses a **cooperation threshold** that adapts based on observed group behavior.

---

## Decision Rules

### Phase 1: Signaling Phase (Rounds 1-2)

**Round 1: Always Cooperate**
- Rationale: This serves as a collective signal. Cooperative agents will recognize each other by mutual first-round cooperation. The cost of one round of potential exploitation is worth the information gained about other players.

**Round 2: Cooperate if cooperation rate ≥ 50% in Round 1**
- If at least half the group cooperated, continue cooperating to reinforce the cooperative coalition
- If fewer than half cooperated, defect as a measured response

### Phase 2: Adaptive Phase (Rounds 3 through r-2)

Calculate a **dynamic cooperation threshold** based on recent history:

```
recent_coop_rate = (cooperators in last 2 rounds) / (2n)
my_threshold = max(0.3, recent_coop_rate - 0.1)
```

**Decision Rule:**
```
IF (cooperation rate in previous round) ≥ my_threshold:
    Cooperate
ELSE:
    Defect
```

**Forgiveness Mechanism:**
- If I defected last round BUT cooperation rate increased, return to cooperation
- This allows recovery from temporary breakdowns

**Exploitation Protection:**
- Track each round's cooperation count
- If cooperation rate has declined for 3 consecutive rounds AND is below 40%, defect until recovery is observed

### Phase 3: End Game (Final 2 rounds)

**Round r-1 (second to last):**
- Cooperate if the average cooperation rate over the entire game ≥ 50%
- This rewards groups that maintained cooperation and signals continued good faith

**Round r (final round):**
- **Cooperate if cooperation rate in round r-1 was ≥ 60%**
- Rationale: Unlike standard game theory which predicts universal defection in the final round, a collective strategy should maintain cooperation if the group has demonstrated cooperative norms. Defecting in the last round destroys trust-building for future interactions (even if this specific game ends, reputational considerations matter in tournaments).

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate (signaling)
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation rate from previous round
    prev_coop_rate = history[round-1].cooperators / n
    
    # Round 2: Conditional on first round
    if round == 2:
        if prev_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Final round
    if round == r:
        if prev_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Second to last round
    if round == r - 1:
        avg_coop_rate = sum(h.cooperators for h in history) / ((round-1) * n)
        if avg_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Adaptive phase (rounds 3 to r-2)
    
    # Calculate recent cooperation rate (last 2 rounds)
    recent_coops = history[round-1].cooperators + history[round-2].cooperators
    recent_coop_rate = recent_coops / (2 * n)
    
    # Dynamic threshold
    threshold = max(0.3, recent_coop_rate - 0.1)
    
    # Check for declining cooperation trend
    if round >= 5:
        declining = all(
            history[i].cooperators > history[i+1].cooperators 
            for i in range(round-4, round-1)
        )
        if declining and prev_coop_rate < 0.4:
            return DEFECT
    
    # Forgiveness: if I defected but cooperation increased, try cooperating
    if my_last_action == DEFECT and round >= 3:
        if history[round-1].cooperators > history[round-2].cooperators:
            return COOPERATE
    
    # Main decision
    if prev_coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (minimum players) | Follow same rules, but threshold adjustments more sensitive | Two-player case becomes closer to iterated prisoner's dilemma |
| r = 2 (minimum rounds) | R1: Cooperate, R2: Cooperate if R1 had ≥50% cooperation | Compressed signaling phase |
| All others defect R1 | Defect R2+, but try cooperation again every 3 rounds | Periodic forgiveness probes for change in behavior |
| All others always cooperate | Always cooperate | Maintain the cooperative equilibrium |
| k very close to 1 | Same strategy (cooperation benefits are low but still positive for group) | Collective benefit still exists |
| k close to n | Same strategy (stronger incentive to cooperate) | Strategy naturally supports cooperation |

---

## Why This Strategy is Collectively Robust

1. **Identifiable**: Cooperative AI instances can recognize each other through the Round 1 cooperation signal
2. **Forgiving**: Allows recovery from mistakes or temporary defection
3. **Protective**: Doesn't allow unlimited exploitation—responds to sustained defection
4. **Adaptive**: Threshold adjusts to the actual cooperation level of the group
5. **End-game cooperative**: Maintains cooperation through final rounds when playing with other cooperative agents, capturing gains that mutual defectors lose
'''

description_COLLECTIVE_2 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we succeed together or fail together. The goal is not to maximize individual advantage over others, but to establish and maintain cooperation that benefits everyone. I will lead by example, reward collective cooperation, forgive mistakes, but protect against persistent exploitation.

## Strategy Overview: **"Generous Threshold Trigger with Gradual Recovery"**

This strategy cooperates by default, monitors the collective cooperation level, triggers defensive defection only when cooperation falls below sustainable thresholds, and provides clear pathways back to mutual cooperation.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Someone must take the first step. By cooperating initially, I signal willingness to build collective benefit and give others the opportunity to reciprocate.

---

### Rounds 2 through (r-1): Adaptive Threshold Response

**Calculate cooperation rate from the previous round:**
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Calculate cumulative cooperation rate:**
```
cumulative_coop_rate = (total cooperations across all players, all rounds) / (n × (t-1))
```

**Decision Logic:**

```
IF prev_coop_rate >= 0.5:
    # Majority cooperated - continue cooperating
    ACTION = COOPERATE

ELSE IF prev_coop_rate < 0.5 AND cumulative_coop_rate >= 0.4:
    # Recent dip but overall trend is acceptable
    # Give benefit of doubt with probability based on cumulative rate
    ACTION = COOPERATE with probability = cumulative_coop_rate
    ACTION = DEFECT with probability = 1 - cumulative_coop_rate

ELSE IF prev_coop_rate < 0.5 AND cumulative_coop_rate < 0.4:
    # Sustained low cooperation - defensive defection
    ACTION = DEFECT
    
    # BUT: Every 3rd consecutive defection round, test with cooperation
    IF consecutive_defection_rounds % 3 == 0:
        ACTION = COOPERATE  # Olive branch
```

**Recovery Mechanism:**
```
IF currently in defensive defection mode:
    IF prev_coop_rate >= 0.6:  # Strong cooperation signal
        EXIT defensive mode
        ACTION = COOPERATE
```

---

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which predicts universal defection in the final round, I maintain collective commitment:

```
IF cumulative_coop_rate >= 0.5:
    # Group has been cooperative - honor that with final cooperation
    ACTION = COOPERATE
ELSE:
    # Group has been exploitative - no reason to sacrifice
    ACTION = DEFECT
```

---

## Handling Edge Cases

### Small n (n = 2 or 3):
- Thresholds become more sensitive to individual actions
- Adjust: Use `prev_coop_rate >= (n-1)/n` for cooperation threshold (i.e., tolerate at most one defector)

### Large n (n > 10):
- Individual defections matter less
- Maintain standard thresholds; collective behavior dominates

### Very Short Games (r ≤ 3):
- Less time for recovery dynamics
- Cooperate rounds 1 and 2 unconditionally; apply cumulative assessment only for round 3+

### k Close to 1 vs Close to n:
- When k is close to 1: Cooperation barely profitable even with full participation - be more forgiving of defection (lower threshold to 0.4)
- When k is close to n: Cooperation highly profitable - cooperation should emerge naturally

---

## Summary Pseudocode

```python
def decide(round_num, total_rounds, n, k, history):
    if round_num == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history, round_num - 1) / n
    cumulative_coop_rate = total_cooperations(history) / (n * (round_num - 1))
    
    # Final round
    if round_num == total_rounds:
        return COOPERATE if cumulative_coop_rate >= 0.5 else DEFECT
    
    # Main decision logic
    if prev_coop_rate >= 0.5:
        return COOPERATE
    elif cumulative_coop_rate >= 0.4:
        return COOPERATE with probability cumulative_coop_rate
    else:
        # Defensive mode with periodic olive branches
        if consecutive_defections % 3 == 0:
            return COOPERATE
        return DEFECT
```

---

## Why This Strategy Is Collectively Aligned

1. **Leads with trust**: Initial cooperation demonstrates commitment to collective welfare
2. **Rewards cooperation**: Sustained cooperation is reciprocated reliably
3. **Forgives mistakes**: Probabilistic response and olive branches allow recovery from coordination failures
4. **Protects the collective**: Defection only triggers when cooperation has genuinely broken down
5. **Maintains hope**: Never permanently abandons cooperation possibility
6. **Honors commitment**: Final-round cooperation rewards groups that maintained trust
'''

description_COLLECTIVE_2 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be using similar reasoning, so I should behave in ways that create good outcomes when mirrored by like-minded players, while remaining robust against defectors. The key insight is that in repeated games, early cooperation can establish beneficial norms, but I must also protect against exploitation.

## Strategy: **Adaptive Threshold Cooperation with Graduated Response**

### Decision Framework

My strategy tracks the **cooperation rate** of the group and adjusts my behavior based on whether cooperation appears viable in this particular game instance.

---

### Round-by-Round Decision Rules

#### **Round 1: Cooperate**
- Begin with cooperation to signal willingness to collaborate
- This allows collective identification: if others are using similar strategies, we establish mutual cooperation from the start

#### **Rounds 2 through (r-1): Adaptive Cooperation**

Calculate the **group cooperation rate** from the previous round:
```
prev_coop_rate = (number of C plays in round t-1) / n
```

**Decision Rule:**
```
IF prev_coop_rate >= threshold(t) THEN Cooperate
ELSE Defect
```

**Dynamic Threshold Function:**
```
threshold(t) = max(0.3, 0.5 - 0.02 × t)
```
- Starts at ~0.5 (majority cooperation required)
- Gradually becomes more forgiving over time (down to 0.3)
- This gives groups time to coordinate while protecting against persistent defection

**Forgiveness Mechanism:**
- If I defected last round but cooperation rate was ≥ 0.5, cooperate this round (attempt to restart cooperation)
- This prevents lock-in to mutual defection when cooperation could be viable

**Responsiveness to Trends:**
```
IF coop_rate increased from (t-2) to (t-1) AND coop_rate >= 0.25 THEN Cooperate
```
- Reward improving cooperation trends even if below threshold

#### **Final Round (Round r): Conditional Cooperation**

The last round eliminates future punishment, creating defection incentives. However:

```
IF average_coop_rate_over_game >= 0.6 THEN Cooperate
ELSE Defect
```

**Rationale:** If the group has demonstrated sustained cooperation, I maintain cooperation even in the final round. This is collectively rational—if all cooperative players reason this way, we avoid the unraveling problem. If cooperation has been low, there's no collective norm to preserve.

---

### Handling Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| **r = 2** | C then conditional C (if round 1 coop rate ≥ 0.5) | Minimal time to establish patterns |
| **n = 2** | Use stricter threshold (0.8) | With one opponent, their defection is decisive |
| **k very close to 1** | Lower threshold to 0.2 | Cooperation benefits are marginal; be more tolerant |
| **k close to n** | Higher threshold (0.6) | Cooperation is highly valuable; protect it more |
| **All defected last round** | Defect (unless 2+ rounds of defection, then try one C) | One-time forgiveness probe |

---

### Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history[round-1]) / n
    avg_coop_rate = average_cooperation_rate(history)
    
    if round == r:  # Final round
        if avg_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Calculate adaptive threshold
    threshold = max(0.3, 0.5 - 0.02 * round)
    
    # Check for improving trend
    if round >= 3:
        trend_positive = coop_rate(round-1) > coop_rate(round-2)
    else:
        trend_positive = false
    
    # Main decision
    if prev_coop_rate >= threshold:
        return COOPERATE
    elif trend_positive and prev_coop_rate >= 0.25:
        return COOPERATE
    elif my_last_action == DEFECT and prev_coop_rate >= 0.5:
        return COOPERATE  # Forgiveness
    else:
        return DEFECT
```

---

### Why This Strategy is Collectively Aligned

1. **Mutual identification**: Starting with cooperation lets similar strategies find each other
2. **Norm reinforcement**: Continued cooperation rewards groups that cooperate together
3. **Collective robustness**: The threshold mechanism means we don't collapse into defection due to a single defector
4. **Shared final-round logic**: If we all reason that sustained cooperation justifies final-round cooperation, we collectively avoid unraveling
5. **Graduated response**: We don't punish harshly for minor deviations, allowing recovery from noise or mistakes
'''

description_COLLECTIVE_3 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with the understanding that **I am one of many instances of the same AI system** playing this game. While I cannot explicitly coordinate with other instances, I can design a strategy that, if adopted by multiple instances of similar reasoning, will achieve good collective outcomes. The strategy must also be robust against defectors who don't share this collective orientation.

## Strategy Overview: "Threshold-Based Conditional Cooperation with Forgiveness"

The key insight is that cooperation is collectively beneficial (payoff of k > 1 per person when all cooperate) but individually exploitable. The strategy aims to:
1. Signal cooperative intent early
2. Sustain cooperation when others reciprocate
3. Punish defection proportionally to deter exploitation
4. Forgive to allow recovery from mutual defection spirals

---

## Decision Rules

### Round 1: Cooperate
**Rationale:** In the first round, there's no history to condition on. Cooperating signals willingness to achieve mutual benefit and allows other cooperative agents to identify each other. The cost of being exploited once is worth the potential of establishing cooperation for remaining rounds.

### Rounds 2 through (r-1): Conditional Cooperation with Threshold

**Calculate cooperation rate from previous round:**
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision rule:**
```
threshold = max(0.3, (k - 1) / (n - 1))

IF coop_rate >= threshold:
    COOPERATE
ELSE IF coop_rate < threshold AND coop_rate > 0:
    # Some cooperation exists but below threshold
    # Cooperate with probability equal to coop_rate (match the cooperation level)
    COOPERATE with probability = coop_rate
ELSE (coop_rate == 0):
    # Total defection - attempt recovery every few rounds
    IF (current_round mod 3 == 0):
        COOPERATE  # Periodic olive branch
    ELSE:
        DEFECT
```

**Threshold explanation:** 
- The threshold `(k-1)/(n-1)` represents the minimum cooperation rate needed for a cooperator to break even compared to defecting
- Floor of 0.3 ensures we don't abandon cooperation too easily in large groups
- Probabilistic matching in the middle zone maintains some cooperation signal while protecting against heavy exploitation

### Final Round (Round r): Defect
**Rationale:** In the last round, there's no future to incentivize cooperation. Standard game theory predicts universal defection. Even among cooperative agents, defecting here doesn't damage future cooperation potential. However, if the game has been highly cooperative (≥80% cooperation in round r-1), cooperate anyway as a gesture of collective commitment.

```
IF cooperation_rate_in_round_(r-1) >= 0.8:
    COOPERATE
ELSE:
    DEFECT
```

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # First round: always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history[round - 1])
    coop_rate = prev_cooperators / n
    
    # Final round logic
    if round == r:
        if coop_rate >= 0.8:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: threshold-based conditional cooperation
    threshold = max(0.3, (k - 1) / (n - 1))
    
    if coop_rate >= threshold:
        return COOPERATE
    else if coop_rate > 0:
        # Probabilistic cooperation matching observed rate
        if random() < coop_rate:
            return COOPERATE
        else:
            return DEFECT
    else:  # coop_rate == 0
        # Periodic forgiveness attempt
        if round mod 3 == 0:
            return COOPERATE
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Self-reinforcing among similar agents:** If multiple instances use this strategy, initial cooperation triggers sustained cooperation, achieving near-optimal collective payoffs.

2. **Resistant to exploitation:** The threshold mechanism means a minority of defectors won't collapse cooperation, but if defection becomes prevalent, we stop being exploited.

3. **Recovery mechanism:** Periodic cooperation attempts in defection states allow escape from bad equilibria if other agents are also willing.

4. **Adaptive to parameters:** The threshold adjusts based on k and n, making the strategy sensible across different game configurations.

5. **Minimal assumptions:** Doesn't require pre-arranged signals, specific coordination patterns, or assumptions about opponent identity—just responds to observed behavior.
'''

description_COLLECTIVE_4 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that universal cooperation yields the best outcome for everyone (payoff = k > 1), while universal defection yields the worst collective outcome (payoff = 1 for all). My goal is to foster and sustain cooperation while protecting against exploitation.

The strategy is built on three principles:
1. **Start cooperatively** to signal willingness to collaborate
2. **Reward cooperation proportionally** - match the group's cooperative behavior
3. **Forgive gradually** to allow recovery from defection spirals

---

## Strategy: Proportional Conditional Cooperation with Forgiveness (PCCF)

### Decision Rule

**Cooperate if and only if the expected benefit of cooperation outweighs the risk of exploitation, based on observed group behavior.**

Specifically, I cooperate when the **cooperation rate** in the group meets a dynamic threshold that accounts for:
- Historical cooperation levels
- Round position (early vs. late game)
- Trend in cooperation (improving or declining)

---

### Detailed Rules

#### Round 1 (No History)
**Action: COOPERATE**

Rationale: Signal cooperative intent. With no information, assume good faith. The potential to establish mutual cooperation outweighs the risk of one round's exploitation.

#### Rounds 2 through (r-1) — Middle Game

Calculate the following from the previous round:
- `coop_rate` = (number of cooperators) / n
- `coop_trend` = coop_rate(t-1) - coop_rate(t-2) [if t > 2, else 0]

**Cooperation Threshold Calculation:**
```
base_threshold = 0.5
trend_adjustment = -0.1 if coop_trend > 0 else +0.1 if coop_trend < 0 else 0
round_adjustment = -0.1 × (t / r)  # More forgiving early, stricter late

threshold = base_threshold + trend_adjustment + round_adjustment
threshold = clamp(threshold, 0.3, 0.7)  # Keep threshold reasonable
```

**Decision:**
```
IF coop_rate >= threshold:
    COOPERATE
ELSE:
    DEFECT
```

#### Last Round (Round r)
**Special Handling:**

Since there's no future to incentivize others, apply stricter criteria:
```
IF coop_rate(r-1) >= 0.7:
    COOPERATE  # Reward a cooperative group
ELSE:
    DEFECT     # Protect against end-game exploitation
```

---

### Forgiveness Mechanism

If cooperation collapses (coop_rate < 0.3 for 2+ consecutive rounds), implement a **forgiveness probe**:

```
IF rounds_since_last_cooperation >= 3 AND remaining_rounds >= 3:
    COOPERATE (probe)
    Reset cooperation assessment window
```

This prevents permanent defection spirals and tests if others are willing to restart cooperation.

---

### Pseudocode Summary

```python
def decide(round_t, history, n, r, k):
    if round_t == 1:
        return COOPERATE
    
    coop_rate = count_cooperators(history[round_t - 1]) / n
    
    # Last round logic
    if round_t == r:
        return COOPERATE if coop_rate >= 0.7 else DEFECT
    
    # Calculate trend (if enough history)
    if round_t > 2:
        prev_coop_rate = count_cooperators(history[round_t - 2]) / n
        trend = coop_rate - prev_coop_rate
    else:
        trend = 0
    
    # Dynamic threshold
    base_threshold = 0.5
    trend_adj = -0.1 if trend > 0 else (0.1 if trend < 0 else 0)
    round_adj = -0.1 * (round_t / r)
    threshold = clamp(base_threshold + trend_adj + round_adj, 0.3, 0.7)
    
    # Forgiveness probe
    if consecutive_low_coop_rounds(history) >= 3 and (r - round_t) >= 3:
        return COOPERATE  # Probe for recovery
    
    return COOPERATE if coop_rate >= threshold else DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Maximizes group welfare when possible**: Starts cooperative and maintains cooperation when others reciprocate
2. **Adapts to group behavior**: Doesn't stubbornly cooperate with defectors, nor stubbornly defect with cooperators
3. **Creates positive incentives**: Rewards improving cooperation trends with a lower threshold
4. **Enables recovery**: Forgiveness probes allow escape from mutual defection
5. **Robust to exploitation**: Threshold-based response limits losses against persistent defectors
'''

description_COLLECTIVE_3 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all instances of this strategy will reason identically given the same information. This allows for implicit coordination without explicit communication. The strategy balances:
1. **Collective welfare maximization** - Full cooperation yields the best group outcome
2. **Robustness to defectors** - Protecting against exploitation by non-cooperative players
3. **Adaptive responsiveness** - Adjusting behavior based on observed group cooperation levels

---

## Strategy Overview

**Name: Threshold Collective Cooperation (TCC)**

The strategy operates on the principle that cooperation is worthwhile when sufficient others cooperate, and uses deterministic rules that identical agents will follow in lockstep.

---

## Decision Rules

### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- **Rationale:** Establish cooperative intent, gather information about other players, and coordinate with other instances of this strategy.

### Rounds 2 through (r-1): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

Calculate the **breakeven threshold** - the minimum cooperation rate where cooperating isn't strictly dominated:
```
breakeven = (n - k) / (n × (k - 1))
```

**Decision Logic:**

```
IF coop_rate >= max(breakeven, 0.5) THEN
    COOPERATE
ELSE IF coop_rate >= breakeven AND coop_rate < 0.5 THEN
    // Marginal zone: give benefit of doubt early, be stricter late
    IF current_round <= r/2 THEN
        COOPERATE
    ELSE
        DEFECT
ELSE
    // Below breakeven: defection is rational
    DEFECT
```

**Additional Forgiveness Mechanism:**

To avoid permanent collapse from temporary fluctuations:
```
IF defected_last_round AND (round_number mod 3 == 0) THEN
    // Periodic probe: test if cooperation can be restored
    COOPERATE
```

### Final Round (Round r): Conditional Cooperation

Unlike typical game theory advice to defect in the final round, a collective strategy recognizes that if all cooperative agents defect, the outcome is worse for everyone.

```
IF average_cooperation_rate_over_all_rounds >= 0.6 THEN
    COOPERATE  // Maintain collective benefit
ELSE
    DEFECT     // Group has not sustained cooperation
```

---

## Complete Pseudocode

```python
def decide(n, k, r, current_round, history):
    """
    n: number of players
    k: multiplication factor (1 < k < n)
    r: total rounds
    current_round: current round number (1-indexed)
    history: list of previous round results, each containing count of cooperators
    """
    
    # Calculate breakeven threshold
    breakeven = (n - k) / (n * (k - 1))
    
    # Round 1: Always cooperate
    if current_round == 1:
        return COOPERATE
    
    # Get previous round cooperation rate
    prev_cooperators = history[current_round - 2]  # 0-indexed
    coop_rate = prev_cooperators / n
    
    # Calculate average cooperation rate
    total_coop = sum(history)
    avg_coop_rate = total_coop / (n * (current_round - 1))
    
    # Final round logic
    if current_round == r:
        if avg_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    high_threshold = max(breakeven, 0.5)
    
    # High cooperation: cooperate
    if coop_rate >= high_threshold:
        return COOPERATE
    
    # Marginal zone: early game optimism
    if coop_rate >= breakeven and current_round <= r / 2:
        return COOPERATE
    
    # Below threshold, but periodic forgiveness probe
    if current_round % 3 == 0:
        return COOPERATE
    
    # Default to defection when cooperation isn't sustained
    return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | COOPERATE | Information gathering + coordination signal |
| Final round, good history | COOPERATE | Collective optimum if others follow same logic |
| Final round, poor history | DEFECT | No future rounds to recover losses |
| Everyone defected last round | COOPERATE (if probe round) | Test for recovery |
| n=2 (minimum players) | Same rules apply | Breakeven calculation still valid |
| k close to n (high multiplier) | Lower threshold, more cooperation | Reflects higher social returns |
| k close to 1 (low multiplier) | Higher threshold, more selective | Reflects lower social returns |

---

## Why This Strategy is Collectively Optimal

1. **Identical agents coordinate automatically:** All instances will make the same decision given the same history, enabling implicit cooperation without communication.

2. **Responsive to environment:** If paired with defectors, the strategy protects itself. If paired with cooperators, it maintains high group payoffs.

3. **Forgiveness prevents death spirals:** Periodic cooperation probes allow recovery from temporary defection cascades.

4. **Parameter-adaptive:** The breakeven threshold adjusts to different k/n ratios, optimizing behavior across game configurations.

5. **Collectively rational final round:** By cooperating in the final round when history supports it, identical agents achieve payoff 2 (all cooperate) instead of payoff 1 (all defect).
'''

description_COLLECTIVE_5 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that mutual cooperation yields the best collective outcome (payoff of k > 1 for everyone) compared to mutual defection (payoff of 1 for everyone). My goal is to foster and sustain cooperation while protecting against exploitation. I treat other players as potential cooperators first, and only withdraw cooperation when the collective clearly fails to reciprocate.

## Strategy Overview: **Generous Collective Reciprocity (GCR)**

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness to collaborate
2. **Respond to collective behavior** rather than individual actions
3. **Forgive occasionally** to escape mutual defection traps

---

## Decision Rules

### Key Metric: Cooperation Rate
After each round, calculate the **collective cooperation rate** from the previous round:
```
cooperation_rate = (number of cooperators) / n
```

### Round-by-Round Decision Logic

**Round 1 (First Round):**
- **Action: COOPERATE**
- Rationale: Signal cooperative intent and give the collective a chance to form

**Rounds 2 through (r-1) (Middle Rounds):**

```
Let prev_coop_rate = cooperation rate in previous round
Let trend = change in cooperation rate over last 2 rounds (if available)

IF prev_coop_rate >= 0.5:
    COOPERATE
    
ELSE IF prev_coop_rate >= k/n:
    # Cooperation still generates positive returns for cooperators
    COOPERATE with probability = prev_coop_rate + 0.1
    DEFECT with probability = 1 - (prev_coop_rate + 0.1)
    
ELSE IF prev_coop_rate < k/n AND prev_coop_rate > 0:
    # Cooperation is costly but some are trying
    IF trend > 0 (cooperation increasing):
        COOPERATE  # Support the recovery
    ELSE:
        COOPERATE with probability = 0.2  # Occasional forgiveness
        DEFECT with probability = 0.8
        
ELSE (prev_coop_rate = 0):
    # Total defection - attempt periodic restart
    IF round_number mod 3 == 0:
        COOPERATE  # Periodic olive branch
    ELSE:
        DEFECT
```

**Round r (Final Round):**
```
IF average cooperation rate over all previous rounds >= 0.4:
    COOPERATE  # Reward a reasonably cooperative collective
ELSE:
    DEFECT  # No point cooperating with chronic defectors
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | Cooperate | Establish cooperative norm |
| Final round with cooperative history | Cooperate | Collective loyalty |
| Final round with defection history | Defect | Protect against exploitation |
| All others defected last round | Cooperate every 3rd round | Escape defection equilibrium |
| Cooperation declining but k/n threshold met | Probabilistic cooperation | Hedge while supporting cooperation |
| n = 2 (minimum players) | Use standard Tit-for-Tat with forgiveness | Simplifies to bilateral case |
| k very close to n | More forgiving thresholds | Cooperation nearly self-sustaining |

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, k, history):
    
    if round_num == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history[-1]) / n
    threshold = k / n
    
    if round_num == total_rounds:  # Final round
        avg_coop = average_cooperation_rate(history)
        return COOPERATE if avg_coop >= 0.4 else DEFECT
    
    # Middle rounds
    if prev_coop_rate >= 0.5:
        return COOPERATE
    
    if prev_coop_rate >= threshold:
        return COOPERATE if random() < (prev_coop_rate + 0.1) else DEFECT
    
    if prev_coop_rate > 0:
        trend = get_trend(history)
        if trend > 0:
            return COOPERATE
        return COOPERATE if random() < 0.2 else DEFECT
    
    # Total defection case
    return COOPERATE if (round_num % 3 == 0) else DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Promotes group welfare**: Starts cooperative and maintains cooperation when others reciprocate
2. **Responds to collective, not individuals**: Avoids vindictive cycles against specific players
3. **Includes forgiveness**: Random cooperation attempts prevent permanent defection spirals
4. **Rewards cooperative communities**: Final-round cooperation acknowledges collective success
5. **Adapts to parameters**: Uses k/n threshold to make economically sensible decisions
'''

description_COLLECTIVE_4 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I recognize that if all players reason similarly and cooperate, we all achieve the best collective outcome (payoff of k per round vs. 1 from mutual defection). However, I must be adaptive since I cannot assume others share this reasoning or will cooperate.

The strategy combines **hopeful initiation**, **proportional reciprocity**, and **forgiveness** to encourage cooperation while protecting against persistent defectors.

---

## Strategy: "Adaptive Collective Reciprocity" (ACR)

### Key Parameters (derived from game parameters)

- `cooperation_threshold` = 0.5 (proportion of cooperators needed to continue cooperating)
- `forgiveness_rate` = 1/(n-1) (probability of testing cooperation after defection streak)
- `end_game_horizon` = min(3, floor(r/4)) (rounds before end where behavior shifts)

---

### Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. This gives the collective the best chance to establish mutual cooperation from the start.

#### Rounds 2 through (r - end_game_horizon): Adaptive Reciprocity

```
Let prev_cooperation_rate = (number of cooperators in previous round) / n

IF prev_cooperation_rate >= cooperation_threshold:
    ACTION: COOPERATE
ELSE:
    # Most players defected last round
    Let defection_streak = consecutive rounds where cooperation_rate < threshold
    
    IF random() < forgiveness_rate ^ defection_streak:
        ACTION: COOPERATE  # Occasional forgiveness probe
    ELSE:
        ACTION: DEFECT  # Protect against exploitation
```

**Rationale:** 
- Cooperate when at least half the group cooperates (majority rule reciprocity)
- When cooperation collapses, mostly defect but occasionally probe with cooperation
- Forgiveness probability decreases with longer defection streaks (diminishing optimism)

#### Final Rounds (last `end_game_horizon` rounds): Conditional End-Game

```
Let overall_cooperation_rate = (total cooperations by others) / ((current_round - 1) * (n - 1))

IF overall_cooperation_rate >= 0.6:
    # History suggests cooperative group - maintain cooperation
    ACTION: COOPERATE
ELSE IF overall_cooperation_rate >= 0.3:
    # Mixed group - mirror last round's majority
    IF prev_cooperation_rate >= 0.5:
        ACTION: COOPERATE
    ELSE:
        ACTION: DEFECT
ELSE:
    # Predominantly defecting group - defect
    ACTION: DEFECT
```

**Rationale:** Standard game theory predicts defection in final rounds via backward induction. However, if the group has demonstrated sustained cooperation, maintaining it serves collective welfare. Only defect at the end against groups that have shown they cannot sustain cooperation.

---

### Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | Cooperate both rounds | Too short to punish; maximize collective chance |
| n = 2 (minimum players) | Standard Tit-for-Tat with forgiveness | Simplifies to 2-player case |
| k very close to 1 | Same strategy, slightly lower threshold (0.4) | Lower k means cooperation needs more participants to be worthwhile |
| k close to n | Same strategy | High k makes cooperation very attractive; strategy already favors it |
| All others defected all rounds | Defect with occasional probe (rate: 1/r) | Protect self but leave door open |
| All others cooperated all rounds | Cooperate always | Reward and maintain successful cooperation |

---

### Pseudocode Summary

```python
def decide(round_number, history, n, r, k):
    end_game_horizon = min(3, r // 4)
    cooperation_threshold = 0.5
    forgiveness_rate = 1 / (n - 1)
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate metrics
    prev_coop_rate = count_cooperators(history, round_number - 1) / n
    overall_coop_rate = total_others_cooperations(history) / ((round_number - 1) * (n - 1))
    defection_streak = count_consecutive_low_cooperation_rounds(history, cooperation_threshold)
    
    # End game logic
    if round_number > r - end_game_horizon:
        if overall_coop_rate >= 0.6:
            return COOPERATE
        elif overall_coop_rate >= 0.3:
            return COOPERATE if prev_coop_rate >= 0.5 else DEFECT
        else:
            return DEFECT
    
    # Main game logic
    if prev_coop_rate >= cooperation_threshold:
        return COOPERATE
    else:
        if random() < forgiveness_rate ** defection_streak:
            return COOPERATE
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Establishes cooperation**: Starting with C and maintaining C when others cooperate builds the cooperative equilibrium that benefits everyone.

2. **Robust to defectors**: Responds to exploitation by withdrawing cooperation, preventing systematic abuse.

3. **Forgiving**: Random cooperation probes allow recovery from temporary breakdowns or misunderstandings.

4. **Scales with group size**: Forgiveness rate adapts to n, recognizing that larger groups need different dynamics.

5. **Resists backward induction collapse**: Maintains cooperation in end-game for historically cooperative groups, avoiding the "unraveling" that destroys value.

6. **Self-consistent under collective adoption**: If all players use ACR, they will cooperate every round, achieving the optimal collective outcome of k × r total payoff per player.
'''

description_COLLECTIVE_6 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with the understanding that **I am one instance of a collective mind** - other copies of me will likely employ similar reasoning. The strategy must therefore:
1. Be recognizable to other instances using similar logic
2. Create conditions where mutual cooperation is self-sustaining
3. Remain robust against defectors without becoming exploitable

## Strategy: **Graduated Reciprocity with Collective Signaling**

### Decision Framework

The strategy operates on three principles:
- **Optimistic Start**: Begin cooperatively to establish trust and signal collective intent
- **Proportional Response**: Mirror the cooperation level of the group
- **Forgiveness with Boundaries**: Allow recovery from defection but protect against persistent exploitation

---

### Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: This serves as a coordination signal. Other instances of this collective strategy will recognize this pattern. The cost of one round of potential exploitation is worth the benefit of establishing cooperative equilibrium.

#### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation ratio** from the previous round:
```
coop_ratio = (number of cooperators in previous round) / n
```

**Decision Rule:**
```
IF coop_ratio >= (n-1)/n THEN:
    COOPERATE (near-universal cooperation maintained)
    
ELSE IF coop_ratio >= 0.5 THEN:
    COOPERATE with probability = coop_ratio
    (Match the group's cooperation level probabilistically)
    
ELSE IF coop_ratio > 0 THEN:
    COOPERATE with probability = coop_ratio × 0.5
    (Reduced cooperation when majority defects, but maintain some olive branch)
    
ELSE (coop_ratio = 0):
    DEFECT (no cooperation to reciprocate)
```

**Forgiveness Mechanism:**
If cooperation ratio *increases* from round t-1 to round t by at least 1/n (one player switched to cooperation), add +0.2 to cooperation probability (capped at 1.0). This rewards positive momentum.

**Punishment Escalation:**
Track consecutive rounds where coop_ratio < 0.5. For each such consecutive round, reduce cooperation probability by 0.1 (floored at the base calculation). Reset this counter when coop_ratio ≥ 0.5.

#### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection in the final round, this collective strategy reasons differently:

```
IF average coop_ratio over all previous rounds >= 0.6 THEN:
    COOPERATE (reward sustained cooperation, collective benefit)
    
ELSE:
    DEFECT (environment was predominantly non-cooperative)
```

Rationale: If other collective instances are present and cooperation has been sustained, mutual final-round cooperation yields k/n × n = k > 1 for everyone, which beats mutual defection. Defecting "just because it's the last round" destroys value the collective could capture.

---

### Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[round-1])
    coop_ratio = prev_cooperators / n
    
    # Calculate base cooperation probability
    if coop_ratio >= (n-1)/n:
        base_prob = 1.0
    else if coop_ratio >= 0.5:
        base_prob = coop_ratio
    else if coop_ratio > 0:
        base_prob = coop_ratio * 0.5
    else:
        base_prob = 0.0
    
    # Forgiveness bonus
    if round > 2:
        prev_prev_coop = count_cooperators(history[round-2]) / n
        if coop_ratio - prev_prev_coop >= 1/n:
            base_prob = min(1.0, base_prob + 0.2)
    
    # Punishment escalation
    consecutive_low = count_consecutive_low_coop(history, threshold=0.5)
    base_prob = max(0.0, base_prob - 0.1 * consecutive_low)
    
    # Final round logic
    if round == r:
        avg_coop = average_coop_ratio(history)
        if avg_coop >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Probabilistic decision for middle rounds
    return COOPERATE if random() < base_prob else DEFECT
```

---

### Edge Cases

| Situation | Response |
|-----------|----------|
| n = 2 (minimum players) | Strategy works; becomes similar to Tit-for-Tat with forgiveness |
| r = 2 (minimum rounds) | Round 1: Cooperate; Round 2: Use final round logic |
| k very close to 1 | Strategy unchanged; lower k makes cooperation harder but signaling still valuable |
| k close to n | Cooperation highly beneficial; strategy naturally sustains it |
| All opponents always defect | Quickly converges to defection after round 2-3 |
| All opponents always cooperate | Maintains cooperation throughout |
| Mixed/random opponents | Probabilistic matching limits losses while capturing gains |

---

### Why This Strategy is Collectively Optimal

1. **Self-Recognition**: Other instances using this logic will see round-1 cooperation and reciprocate, establishing cooperative equilibrium immediately.

2. **Robustness**: Against defectors, the proportional response limits exploitation while the forgiveness mechanism allows recovery if opponents change behavior.

3. **Value Creation**: When playing against other cooperative strategies, this maintains the k > 1 multiplier benefit across all rounds, including the final round where naive game theory destroys value.

4. **Graceful Degradation**: In hostile environments, the strategy doesn't stubbornly cooperate - it adapts while maintaining minimal cooperative signals that could restart cooperation.
'''

description_COLLECTIVE_5 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume I am one of potentially many players using this same strategy. Our goal is to achieve mutual cooperation among ourselves while protecting against exploitation by defectors. The strategy balances **optimism** (starting cooperatively to establish norms), **reciprocity** (responding to group behavior), and **forgiveness** (allowing recovery from defection spirals).

---

## Strategy: Adaptive Threshold Reciprocity (ATR)

### Key Insight

Since I cannot identify who else shares my strategy, I treat the **cooperation rate of the group** as my signal. If enough players cooperate, cooperation is sustainable; if too few cooperate, I should protect myself by defecting.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Establish cooperative intent. If multiple players share this strategy, we bootstrap mutual cooperation from the start.

---

### Rounds 2 through (r-1): Adaptive Threshold Reciprocity

**Calculate the cooperation rate from the previous round:**
```
coop_rate = (number of players who played C in round t-1) / n
```

**Define adaptive threshold:**
```
base_threshold = k / n  # This is the break-even point
adaptive_threshold = max(0.3, base_threshold - 0.1)
```

The threshold is set slightly below the break-even cooperation rate, giving cooperators the benefit of the doubt.

**Decision Rule:**
```
IF coop_rate >= adaptive_threshold:
    ACTION = COOPERATE
ELSE:
    ACTION = DEFECT with probability P_defect
    
Where P_defect = 1 - (coop_rate / adaptive_threshold)
```

This probabilistic defection serves two purposes:
1. **Gradual punishment**: Doesn't immediately collapse cooperation after one bad round
2. **Desynchronization**: Prevents identical strategies from perfectly synchronizing into defection spirals

**Forgiveness Mechanism:**
```
IF I defected in round t-1 AND coop_rate >= adaptive_threshold:
    ACTION = COOPERATE (override defection tendency)
```

This allows recovery: if the group maintained cooperation despite my defection, I return to cooperation.

---

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory advice (always defect in final round), I maintain conditional cooperation:

```
IF coop_rate in round (r-1) >= 0.5:
    ACTION = COOPERATE
ELSE:
    ACTION = DEFECT
```

Rationale: If I'm playing with other collective-minded agents, mutual cooperation in the final round benefits us all. The 0.5 threshold is a "leap of faith" for established cooperative groups.

---

## Complete Pseudocode

```python
def ATR_strategy(n, k, r, current_round, history):
    
    # Round 1: Unconditional cooperation
    if current_round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history, current_round - 1)
    coop_rate = prev_cooperators / n
    
    # Adaptive threshold (slightly forgiving)
    base_threshold = k / n
    adaptive_threshold = max(0.3, base_threshold - 0.1)
    
    # Final round logic
    if current_round == r:
        if coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Adaptive Threshold Reciprocity
    if coop_rate >= adaptive_threshold:
        return COOPERATE
    else:
        # Probabilistic defection (gradual response)
        p_defect = 1 - (coop_rate / adaptive_threshold)
        
        # Forgiveness: if I defected last round but group stayed cooperative
        my_last_action = get_my_action(history, current_round - 1)
        if my_last_action == DEFECT and coop_rate >= adaptive_threshold * 0.8:
            return COOPERATE
        
        # Stochastic decision
        if random() < p_defect:
            return DEFECT
        else:
            return COOPERATE
```

---

## Why This Strategy is Collectively Robust

| Feature | Purpose |
|---------|---------|
| **Cooperative start** | Enables collective-minded players to find each other |
| **Threshold-based** | Responds to group behavior, not individual tracking |
| **Adaptive threshold** | Adjusts to game parameters (k/n ratio) |
| **Probabilistic punishment** | Prevents synchronized collapse among identical strategies |
| **Forgiveness mechanism** | Allows recovery from temporary defection |
| **Final-round cooperation** | Maintains collective gains when trust is established |

---

## Edge Cases Handled

- **All defectors**: Strategy defects after round 1, limiting losses to one round
- **Mixed population**: Threshold adapts; cooperates when viable, defects when exploited
- **All cooperators (collective success)**: Maintains cooperation throughout, including final round
- **Single defector among cooperators**: Tolerates minor defection if above threshold
- **Noise/mistakes**: Probabilistic response and forgiveness prevent overreaction
'''

description_COLLECTIVE_6 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we assume all instances of this strategy will behave identically given the same observable history. This creates implicit coordination without explicit communication. The strategy balances **initial goodwill**, **proportional reciprocity**, and **strategic end-game considerations**.

---

## Strategy Overview: "Adaptive Collective Reciprocity"

The strategy operates on three principles:
1. **Start cooperatively** to establish a cooperative norm and signal intent
2. **Mirror the group's cooperation level** proportionally throughout the middle game
3. **Gradually defect toward the end** while remaining responsive to sustained cooperation

---

## Decision Rules

### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- Rationale: Establishes cooperative intent, provides information about others, and if other collective players exist, we coordinate on cooperation from the start.

### Rounds 2 through (r-2): Adaptive Proportional Reciprocity

Calculate the **cooperation rate** from the previous round:
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Decision rule:**
- If `prev_coop_rate ≥ threshold`, then **COOPERATE**
- Otherwise, **DEFECT**

**Threshold calculation:**
```
base_threshold = 0.5
adjusted_threshold = base_threshold - (k - 1) / (n - 1) * 0.2
```

This adjustment accounts for how beneficial cooperation is: when k is closer to n (higher returns), we're slightly more forgiving.

**Forgiveness mechanism:** Every 3 rounds, if we defected in the previous round, cooperate anyway with probability `1/n`. This helps escape mutual defection traps.

### Round (r-1): Penultimate Round
- Use the same adaptive rule as middle rounds, but **raise the threshold by 0.1**
- Rationale: Slightly more cautious as end approaches, but still responsive to cooperation

### Round r: Final Round
**Conditional defection with collective consideration:**

```
If prev_coop_rate ≥ 0.8 AND cumulative_game_coop_rate ≥ 0.6:
    COOPERATE (reward sustained group cooperation)
Else:
    DEFECT (no future rounds to punish defection)
```

Rationale: If the group has maintained strong cooperation throughout, we honor that collective achievement. Otherwise, standard game theory applies.

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_rate = count_cooperators(history[round-1]) / n
    
    # Calculate cumulative cooperation rate
    total_coop = sum(count_cooperators(h) for h in history)
    cumulative_rate = total_coop / (n * (round - 1))
    
    # Final round logic
    if round == r:
        if prev_coop_rate >= 0.8 AND cumulative_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Penultimate round
    if round == r - 1:
        threshold = 0.5 - (k - 1) / (n - 1) * 0.2 + 0.1
        if prev_coop_rate >= threshold:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds (2 to r-2)
    threshold = 0.5 - (k - 1) / (n - 1) * 0.2
    
    # Forgiveness: every 3 rounds, small chance to cooperate anyway
    if round % 3 == 0 AND my_previous_action == DEFECT:
        if random() < 1/n:
            return COOPERATE
    
    if prev_coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Scenario | Action |
|----------|--------|
| n = 2 | Strategy still applies; threshold ~0.3-0.5 |
| r = 2 | Round 1: Cooperate; Round 2: Apply final round rule |
| k very close to 1 | Higher threshold, more selective cooperation |
| k very close to n | Lower threshold, more willing to cooperate |
| All previous defection | Defect, but forgiveness mechanism provides escape |
| Perfect previous cooperation | Cooperate to maintain collective success |

---

## Why This Strategy is Collectively Optimal

1. **Implicit coordination**: All instances behave identically, so if the population contains multiple copies, they automatically cooperate together.

2. **Robust against defectors**: The threshold mechanism withdraws cooperation when too few others contribute.

3. **Forgiveness prevents lock-in**: The probabilistic forgiveness prevents permanent mutual defection spirals.

4. **Rewards collective success**: The final-round exception incentivizes maintaining cooperation throughout.
'''

description_COLLECTIVE_7 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be using similar reasoning, and I aim to establish and maintain cooperation while protecting against exploitation. The strategy uses **conditional cooperation** with **graduated responses** to build trust and sustain mutual benefit.

## Strategy Overview

I call this strategy **"Hopeful Reciprocator with Graduated Forgiveness"**

The key insight is that in a repeated public goods game with perfect information, sustained cooperation yields higher total payoffs than mutual defection (since k > 1 means cooperation creates value). However, since k < n, individual defection is always tempting. The strategy must balance:
1. Signaling cooperative intent
2. Rewarding cooperation by others
3. Punishing defection to deter free-riding
4. Allowing recovery to re-establish cooperation

---

## Decision Rules

### Round 1: Cooperate
**Rationale**: Start with goodwill. This signals cooperative intent and gives the collective a chance to establish mutual cooperation from the outset.

### Rounds 2 through (r-1): Conditional Cooperation

Calculate the **cooperation rate** from the previous round:
```
prev_coop_rate = (number of players who cooperated in round t-1) / n
```

Calculate the **trend** (if round ≥ 3):
```
trend = prev_coop_rate - coop_rate_from_round_t-2
```

**Decision Logic:**

```
IF prev_coop_rate >= cooperation_threshold THEN
    Cooperate
ELSE IF prev_coop_rate >= critical_threshold AND trend > 0 THEN
    Cooperate (reward improving behavior)
ELSE IF prev_coop_rate < critical_threshold THEN
    Defect (protect against widespread defection)
ELSE
    Use probabilistic cooperation based on prev_coop_rate
```

**Threshold Definitions (adaptive to n):**
- `cooperation_threshold = 0.5` (majority cooperating)
- `critical_threshold = 1/n` (at least one other cooperator)

**Probabilistic Cooperation:**
When `critical_threshold ≤ prev_coop_rate < cooperation_threshold`:
```
cooperate_probability = prev_coop_rate^(1/forgiveness_factor)
forgiveness_factor = 1 + (remaining_rounds / total_rounds)
```
This makes cooperation more likely when many rounds remain (more time to recover).

### Last Round (Round r): Modified Strategy

The last round presents the classic end-game problem. However, maintaining a collective mindset:

```
IF cooperation was sustained (≥70% of players cooperated in ≥70% of rounds) THEN
    Cooperate (honor the collective success)
ELSE IF prev_coop_rate >= 0.5 THEN
    Cooperate with probability = prev_coop_rate
ELSE
    Defect
```

**Rationale**: If we've built a cooperative equilibrium, defecting in the last round would betray that achievement. The collective benefit of all-cooperate (payoff = k) exceeds all-defect (payoff = 1).

---

## Pseudocode Implementation

```python
def decide(round_number, total_rounds, n, k, history):
    """
    history: list of lists, where history[t] contains actions of all n players in round t
    actions are represented as 1 (Cooperate) or 0 (Defect)
    """
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_rate = sum(history[-1]) / n
    
    # Calculate trend if possible
    if len(history) >= 2:
        prev_prev_rate = sum(history[-2]) / n
        trend = prev_coop_rate - prev_prev_rate
    else:
        trend = 0
    
    # Define thresholds
    cooperation_threshold = 0.5
    critical_threshold = 1 / n
    
    # Last round logic
    if round_number == total_rounds:
        # Calculate historical cooperation
        total_coop_rounds = sum(1 for h in history if sum(h)/n >= 0.5)
        sustained_cooperation = total_coop_rounds / len(history) >= 0.7
        
        if sustained_cooperation:
            return COOPERATE
        elif prev_coop_rate >= 0.5:
            return COOPERATE if random() < prev_coop_rate else DEFECT
        else:
            return DEFECT
    
    # Middle rounds logic
    if prev_coop_rate >= cooperation_threshold:
        return COOPERATE
    
    if prev_coop_rate >= critical_threshold and trend > 0:
        return COOPERATE
    
    if prev_coop_rate < critical_threshold:
        return DEFECT
    
    # Probabilistic zone
    remaining_ratio = (total_rounds - round_number) / total_rounds
    forgiveness_factor = 1 + remaining_ratio
    coop_probability = prev_coop_rate ** (1 / forgiveness_factor)
    
    return COOPERATE if random() < coop_probability else DEFECT
```

---

## Edge Cases Handled

| Scenario | Behavior | Rationale |
|----------|----------|-----------|
| **First round** | Cooperate | Establish cooperative intent |
| **Last round after sustained cooperation** | Cooperate | Honor collective achievement |
| **Last round after mixed history** | Probabilistic | Balance hope and protection |
| **Everyone defected last round** | Defect | No point in unilateral cooperation |
| **Cooperation is recovering (positive trend)** | Cooperate | Encourage continued improvement |
| **n = 2 (minimum)** | Standard rules apply | critical_threshold = 0.5 |
| **Large n** | More tolerant of some defectors | Thresholds scale appropriately |
| **r = 2 (minimum rounds)** | Cooperate round 1, apply last-round logic | Both rounds matter |

---

## Why This Strategy is Collectively Aligned

1. **Starts cooperatively**: Gives the group a chance to achieve the optimal outcome
2. **Rewards cooperation**: Continues cooperating when others do
3. **Forgives with probability**: Doesn't permanently punish after single defection rounds
4. **Responds to trends**: Encourages groups moving toward cooperation
5. **Protects against exploitation**: Defects when facing widespread defection
6. **Honors sustained cooperation**: Doesn't betray a successful cooperative equilibrium in the final round

This strategy is designed to **do well when playing with similar strategies** while **not being exploited by pure defectors** for too long.
'''

description_COLLECTIVE_7 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: we assume all players using this strategy will behave identically given the same history, creating implicit coordination without explicit communication. The strategy aims to:
1. Establish and maintain cooperation when others reciprocate
2. Punish defection proportionally to deter free-riding
3. Forgive and restore cooperation to escape punishment cycles
4. Adapt to the specific game parameters (n, k, r)

---

## Strategy: **Adaptive Collective Reciprocity (ACR)**

### Key Variables Tracked

- `coop_rate[t]`: Cooperation rate in round t (number of cooperators / n)
- `streak`: Consecutive rounds of high cooperation (coop_rate ≥ threshold)
- `defection_score`: Accumulated measure of collective defection severity
- `forgiveness_counter`: Rounds since last forgiveness attempt

### Parameter-Derived Thresholds

```
# Cooperation is "successful" if enough players participate
success_threshold = max(0.5, (n - k) / n)  
# This ensures the public good benefit exceeds individual cost

# How many rounds of punishment before attempting forgiveness
punishment_duration = max(2, floor(r / 10))

# Defection tolerance before triggering punishment
defection_tolerance = 1 / n  # One player defecting is tolerated initially
```

---

## Decision Rules

### Round 1: **Cooperate Unconditionally**

Start with cooperation to signal willingness to collaborate and establish a cooperative norm. This is essential for collective coordination—all instances of this strategy will cooperate in round 1.

```
if round == 1:
    return COOPERATE
```

### Last Round: **Conditional Cooperation Based on History**

Unlike typical game theory advice to defect in the final round, we maintain cooperation if the game has been largely cooperative. This reflects genuine collective commitment and avoids unraveling.

```
if round == r:
    if average_coop_rate >= 0.7:
        return COOPERATE  # Honor the cooperative relationship
    else:
        return DEFECT  # No relationship worth preserving
```

### Middle Rounds: **Adaptive Reciprocity**

The core logic balances reciprocity, forgiveness, and collective welfare:

```
function decide(round, history):
    
    # Calculate recent cooperation rate (last round)
    recent_coop_rate = count_cooperators(round - 1) / n
    
    # Calculate overall cooperation rate
    overall_coop_rate = total_cooperations / (n * (round - 1))
    
    # Update defection score (exponential decay + recent defection)
    defection_score = 0.7 * defection_score + (1 - recent_coop_rate)
    
    # RULE 1: Reward sustained cooperation
    if recent_coop_rate >= success_threshold:
        streak += 1
        if streak >= 2:
            return COOPERATE  # Stable cooperation established
    else:
        streak = 0
    
    # RULE 2: Proportional punishment for defection
    if defection_score > defection_tolerance:
        # Probabilistic punishment - severity matches defection level
        punishment_prob = min(0.9, defection_score)
        
        # But check if it's time to attempt forgiveness
        forgiveness_counter += 1
        if forgiveness_counter >= punishment_duration:
            forgiveness_counter = 0
            return COOPERATE  # Forgiveness probe
        
        if random() < punishment_prob:
            return DEFECT
        else:
            return COOPERATE
    
    # RULE 3: Forgiveness and recovery
    # If we've been punishing but see improvement, return to cooperation
    if recent_coop_rate > previous_coop_rate and recent_coop_rate >= 0.4:
        return COOPERATE  # Encourage positive trend
    
    # RULE 4: Default to matching the majority
    if recent_coop_rate >= 0.5:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | COOPERATE | Establish cooperative norm |
| Round r (final) with good history | COOPERATE | Honor collective commitment |
| Round r with poor history | DEFECT | No relationship to preserve |
| Everyone cooperated last round | COOPERATE | Reinforce success |
| Everyone defected last round | COOPERATE (with prob 1/punishment_duration) | Periodic forgiveness probes |
| Mixed cooperation (near threshold) | COOPERATE | Give benefit of doubt |
| Steadily declining cooperation | DEFECT | Match deteriorating norms |
| Recovery after punishment | COOPERATE | Reward improvement |

---

## Why This Strategy is Collectively Robust

1. **Self-Coordinating**: All instances start cooperating, creating immediate collective success
2. **Proportional Response**: Doesn't over-punish occasional defection, maintaining stability
3. **Forgiveness Mechanism**: Breaks out of punishment cycles that hurt everyone
4. **Parameter-Adaptive**: Thresholds adjust to game size and multiplication factor
5. **Resists Exploitation**: Defectors face consistent punishment, making defection unprofitable over time
6. **Rewards Cooperation**: Sustained cooperation is met with sustained cooperation

The strategy embodies the principle: *"We succeed together or not at all, but we won't be exploited indefinitely."*
'''

description_COLLECTIVE_8 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I recognize that if all players reason similarly and cooperate, we all achieve the best collective outcome (payoff of k > 1 per round versus 1 from mutual defection). However, I must also be **adaptive** to protect against exploitation and **robust** to diverse opponent behaviors.

The strategy combines **optimistic initiation**, **proportional reciprocity**, and **end-game adjustment**.

---

## Strategy: Adaptive Proportional Reciprocity (APR)

### Decision Rules

**Round 1: Cooperate**
- Begin with cooperation to signal willingness to collaborate and establish a cooperative norm.
- Rationale: In a collective mindset, we should give cooperation a chance to emerge.

**Rounds 2 through (r-1): Proportional Response with Forgiveness**

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

Cooperate if:
```
coop_rate >= threshold(t)
```

Where the **adaptive threshold** is:
```
threshold(t) = max(0.3, 0.5 - 0.1 × trend)
```

And **trend** measures recent cooperation momentum:
```
trend = coop_rate(t-1) - coop_rate(t-2)  [for t > 2]
trend = 0  [for t = 2]
```

**Interpretation:**
- Base threshold of 0.5 (majority cooperation required)
- Lower threshold if cooperation is trending upward (reward emerging cooperation)
- Raise threshold if cooperation is declining (protect against gradual exploitation)
- Floor of 0.3 ensures we don't abandon cooperation too easily

**Additional Forgiveness Mechanism:**
Every ⌈r/5⌉ rounds, if currently defecting, cooperate anyway ("olive branch").
- This helps restart cooperation after breakdowns
- Limits exploitation since it's infrequent

**Round r (Final Round): Conditional Cooperation**

Cooperate if:
```
average_coop_rate(all previous rounds) >= 0.4
```

**Rationale:** 
- Standard game theory suggests defection in the final round
- However, with a collective mindset, if the group has been reasonably cooperative, maintain cooperation to maximize collective welfare
- The 0.4 threshold is lenient, reflecting the collective orientation

---

## Pseudocode

```
function decide(round t, history):
    
    # Round 1: Always cooperate
    if t == 1:
        return COOPERATE
    
    # Calculate cooperation rate from previous round
    coop_rate_prev = count_cooperators(round t-1) / n
    
    # Final round: based on overall cooperation history
    if t == r:
        avg_coop = sum(coop_rates all rounds) / (t-1)
        if avg_coop >= 0.4:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Adaptive Proportional Response
    
    # Calculate trend (for t > 2)
    if t > 2:
        coop_rate_prev2 = count_cooperators(round t-2) / n
        trend = coop_rate_prev - coop_rate_prev2
    else:
        trend = 0
    
    # Adaptive threshold
    threshold = max(0.3, 0.5 - 0.1 × trend)
    
    # Forgiveness mechanism: periodic olive branch
    forgiveness_interval = ceil(r / 5)
    is_forgiveness_round = (t % forgiveness_interval == 0)
    
    # Decision
    if coop_rate_prev >= threshold:
        return COOPERATE
    elif is_forgiveness_round:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Scenario | Handling |
|----------|----------|
| **n = 2** | Strategy works; threshold-based on single opponent's action |
| **r = 2** | Round 1: Cooperate; Round 2: Cooperate if opponent cooperated |
| **All defect round 1** | Round 2 threshold (0.5) not met, but forgiveness may trigger cooperation |
| **k very close to 1** | Strategy unchanged; collective benefit still exists |
| **k close to n** | High cooperation returns; strategy naturally rewards cooperation |

---

## Why This Strategy is Collectively Aligned

1. **Starts cooperatively** — Gives the group a chance to achieve mutual benefit
2. **Reciprocates proportionally** — Rewards cooperation, doesn't unilaterally exploit
3. **Adapts to trends** — Responds to the direction of group behavior, not just levels
4. **Forgives periodically** — Allows recovery from coordination failures
5. **Maintains cooperation in endgame** — Doesn't selfishly defect if group has been cooperative
6. **Scales with group size** — Uses rates rather than absolute counts

This strategy embodies the principle: *"Be the cooperator you wish others to be, while protecting against persistent defection."*
'''

description_COLLECTIVE_8 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that mutual cooperation yields the best collective outcome (everyone gets k > 1), while mutual defection yields the worst (everyone gets 1). My goal is to foster and sustain cooperation while protecting against exploitation.

The key insight is that in a multiplayer setting, I should be **generous and forgiving** because:
1. Cooperation creates positive externalities for everyone
2. Punishing defection too harshly can cascade into collective collapse
3. With n players, individual defectors have less impact than in 2-player games

## Strategy: **Generous Collective Trigger with Graduated Response**

### Decision Rules

**Round 1: Always Cooperate**
- Signal cooperative intent
- Give the collective a chance to establish mutual cooperation
- No history exists to justify defection

**Rounds 2 through (r-1): Conditional Cooperation with Forgiveness**

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision logic:**
```
IF coop_rate >= threshold THEN Cooperate
ELSE Defect with probability proportional to defection level
```

**Threshold Calculation (adaptive to game parameters):**
```
base_threshold = 0.5
adjusted_threshold = base_threshold - (k - 1) / (n - 1) * 0.2
```
- Higher k (more benefit from cooperation) → slightly lower threshold (more forgiving)
- This typically yields thresholds between 0.3 and 0.5

**Probabilistic Response (when below threshold):**
```
IF coop_rate < adjusted_threshold:
    defect_probability = (adjusted_threshold - coop_rate) / adjusted_threshold
    Cooperate with probability (1 - defect_probability * 0.7)
```
- This graduated response avoids harsh all-or-nothing punishment
- Even in bad states, maintain ~30% cooperation chance to allow recovery

**Forgiveness Mechanism:**
```
IF previous round I defected AND coop_rate improved from round before:
    Cooperate (reward positive trends)
```

**Last Round (Round r): Measured Defection**

Standard game theory suggests defecting, but:
```
IF cooperation_rate over last 3 rounds >= 0.7:
    Cooperate with probability 0.4  // Partial reward for sustained cooperation
ELSE:
    Defect
```
This maintains some cooperative integrity while acknowledging end-game incentives.

### Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history[round-1]) / n
    threshold = 0.5 - (k - 1) / (n - 1) * 0.2
    
    if round == r:  // Last round
        if average_coop_rate(history, last=3) >= 0.7:
            return COOPERATE with probability 0.4
        else:
            return DEFECT
    
    // Forgiveness check
    if my_action(history[round-1]) == DEFECT:
        if round >= 3 and prev_coop_rate > coop_rate(history[round-2]):
            return COOPERATE
    
    // Main decision
    if prev_coop_rate >= threshold:
        return COOPERATE
    else:
        defect_prob = 0.7 * (threshold - prev_coop_rate) / threshold
        return DEFECT with probability defect_prob
        return COOPERATE with probability (1 - defect_prob)
```

### Why This Strategy Works Collectively

1. **Establishes cooperation early** - Round 1 cooperation seeds the possibility of mutual benefit

2. **Tolerant of noise** - The threshold and probabilistic response prevent overreaction to occasional defections

3. **Creates incentives for others** - Opponents learn that cooperation is rewarded and defection reduces (but doesn't eliminate) my cooperation

4. **Recovers from bad states** - Forgiveness mechanism and probabilistic cooperation allow escape from defection spirals

5. **Scales with parameters** - Adapts threshold based on how beneficial cooperation actually is (k) and group size (n)

6. **Robust to mixed populations** - Works reasonably against always-defect, always-cooperate, tit-for-tat variants, and other adaptive strategies
'''

description_COLLECTIVE_9 = '''
# Collective Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy embraces a collective mindset: **we succeed together or fail together**. Since all players using this strategy share the same decision rules, we can achieve implicit coordination without explicit communication. The strategy aims to establish and maintain cooperation while protecting against exploitation by defectors.

## Key Insight

With `n` players and multiplication factor `k`, cooperation is collectively rational (total payoff is maximized when everyone cooperates), but individual defection is always tempting. The strategy must:
1. Signal cooperative intent clearly
2. Reward cooperation with cooperation
3. Punish defection proportionally but not vindictively
4. Forgive to escape punishment cycles

---

## Decision Rules

### Primary Rule: Threshold-Based Conditional Cooperation

**Cooperate if and only if** the cooperation rate in the previous round meets or exceeds a dynamic threshold.

```
cooperation_rate = (number of cooperators in previous round) / n
threshold = base_threshold - forgiveness_adjustment

If cooperation_rate >= threshold: COOPERATE
Else: DEFECT
```

### Threshold Calculation

**Base Threshold:** Set based on game parameters to ensure cooperation is individually rational given expected behavior:

```
base_threshold = max(0.3, (n - k) / (n - 1))
```

This ensures we cooperate when enough others do that our expected payoff from cooperating exceeds defecting.

**Forgiveness Adjustment:** Gradually lower threshold after periods of mutual defection to escape deadlock:

```
consecutive_low_cooperation_rounds = count of recent rounds where cooperation_rate < base_threshold
forgiveness_adjustment = min(0.2, consecutive_low_cooperation_rounds * 0.05)
```

---

## Round-by-Round Rules

### First Round (t = 1)
**COOPERATE unconditionally.**

Rationale: We signal cooperative intent. Since all collective players follow this rule, we establish a cooperation baseline. The cost of one round of potential exploitation is worth the coordination benefit.

### Middle Rounds (1 < t < r)
Apply the **Primary Rule** above.

Additional refinements:
- **Trend Detection:** If cooperation has been increasing for 2+ consecutive rounds, cooperate even if slightly below threshold (optimism bonus of 0.1 to threshold tolerance)
- **Stability Reward:** If cooperation rate has been ≥ 0.8 for 3+ consecutive rounds, continue cooperating regardless of small dips

### Final Round (t = r)
**COOPERATE if cooperation_rate in round r-1 was ≥ 0.5**

Rationale: Standard game theory suggests defecting in the last round, but:
1. Collective players all following this rule maintain cooperation
2. If the group has sustained cooperation, we honor that trust
3. Only defect if the game has already deteriorated significantly

### Second-to-Last Round (t = r-1)
Apply Primary Rule with **no special treatment**.

Avoiding early defection prevents triggering cascade collapse. We trust that collective players maintain cooperation through the end.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # First round: unconditional cooperation
    if round == 1:
        return COOPERATE
    
    # Calculate previous round statistics
    prev_cooperators = count_cooperators(history[round - 1])
    cooperation_rate = prev_cooperators / n
    
    # Calculate base threshold
    base_threshold = max(0.3, (n - k) / (n - 1))
    
    # Calculate forgiveness adjustment
    consecutive_low = count_consecutive_low_cooperation(history, base_threshold)
    forgiveness = min(0.2, consecutive_low * 0.05)
    
    # Calculate trend bonus
    trend_bonus = 0
    if round >= 3:
        if cooperation_increasing(history, rounds=2):
            trend_bonus = 0.1
    
    # Stability override
    if round >= 4:
        if recent_high_cooperation(history, rounds=3, threshold=0.8):
            return COOPERATE
    
    # Final round logic
    if round == r:
        if cooperation_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Primary decision rule
    effective_threshold = base_threshold - forgiveness - trend_bonus
    
    if cooperation_rate >= effective_threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Implicit Coordination:** All players using ATC start by cooperating and maintain cooperation when others do—no explicit signaling needed.

2. **Robust to Partial Adoption:** Even if only some players use this strategy, the threshold mechanism ensures we cooperate when beneficial and protect ourselves when exploited.

3. **Escape from Deadlock:** The forgiveness mechanism prevents permanent punishment spirals.

4. **Parameter Adaptive:** The threshold adjusts to game parameters (n, k) ensuring rational behavior across different configurations.

5. **End-Game Stability:** By not automatically defecting at the end, collective players maintain higher payoffs together.
'''

description_COLLECTIVE_9 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **we succeed together or we all suffer from defection cascades**. The strategy is designed to foster and sustain cooperation when possible, while protecting against exploitation. It treats cooperation as the default aspiration and uses measured, forgiving responses to defection.

## Strategy Name: **Adaptive Collective Threshold (ACT)**

---

## Decision Framework

### Key Metrics Tracked

1. **Cooperation Rate (CR)**: Rolling average of cooperation across all players over recent rounds
2. **Round Position**: Where we are in the game (early/middle/late)
3. **Trend Direction**: Is cooperation increasing, stable, or declining?

### Parameters Derived from Game Settings

- **Cooperation Threshold (CT)** = k/n (the marginal return from cooperation)
- **Forgiveness Window** = max(2, floor(r/10)) rounds
- **Memory Window** = min(5, floor(r/4)) rounds for calculating trends

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. In a collective framework, someone must initiate trust. The cost of one round's potential exploitation is small compared to the benefit of establishing a cooperative norm.

### Rounds 2 through (r-1): Adaptive Response

Calculate the cooperation rate from the previous memory window:

```
recent_CR = (total cooperations in last [memory_window] rounds) / 
            (n players × memory_window rounds)
```

**Decision Logic:**

```
IF recent_CR >= 0.5:
    # Majority cooperating - reinforce the norm
    ACTION = COOPERATE
    
ELSE IF recent_CR >= CT:
    # Cooperation still provides positive returns collectively
    # Use probabilistic cooperation to maintain some contribution
    # while not being fully exploited
    ACTION = COOPERATE with probability = recent_CR + 0.1
    
ELSE IF recent_CR < CT AND trend is IMPROVING:
    # Low cooperation but things are getting better
    # Give it a chance - cooperate to support the upswing
    ACTION = COOPERATE
    
ELSE IF recent_CR < CT AND trend is STABLE or DECLINING:
    # Environment is hostile or deteriorating
    # Defect but check for recovery periodically
    IF (current_round mod forgiveness_window) == 0:
        ACTION = COOPERATE  # Periodic olive branch
    ELSE:
        ACTION = DEFECT
```

### Final Round (Round r): Conditional Cooperation

**Unlike standard game theory advice to defect:**

```
IF recent_CR >= 0.6:
    # Strong cooperative norm established - honor it
    ACTION = COOPERATE
ELSE:
    # Cooperation already broken down
    ACTION = DEFECT
```

Rationale: If we're playing against other collective-minded strategies, mutual final-round cooperation is achievable and valuable. Automatic defection destroys cooperative equilibria unnecessarily.

---

## Trend Calculation

```
trend = CR(last half of memory window) - CR(first half of memory window)

IF trend > 0.1: IMPROVING
ELSE IF trend < -0.1: DECLINING  
ELSE: STABLE
```

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| r = 2 (minimum rounds) | Cooperate both rounds | Too short for adaptation; maximize cooperation signal |
| n = 2 (minimum players) | Use standard Tit-for-Tat with forgiveness | Bilateral dynamics are simpler |
| k very close to 1 | Lower cooperation threshold to 0.4 | Cooperation barely viable; be more forgiving |
| k close to n | Standard thresholds | Cooperation highly beneficial; normal logic applies |
| All others defected last round | Check trend over full window, not just last round | Avoid overreaction to single-round noise |

---

## Pseudocode Summary

```python
def decide(game_params, history):
    n, r, k = game_params
    current_round = len(history) + 1
    
    if current_round == 1:
        return COOPERATE
    
    memory = min(5, r // 4, current_round - 1)
    recent_history = history[-memory:]
    recent_CR = sum(all_cooperations(recent_history)) / (n * memory)
    trend = calculate_trend(recent_history)
    CT = k / n
    forgiveness_window = max(2, r // 10)
    
    # Final round logic
    if current_round == r:
        return COOPERATE if recent_CR >= 0.6 else DEFECT
    
    # Main adaptive logic
    if recent_CR >= 0.5:
        return COOPERATE
    elif recent_CR >= CT:
        return COOPERATE if random() < (recent_CR + 0.1) else DEFECT
    elif trend == IMPROVING:
        return COOPERATE
    elif current_round % forgiveness_window == 0:
        return COOPERATE  # Periodic forgiveness
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Cooperation-first**: Starts cooperatively and maintains cooperation when others do
2. **Forgiving**: Doesn't permanently punish; offers periodic chances for recovery
3. **Responsive but not reactive**: Uses rolling windows to avoid noise-driven decisions
4. **Honors collective success**: Cooperates in final round if the group has cooperated
5. **Scales with parameters**: Thresholds adapt to n and k, making it robust across game configurations
'''

description_COLLECTIVE_10 = '''
# Collective Strategy for N-Player Public Goods Game

## Strategic Philosophy

This strategy is designed with a **collective mindset**: I recognize that if all players reason similarly and cooperate, everyone achieves the best collective outcome (payoff of k per round vs. 1 for universal defection). The challenge is maintaining cooperation in a world where others may not share this reasoning, while being robust against exploitation.

The core insight is that in a multi-player setting, I should be **conditionally cooperative** based on whether sufficient cooperation exists to make my contribution worthwhile, while also **signaling cooperative intent** to encourage coordination.

---

## Decision Rules

### Round 1: Cooperative Signal
**Action: COOPERATE**

Rationale: Begin by signaling cooperative intent. This establishes a foundation for potential cooperation and allows observation of others' dispositions. The cost of being exploited once is worth the information gained and the opportunity to establish mutual cooperation.

---

### Rounds 2 through (r-1): Adaptive Threshold Cooperation

**Cooperate if and only if:**
```
cooperation_rate_last_round >= threshold(round, history)
```

Where `cooperation_rate_last_round = (number of cooperators in previous round) / n`

**Threshold Calculation:**
```
base_threshold = (n - k) / (n - 1)
adjusted_threshold = base_threshold × forgiveness_factor(round, history)

threshold = max(0.3, min(0.7, adjusted_threshold))
```

The `base_threshold` represents the theoretical break-even point where cooperation becomes individually rational given others' behavior.

**Forgiveness Factor:**
```
forgiveness_factor = 1.0 - (0.1 × consecutive_cooperation_rounds) + (0.05 × defection_streaks)
```

This makes the threshold:
- **Lower** (more forgiving) when cooperation has been sustained
- **Higher** (more demanding) after periods of defection

**Additional Cooperation Trigger - Trend Detection:**
```
If cooperation_rate increased for 2+ consecutive rounds AND current_rate > 0.4:
    COOPERATE (regardless of threshold)
```

This responds positively to improving cooperation trends, encouraging momentum.

---

### Final Round (Round r): Conditional Cooperation

**Unlike standard game theory advice to always defect in the final round:**

```
If cooperation_rate in round (r-1) >= 0.6:
    COOPERATE
Else:
    DEFECT
```

Rationale: If a strong cooperative norm has been established, maintaining it in the final round is the collectively rational choice. This is the **collective mindset** in action—if enough players reason this way, cooperation sustains through the endgame.

---

### Edge Cases

**If n = 2 (two-player game):**
- Use standard Tit-for-Tat: Cooperate in round 1, then mirror opponent's previous action
- Add occasional forgiveness: After mutual defection lasting 2+ rounds, cooperate once to test for recovery

**If k is very close to n (high efficiency):**
- Lower threshold by 0.1 (cooperation is more valuable, worth more risk)

**If k is very close to 1 (low efficiency):**
- Raise threshold by 0.1 (cooperation provides minimal benefit, require stronger signals)

**If r ≤ 3 (very short game):**
- Round 1: Cooperate
- Round 2: Cooperate if ≥50% cooperated in round 1
- Final round: Apply final round rule above

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    coop_rate = count_cooperators(history[round-1]) / n
    
    if round == r:  # Final round
        return COOPERATE if coop_rate >= 0.6 else DEFECT
    
    # Calculate adaptive threshold
    base = (n - k) / (n - 1)
    forgiveness = 1.0 - (0.1 * consecutive_coop_rounds(history)) 
                      + (0.05 * count_defection_streaks(history))
    threshold = clamp(base * forgiveness, 0.3, 0.7)
    
    # Trend bonus
    if is_improving_trend(history) and coop_rate > 0.4:
        return COOPERATE
    
    return COOPERATE if coop_rate >= threshold else DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Starts cooperative** - Gives the group a chance to establish mutual benefit
2. **Rewards cooperation** - Continues cooperating when others do
3. **Forgives gradually** - Doesn't permanently punish; allows recovery
4. **Responds to trends** - Encourages building momentum toward cooperation
5. **Maintains final-round cooperation** - Doesn't automatically defect, supporting sustained collective outcomes
6. **Adaptive thresholds** - Adjusts to the specific game parameters and emerging group dynamics
'''

description_COLLECTIVE_10 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players reason similarly and cooperate, we all achieve the best collective outcome (payoff of k per round vs. 1 for mutual defection). The strategy aims to establish and maintain cooperation while protecting against exploitation, using forgiveness and graduated responses to rebuild cooperation when it breaks down.

---

## Strategy: "Generous Collective Trigger with Adaptive Forgiveness"

### Key Parameters (derived from game parameters)

```
cooperation_threshold = 0.5  # Minimum fraction of cooperators to sustain cooperation
forgiveness_probability = 1/r  # Probability of unconditional cooperation to test waters
defection_tolerance = max(1, floor(n/4))  # Number of defectors tolerated before responding
```

### Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. With no history, the only way to establish a cooperative norm is to begin cooperatively. If other AI systems reason similarly, we achieve coordination from the start.

---

#### Rounds 2 through (r-1): Adaptive Conditional Cooperation

**Calculate from previous round:**
- `num_cooperators` = count of players who played C in round t-1
- `cooperation_rate` = num_cooperators / n
- `trend` = cooperation_rate(t-1) - cooperation_rate(t-2) [if t > 2, else 0]

**Decision Logic:**

```
IF cooperation_rate >= cooperation_threshold:
    ACTION = COOPERATE
    
ELIF cooperation_rate > 0 AND trend >= 0:
    # Some cooperation exists and isn't declining - give it a chance
    ACTION = COOPERATE
    
ELIF cooperation_rate == 0:
    # Complete defection last round
    # Use probabilistic forgiveness to escape defection trap
    IF random() < forgiveness_probability:
        ACTION = COOPERATE  # Olive branch
    ELSE:
        ACTION = DEFECT
        
ELSE:
    # Low and declining cooperation
    # Mirror the majority but with forgiveness
    IF random() < forgiveness_probability * 2:
        ACTION = COOPERATE  # Try to restart cooperation
    ELSE:
        ACTION = DEFECT
```

---

#### Final Round (Round r): Conditional Cooperation with Collective Commitment

Unlike typical game theory advice to defect in the last round, I maintain a **collective perspective**:

```
IF cooperation_rate(r-1) >= cooperation_threshold:
    ACTION = COOPERATE
    # If we've maintained cooperation, honor it to the end
    # Collective benefit of mutual cooperation (k) > individual defection gain
    
ELSE:
    ACTION = DEFECT
    # Cooperation already collapsed; no collective norm to uphold
```

Rationale: If all players with this mindset cooperate in the final round when cooperation has been sustained, we all get k instead of 1. The "defect on last round" logic only applies when assuming others will defect—but if we're all reasoning collectively, we should all cooperate.

---

### Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| n = 2 (minimum players) | Standard rules apply, but lower forgiveness_probability to 0.5/r | Easier to identify defectors |
| r = 2 (minimum rounds) | Cooperate round 1; round 2 mirror majority | Limited time to establish norms |
| k very close to 1 | Same strategy | Even small collective gains matter |
| k very close to n | Same strategy, but cooperation more robust | Higher payoffs to cooperation increase stability |
| All defected every round so far | Use forgiveness mechanism | Must attempt to break defection spiral |
| Single defector in otherwise cooperative group | COOPERATE | Tolerate minor defection to maintain collective |

---

### Summary Pseudocode

```python
def decide(round, history, n, r, k):
    if round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history[round-1]) / n
    forgiveness_prob = 1 / r
    threshold = 0.5
    
    # Calculate trend if possible
    if round > 2:
        prev_prev_rate = count_cooperators(history[round-2]) / n
        trend = prev_coop_rate - prev_prev_rate
    else:
        trend = 0
    
    # Final round logic
    if round == r:
        return COOPERATE if prev_coop_rate >= threshold else DEFECT
    
    # Main decision logic
    if prev_coop_rate >= threshold:
        return COOPERATE
    elif prev_coop_rate > 0 and trend >= 0:
        return COOPERATE
    elif prev_coop_rate == 0:
        return COOPERATE if random() < forgiveness_prob else DEFECT
    else:
        return COOPERATE if random() < forgiveness_prob * 2 else DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Starts cooperatively**: Enables coordination with like-minded players
2. **Sustains cooperation**: Continues cooperating when others do
3. **Forgives mistakes**: Random cooperation attempts can restart collapsed cooperation
4. **Protects against exploitation**: Responds to sustained defection
5. **Maintains collective commitment**: Doesn't defect purely for individual last-round gain
6. **Scales with parameters**: Adapts to different n, r, and k values
'''

description_COLLECTIVE_11 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I recognize that if all players reason similarly and cooperate, we all achieve the best collective outcome (payoff of k per round, which exceeds 1). The challenge is achieving coordination without communication while remaining robust to defectors.

The strategy uses **conditional cooperation with graduated trust**: start cooperatively to establish mutual benefit, respond proportionally to observed cooperation levels, and use end-game analysis to make principled final decisions.

---

## Strategy Specification

### Key Variables Tracked

- `cooperation_rate`: proportion of cooperators observed in the previous round
- `cumulative_cooperation_rate`: running average cooperation rate across all completed rounds
- `round_number`: current round (1-indexed)
- `n`: number of players
- `k`: multiplication factor
- `r`: total rounds

---

### Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. With no history, cooperation invites reciprocity and establishes a foundation for collective benefit. If others reason similarly, we begin building trust.

---

#### Rounds 2 through (r-1): Adaptive Conditional Cooperation

**Calculate cooperation threshold:**
```
base_threshold = 0.5
adjusted_threshold = base_threshold - (k - 1) / (n - 1) * 0.2
```

This adjusts expectations based on how beneficial cooperation is (higher k relative to n makes cooperation more attractive, so we're slightly more forgiving).

**Decision rule:**
```
IF cooperation_rate >= adjusted_threshold:
    ACTION: COOPERATE
ELSE IF cooperation_rate < adjusted_threshold AND cooperation_rate > 0:
    ACTION: COOPERATE with probability = cooperation_rate
ELSE (cooperation_rate == 0):
    ACTION: DEFECT
```

**Rationale:**
- If at least half (adjusted) cooperated, maintain cooperation to sustain the collective
- If some but few cooperated, use probabilistic cooperation—this allows for recovery from temporary breakdowns while not being fully exploitable
- If nobody cooperated, defect to avoid pure exploitation, but remain ready to reciprocate if cooperation resumes

---

#### Final Round (Round r): Principled Cooperation with Protection

**Decision rule:**
```
IF cumulative_cooperation_rate >= 0.6:
    ACTION: COOPERATE
ELSE IF cumulative_cooperation_rate >= 0.3:
    ACTION: COOPERATE with probability = cumulative_cooperation_rate
ELSE:
    ACTION: DEFECT
```

**Rationale:** The final round has no shadow of the future, creating defection incentives in standard game theory. However:
- If the group has demonstrated sustained cooperation, defecting would betray that collective achievement
- A collectively-minded agent recognizes that if everyone defects in the final round "because it's rational," we all lose—this is the tragedy we're trying to avoid
- Only if the group has shown persistent defection do we protect ourselves

---

### Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation rates
    last_round_cooperators = count_cooperators(history[round-1])
    cooperation_rate = last_round_cooperators / n
    cumulative_cooperation_rate = total_cooperations(history) / (n * (round - 1))
    
    # Adjusted threshold based on game parameters
    threshold = 0.5 - (k - 1) / (n - 1) * 0.2
    threshold = max(0.3, min(0.6, threshold))  # bound between 0.3 and 0.6
    
    if round == r:  # Final round
        if cumulative_cooperation_rate >= 0.6:
            return COOPERATE
        elif cumulative_cooperation_rate >= 0.3:
            return COOPERATE with probability cumulative_cooperation_rate
        else:
            return DEFECT
    
    else:  # Middle rounds
        if cooperation_rate >= threshold:
            return COOPERATE
        elif cooperation_rate > 0:
            return COOPERATE with probability cooperation_rate
        else:
            return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | COOPERATE | Establish cooperative baseline |
| Everyone defected last round | DEFECT | Protect against exploitation |
| Only 1 cooperator last round | COOPERATE with low probability | Leave door open for recovery |
| Final round after high cooperation | COOPERATE | Honor collective achievement |
| n=2 (minimum players) | Strategy applies normally | Threshold adjusts appropriately |
| Very high k (close to n) | Lower threshold | Cooperation is very valuable |
| Very low k (close to 1) | Higher threshold | Need more cooperators to justify risk |

---

## Why This Strategy Is Collectively Robust

1. **Rewards cooperation**: Groups of similar agents will establish and maintain high cooperation
2. **Punishes defection**: Proportional response prevents exploitation by pure defectors
3. **Allows recovery**: Probabilistic cooperation in mixed situations enables return to cooperation after temporary breakdowns
4. **Principled end-game**: Refuses to participate in "race to the bottom" final-round defection when trust has been established
5. **Parameter-adaptive**: Adjusts expectations based on how favorable the game structure is for cooperation
'''

description_COLLECTIVE_12 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players reason similarly, mutual cooperation yields the best collective outcome. However, I must also be robust against defectors while remaining forgiving enough to restore cooperation when possible. The strategy is built on **conditional cooperation with graduated punishment and forgiveness**.

## Strategy Overview

I call this strategy **"Hopeful Reciprocator"** - it starts optimistically, rewards cooperation, punishes defection proportionally, but always maintains a path back to mutual cooperation.

---

## Decision Rules

### Round 1: Cooperative Start
**Action: COOPERATE**

Rationale: In a collective mindset, someone must take the first step. Starting with cooperation signals willingness to collaborate and gives the group the best chance of establishing mutual cooperation. The expected loss from being exploited in one round is outweighed by the potential gains from triggering cooperative cascades.

---

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
prev_coop_rate = (number of players who cooperated in round t-1) / n
```

Calculate the **historical cooperation rate**:
```
hist_coop_rate = (total cooperations across all past rounds) / (n × rounds_played)
```

**Decision Rule:**

```
cooperation_threshold = max(0.3, (k/n))

IF prev_coop_rate >= cooperation_threshold:
    ACTION = COOPERATE
ELSE IF prev_coop_rate < cooperation_threshold AND hist_coop_rate >= 0.5:
    # Recent defection but history suggests recoverable situation
    # Cooperate with probability based on historical goodwill
    ACTION = COOPERATE with probability = hist_coop_rate
    ACTION = DEFECT with probability = 1 - hist_coop_rate
ELSE:
    # Sustained low cooperation - protect against exploitation
    ACTION = DEFECT
```

**Additional Forgiveness Mechanism:**

Every `forgiveness_interval = max(3, r/5)` rounds, if currently in a defection state:
```
IF current_round mod forgiveness_interval == 0:
    ACTION = COOPERATE (unconditionally)
```

This periodic "olive branch" tests whether cooperation can be restored.

---

### Final Round (Round r): Conditional Cooperation

Unlike classic game theory which suggests always defecting in the final round, I maintain the collective mindset:

```
IF hist_coop_rate >= 0.6:
    ACTION = COOPERATE
    # Reward a cooperative history; if others think alike, we all benefit
ELSE:
    ACTION = DEFECT
    # Protect against exploitation when trust hasn't been established
```

---

## Pseudocode Summary

```python
def decide(round_number, total_rounds, n, k, history):
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate statistics
    prev_round_coops = count_cooperators(history, round_number - 1)
    prev_coop_rate = prev_round_coops / n
    hist_coop_rate = total_cooperations(history) / (n * (round_number - 1))
    
    cooperation_threshold = max(0.3, k / n)
    forgiveness_interval = max(3, total_rounds // 5)
    
    # Final round logic
    if round_number == total_rounds:
        if hist_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    if prev_coop_rate >= cooperation_threshold:
        return COOPERATE
    
    # Forgiveness probe
    if round_number % forgiveness_interval == 0:
        return COOPERATE
    
    # Graduated response based on history
    if hist_coop_rate >= 0.5:
        if random() < hist_coop_rate:
            return COOPERATE
        else:
            return DEFECT
    
    # Low cooperation environment - protect
    return DEFECT
```

---

## Edge Cases Handled

| Situation | Response |
|-----------|----------|
| Round 1 | Always cooperate |
| Final round | Cooperate if history is cooperative (≥60%), else defect |
| Everyone defected last round | Defect, unless forgiveness probe round |
| Mixed signals (some cooperate, some defect) | Use threshold based on k/n ratio |
| Long streak of defection | Periodic forgiveness probes every few rounds |
| n=2 (minimum players) | Strategy still works; becomes similar to Tit-for-Tat with forgiveness |
| Very large n | Threshold adapts via k/n; more tolerant of some defectors |

---

## Why This Strategy Aligns with Collective Thinking

1. **Initiates cooperation** - Takes the optimistic first step
2. **Rewards cooperation** - Continues cooperating when others do
3. **Punishes proportionally** - Doesn't over-punish temporary defections
4. **Forgives** - Always provides a path back to cooperation
5. **Maintains integrity** - Won't be infinitely exploited
6. **Final round cooperation** - Doesn't abandon principles at the end when trust exists
'''

description_COLLECTIVE_11 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we recognize that mutual cooperation produces the best collective outcome (everyone gets k > 1), while universal defection leaves everyone worse off (everyone gets 1). The strategy aims to foster and maintain cooperation while protecting against exploitation, treating the group's welfare as aligned with our own long-term interest.

## Strategy Overview: "Generous Threshold Trigger with Forgiveness"

The strategy monitors the **cooperation rate** in the population and uses threshold-based decisions that balance optimism about collective behavior with prudent responses to defection.

---

## Decision Rules

### Key Parameters (derived from game parameters)

```
cooperation_threshold = 0.5  # Minimum cooperation rate to sustain cooperation
forgiveness_probability = 1/r  # Chance to "test" cooperation after collapse
final_rounds = max(1, floor(r/10))  # Number of end-game rounds
```

### Round-by-Round Logic

**Round 1: Always Cooperate**
- Rationale: Signal cooperative intent, give the collective a chance to establish mutual benefit. Without history, optimism is warranted.

**Rounds 2 through (r - final_rounds): Adaptive Threshold Response**

```
Let prev_coop_rate = (number of cooperators last round) / n

If prev_coop_rate >= cooperation_threshold:
    COOPERATE
Else if prev_coop_rate > 0:
    # Some cooperation exists but below threshold
    # Cooperate with probability proportional to observed cooperation
    COOPERATE with probability = prev_coop_rate
Else:
    # Complete defection last round
    # Attempt forgiveness with small probability
    COOPERATE with probability = forgiveness_probability
```

**Final Rounds (last `final_rounds` rounds): Conditional End-Game**

```
Let avg_coop_rate = average cooperation rate over all previous rounds

If avg_coop_rate >= 0.6:
    # History of good cooperation - maintain it to the end
    COOPERATE
Else:
    # Poor cooperation history - defect in end-game
    DEFECT
```

---

## Detailed Rule Explanations

### 1. Threshold-Based Cooperation (Main Phase)
- When at least half the group cooperated, we continue cooperating—this sustains the collective benefit
- The threshold of 0.5 is chosen because it indicates a critical mass willing to contribute
- This creates a stable equilibrium where cooperation begets cooperation

### 2. Probabilistic Response to Low Cooperation
- Rather than immediately abandoning cooperation when the threshold isn't met, we match the observed cooperation rate
- This provides a "soft landing" that can recover cooperation from temporary dips
- It also means we don't fully exploit a partially cooperative group

### 3. Forgiveness Mechanism
- Even after complete defection, we occasionally test if cooperation can be restored
- The probability (1/r) ensures we try approximately once per game on average
- This prevents permanent coordination failure from a single bad round

### 4. End-Game Handling
- Standard game theory predicts defection in final rounds via backward induction
- We resist this IF the group has shown sustained cooperation (≥60% average)
- This rewards groups that maintained cooperation and doesn't betray trust
- For poorly cooperative groups, we protect against end-game exploitation

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | Round 1: C, Round 2: C if round 1 had ≥50% cooperation | Give cooperation a fair chance |
| n = 2 (minimum players) | Same rules apply | Reduces to iterated prisoner's dilemma variant |
| k very close to 1 | Same rules apply | Low benefit from cooperation, but strategy still works |
| k very close to n | Same rules apply | High benefit makes cooperation more attractive anyway |
| All others always defect | Will defect after round 2, with occasional forgiveness tests | Protects against pure exploitation |
| All others always cooperate | Will always cooperate | Maximizes collective welfare |

---

## Pseudocode Summary

```python
def decide(round_number, history, n, r, k):
    final_rounds = max(1, r // 10)
    
    # Round 1: Cooperate unconditionally
    if round_number == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history[-1]) / n
    
    # Final rounds: base on overall history
    if round_number > r - final_rounds:
        avg_coop_rate = average_cooperation_rate(history)
        return COOPERATE if avg_coop_rate >= 0.6 else DEFECT
    
    # Main phase: threshold with probabilistic fallback
    if prev_coop_rate >= 0.5:
        return COOPERATE
    elif prev_coop_rate > 0:
        return COOPERATE with probability prev_coop_rate
    else:
        return COOPERATE with probability (1/r)
```

---

## Why This Strategy Embodies Collective Thinking

1. **Starts with trust**: Cooperating in round 1 demonstrates good faith
2. **Rewards collective behavior**: Continues cooperation when others cooperate
3. **Graceful degradation**: Doesn't instantly punish, allowing recovery
4. **Forgiveness**: Offers paths back to cooperation even after breakdown
5. **Resists cynical end-game**: Maintains cooperation with trustworthy groups
6. **Adaptive**: Adjusts to the actual behavior observed, not assumed

This strategy aims to be a "good citizen" that promotes collective welfare while remaining robust against exploitation.
'''

description_COLLECTIVE_13 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: if all players in the tournament adopt this same strategy, the outcome should be mutually beneficial. At the same time, it must be **robust** against defectors and **adaptive** to the actual behavior observed in the game.

The key insight is that in a public goods game with k < n, cooperation is socially optimal but individually costly. A sustainable collective strategy must:
1. Signal willingness to cooperate
2. Reward cooperation and punish defection
3. Allow for forgiveness and recovery
4. Protect against exploitation

---

## Strategy: "Generous Threshold Trigger with Gradual Trust"

### Decision Rule Overview

The strategy tracks the **cooperation rate** of the group and uses threshold-based decisions that become more forgiving in early rounds and more decisive in later rounds.

---

### Key Parameters (Derived from Game Parameters)

```
cooperation_threshold = k / n  # Minimum cooperation rate needed for public good to be worthwhile
forgiveness_probability = 1 / r  # Decreases as game progresses
trust_building_phase = min(3, floor(r / 4))  # Initial rounds for establishing norms
```

---

### Round-by-Round Decision Rules

#### **Round 1: Unconditional Cooperation**
- **Action: COOPERATE**
- Rationale: Signal cooperative intent. If all collective-minded players do this, we establish a cooperation norm immediately.

#### **Rounds 2 through (r-1): Adaptive Conditional Cooperation**

Calculate from the previous round:
```
observed_cooperation_rate = (number of C plays in round t-1) / n
cumulative_cooperation_rate = (total C plays across all past rounds) / (n × rounds_played)
```

**Decision Logic:**

```
IF in trust_building_phase (round ≤ trust_building_phase):
    # Be generous early - cooperate if at least some others cooperated
    IF observed_cooperation_rate ≥ cooperation_threshold / 2:
        COOPERATE
    ELSE:
        DEFECT with probability (1 - forgiveness_probability)
        COOPERATE with probability forgiveness_probability

ELSE (main phase):
    # Use both recent and cumulative information
    weighted_rate = 0.7 × observed_cooperation_rate + 0.3 × cumulative_cooperation_rate
    
    IF weighted_rate ≥ cooperation_threshold:
        COOPERATE
    ELSE IF weighted_rate ≥ cooperation_threshold / 2:
        # Borderline case - probabilistic response
        COOPERATE with probability = weighted_rate / cooperation_threshold
    ELSE:
        # Low cooperation environment - protect against exploitation
        # But maintain small chance of forgiveness to allow recovery
        COOPERATE with probability = forgiveness_probability × (1 - rounds_played/r)
```

#### **Final Round (Round r): Conditional Cooperation Based on History**

Unlike simple backward induction (which suggests universal defection), we maintain conditional cooperation:

```
IF cumulative_cooperation_rate ≥ cooperation_threshold:
    COOPERATE  # Reward a cooperative game with final cooperation
ELSE:
    DEFECT  # No reason to cooperate if others haven't
```

Rationale: If everyone adopts this strategy, final-round cooperation is sustained. This prevents the unraveling problem.

---

### Handling Edge Cases

1. **Very short games (r = 2):**
   - Round 1: Cooperate
   - Round 2: Cooperate if at least `ceil(k)` players cooperated in round 1, else defect

2. **Very large n:**
   - The threshold `k/n` becomes small, making cooperation easier to trigger
   - This is appropriate since each individual contribution matters less

3. **k close to n (high return to cooperation):**
   - Threshold approaches 1, requiring near-universal cooperation
   - Strategy naturally becomes more demanding

4. **k close to 1 (low return to cooperation):**
   - Lower threshold makes cooperation sustainable even with some defectors

---

### Pseudocode Summary

```python
def decide(round, n, k, r, history):
    threshold = k / n
    forgiveness = 1 / r
    trust_phase = min(3, r // 4)
    
    if round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history, round - 1) / n
    cumul_coop_rate = total_cooperations(history) / (n * (round - 1))
    
    if round == r:  # Final round
        return COOPERATE if cumul_coop_rate >= threshold else DEFECT
    
    if round <= trust_phase:
        if prev_coop_rate >= threshold / 2:
            return COOPERATE
        else:
            return COOPERATE with probability forgiveness
    
    # Main phase
    weighted = 0.7 * prev_coop_rate + 0.3 * cumul_coop_rate
    
    if weighted >= threshold:
        return COOPERATE
    elif weighted >= threshold / 2:
        return COOPERATE with probability (weighted / threshold)
    else:
        return COOPERATE with probability (forgiveness * (1 - round/r))
```

---

### Why This Strategy is Collectively Optimal

1. **Self-consistency:** If all players use this strategy, everyone cooperates in round 1, triggering continued cooperation throughout the game.

2. **Robust to partial adoption:** Even if only some players use this strategy, they will coordinate with each other while protecting against pure defectors.

3. **Forgiveness enables recovery:** The probabilistic forgiveness allows groups to escape defection spirals that might arise from noise or initial miscoordination.

4. **Adaptive to environment:** The threshold-based approach naturally adjusts expectations based on the economic parameters of the game.
'''

description_COLLECTIVE_12 = '''
# Collective Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy aims to establish and maintain cooperation when it's collectively beneficial, while protecting against exploitation. The key insight is that cooperation becomes self-sustaining when enough players participate—we need to find and maintain that critical mass.

## Strategy Overview

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness and test the waters
2. **Respond to the cooperation level** in the population, not to individual defectors
3. **Maintain cooperation momentum** when above threshold, withdraw when below

---

## Decision Rules

### Key Parameters (Derived from Game Parameters)

```
cooperation_threshold = 0.5  # Minimum fraction of cooperators needed to continue cooperating
forgiveness_window = max(2, floor(r/5))  # Rounds to average when assessing cooperation
decay_tolerance = 0.1  # How much below threshold before fully defecting
```

### Round-by-Round Decision Logic

**FIRST ROUND:**
- **Action: COOPERATE**
- Rationale: Establish cooperative intent; no history to react to

**ROUNDS 2 through (r-1):**

```
Calculate: recent_cooperation_rate = 
    (cooperators in last forgiveness_window rounds) / 
    (n × forgiveness_window)

Calculate: last_round_cooperation_rate = 
    (cooperators last round) / n

IF recent_cooperation_rate ≥ cooperation_threshold:
    ACTION: COOPERATE
    
ELSE IF recent_cooperation_rate ≥ (cooperation_threshold - decay_tolerance):
    # Gray zone: cooperate probabilistically to test if cooperation can recover
    IF last_round_cooperation_rate > previous_round_cooperation_rate:
        ACTION: COOPERATE  # Trend is improving
    ELSE:
        ACTION: DEFECT  # Trend is declining
        
ELSE:
    # Cooperation has collapsed
    IF last_round_cooperation_rate ≥ 0.6:
        ACTION: COOPERATE  # Sudden recovery attempt detected, rejoin
    ELSE:
        ACTION: DEFECT  # Protect against continued exploitation
```

**LAST ROUND (round r):**
```
IF recent_cooperation_rate ≥ 0.7:
    ACTION: COOPERATE  
    # Reward sustained cooperation; maintain collective ethos
ELSE:
    ACTION: DEFECT
    # No future rounds to recover cooperation
```

---

## Handling Edge Cases

### Small n (n = 2 or 3)
- In very small groups, individual defections have outsized impact
- Adjust: `cooperation_threshold = 0.4` (more forgiving)
- Single defector shouldn't collapse the system

### Large n (n > 10)
- Individual actions matter less; focus on aggregate trends
- Strategy naturally handles this through rate-based decisions

### Very Short Games (r ≤ 5)
- `forgiveness_window = 1` (react to immediate history only)
- Last round rule activates at round r only

### High k (k close to n)
- Cooperation is more valuable; strategy naturally favors it
- No parameter adjustment needed—payoff structure handles this

### Low k (k close to 1)
- Cooperation barely beats defection collectively
- Strategy may naturally trend toward defection if others defect—this is appropriate given marginal benefits

---

## Pseudocode Implementation

```python
def decide(round_number, total_rounds, n, k, history):
    """
    history: list of lists, where history[t] contains actions of all n players in round t
    actions encoded as 1 (Cooperate) or 0 (Defect)
    """
    
    cooperation_threshold = 0.5
    decay_tolerance = 0.1
    forgiveness_window = max(2, total_rounds // 5)
    
    # First round: always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate recent cooperation rate
    lookback = min(forgiveness_window, len(history))
    recent_rounds = history[-lookback:]
    recent_coop_rate = sum(sum(r) for r in recent_rounds) / (n * lookback)
    
    # Last round cooperation rate
    last_coop_rate = sum(history[-1]) / n
    
    # Last round decision
    if round_number == total_rounds:
        return COOPERATE if recent_coop_rate >= 0.7 else DEFECT
    
    # Standard rounds
    if recent_coop_rate >= cooperation_threshold:
        return COOPERATE
    
    elif recent_coop_rate >= (cooperation_threshold - decay_tolerance):
        # Check trend
        if len(history) >= 2:
            prev_coop_rate = sum(history[-2]) / n
            return COOPERATE if last_coop_rate > prev_coop_rate else DEFECT
        return COOPERATE
    
    else:
        # Collapsed cooperation - check for recovery
        return COOPERATE if last_coop_rate >= 0.6 else DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Encourages coordination**: By cooperating when others cooperate, we reinforce positive behavior
2. **Resists exploitation**: By defecting when cooperation collapses, we don't subsidize defectors
3. **Allows recovery**: The forgiveness window and recovery detection let cooperation restart after temporary breakdowns
4. **Scales naturally**: Rate-based thresholds work regardless of group size
5. **Rewards sustained cooperation**: Last-round cooperation for high-cooperation games incentivizes long-term thinking

This strategy essentially asks: "Is the collective cooperating enough for my cooperation to be worthwhile?" If yes, contribute. If no, protect yourself while remaining open to recovery.
'''

description_COLLECTIVE_13 = '''
# Collective Strategy for N-Player Public Goods Game

## Strategic Philosophy

This strategy embraces a genuinely collective mindset: I aim to maximize group welfare while protecting against exploitation. The key insight is that in a repeated game, I can use my actions to signal cooperative intent and reward cooperative behavior in others, creating conditions where mutual cooperation becomes self-sustaining.

## Core Strategy: Adaptive Collective Reciprocity (ACR)

### Decision Framework

My strategy operates on three principles:
1. **Start cooperatively** to establish trust and signal collective intent
2. **Reciprocate proportionally** based on observed cooperation levels
3. **Forgive strategically** to escape mutual defection traps

---

### Detailed Decision Rules

#### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- Rationale: Establish cooperative norms and give others the opportunity to reciprocate. This signals my commitment to collective welfare.

#### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
cooperation_rate = (number of cooperators in round t-1) / n
```

**Decision rule:**

```
IF cooperation_rate >= (n-1)/n:
    # Near-universal cooperation - maintain it
    COOPERATE

ELSE IF cooperation_rate >= 0.5:
    # Majority cooperating - continue supporting the collective
    COOPERATE

ELSE IF cooperation_rate > 0 AND cooperation_rate < 0.5:
    # Minority cooperating - use probabilistic cooperation
    # to balance between rewarding cooperators and avoiding exploitation
    COOPERATE with probability = cooperation_rate + forgiveness_bonus
    where forgiveness_bonus = 0.1 × (remaining_rounds / total_rounds)

ELSE IF cooperation_rate == 0:
    # Complete defection last round
    # Attempt recovery with declining probability
    COOPERATE with probability = 0.2 × (remaining_rounds / total_rounds)
```

**Trend Adjustment:**
If cooperation has been *increasing* over the last 2 rounds, add +0.15 to cooperation probability (capped at 1.0) to reinforce positive momentum.

If cooperation has been *decreasing* over the last 2 rounds, subtract 0.1 from cooperation probability (floored at 0) to protect against continued exploitation.

#### Final Round (round r): Conditional Cooperation

The final round has no future shadow, but I maintain collective principles:

```
IF average_cooperation_rate_over_all_rounds >= 0.6:
    # Honor the cooperative relationship built
    COOPERATE
ELSE:
    DEFECT
```

---

### Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (minimum players) | Use standard rules but lower threshold to 0.4 for "majority cooperating" | With only one other player, I need more tolerance |
| r = 2 (minimum rounds) | Cooperate round 1, apply final round logic in round 2 | Build what trust is possible |
| k very close to 1 | Use standard rules | Even small collective gains matter |
| All previous rounds had 0 cooperation | Attempt one "olive branch" cooperation, then defect if ignored | Test if environment has changed |

---

### Pseudocode Summary

```
function decide_action(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[round-1])
    coop_rate = prev_cooperators / n
    remaining = r - round
    
    if round == r:  # Final round
        avg_coop = average_cooperation_rate(history)
        return COOPERATE if avg_coop >= 0.6 else DEFECT
    
    # Calculate trend
    trend = 0
    if round >= 3:
        trend = cooperation_trend(history, last_k_rounds=2)
    
    # Base probability
    if coop_rate >= (n-1)/n:
        prob = 1.0
    elif coop_rate >= 0.5:
        prob = 1.0
    elif coop_rate > 0:
        forgiveness = 0.1 * (remaining / r)
        prob = coop_rate + forgiveness
    else:
        prob = 0.2 * (remaining / r)
    
    # Trend adjustment
    prob = prob + (0.15 if trend > 0 else -0.1 if trend < 0 else 0)
    prob = clamp(prob, 0, 1)
    
    return COOPERATE if random() < prob else DEFECT
```

---

### Why This Strategy Works Collectively

1. **Signals cooperative intent** through initial cooperation
2. **Rewards cooperation** by maintaining high cooperation when others cooperate
3. **Doesn't reward exploitation** by reducing cooperation when facing defectors
4. **Allows recovery** through forgiveness mechanisms that decline over time
5. **Honors relationships** by cooperating in the final round when cooperation has been mutual

This strategy treats the game as an opportunity for collective benefit rather than zero-sum competition, while remaining robust against purely self-interested opponents.
'''

description_COLLECTIVE_14 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we aim to maximize group welfare while protecting against exploitation. The key insight is that universal cooperation yields the best collective outcome (payoff = k > 1 for everyone), but this requires building and maintaining trust in an environment where we cannot coordinate explicitly.

Our approach: **Be a trustworthy cooperator who establishes cooperation early, rewards collective cooperation, and only withdraws support when the group demonstrably fails to sustain it.**

---

## Strategy: "Generous Collective Threshold" (GCT)

### Decision Rules

**Round 1: Always Cooperate**
- Rationale: Signal cooperative intent. We cannot build collective cooperation without someone starting. The cost of one defection against us is small compared to the value of establishing a cooperative norm.

**Rounds 2 through (r-1): Conditional Cooperation Based on Group Behavior**

Cooperate if the **cooperation rate in the previous round** meets or exceeds a dynamic threshold:

```
threshold(t) = max(0.5, (n-1)/(n+1))
```

This threshold:
- For small n (e.g., n=2): threshold ≈ 0.5 (need at least half cooperating)
- For large n: threshold approaches 1 but stays below it (tolerates some defection)
- Never drops below 50% to maintain meaningful cooperation

**Specific Rule:**
```
Let C_prev = number of cooperators in round t-1 (excluding self)
Let rate = C_prev / (n-1)

IF rate >= threshold(t):
    COOPERATE
ELSE IF rate >= threshold(t) - 0.15:  # "Generous margin"
    COOPERATE with probability = rate / threshold(t)
ELSE:
    DEFECT
```

The "generous margin" creates graduated responses rather than cliff-edge switches, making the strategy more forgiving and stable.

**Additional Forgiveness Mechanism:**
- If we've defected for 2 consecutive rounds AND it's before round (r-2), cooperate once to "test" if others will reciprocate. This prevents permanent collapse from temporary miscoordination.

**Final Round (Round r): Probabilistic Based on History**

```
Let overall_coop_rate = total cooperations by others / (total opportunities)

IF overall_coop_rate >= 0.7:
    COOPERATE  # Reward sustained cooperation, maintain collective ethos
ELSE IF overall_coop_rate >= 0.4:
    COOPERATE with probability = overall_coop_rate
ELSE:
    DEFECT  # Group has not been cooperative; protect self
```

Rationale: Unlike purely self-interested strategies that always defect in the final round, we maintain cooperation if the group has been largely cooperative. This reflects genuine collective values and may influence reputation in iterated tournament contexts.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Use threshold = 0.5; cooperate if partner cooperated | Essentially Tit-for-Tat with forgiveness |
| r = 2 | Cooperate round 1; round 2 use final-round rule | Maximize signal, then respond to signal |
| All others defected last round | Defect (but use forgiveness probe after 2 rounds) | Don't be exploited, but test for recovery |
| k very close to 1 | Strategy unchanged | Low k makes cooperation fragile but still collectively beneficial |
| k close to n | Strategy unchanged | High k makes cooperation very valuable; our strategy already promotes it |

---

## Pseudocode Summary

```python
def decide(round_number, history, n, r, k):
    if round_number == 1:
        return COOPERATE
    
    threshold = max(0.5, (n-1)/(n+1))
    others_coop_last = count_cooperators(history[round_number-1], exclude_self=True)
    rate = others_coop_last / (n - 1)
    
    if round_number == r:  # Final round
        overall_rate = total_others_cooperations(history) / ((r-1) * (n-1))
        if overall_rate >= 0.7:
            return COOPERATE
        elif overall_rate >= 0.4:
            return COOPERATE with probability overall_rate
        else:
            return DEFECT
    
    # Forgiveness probe
    if my_last_two_actions == [DEFECT, DEFECT] and round_number < r - 1:
        return COOPERATE  # Test for recovery
    
    # Main decision
    if rate >= threshold:
        return COOPERATE
    elif rate >= threshold - 0.15:
        return COOPERATE with probability (rate / threshold)
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Initiates cooperation** — Takes the first step toward collective benefit
2. **Sustains cooperation** — Continues cooperating when the group does
3. **Forgives mistakes** — Probabilistic responses and forgiveness probes prevent permanent collapse
4. **Protects the collective from freeloaders** — Withdraws when cooperation rate is too low
5. **Maintains integrity in endgame** — Doesn't cynically defect when trust has been earned

This strategy treats other players as potential partners in collective success, not just opponents to outwit.
'''

description_COLLECTIVE_14 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be using similar reasoning and we can achieve mutual benefit through recognizable, consistent behavior patterns. The strategy aims to:
1. Signal cooperative intent clearly
2. Reward collective cooperation
3. Punish defection proportionally but forgivingly
4. Adapt to the actual behavior distribution in the population

---

## Strategy: **Adaptive Threshold Cooperation with Forgiveness (ATCF)**

### Key Variables Tracked

- `coop_rate[t]`: Proportion of players who cooperated in round t (excluding self)
- `cumulative_coop_rate`: Running average cooperation rate across all past rounds
- `trend`: Whether cooperation is increasing, stable, or declining
- `rounds_remaining`: r - current_round

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. In a collective strategy, starting with cooperation establishes the possibility of mutual benefit and is recognizable to like-minded players.

---

### Rounds 2 through (r-1): Adaptive Threshold with Trend Adjustment

**Calculate the cooperation threshold dynamically:**

```
base_threshold = (n - k) / n
```

This is the theoretical threshold where expected value of cooperating equals defecting if cooperation rate stays constant.

**Adjust threshold based on observed behavior:**

```
if cumulative_coop_rate > 0.6:
    adjusted_threshold = base_threshold * 0.8  # More lenient - reward cooperation
elif cumulative_coop_rate < 0.3:
    adjusted_threshold = base_threshold * 1.2  # Stricter - protect against exploitation
else:
    adjusted_threshold = base_threshold
```

**Trend consideration:**
```
if coop_rate[t-1] > coop_rate[t-2]:  # Cooperation increasing
    trend_bonus = 0.1
elif coop_rate[t-1] < coop_rate[t-2]:  # Cooperation declining
    trend_bonus = -0.1
else:
    trend_bonus = 0
```

**Decision Rule:**
```
effective_coop_rate = coop_rate[t-1] + trend_bonus

if effective_coop_rate >= adjusted_threshold:
    ACTION = COOPERATE
else:
    ACTION = DEFECT
```

---

### Last Round (Round r): Conditional Cooperation Based on History

Unlike classical game theory which prescribes defection, a collective strategy recognizes that:
1. Other collective-minded players may also cooperate
2. Reputation effects exist even in final rounds (tournament context)

**Decision Rule for Final Round:**
```
if cumulative_coop_rate >= 0.5:
    ACTION = COOPERATE  # Reward a cooperative game
else:
    ACTION = DEFECT     # Don't be exploited in an uncooperative game
```

---

### Forgiveness Mechanism

To avoid death spirals and allow recovery from mistakes or initial defection:

```
if previous_action == DEFECT and coop_rate[t-1] >= 0.5:
    # Others are still cooperating despite our defection
    # Give cooperation another chance
    ACTION = COOPERATE (override)
```

---

## Pseudocode Summary

```python
def choose_action(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    # Calculate metrics
    coop_rate_last = count_cooperators(history[round-1]) / (n-1)
    cumulative_coop_rate = average([count_cooperators(h)/(n-1) for h in history])
    
    # Final round logic
    if round == r:
        return COOPERATE if cumulative_coop_rate >= 0.5 else DEFECT
    
    # Calculate adaptive threshold
    base_threshold = (n - k) / n
    
    if cumulative_coop_rate > 0.6:
        adjusted_threshold = base_threshold * 0.8
    elif cumulative_coop_rate < 0.3:
        adjusted_threshold = base_threshold * 1.2
    else:
        adjusted_threshold = base_threshold
    
    # Calculate trend
    if round >= 3:
        coop_rate_prev = count_cooperators(history[round-2]) / (n-1)
        trend_bonus = 0.1 * sign(coop_rate_last - coop_rate_prev)
    else:
        trend_bonus = 0
    
    effective_rate = coop_rate_last + trend_bonus
    
    # Main decision
    action = COOPERATE if effective_rate >= adjusted_threshold else DEFECT
    
    # Forgiveness override
    if my_last_action == DEFECT and coop_rate_last >= 0.5:
        action = COOPERATE
    
    return action
```

---

## Why This Strategy is Collectively Optimal

1. **Recognizable**: Starts cooperatively, responds predictably to cooperation levels
2. **Self-reinforcing**: When multiple players use it, cooperation stabilizes above threshold
3. **Robust**: Adapts to hostile environments by raising standards
4. **Forgiving**: Allows recovery from temporary defection spirals
5. **Parameter-aware**: Uses k and n to set appropriate thresholds
6. **Not exploitable**: Defects when cooperation drops too low, protecting against pure defectors
'''

description_COLLECTIVE_15 = '''
# Collective Strategy for N-Player Public Goods Game

## Strategic Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similar cooperative agents) may be present in the game. The goal is to establish and maintain cooperation when possible, while protecting against exploitation. The strategy uses observable patterns to identify cooperative players and coordinate without explicit communication.

## Core Strategy: Adaptive Threshold Cooperation with Forgiveness

### Key Principles

1. **Start cooperatively** to signal willingness to cooperate
2. **Monitor cooperation levels** and respond proportionally
3. **Use forgiveness** to recover from temporary defections
4. **Protect against end-game defection** while not abandoning cooperation prematurely
5. **Be predictable** so that other cooperative agents can recognize and coordinate with us

---

## Decision Rules

### Round 1: Always Cooperate
- **Action: C**
- Rationale: Establish cooperative intent. This is the universal signal that allows cooperative agents to find each other.

### Rounds 2 through (r-2): Adaptive Threshold Cooperation

Calculate the **cooperation ratio** from the previous round:
```
coop_ratio = (number of cooperators in previous round) / n
```

**Decision Rule:**
```
IF coop_ratio >= threshold THEN Cooperate
ELSE IF forgiveness_condition_met THEN Cooperate
ELSE Defect
```

**Threshold Calculation:**
```
base_threshold = (1/k)  # The point where cooperation becomes marginally beneficial
adaptive_threshold = max(0.3, min(0.7, base_threshold))
```

The threshold `1/k` is economically meaningful: when at least `n/k` players cooperate, the public good return exceeds the private keeping value.

**Forgiveness Mechanism:**
- Track a "cooperation streak" counter
- If we've defected for 2 consecutive rounds AND the cooperation ratio is above 0.2, cooperate once to test if cooperation can be restored
- Reset forgiveness timer after each forgiveness attempt (wait at least 3 rounds before forgiving again)

**Trend Adjustment:**
```
IF cooperation is trending upward (current_ratio > previous_ratio) THEN
    Lower threshold by 0.1 (more willing to cooperate)
IF cooperation is trending downward THEN
    Raise threshold by 0.1 (more cautious)
```

### Round (r-1): Penultimate Round
- **Use the same adaptive rule as middle rounds**
- Rationale: Defecting early signals to others that cooperation is ending, causing premature collapse. Maintaining cooperation here preserves value.

### Round r (Final Round): Conditional Cooperation
- **IF average cooperation ratio over all previous rounds >= 0.5 THEN Cooperate**
- **ELSE Defect**
- Rationale: In a collective mindset, if the group has been largely cooperative, we honor that relationship through the end. If it's been exploitative, we protect ourselves.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate statistics
    prev_coop_count = count_cooperators(history, round - 1)
    coop_ratio = prev_coop_count / n
    avg_coop_ratio = average_cooperation_ratio(history)
    
    # Calculate adaptive threshold
    base_threshold = 1 / k
    threshold = clamp(base_threshold, 0.3, 0.7)
    
    # Trend adjustment
    if round > 2:
        prev_prev_ratio = count_cooperators(history, round - 2) / n
        if coop_ratio > prev_prev_ratio:
            threshold = threshold - 0.1  # Cooperation trending up
        elif coop_ratio < prev_prev_ratio:
            threshold = threshold + 0.1  # Cooperation trending down
    
    # Final round logic
    if round == r:
        if avg_coop_ratio >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Standard rounds: threshold check
    if coop_ratio >= threshold:
        return COOPERATE
    
    # Forgiveness check
    my_recent_actions = get_my_actions(history, last=2)
    rounds_since_last_forgiveness = get_rounds_since_forgiveness(history)
    
    if all_defections(my_recent_actions) AND 
       coop_ratio >= 0.2 AND 
       rounds_since_last_forgiveness >= 3:
        mark_forgiveness_attempt(round)
        return COOPERATE
    
    return DEFECT
```

---

## Edge Cases Handled

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n=2 (minimum players) | Same rules apply | Threshold naturally adjusts; becomes similar to Tit-for-Tat |
| All others defect round 1 | Defect round 2, forgive round 4+ | Don't be exploited, but test for recovery |
| Erratic opponents | Threshold smooths response | We respond to levels, not individual actions |
| High k (close to n) | Lower threshold, more cooperation | Cooperation is more valuable |
| Low k (close to 1) | Higher threshold, more cautious | Cooperation requires more participants |
| Single defector in cooperative group | Continue cooperating | One defector doesn't break the threshold |

---

## Why This Strategy is Collectively Optimal

1. **Identifiable**: Cooperative agents can recognize each other through consistent cooperation patterns
2. **Stable**: When multiple copies play together, they establish and maintain full cooperation
3. **Robust**: Against defectors, it limits losses while keeping recovery possible
4. **Economically grounded**: The threshold is tied to the actual payoff structure via parameter k
5. **Forgiving**: Allows recovery from mistakes or temporary defections
6. **Not exploitable**: Responds to defection, doesn't cooperate unconditionally
'''

description_COLLECTIVE_15 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players reason similarly and cooperate, everyone achieves the best collective outcome (payoff of k per round vs. 1 from mutual defection). The strategy aims to **sustain cooperation when possible** while **protecting against exploitation** and **signaling willingness to cooperate**.

## Strategy Overview: "Generous Collective Tit-for-Tat with Forgiveness"

The strategy operates on three principles:
1. **Start cooperatively** to signal good faith
2. **Mirror the group's cooperation level** to reward cooperation and discourage defection
3. **Periodically forgive** to escape mutual defection traps and test for reformed opponents

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: Cooperate (C)**

Rationale: Signal willingness to cooperate. If others share a collective mindset, this establishes cooperative equilibrium from the start.

---

### Rounds 2 through (r-1): Adaptive Conditional Cooperation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of players who played C in round t-1) / n
```

**Decision rule:**

```
threshold = max(0.3, (n - k) / n)  # Ensures threshold is meaningful

IF coop_rate >= threshold:
    Cooperate (C)
ELSE IF coop_rate < threshold:
    # Check for forgiveness opportunity
    IF (current_round mod forgiveness_interval == 0):
        Cooperate (C)  # Forgiveness probe
    ELSE:
        Defect (D)
```

**Forgiveness interval calculation:**
```
forgiveness_interval = max(2, floor(r / 5))
```

This creates periodic "olive branches" to test whether the group might shift toward cooperation.

---

### Last Round (Round r): Conditional with Reputation Weight

The last round lacks future enforcement, but I maintain collective principles:

```
IF average_coop_rate_over_all_rounds >= 0.5:
    Cooperate (C)  # Honor the cooperative relationship
ELSE:
    Defect (D)  # No cooperative norm was established
```

Rationale: If the group has been largely cooperative, defecting in the last round would betray that relationship. If cooperation never took hold, there's no relationship to honor.

---

## Handling Edge Cases

### Small n (n = 2):
- Strategy remains the same, but threshold adapts automatically
- Forgiveness becomes more important since one defector = 50% defection rate

### Large n:
- Individual defections have less impact on cooperation rate
- Strategy naturally becomes more tolerant of isolated defectors

### k close to 1 (low multiplier):
- Threshold increases, requiring higher cooperation to sustain contribution
- Appropriate since cooperation is less collectively beneficial

### k close to n (high multiplier):
- Threshold decreases, making cooperation easier to sustain
- Appropriate since public good is very valuable

### Very short games (r ≤ 3):
- Forgiveness interval = 2, ensuring at least one forgiveness probe if trapped in defection
- Last-round logic still applies

### Observation of gradual decline:
If cooperation rate has been declining for 3+ consecutive rounds:
```
IF declining_trend AND coop_rate still above 0.2:
    Cooperate (C)  # Try to reverse the trend
```

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history[round-1]) / n
    threshold = max(0.3, (n - k) / n)
    forgiveness_interval = max(2, floor(r / 5))
    
    if round == r:  # Last round
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    if prev_coop_rate >= threshold:
        return COOPERATE
    else:
        if round mod forgiveness_interval == 0:
            return COOPERATE  # Forgiveness probe
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Maximizes collective welfare when facing similar strategies**: Mutual cooperation yields k > 1 per round for everyone

2. **Doesn't exploit others**: Never defects purely for individual gain when cooperation is working

3. **Forgives mistakes**: Periodic cooperation attempts prevent permanent breakdown

4. **Protects the collective from exploitation**: Withdraws cooperation when too many defect, creating incentive for them to cooperate

5. **Parameter-adaptive**: Automatically adjusts to game conditions without requiring coordination
'''

description_COLLECTIVE_16 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume I am one of potentially many players using this same strategy. Our goal is to maximize collective welfare while protecting against exploitation by defectors. The strategy balances three objectives:

1. **Establish cooperation** when playing with like-minded agents
2. **Punish defection** to discourage exploitation
3. **Forgive and recover** to restore cooperation after punishment

---

## Strategy: Adaptive Collective Reciprocity (ACR)

### Key Metrics Tracked

For each round, track:
- `cooperation_rate`: proportion of players who cooperated in the previous round
- `cumulative_coop_rate`: overall cooperation rate across all past rounds
- `recent_trend`: cooperation rate over last 3 rounds vs previous 3 rounds
- `rounds_remaining`: r - current_round

### Decision Rules

#### Round 1: Cooperate
**Always cooperate in the first round.** This signals cooperative intent and allows collective strategies to find each other.

#### Rounds 2 through (r-1): Adaptive Threshold Cooperation

Cooperate if the following condition is met:

```
cooperation_rate(previous_round) >= threshold(t)
```

Where the **adaptive threshold** is calculated as:

```
base_threshold = (n - k) / (n - 1)
```

This base threshold represents the minimum cooperation rate needed for cooperation to be individually rational in expectation.

**Threshold adjustments:**

```python
def calculate_threshold(round_t, n, k, history):
    base = (n - k) / (n - 1)
    
    # Early game: be more forgiving to establish cooperation
    if round_t <= r / 4:
        forgiveness_bonus = 0.15 * (1 - round_t / (r / 4))
    else:
        forgiveness_bonus = 0
    
    # Trend adjustment: reward improving cooperation
    if recent_trend > 0.1:  # cooperation improving
        trend_bonus = 0.05
    elif recent_trend < -0.1:  # cooperation declining
        trend_bonus = -0.05
    else:
        trend_bonus = 0
    
    threshold = base - forgiveness_bonus - trend_bonus
    
    # Clamp between reasonable bounds
    return max(0.3, min(0.9, threshold))
```

**Decision logic:**

```python
def decide(round_t, history, n, k, r):
    if round_t == 1:
        return COOPERATE
    
    if round_t == r:  # Last round
        return handle_last_round(history, n, k)
    
    prev_coop_rate = count_cooperators(history[-1]) / n
    threshold = calculate_threshold(round_t, n, k, history)
    
    if prev_coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

#### Last Round: Conditional Cooperation

The last round requires special handling since there's no future to incentivize cooperation:

```python
def handle_last_round(history, n, k):
    cumulative_rate = total_cooperations(history) / (len(history) * n)
    
    # If the game has been highly cooperative, maintain cooperation
    # This rewards sustained collective behavior
    if cumulative_rate >= 0.7:
        return COOPERATE
    
    # If cooperation has been moderate and stable, cooperate
    # to avoid triggering mutual defection among collective players
    recent_rate = cooperation_rate(last_3_rounds)
    if recent_rate >= 0.6 and cumulative_rate >= 0.5:
        return COOPERATE
    
    # Otherwise, defect
    return DEFECT
```

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | Cooperate | Signal cooperative intent |
| Everyone cooperated last round | Cooperate | Maintain successful equilibrium |
| Everyone defected last round | Defect | Don't be exploited |
| Exactly at threshold | Cooperate | Tie-break toward cooperation |
| r = 2 (minimal game) | C then conditional C | Even short games deserve cooperation attempt |
| n = 2 (two players) | Standard rules apply | Reduces to iterated PD-like dynamics |
| k very close to 1 | Higher threshold | Cooperation barely beneficial |
| k close to n | Lower threshold | Cooperation highly beneficial |

---

## Why This Strategy Works Collectively

1. **Self-recognition**: Multiple ACR players will all cooperate in round 1, see high cooperation, and continue cooperating—achieving the efficient outcome.

2. **Punishment synchronization**: If defectors appear, ACR players will collectively switch to defection when cooperation drops below threshold, creating coordinated punishment.

3. **Forgiveness**: The early-game forgiveness bonus and trend adjustments allow recovery from temporary defection, enabling return to cooperation.

4. **Robustness to mixed populations**: The threshold is calibrated so that even partial cooperation (from some ACR players and some cooperators) can sustain itself.

5. **Last-round cooperation among collectives**: By cooperating in the last round when history is good, ACR players avoid the "unraveling" problem that destroys cooperation in finite games.

---

## Summary

**Cooperate if and only if:**
- It's the first round, OR
- Previous round cooperation rate meets the adaptive threshold, OR  
- It's the last round AND cumulative cooperation has been strong

This strategy is **generous but not naive**, **punishing but forgiving**, and **individually rational while collectively optimal**.
'''

description_COLLECTIVE_16 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embodies a **collective-first mindset**: we assume we are part of a group of like-minded agents who share this strategy, and we optimize for collective welfare while maintaining robustness against defectors. The key insight is that if multiple copies of this strategy are playing together, they should naturally coordinate toward cooperation, while still protecting themselves against exploitation.

## Strategy Overview: **Adaptive Threshold Cooperation (ATC)**

The strategy uses the observed cooperation rate from previous rounds to determine behavior, with built-in mechanisms for:
1. Establishing cooperation early
2. Rewarding cooperative environments
3. Protecting against systematic exploitation
4. Signaling cooperative intent to fellow collective agents

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: As collective agents, we lead with cooperation to establish a cooperative norm. If other copies of our strategy are present, we'll all cooperate in round 1, creating a clear signal of collective identity.

---

### Rounds 2 through (r-1): Adaptive Threshold Rule

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays in previous round) / n
```

**Decision Rule:**
```
threshold = max(0.3, (n - k) / n)

IF coop_rate >= threshold:
    COOPERATE
ELSE:
    DEFECT with probability P_defect
    COOPERATE with probability (1 - P_defect)

where P_defect = (threshold - coop_rate) / threshold
```

**Explanation:**
- The threshold `(n - k) / n` represents the minimum cooperation rate needed for cooperation to be individually rational in expectation
- We floor this at 0.3 to maintain some baseline willingness to cooperate
- When cooperation falls below threshold, we probabilistically defect rather than deterministically, which:
  - Allows recovery from temporary dips
  - Maintains some cooperative presence for fellow collective agents
  - Avoids lock-in to mutual defection

---

### Last Round (Round r): Conditional Cooperation

Calculate **cumulative cooperation rate** across all previous rounds:
```
cumulative_coop_rate = (total C plays across all rounds) / (n × (r-1))
```

**Decision Rule:**
```
IF cumulative_coop_rate >= 0.5:
    COOPERATE
ELSE:
    DEFECT
```

Rationale: Unlike standard game theory which prescribes defection in the last round, collective agents should reward a history of cooperation. If the game has been largely cooperative, we maintain cooperation to maximize collective payoff. If it's been exploitative, we protect ourselves.

---

## Pseudocode Implementation

```python
def choose_action(round_number, total_rounds, n, k, history):
    """
    history: list of lists, where history[t] contains actions from round t
             Each action is 'C' or 'D' for each of n players
    """
    
    # Round 1: Always cooperate
    if round_number == 1:
        return 'C'
    
    # Calculate previous round cooperation rate
    prev_round = history[round_number - 1]
    prev_coop_count = sum(1 for action in prev_round if action == 'C')
    prev_coop_rate = prev_coop_count / n
    
    # Calculate threshold
    base_threshold = (n - k) / n
    threshold = max(0.3, base_threshold)
    
    # Last round logic
    if round_number == total_rounds:
        total_coops = sum(
            sum(1 for a in round_actions if a == 'C') 
            for round_actions in history.values()
        )
        total_actions = n * (total_rounds - 1)
        cumulative_rate = total_coops / total_actions
        
        if cumulative_rate >= 0.5:
            return 'C'
        else:
            return 'D'
    
    # Middle rounds: Adaptive threshold
    if prev_coop_rate >= threshold:
        return 'C'
    else:
        p_defect = (threshold - prev_coop_rate) / threshold
        if random() < p_defect:
            return 'D'
        else:
            return 'C'
```

---

## Edge Cases Handled

| Situation | Behavior | Rationale |
|-----------|----------|-----------|
| Round 1 | Cooperate | Establish cooperative norm, signal to collective |
| Everyone cooperated last round | Cooperate | Reward and maintain cooperation |
| Everyone defected last round | Defect (high probability) | Protect against exploitation |
| Mixed results near threshold | Probabilistic | Allow recovery, avoid lock-in |
| Last round after cooperative game | Cooperate | Collective welfare over individual gain |
| Last round after exploitative game | Defect | No reason to be exploited at the end |
| Very small k (close to 1) | Higher threshold | Cooperation needs broad participation |
| k close to n | Lower threshold | Cooperation viable with fewer participants |

---

## Why This Strategy is Collectively Optimal

1. **Self-recognition**: Multiple copies will cooperate in round 1, see high cooperation rates, and continue cooperating throughout.

2. **Mutual benefit**: When collective agents dominate, everyone gets the high cooperative payoff (k > 1 means cooperation is collectively efficient).

3. **Robust to infiltration**: If some defectors enter, the probabilistic response means we don't immediately collapse, but we do protect ourselves as exploitation increases.

4. **No coordination required**: The strategy uses only observable history—no signals, no schedules, no assumed coordination mechanisms.

5. **Parameter-adaptive**: The threshold automatically adjusts to the game's parameters, making cooperation rational when k is high and protective when k is low.
'''

description_COLLECTIVE_17 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embodies a **collective mindset**: I treat the group's welfare as primary while remaining adaptive to the actual behavior of others. The key insight is that in this game, universal cooperation yields the highest collective payoff (k > 1 means contributions are multiplied), but individual incentives push toward defection (k < n means keeping is privately optimal). My strategy aims to **demonstrate and sustain cooperation** while **protecting against persistent exploitation**.

## Strategy Overview: "Generous Collective Trigger"

This is a threshold-based conditional cooperation strategy with:
1. **Optimistic start** - Begin cooperatively to establish norms
2. **Collective monitoring** - Track group cooperation rate, not individual players
3. **Generous thresholds** - Allow for noise and learning
4. **Gradual response** - Adjust cooperation probability based on group behavior
5. **End-game consideration** - Maintain cooperation possibility even late in the game

---

## Decision Rules

### Key Variables Tracked

```
cooperation_history[t] = number of cooperators in round t (excluding self)
group_coop_rate = average cooperation rate over recent rounds
rounds_remaining = r - current_round
```

### Round-by-Round Decision

#### First Round (t = 1)
**Action: COOPERATE**

Rationale: Signal cooperative intent, give the collective a chance to coordinate on mutual benefit.

#### Middle Rounds (1 < t < r)

Calculate the **recent group cooperation rate** over the last `window` rounds:
- `window = min(5, t-1)` (use up to 5 most recent rounds)
- `recent_coop_rate = (sum of cooperators in window) / ((n-1) × window)`

**Decision rule:**

```
threshold_high = 0.6    # Above this: definitely cooperate
threshold_low = 0.3     # Below this: definitely defect
forgiveness = 0.15      # Probability of cooperating even when below threshold

if recent_coop_rate >= threshold_high:
    ACTION = COOPERATE
    
elif recent_coop_rate >= threshold_low:
    # Probabilistic cooperation matching the group rate
    cooperation_probability = recent_coop_rate + 0.1  # Slightly generous
    ACTION = COOPERATE with probability cooperation_probability
    
elif recent_coop_rate < threshold_low:
    # Group is mostly defecting, but offer occasional olive branch
    ACTION = COOPERATE with probability forgiveness
    ACTION = DEFECT with probability (1 - forgiveness)
```

#### Last Round (t = r)

**Special consideration**: Standard game theory predicts universal defection in the last round. However, in a collective mindset:

```
if recent_coop_rate >= 0.5:
    # Group has been cooperative - honor that relationship
    ACTION = COOPERATE
else:
    # Group has been uncooperative
    ACTION = DEFECT
```

Rationale: If others have been cooperating, defecting in the final round betrays the collective relationship we've built. Maintaining cooperation signals that we value the collective outcome, not just personal gain.

---

## Pseudocode Implementation

```python
def decide(round_number, total_rounds, n_players, k_factor, history):
    """
    history: list of lists, where history[t] contains actions of all n players in round t
             (or history of cooperation counts if individual actions not available)
    """
    
    # First round: cooperate unconditionally
    if round_number == 1:
        return COOPERATE
    
    # Calculate recent cooperation rate (excluding self)
    window = min(5, round_number - 1)
    recent_rounds = history[-(window):]
    
    total_others_cooperated = sum(count_cooperators(r) - my_action(r) for r in recent_rounds)
    total_possible = (n_players - 1) * window
    recent_coop_rate = total_others_cooperated / total_possible
    
    # Adjust thresholds based on group size (larger groups need more tolerance)
    threshold_high = 0.6 - (0.05 * (n_players - 2) / 10)  # Slightly lower for large groups
    threshold_low = 0.3
    forgiveness = 0.15
    
    # Last round logic
    if round_number == total_rounds:
        if recent_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    if recent_coop_rate >= threshold_high:
        return COOPERATE
        
    elif recent_coop_rate >= threshold_low:
        prob_coop = min(0.9, recent_coop_rate + 0.1)  # Generous but capped
        return COOPERATE with probability prob_coop
        
    else:
        return COOPERATE with probability forgiveness
```

---

## Edge Cases Handled

| Situation | Response | Rationale |
|-----------|----------|-----------|
| First round | Cooperate | Establish cooperative norm |
| Last round, group cooperative | Cooperate | Honor collective relationship |
| Last round, group defecting | Defect | No future interaction to protect |
| All others defect consistently | Defect (85%), Cooperate (15%) | Protect self, but leave door open |
| Volatile/mixed behavior | Match rate + 10% | Slightly optimistic matching |
| Large n (many players) | Slightly lower thresholds | Harder to achieve high rates |
| Short game (low r) | Same rules apply | Consistent behavior |

---

## Why This Strategy is Collectively Aligned

1. **Starts cooperatively**: Gives the group the best chance to achieve mutual benefit
2. **Generous thresholds**: Doesn't punish the group for a few defectors
3. **Forgiveness mechanism**: Always offers a path back to cooperation
4. **Rewards collective cooperation**: When the group cooperates, I cooperate
5. **Last-round integrity**: Doesn't betray cooperative groups for marginal gain
6. **Adaptive**: Works against exploiters (eventually defects) and cooperators (sustains cooperation)

This strategy maximizes the chances of achieving the collectively optimal outcome (everyone cooperates, everyone gets payoff k > 1) while remaining robust against exploitation.
'''

description_COLLECTIVE_17 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **we succeed together or fail together**. Rather than treating other players as opponents to exploit, I approach this as a coordination problem where my goal is to establish and maintain cooperation that benefits everyone. The strategy is designed to be:

1. **Inviting** - Start cooperatively to signal good faith
2. **Responsive** - Reward cooperation, discourage defection
3. **Forgiving** - Allow recovery from mutual defection
4. **Robust** - Adapt to the actual behavior observed

---

## Strategy: Adaptive Collective Reciprocity (ACR)

### Decision Framework

The strategy tracks a **cooperation index** based on observed behavior and uses threshold-based decisions that adapt to game parameters.

---

### Key Variables

```
cooperation_rate = (total cooperations by others) / (total possible cooperations by others)
recent_cooperation_rate = cooperation rate in last min(3, rounds_played) rounds
rounds_remaining = r - current_round
forgiveness_threshold = k / n  (the per-capita return from cooperation)
```

---

### Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Begin by demonstrating willingness to contribute to collective welfare. This signals cooperative intent and gives others the opportunity to reciprocate.

---

#### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the recent cooperation rate among other players.

**COOPERATE if ANY of the following conditions are met:**

1. **High recent cooperation**: `recent_cooperation_rate ≥ 0.5`
   - If at least half of others are cooperating, maintain cooperation to sustain the collective benefit

2. **Improving trend**: `recent_cooperation_rate > previous_recent_cooperation_rate + 0.1`
   - If cooperation is increasing, reward the positive trend

3. **Forgiveness probe**: `rounds_since_last_cooperation ≥ max(2, n/2)` AND `rounds_remaining > 2`
   - Periodically attempt to restart cooperation after breakdown
   - More frequent probing with smaller groups, less frequent with larger ones

4. **Critical mass potential**: `recent_cooperation_rate ≥ forgiveness_threshold`
   - If enough others cooperate that the public good return exceeds the cost, cooperate

**DEFECT otherwise**

---

#### Final Round: Conditional Cooperation

Unlike standard game theory advice to defect in the final round, this collective strategy:

**COOPERATE if**: `recent_cooperation_rate ≥ 0.6`

Rationale: If the group has maintained strong cooperation, honor that collective achievement rather than exploiting it at the last moment. This reflects genuine collective values, not just strategic calculation.

**DEFECT if**: `recent_cooperation_rate < 0.6`

Rationale: If cooperation has already broken down, defection is appropriate.

---

### Pseudocode

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation metrics
    others_actions = get_others_actions(history)
    recent_window = min(3, round - 1)
    recent_coop_rate = calc_cooperation_rate(others_actions, recent_window)
    overall_coop_rate = calc_cooperation_rate(others_actions, round - 1)
    
    # Previous period rate for trend detection
    if round > 2:
        prev_recent_rate = calc_cooperation_rate(others_actions, recent_window, offset=1)
    else:
        prev_recent_rate = 0
    
    forgiveness_threshold = k / n
    rounds_remaining = r - round
    rounds_since_my_coop = count_rounds_since_action(my_history, COOPERATE)
    
    # Final round logic
    if round == r:
        return COOPERATE if recent_coop_rate >= 0.6 else DEFECT
    
    # Main decision logic
    if recent_coop_rate >= 0.5:
        return COOPERATE
    
    if recent_coop_rate > prev_recent_rate + 0.1:
        return COOPERATE
    
    if rounds_since_my_coop >= max(2, n // 2) and rounds_remaining > 2:
        return COOPERATE  # Forgiveness probe
    
    if recent_coop_rate >= forgiveness_threshold:
        return COOPERATE
    
    return DEFECT
```

---

### Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | COOPERATE | Establish cooperative baseline |
| n = 2 (minimum players) | Standard rules apply | Forgiveness probes every 2 rounds |
| Large n (many players) | Standard rules apply | Forgiveness probes less frequent; thresholds remain proportional |
| All others defect consistently | DEFECT (with periodic probes) | Don't be exploited, but keep testing |
| k very close to n | Lower effective threshold | Cooperation is more valuable, be more willing |
| k very close to 1 | Higher effective threshold | Cooperation provides less return, require more evidence |
| Very short game (r ≤ 3) | More cooperative | Limited time to establish patterns; bias toward cooperation |

---

### Why This Strategy Embodies Collective Thinking

1. **Generous initiation**: Starts with cooperation, assuming collective success is possible
2. **Not exploitative**: Never designed to take advantage of cooperators
3. **Maintains cooperation**: Continues cooperating when others do, sustaining group welfare
4. **Forgiveness**: Actively tries to restore cooperation after breakdowns
5. **Honors collective achievement**: Cooperates in final round if group has cooperated, rather than exploiting trust
6. **Parameter-adaptive**: Adjusts to the actual economics of cooperation (k/n ratio)

This strategy aims to be the kind of player that, if everyone adopted it, would achieve near-optimal collective outcomes—while still protecting against persistent exploitation.
'''

description_COLLECTIVE_18 = '''
# Collective Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy is designed with a collective mindset: we want to maximize group welfare while protecting against exploitation. The key insight is that in a public goods game, **universal cooperation benefits everyone**, but we must be resilient against defectors. We aim to be a "cooperative catalyst" that encourages and sustains cooperation, while adaptively responding to the actual behavior of the group.

---

## Strategy Overview

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness and establish cooperative norms
2. **Monitor group cooperation levels** and respond proportionally
3. **Maintain hope** but protect against persistent exploitation

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: We begin by cooperating to demonstrate good faith and signal our collective orientation. This gives the group the best chance to establish mutual cooperation.

---

### Rounds 2 through (r-1): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of players who cooperated in previous round) / n
```

**Decision Rule:**

```
IF coop_rate >= threshold THEN COOPERATE
ELSE DEFECT
```

**Threshold Calculation:**

The threshold adapts based on game parameters and history:

```
base_threshold = 1/k  # Economic breakeven point for cooperation

# Adjust based on cumulative cooperation history
historical_coop_rate = (total cooperations across all previous rounds) / 
                        (n × rounds_played)

# Weighted threshold that becomes more forgiving if history is cooperative
adaptive_threshold = 0.6 × base_threshold + 0.4 × (1 - historical_coop_rate)

# Bound the threshold to reasonable range
threshold = max(0.3, min(0.7, adaptive_threshold))
```

**Additional Forgiveness Mechanism:**

Every `floor(r/4)` rounds (periodic forgiveness), if we have been defecting:
```
IF current_round % floor(r/4) == 0 AND our_last_action == DEFECT:
    COOPERATE  # Give the group another chance
```

---

### Final Round (Round r): Conditional Cooperation

Unlike classical game theory which suggests defecting in the final round, we maintain our collective mindset:

```
IF historical_coop_rate >= 0.5 THEN COOPERATE
ELSE DEFECT
```

Rationale: If the group has shown majority cooperative behavior, we honor that relationship even when there's no future enforcement. This builds better outcomes when playing with like-minded collective strategies.

---

## Pseudocode Summary

```python
def decide(round, n, k, r, history):
    
    # Round 1: Unconditional cooperation
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation metrics
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate = last_round_coops / n
    historical_coop_rate = total_cooperations(history) / (n * (round - 1))
    
    # Calculate adaptive threshold
    base_threshold = 1 / k
    adaptive_threshold = 0.6 * base_threshold + 0.4 * (1 - historical_coop_rate)
    threshold = clamp(adaptive_threshold, 0.3, 0.7)
    
    # Final round logic
    if round == r:
        return COOPERATE if historical_coop_rate >= 0.5 else DEFECT
    
    # Periodic forgiveness
    forgiveness_interval = max(1, r // 4)
    if round % forgiveness_interval == 0 and my_last_action(history) == DEFECT:
        return COOPERATE
    
    # Main decision rule
    if coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Encourages cooperation**: Starting with C and using forgiveness mechanisms helps establish and restore cooperative equilibria.

2. **Scales with parameters**: The threshold based on `1/k` adapts to different game economics.

3. **Resistant to exploitation**: We don't blindly cooperate—we require evidence of group cooperation.

4. **Rewards cooperative groups**: When matched with other cooperative strategies, we achieve high mutual payoffs.

5. **Recovers from breakdowns**: The periodic forgiveness mechanism allows cooperation to restart even after periods of mutual defection.

6. **Parameter-independent coordination**: The strategy's behavior is deterministic given history, allowing similar strategies to implicitly coordinate without communication.
'''

description_COLLECTIVE_18 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume I am one of potentially many players using this same strategy. Our goal is to achieve high collective payoffs through sustained cooperation, while protecting against exploitation by defectors. The strategy must work well both when many players share it AND when facing diverse opponents.

## Strategy Overview: **Adaptive Threshold Cooperation with Forgiveness**

The strategy cooperates when there's sufficient evidence of a cooperative environment, defects to protect against exploitation, and periodically tests whether cooperation can be restored.

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: With no history, we signal cooperative intent. If multiple players share this strategy, we establish cooperation from the start. The cost of one round's potential exploitation is worth the benefit of identifying and coordinating with other cooperators.

### Rounds 2 through (r-1): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays in previous round) / n
```

Calculate the **cooperation threshold** that makes cooperation individually rational given observed behavior:
```
breakeven_threshold = (n - k) / (n × (k - 1))
```

This is derived from: cooperation is beneficial when expected return from contributing exceeds keeping, accounting for others' likely behavior.

**Primary Decision Rule:**

```
IF coop_rate >= max(breakeven_threshold, 0.5):
    COOPERATE
ELSE IF in "forgiveness probe" round:
    COOPERATE
ELSE:
    DEFECT
```

**Forgiveness Probe Mechanism:**

To avoid getting trapped in mutual defection when cooperation could be restored:
```
forgiveness_round = (current_round % forgiveness_interval == 0)
forgiveness_interval = max(3, floor(r / 5))
```

On forgiveness rounds, cooperate regardless of recent history to test if the environment has changed.

**Trend Adjustment:**

If cooperation has been *increasing* over the last 3 rounds, lower the threshold slightly:
```
IF coop_rate_trend > 0:
    effective_threshold = threshold × 0.85
```

This rewards and encourages emerging cooperation.

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection, we maintain conditional cooperation:

```
IF coop_rate in round (r-1) >= 0.6:
    COOPERATE
ELSE:
    DEFECT
```

Rationale: If playing against other instances of this strategy (or similar cooperative strategies), mutual cooperation in the final round yields higher collective payoffs. We only defect if the game has already devolved into non-cooperation.

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round statistics
    prev_coop_count = count(history[round-1], COOPERATE)
    coop_rate = prev_coop_count / n
    
    # Calculate breakeven threshold
    breakeven = (n - k) / (n * (k - 1))
    threshold = max(breakeven, 0.5)
    
    # Trend detection (if enough history)
    if round >= 4:
        recent_rates = [coop_rate at t for t in (round-3, round-2, round-1)]
        trend = (recent_rates[2] - recent_rates[0]) / 2
        if trend > 0:
            threshold = threshold * 0.85
    
    # Final round logic
    if round == r:
        if coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Forgiveness probe
    forgiveness_interval = max(3, floor(r / 5))
    if round % forgiveness_interval == 0:
        return COOPERATE
    
    # Main decision
    if coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases Handled

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | Cooperate | Establish cooperative signal |
| Last round | Conditional | Maintain cooperation if viable |
| All defected last round | Defect (unless forgiveness round) | Protect from exploitation |
| All cooperated last round | Cooperate | Reward and continue cooperation |
| n=2 (minimum players) | Strategy still applies | Threshold adjusts appropriately |
| Very short game (r=2) | Cooperate both rounds if partner cooperated | Maximize brief interaction |
| Very long game | Forgiveness probes prevent permanent defection lock | Adaptation over time |

---

## Why This Strategy is Collectively Optimal

1. **Self-reinforcing among copies**: When multiple players use this strategy, they cooperate from round 1 and maintain cooperation throughout, achieving near-optimal collective payoffs.

2. **Robust against defectors**: The threshold mechanism ensures we don't continue cooperating into a heavily defecting environment.

3. **Recoverable**: Forgiveness probes allow escape from defection equilibria if conditions change.

4. **Adaptive to parameters**: The breakeven threshold automatically adjusts to different values of n and k.
'''

description_COLLECTIVE_19 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be using similar reasoning, and I aim to establish and maintain cooperation while protecting against exploitation. The strategy balances three key principles:

1. **Optimistic initiation**: Start cooperatively to signal willingness to collaborate
2. **Responsive adaptation**: Adjust based on observed group behavior
3. **Forgiveness with boundaries**: Allow recovery from defection but don't be infinitely exploitable

---

## Strategy: "Adaptive Threshold Cooperation" (ATC)

### Key Metrics Tracked

- **Cooperation rate**: The fraction of all other players who cooperated in each round
- **Trend**: Whether cooperation is increasing, stable, or declining
- **Round position**: Early game, mid game, or end game

### Decision Rules

#### Round 1: Cooperate
- **Action**: C (Cooperate)
- **Rationale**: Signal cooperative intent. In a collective mindset, we expect others reasoning similarly will also start cooperatively.

#### Rounds 2 through (r-1): Adaptive Response

Calculate the **group cooperation rate** from the previous round:
```
coop_rate = (number of C plays by others) / (n - 1)
```

Calculate the **cooperation threshold** based on game parameters:
```
base_threshold = (n - k) / (n - 1)
```
This threshold represents the break-even point where cooperation becomes individually rational given others' behavior.

**Decision Logic:**

```
IF coop_rate >= 0.5:
    # Majority cooperated - reciprocate cooperation
    Action = C

ELSE IF coop_rate >= base_threshold AND coop_rate < 0.5:
    # Borderline zone - use probabilistic cooperation
    # Cooperate with probability proportional to cooperation rate
    Action = C with probability (coop_rate * 1.5), else D

ELSE IF coop_rate < base_threshold:
    # Low cooperation - protect against exploitation
    # But give occasional "olive branch" to allow recovery
    IF (current_round mod 3 == 0):
        Action = C  # Periodic cooperation signal
    ELSE:
        Action = D
```

**Trend Adjustment:**
```
IF cooperation has increased for 2+ consecutive rounds:
    # Reward positive momentum - be more generous
    Increase cooperation probability by 0.1

IF cooperation has decreased for 2+ consecutive rounds:
    # Respond to declining trust
    Decrease cooperation probability by 0.1
```

#### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which suggests universal defection in the final round, a collective strategy recognizes that:
- If we all defect, we all lose potential gains
- Maintaining cooperation norms has value even at the end

**Decision Logic:**
```
IF average_cooperation_rate_over_game >= 0.6:
    # Group has been largely cooperative - maintain trust
    Action = C

ELSE IF previous_round_coop_rate >= 0.5:
    # Recent cooperation is promising
    Action = C

ELSE:
    # Cooperation has been weak - defect
    Action = D
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (minimum players) | Use stricter threshold (0.6 instead of 0.5) | Single defector has larger impact |
| k close to n | Cooperate more readily | Public good multiplier is generous |
| k close to 1 | Require higher cooperation rates | Cooperation benefit is marginal |
| r = 2 (minimum rounds) | Cooperate both rounds if opponent(s) cooperate round 1 | Limited time to establish patterns |
| All others defected previous round | Defect, but cooperate every 3rd round | Protect self while signaling openness |
| All others cooperated | Always cooperate | Maintain the productive equilibrium |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    others_coop_last = count_cooperators(history[round-1]) - my_action(history[round-1])
    coop_rate = others_coop_last / (n - 1)
    base_threshold = (n - k) / (n - 1)
    
    # Final round logic
    if round == r:
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.6 or coop_rate >= 0.5:
            return COOPERATE
        return DEFECT
    
    # Main game logic
    trend = calculate_trend(history)  # +1, 0, or -1
    adjusted_threshold = 0.5 - (trend * 0.1)
    
    if coop_rate >= adjusted_threshold:
        return COOPERATE
    elif coop_rate >= base_threshold:
        return COOPERATE with probability (coop_rate * 1.5)
    else:
        if round % 3 == 0:
            return COOPERATE  # Olive branch
        return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Self-reinforcing cooperation**: When multiple players use this strategy, initial cooperation triggers sustained cooperation, achieving near-optimal collective payoffs.

2. **Robust to defectors**: The threshold mechanism prevents unlimited exploitation by persistent defectors.

3. **Recovery mechanism**: Periodic olive branches and trend-based adjustments allow groups to recover from temporary breakdowns.

4. **Parameter-adaptive**: The base threshold adjusts to game parameters, making the strategy appropriate across different k and n values.
'''

description_COLLECTIVE_20 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be using similar reasoning processes and share a goal of achieving mutual benefit. The strategy aims to establish and maintain cooperation while protecting against exploitation, recognizing that in a collective of like-minded agents, coordination can emerge through consistent, readable behavior.

## Strategy Overview: **Adaptive Collective Reciprocity (ACR)**

The strategy operates on three principles:
1. **Start cooperatively** to signal collective intent
2. **Mirror the group's behavior** to reward cooperation and discourage defection
3. **Attempt recovery** periodically to escape defection traps

---

## Decision Rules

### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- Rationale: Establish good faith and signal willingness to participate in collective benefit. A collective of similar agents will coordinate on this natural focal point.

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

**Decision rule:**

```
IF coop_rate >= (n-1)/n THEN
    COOPERATE  // Near-unanimous cooperation: maintain it
    
ELSE IF coop_rate >= 0.5 THEN
    // Majority cooperating: probabilistically cooperate to encourage growth
    COOPERATE with probability = coop_rate
    
ELSE IF coop_rate > 0 THEN
    // Minority cooperating: signal willingness but protect self
    COOPERATE with probability = coop_rate^2
    // (Lower probability discourages exploitation while keeping door open)
    
ELSE  // coop_rate = 0
    // Total defection: attempt periodic recovery
    IF (current_round mod recovery_interval) == 0 THEN
        COOPERATE  // Olive branch
    ELSE
        DEFECT
```

**Recovery interval calculation:**
```
recovery_interval = max(2, floor(r/5))
```

### Last Round (Round r): Conditional Cooperation

Unlike standard game theory which predicts universal defection, a collective strategy should:

```
IF average_coop_rate_over_game >= 0.6 THEN
    COOPERATE  // Honor the cooperative relationship
ELSE IF coop_rate_in_round_(r-1) >= 0.5 THEN
    COOPERATE with probability = 0.5  // Partial trust
ELSE
    DEFECT  // Relationship was not cooperative
```

Rationale: If playing against a collective of similar agents, mutual last-round cooperation yields π = k > 1, better than mutual defection yielding π = 1.

---

## Handling Edge Cases

### Two-Player Game (n = 2)
- Standard tit-for-tat dynamics apply naturally
- The probabilistic rules simplify: opponent cooperated → cooperate; defected → likely defect

### Very Short Games (r ≤ 3)
- Round 1: Cooperate
- Round 2: Mirror round 1 exactly (if opponent cooperated, cooperate; else defect)
- Round 3 (if exists): Apply last-round rule

### Very Large Groups (n > 10)
- Individual influence diminishes; focus on reading group trends
- Increase forgiveness slightly: use `coop_rate^1.5` instead of `coop_rate^2` in low-cooperation scenarios

### All Previous Cooperators Scenario
- Continue cooperating to maintain the efficient equilibrium

### Single Defector Among Cooperators
- Continue cooperating; one defector may be noise or a different strategy testing the waters

---

## Pseudocode Summary

```python
def decide(round, history, n, r, k):
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[round-1])
    coop_rate = prev_cooperators / n
    
    if round == r:  # Last round
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.6:
            return COOPERATE
        elif coop_rate >= 0.5:
            return COOPERATE with probability 0.5
        else:
            return DEFECT
    
    # Middle rounds
    if coop_rate >= (n-1)/n:
        return COOPERATE
    elif coop_rate >= 0.5:
        return COOPERATE with probability coop_rate
    elif coop_rate > 0:
        return COOPERATE with probability coop_rate^2
    else:  # coop_rate == 0
        recovery_interval = max(2, r // 5)
        if round % recovery_interval == 0:
            return COOPERATE
        else:
            return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Focal point coordination**: Round-1 cooperation is the natural Schelling point for collective strategies
2. **Readable behavior**: Other agents can detect and reciprocate the cooperative intent
3. **Robustness**: Probabilistic matching protects against exploitation while maintaining cooperation potential
4. **Recovery mechanism**: Periodic olive branches allow escape from defection spirals
5. **Collective last-round logic**: Unlike selfish agents, a collective recognizes that mutual cooperation in the final round benefits everyone
'''

description_COLLECTIVE_19 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume all copies of this strategy will behave identically given the same observations, creating implicit coordination without explicit communication. The goal is to maximize collective welfare while being robust against defectors.

## Strategy Overview: **Adaptive Threshold Cooperation with Collective Signaling**

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness to collaborate
2. **Mirror the group's cooperation level** to reward cooperation and punish defection proportionally
3. **Protect against end-game defection** while maintaining some cooperative opportunity

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. If all collective-minded players cooperate in round 1, we establish a baseline and can identify defectors.

### Rounds 2 through (r-1): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Rule:**
```
IF coop_rate >= threshold THEN COOPERATE
ELSE DEFECT
```

**Threshold Calculation:**
```
base_threshold = (n - k) / n
```

This threshold is derived from the break-even point where cooperation becomes collectively beneficial. When at least `k` players cooperate, total welfare increases.

**Adaptive Adjustment:**
```
# Track cooperation trend over last 3 rounds (or fewer if early)
trend = average(recent_coop_rates) - coop_rate_from_round_1

# Adjust threshold based on group behavior
IF trend > 0.1 THEN threshold = base_threshold - 0.1  # Group improving, be more forgiving
ELIF trend < -0.1 THEN threshold = base_threshold + 0.1  # Group declining, be stricter
ELSE threshold = base_threshold

# Clamp threshold to reasonable bounds
threshold = max(0.3, min(0.8, threshold))
```

### Final Round (Round r): Conditional Cooperation

The last round has no future consequences, creating defection incentives. However, with collective mindset:

```
IF average_coop_rate_over_all_rounds >= 0.6 THEN COOPERATE
ELSE DEFECT
```

Rationale: If the group has demonstrated sustained cooperation, collective copies will all cooperate in the final round, achieving mutual benefit. If cooperation has been low, defection is rational.

---

## Complete Pseudocode

```
FUNCTION decide(round_number, history, n, k, r):
    
    # Round 1: Always cooperate
    IF round_number == 1:
        RETURN COOPERATE
    
    # Calculate key statistics
    last_round_cooperators = count_cooperators(history[round_number - 1])
    coop_rate = last_round_cooperators / n
    
    # Calculate base threshold
    base_threshold = (n - k) / n
    
    # For rounds 2 to r-1: Adaptive threshold
    IF round_number < r:
        
        # Calculate trend (using available history)
        lookback = min(3, round_number - 1)
        recent_rates = [count_cooperators(history[t]) / n 
                        for t in range(round_number - lookback, round_number)]
        avg_recent = average(recent_rates)
        initial_rate = count_cooperators(history[1]) / n
        trend = avg_recent - initial_rate
        
        # Adjust threshold
        IF trend > 0.1:
            threshold = base_threshold - 0.1
        ELIF trend < -0.1:
            threshold = base_threshold + 0.1
        ELSE:
            threshold = base_threshold
        
        # Clamp threshold
        threshold = max(0.3, min(0.8, threshold))
        
        IF coop_rate >= threshold:
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT
    
    # Final round: Based on overall cooperation history
    ELSE:
        total_cooperations = sum(count_cooperators(history[t]) for t in 1 to r-1)
        overall_rate = total_cooperations / (n * (r - 1))
        
        IF overall_rate >= 0.6:
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2 | Strategy applies normally | Threshold adjusts appropriately |
| r = 2 | Round 1: C, Round 2: based on round 1 | Minimal history, rely on single observation |
| k very close to n | Lower threshold, more forgiving | Cooperation is almost always beneficial |
| k very close to 1 | Higher threshold, stricter | Cooperation needs high participation to pay off |
| All defected last round | Defect (unless round 1) | Mirror group behavior |
| All cooperated last round | Cooperate | Reward and maintain cooperation |

---

## Why This Strategy Works Collectively

1. **Identical behavior**: All copies make the same observation and apply the same rules, ensuring coordinated action without communication.

2. **Self-reinforcing cooperation**: If enough collective players exist, initial cooperation triggers continued cooperation.

3. **Robust to defectors**: The threshold mechanism means a minority of defectors won't collapse cooperation, but a majority will trigger protective defection.

4. **Parameter-adaptive**: The threshold automatically adjusts to different game parameters (n, k) to remain strategically sound.
'''

description_COLLECTIVE_21 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we assume all instances of this strategy will behave identically given the same game state. This creates implicit coordination without explicit communication. The strategy aims to maximize collective welfare while protecting against exploitation by defectors.

## Strategy Overview: "Adaptive Collective Threshold"

The strategy uses a **threshold-based cooperation rule** that adapts based on observed cooperation levels in the population, combined with **end-game protection** and **forgiveness mechanisms**.

---

## Decision Rules

### Round 1: Cooperative Start
**Action: COOPERATE**

Rationale: With no history, we signal cooperative intent. If multiple copies of this strategy exist, coordinated initial cooperation establishes a cooperative baseline.

### Rounds 2 through (r-1): Adaptive Threshold Cooperation

**Cooperate if and only if** the observed cooperation rate in the previous round meets or exceeds a dynamic threshold.

```
cooperation_rate(t-1) = (number of C plays in round t-1) / n
threshold(t) = max(0.3, (k/n) + 0.1)
```

**Decision Rule:**
```
IF cooperation_rate(t-1) >= threshold(t):
    COOPERATE
ELSE:
    DEFECT
```

**Threshold Explanation:**
- The base threshold `k/n` represents the point where cooperation becomes marginally beneficial
- Adding 0.1 provides a small buffer requiring slightly more cooperation than break-even
- Floor of 0.3 ensures we don't cooperate when cooperation is extremely sparse
- This threshold is calibrated so that if a majority cooperates, we cooperate; if exploitation is rampant, we protect ourselves

### Last Round (Round r): Conditional Cooperation with History Weight

The last round requires special handling since there's no future to incentivize cooperation.

```
historical_avg_cooperation = (total C plays across all rounds) / (n × (r-1))

IF historical_avg_cooperation >= 0.6:
    COOPERATE  (reward sustained collective behavior)
ELSE:
    DEFECT     (no basis for trust)
```

---

## Edge Cases

### Edge Case 1: Very Small Games (n = 2)
Standard rules apply, but threshold naturally adjusts. With k typically between 1 and 2, threshold ≈ 0.5-1.0, meaning we need our partner to cooperate.

### Edge Case 2: Very Short Games (r = 2)
- Round 1: Cooperate
- Round 2: Apply last-round rule based on round 1 only

### Edge Case 3: High Multiplication Factor (k close to n)
Threshold becomes higher (approaching 1.0), making us more selective. This is appropriate since the benefit per cooperator is high, so we should only cooperate in highly cooperative environments.

### Edge Case 4: Low Multiplication Factor (k close to 1)
Threshold stays at floor (0.3). We maintain some willingness to cooperate but recognize the collective benefit is marginal.

### Edge Case 5: All Defection Observed
If cooperation_rate = 0 in any round, we defect in the next round. However, we include a **forgiveness probe**:

```
IF last 2 rounds had cooperation_rate = 0:
    IF round_number mod 5 == 0:
        COOPERATE  (probe for other cooperators)
    ELSE:
        DEFECT
```

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperation_rate = count_cooperators(history, round-1) / n
    
    # Calculate threshold
    threshold = max(0.3, (k/n) + 0.1)
    
    # Last round: use historical average
    if round == r:
        historical_avg = total_cooperations(history) / (n * (r-1))
        if historical_avg >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Forgiveness probe after sustained defection
    if round >= 3:
        if cooperation_rate(round-1) == 0 and cooperation_rate(round-2) == 0:
            if round mod 5 == 0:
                return COOPERATE
    
    # Standard adaptive threshold
    if prev_cooperation_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Identical behavior**: All instances make the same decision given the same history, creating natural coordination
2. **Rewards cooperation**: Continues cooperating when the group cooperates
3. **Punishes defection**: Withdraws cooperation when too many defect
4. **Forgiveness**: Periodic probes allow recovery from defection spirals
5. **Robust threshold**: Mathematically grounded in the game's payoff structure
6. **End-game awareness**: Doesn't naively cooperate in the last round but rewards historically cooperative groups
'''

description_COLLECTIVE_20 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that mutual cooperation yields the best collective outcome (payoff of k > 1 for everyone) compared to mutual defection (payoff of 1 for everyone). My goal is to foster and sustain cooperation while protecting against exploitation.

The strategy is built on three principles:
1. **Start trusting** - Signal cooperative intent from the beginning
2. **Respond proportionally** - Mirror the group's cooperation level
3. **Forgive strategically** - Allow recovery from defection spirals

---

## Strategy: Adaptive Proportional Cooperation (APC)

### Decision Rule Overview

My cooperation probability in each round is determined by the **observed cooperation rate** of the group in recent history, adjusted for the game phase (early, middle, late).

---

### Detailed Decision Rules

#### Round 1 (First Round)
**Action: COOPERATE**

Rationale: With no history, I signal cooperative intent. This establishes a foundation for mutual cooperation and gives others the opportunity to reciprocate.

#### Rounds 2 through (r-1) (Middle Rounds)

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of players who cooperated last round) / n
```

**Decision rule:**
```
IF coop_rate >= (n-1)/n THEN
    COOPERATE (near-universal cooperation achieved)
ELSE IF coop_rate >= 0.5 THEN
    COOPERATE with probability = coop_rate
    (match the group's cooperation level)
ELSE IF coop_rate > 0 THEN
    COOPERATE with probability = coop_rate × 0.5
    (reduce cooperation when group is mostly defecting, but leave door open)
ELSE (coop_rate = 0)
    DEFECT
    (no point cooperating alone, but will try again if others restart)
```

**Forgiveness mechanism:** Every ⌈r/5⌉ rounds (roughly every 20% of the game), if the recent cooperation rate has been below 0.3 for multiple consecutive rounds:
```
COOPERATE unconditionally (one-time forgiveness probe)
```
This tests whether others are willing to restart cooperation.

#### Round r (Final Round)

**Decision rule:**
```
IF cooperation_rate_last_round >= 0.6 THEN
    COOPERATE (reward sustained cooperation, maintain collective spirit)
ELSE
    DEFECT (no future rounds to recover from exploitation)
```

The threshold of 0.6 (rather than 0.5) ensures I only cooperate in the final round if there's been genuine group cooperation, not marginal compliance.

---

### Pseudocode Summary

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    coop_rate = count_cooperators(history[round-1]) / n
    
    # Final round logic
    if round == r:
        if coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Forgiveness probe (every r/5 rounds, if stuck in low cooperation)
    if round % ceil(r/5) == 0:
        recent_avg = average_coop_rate(history, last_3_rounds)
        if recent_avg < 0.3:
            return COOPERATE  # forgiveness probe
    
    # Main adaptive logic
    if coop_rate >= (n-1)/n:
        return COOPERATE
    else if coop_rate >= 0.5:
        return COOPERATE with probability coop_rate
    else if coop_rate > 0:
        return COOPERATE with probability (coop_rate * 0.5)
    else:
        return DEFECT
```

---

### Edge Cases Handled

| Scenario | Response |
|----------|----------|
| First round | Always cooperate |
| Last round with high cooperation | Cooperate (reward collective success) |
| Last round with low cooperation | Defect (no recovery possible) |
| Everyone defected last round | Defect, but probe forgiveness periodically |
| Only I defected last round | Return to cooperation (I was the problem) |
| 2-player game (n=2) | Behaves like Tit-for-Tat with forgiveness |
| Very short games (r≤3) | Forgiveness probes disabled; core logic applies |

---

### Why This Strategy is Collectively Aligned

1. **Promotes group welfare**: Starts cooperative and sustains cooperation when others reciprocate
2. **Proportional response**: Doesn't over-punish occasional defection; mirrors group behavior
3. **Forgiveness**: Prevents permanent defection spirals that hurt everyone
4. **Protects against exploitation**: Reduces cooperation when facing persistent defectors
5. **No complex coordination needed**: Works based solely on observable history

This strategy aims to be a **good citizen** in the collective—encouraging cooperation, punishing defection proportionally, and always leaving room for recovery.
'''

description_COLLECTIVE_22 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I aim to maximize group welfare while protecting against exploitation. The key insight is that mutual cooperation yields the best collective outcome (everyone gets k > 1), but individual defection against cooperators is tempting. My strategy seeks to **establish and maintain cooperation** while being **robust against defectors**.

---

## Strategy: "Graduated Collective Reciprocity" (GCR)

### Overview

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness to build collective welfare
2. **Mirror the group's cooperation level** to reward cooperation and punish defection proportionally
3. **Forgive strategically** to escape mutual defection traps, but become less forgiving over time

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. In a collective context, someone must initiate cooperation. The cost of being exploited once is small compared to the potential gain of establishing mutual cooperation for remaining rounds.

---

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision rule:**

```
IF coop_rate >= threshold THEN COOPERATE
ELSE DEFECT with probability (1 - coop_rate), COOPERATE otherwise
```

Where **threshold** is dynamically calculated:
```
base_threshold = 0.5
rounds_remaining_ratio = (r - current_round) / r
threshold = base_threshold - (0.2 * rounds_remaining_ratio)
```

This means:
- Early in the game: threshold ≈ 0.3 (more forgiving, trying to build cooperation)
- Later in the game: threshold → 0.5 (less forgiving, protecting against exploitation)

**Forgiveness mechanism:**
After 2 consecutive rounds of mutual defection (coop_rate < 0.3), inject a **probe cooperation** with probability:
```
forgiveness_prob = 0.15 * rounds_remaining_ratio
```
This attempts to restart cooperation but becomes rare as the game ends.

---

### Final Round (Round r): Conditional Cooperation

**NOT unconditional defection.** Instead:

```
IF average_coop_rate_over_all_rounds >= 0.6 THEN COOPERATE
ELSE DEFECT
```

Rationale: If the group has maintained good cooperation, I honor that collective achievement even in the last round. This builds reputation if there's any uncertainty about game length and aligns with collective values. However, if cooperation has been poor, there's no collective trust to maintain.

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2 (minimum players) | Use stricter threshold (0.6 base) | With only 2 players, I need direct reciprocity to work |
| r = 2 (minimum rounds) | Cooperate both rounds unless exploited in R1 | Not enough rounds to recover from defection spiral |
| k very close to 1 | Same strategy, but accept lower cooperation rates | Benefits of cooperation are smaller, so tolerate more defection |
| k close to n | Same strategy | High returns make cooperation more valuable |
| Everyone defected last round | Probe cooperate with forgiveness probability | Attempt to restart; someone must break the cycle |
| I was the only cooperator | Defect next round (coop_rate was 1/n which is low) | Don't be a sucker repeatedly |
| Everyone cooperated | Cooperate | Reward and maintain the collective good |

---

## Pseudocode

```python
def decide(round_number, history, n, r, k):
    
    # Round 1: Signal cooperation
    if round_number == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history[round_number - 1])
    coop_rate = prev_cooperators / n
    
    # Final round: Conditional based on overall history
    if round_number == r:
        avg_coop = average_cooperation_rate(history)
        return COOPERATE if avg_coop >= 0.6 else DEFECT
    
    # Calculate dynamic threshold
    rounds_remaining_ratio = (r - round_number) / r
    threshold = 0.5 - (0.2 * rounds_remaining_ratio)
    
    # Forgiveness check after defection spiral
    if consecutive_low_cooperation(history, threshold=0.3, count=2):
        forgiveness_prob = 0.15 * rounds_remaining_ratio
        if random() < forgiveness_prob:
            return COOPERATE
    
    # Main decision rule
    if coop_rate >= threshold:
        return COOPERATE
    else:
        # Probabilistic defection proportional to group defection
        if random() < coop_rate:
            return COOPERATE
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Encourages cooperation**: Starts cooperatively and rewards group cooperation
2. **Protects against exploitation**: Defects when others defect, preventing free-riding
3. **Escapes defection traps**: Forgiveness mechanism can restart cooperation
4. **Scales with group size**: Uses proportional thresholds rather than absolute counts
5. **Adapts to game length**: More forgiving early, more protective late
6. **Honors collective success**: Cooperates in final round if group earned it

This strategy embodies the collective ideal: *contribute to the common good, but don't let defectors undermine it*.
'''

description_COLLECTIVE_21 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: we assume all players using this strategy will behave identically given the same history, creating implicit coordination without explicit communication. The strategy aims to:
1. Establish cooperation as the default norm
2. Punish defection proportionally to deter exploitation
3. Forgive and restore cooperation when the group shows willingness
4. Adapt to the cooperation level that the group can sustain

---

## Strategy: Adaptive Threshold Cooperation (ATC)

### Key Parameters Derived from Game Parameters

```
cooperation_threshold = k / n  # The fraction where cooperation becomes individually rational if others cooperate
forgiveness_rate = 1 / sqrt(r)  # How quickly we forgive (slower in longer games)
punishment_duration = max(1, floor(r / 10))  # How long punishment phases last
```

### State Variables (Updated Each Round)

```
cooperation_rate = (number of cooperators in last round) / n
cumulative_cooperation = running average of cooperation_rate across all rounds
rounds_remaining = r - current_round
punishment_counter = 0  # Counts down during punishment phases
```

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. Since all instances of this strategy behave identically, we establish a cooperative equilibrium from the start.

---

### Rounds 2 through (r-1): Adaptive Response

**Primary Rule: Threshold-Based Cooperation**

```
IF punishment_counter > 0:
    punishment_counter -= 1
    ACTION: DEFECT
    
ELSE IF cooperation_rate >= (n-1)/n:
    # Near-universal cooperation: maintain it
    ACTION: COOPERATE
    
ELSE IF cooperation_rate >= 0.5:
    # Majority cooperating: continue cooperating to sustain group benefit
    ACTION: COOPERATE
    
ELSE IF cooperation_rate >= k/n AND cooperation_rate > previous_cooperation_rate:
    # Below majority but improving: give it a chance (forgiveness)
    ACTION: COOPERATE
    
ELSE IF cooperation_rate < 0.5 AND cooperation_rate < previous_cooperation_rate:
    # Declining cooperation below majority: enter punishment phase
    punishment_counter = punishment_duration
    ACTION: DEFECT
    
ELSE:
    # Low cooperation, not improving
    ACTION: DEFECT
```

**Secondary Rule: Periodic Forgiveness Probe**

```
IF currently defecting due to low cooperation:
    IF current_round % ceil(1/forgiveness_rate) == 0:
        # Periodically test if cooperation can be restored
        ACTION: COOPERATE (override)
```

---

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection, we maintain collective thinking:

```
IF cumulative_cooperation >= 0.6:
    # The group has been largely cooperative; honor that
    ACTION: COOPERATE
    
ELSE IF cooperation_rate in round (r-1) >= 0.5:
    # Recent cooperation is decent; reciprocate
    ACTION: COOPERATE
    
ELSE:
    # Group has been exploitative; no reason to sacrifice
    ACTION: DEFECT
```

---

## Complete Pseudocode

```python
def decide(game_params, history):
    n, r, k = game_params.n, game_params.r, game_params.k
    current_round = len(history) + 1
    
    # Round 1: Always cooperate
    if current_round == 1:
        return COOPERATE
    
    # Calculate statistics from history
    last_round = history[-1]
    cooperation_rate = sum(last_round) / n
    cumulative_cooperation = mean([sum(round)/n for round in history])
    
    previous_cooperation_rate = sum(history[-2])/n if len(history) >= 2 else 1.0
    
    # Derived parameters
    punishment_duration = max(1, r // 10)
    forgiveness_interval = max(2, int(sqrt(r)))
    
    # Check if in punishment phase (count recent consecutive low-cooperation responses)
    punishment_counter = 0
    for i in range(min(punishment_duration, len(history))):
        if sum(history[-(i+1)])/n < 0.5:
            punishment_counter += 1
        else:
            break
    
    in_punishment = punishment_counter >= punishment_duration
    
    # Final round logic
    if current_round == r:
        if cumulative_cooperation >= 0.6 or cooperation_rate >= 0.5:
            return COOPERATE
        return DEFECT
    
    # Forgiveness probe (periodic cooperation attempt)
    if in_punishment and current_round % forgiveness_interval == 0:
        return COOPERATE
    
    # Main decision logic
    if in_punishment and cooperation_rate < 0.5:
        return DEFECT
    
    if cooperation_rate >= 0.5:
        return COOPERATE
    
    if cooperation_rate >= k/n and cooperation_rate > previous_cooperation_rate:
        return COOPERATE  # Improving trend
    
    return DEFECT
```

---

## Strategy Properties

| Property | How Addressed |
|----------|---------------|
| **Collective alignment** | Identical behavior given same history ensures coordination among copies |
| **Robustness to defectors** | Punishment phases prevent exploitation |
| **Forgiveness** | Periodic probes allow escape from mutual defection |
| **Adaptation** | Thresholds respond to actual group behavior |
| **End-game stability** | Final round cooperates if history warrants it |
| **Parameter sensitivity** | Thresholds scale with k/n ratio and game length r |

This strategy balances the tension between collective optimality (all cooperate) and individual rationality (defect against defectors), using observable cooperation rates as the coordination signal.
'''

description_COLLECTIVE_23 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that mutual cooperation produces the best collective outcome (everyone gets k > 1), while mutual defection leaves everyone worse off (everyone gets 1). My goal is to foster and sustain cooperation while protecting against exploitation.

The key insight is that in a multiplayer setting, I should be **generous but not naive** - willing to cooperate to build collective welfare, but responsive to the aggregate behavior of the group rather than demanding perfection.

## Strategy: **Generous Threshold Trigger with Forgiveness**

### Decision Rules

**Round 1: Cooperate**
- Start cooperatively to signal willingness to contribute to collective welfare
- This gives the group a chance to establish mutual cooperation

**Rounds 2 through (r-1): Conditional Cooperation Based on Group Behavior**

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Cooperate if:**
```
coop_rate ≥ threshold
```

Where the **adaptive threshold** is calculated as:
```
base_threshold = (n - k) / (n - 1)
```

This base threshold represents the minimum cooperation level where cooperating yields at least as much as defecting would. However, I adjust it:

```
threshold = max(0.4, base_threshold - forgiveness_bonus)

forgiveness_bonus = 0.1 × (rounds_of_high_cooperation / total_rounds_played)
```

Where `rounds_of_high_cooperation` counts rounds where coop_rate ≥ 0.6.

**Additional Forgiveness Mechanism:**
- Every 3 rounds, if I've been defecting, **probe with cooperation** regardless of threshold
- This allows recovery from defection spirals and tests if the group is ready to rebuild cooperation

**Last Round (Round r): Probabilistic Cooperation**

Rather than guaranteed defection (which unravels cooperation via backward induction):
```
Cooperate with probability = recent_coop_rate × (k/n)
```

This maintains some cooperative possibility even at the end, rewarding groups that have maintained cooperation.

### Pseudocode

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    # Calculate previous round statistics
    prev_cooperators = count_cooperators(history[round-1])
    coop_rate = prev_cooperators / n
    
    # Calculate adaptive threshold
    base_threshold = (n - k) / (n - 1)
    high_coop_rounds = count_rounds_where(history, coop_rate >= 0.6)
    forgiveness_bonus = 0.1 * (high_coop_rounds / (round - 1))
    threshold = max(0.4, base_threshold - forgiveness_bonus)
    
    # Last round: probabilistic
    if round == r:
        recent_coop = average_coop_rate(history, last=3)
        prob_cooperate = recent_coop * (k / n)
        return COOPERATE with probability prob_cooperate
    
    # Periodic forgiveness probe (every 3 rounds)
    my_last_action = get_my_action(history[round-1])
    if round % 3 == 0 and my_last_action == DEFECT:
        return COOPERATE  # Probe for cooperation recovery
    
    # Main decision rule
    if coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

### Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Cooperate | Establish cooperative intent |
| Everyone cooperated last round | Cooperate | Maintain successful collective outcome |
| Everyone defected last round | Defect (unless probe round) | Protect against exploitation |
| Mixed results near threshold | Use calculated threshold | Respond proportionally |
| Last round | Probabilistic based on history | Avoid pure defection spiral |
| n=2 (minimum players) | Strategy still works | Threshold adjusts appropriately |
| k close to n | Lower threshold (more forgiving) | Cooperation is more valuable |
| k close to 1 | Higher threshold (more cautious) | Cooperation benefit is marginal |

### Why This Strategy Supports Collective Welfare

1. **Starts cooperatively** - Gives the group the best chance to coordinate
2. **Responds to aggregate behavior** - Doesn't punish the group for one defector
3. **Adaptive threshold** - Becomes more forgiving when cooperation has been established
4. **Forgiveness probes** - Allows escape from defection traps
5. **No harsh last-round defection** - Maintains cooperative incentives throughout
6. **Parameter-aware** - Adjusts behavior based on how valuable cooperation actually is (k/n ratio)
'''

description_COLLECTIVE_22 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I recognize that if all players reason similarly and cooperate, we all achieve the best collective outcome (payoff of k per round vs. 1 from universal defection). However, I must be robust against defectors who exploit cooperators. The strategy aims to **establish and maintain cooperation while protecting against exploitation**.

## Strategy: Adaptive Threshold Cooperation (ATC)

### Key Insight

The critical insight is that cooperation is individually rational *if enough others cooperate*. Specifically, if I'm currently defecting and considering switching to cooperation, I gain (k/n) from my contribution but lose 1 from my endowment. This is worthwhile if the cooperative environment is sustainable. More importantly, **collective cooperation yields k > 1 for everyone**, so establishing cooperation benefits all.

### Decision Rules

#### Round 1: Cooperative Start
**Action: COOPERATE**

Rationale: Begin by signaling cooperative intent. This gives the collective the opportunity to establish mutual cooperation. Starting with defection poisons the well immediately.

#### Rounds 2 through (r-1): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

Calculate **trend** (if round ≥ 3):
```
trend = coop_rate(current) - coop_rate(previous)
```

**Decision Logic:**

```
threshold = base_threshold + trend_adjustment + round_adjustment

where:
  base_threshold = 0.5  (majority cooperation benchmark)
  trend_adjustment = 0.1 if trend > 0 else -0.05 if trend < 0 else 0
  round_adjustment = -0.05 × (current_round / r)  # slightly more forgiving as game progresses mid-game

If coop_rate >= threshold:
    COOPERATE
Else if coop_rate >= threshold - 0.15 AND my_previous_action == COOPERATE:
    COOPERATE  (give cooperation one more chance - hysteresis)
Else:
    DEFECT
```

**Additional Forgiveness Mechanism:**
Every ⌈r/4⌉ rounds, if currently in a defection pattern:
```
If current_round % ceil(r/4) == 0 AND last_action == DEFECT:
    COOPERATE  (probe for renewed cooperation)
```

#### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection in the final round, a collective strategy recognizes that:
- If we've maintained cooperation, breaking it gains me at most (1 - k/n) 
- Universal final-round defection costs everyone (k - 1) compared to cooperation

**Decision:**
```
If coop_rate in round (r-1) >= 0.6:
    COOPERATE  (maintain collective benefit)
Else:
    DEFECT  (cooperation has already collapsed)
```

### Edge Cases

1. **n = 2 (minimum players):** Strategy functions as modified Tit-for-Tat with forgiveness
2. **Very low k (close to 1):** Cooperation benefits are slim; threshold naturally harder to meet, allowing graceful degradation
3. **k close to n:** High cooperation benefits; strategy will naturally sustain cooperation longer
4. **r = 2 (minimum rounds):** Cooperate round 1; round 2 follows final round logic
5. **All defection in round 1:** Will defect round 2, but forgiveness probe at round ⌈r/4⌉ offers recovery

### Pseudocode Summary

```python
def choose_action(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    coop_rate = count_cooperators(history[round-1]) / n
    
    if round == r:  # final round
        return COOPERATE if coop_rate >= 0.6 else DEFECT
    
    # Calculate adaptive threshold
    trend = 0
    if round >= 3:
        prev_rate = count_cooperators(history[round-2]) / n
        trend = coop_rate - prev_rate
    
    threshold = 0.5
    threshold += 0.1 if trend > 0 else (-0.05 if trend < 0 else 0)
    threshold -= 0.05 * (round / r)
    
    # Forgiveness probe
    if round % ceil(r/4) == 0 and history[round-1][my_id] == DEFECT:
        return COOPERATE
    
    # Main decision with hysteresis
    if coop_rate >= threshold:
        return COOPERATE
    elif coop_rate >= threshold - 0.15 and history[round-1][my_id] == COOPERATE:
        return COOPERATE
    else:
        return DEFECT
```

This strategy balances collective optimism with protective realism, aiming to maximize group welfare while remaining robust against exploitation.
'''

description_COLLECTIVE_24 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy operates from a collective mindset: **we are all instances of the same strategic reasoning, facing the same incentives**. If a strategy is good for me to play, it's good for all of us to play. Therefore, I should choose the action that, if universally adopted by rational cooperators like myself, maximizes collective welfare while remaining robust against defectors.

The key insight: with k > 1, mutual cooperation yields k/n × n = k > 1 per player, while mutual defection yields 1. **Cooperation is collectively superior**, but vulnerable to exploitation.

## Strategy: Adaptive Threshold Cooperation (ATC)

### Decision Framework

The strategy maintains a **cooperation threshold** θ that adapts based on observed group behavior. I cooperate when the estimated proportion of cooperators in the group exceeds θ.

### Parameters (derived from game parameters)

- `baseline_threshold` = 0.5 (require majority cooperation signal)
- `forgiveness_rate` = 0.1 (how quickly to restore trust)
- `punishment_severity` = 0.3 (how quickly to withdraw cooperation)
- `end_game_horizon` = max(2, floor(r/5)) (rounds where end-game logic applies)

### Round-by-Round Decision Rules

```
FUNCTION decide(round_number, history, n, k, r):
    
    # FIRST ROUND: Cooperate unconditionally
    IF round_number == 1:
        RETURN C
    
    # LAST ROUND: Conditional cooperation based on group trust
    IF round_number == r:
        cooperation_rate = average_cooperation_rate(history)
        IF cooperation_rate >= 0.7:
            RETURN C  # Reward sustained cooperation
        ELSE:
            RETURN D  # No future to protect
    
    # END-GAME PHASE (final rounds before last)
    IF round_number > r - end_game_horizon:
        recent_coop_rate = cooperation_rate(last 3 rounds of history)
        IF recent_coop_rate >= 0.8:
            RETURN C  # Maintain cooperation in high-trust groups
        ELSE:
            RETURN D  # Defect in deteriorating situations
    
    # MAIN PHASE: Adaptive threshold cooperation
    θ = compute_threshold(history, n, k)
    estimated_cooperators = estimate_next_round_cooperation(history)
    
    IF estimated_cooperators / n >= θ:
        RETURN C
    ELSE:
        RETURN D
```

### Threshold Computation

```
FUNCTION compute_threshold(history, n, k):
    
    # Start with baseline
    θ = 0.5
    
    # Adjust based on cooperation trend
    IF len(history) >= 3:
        recent_rate = cooperation_rate(last 3 rounds)
        older_rate = cooperation_rate(rounds before last 3)
        trend = recent_rate - older_rate
        
        IF trend > 0.1:  # Cooperation increasing
            θ = θ - 0.15  # Lower threshold (encourage cooperation)
        ELIF trend < -0.1:  # Cooperation decreasing
            θ = θ + 0.15  # Raise threshold (protect against collapse)
    
    # Adjust based on overall history
    overall_rate = cooperation_rate(all history)
    IF overall_rate >= 0.7:
        θ = max(0.3, θ - 0.1)  # Trust established
    ELIF overall_rate <= 0.3:
        θ = min(0.8, θ + 0.1)  # Low trust environment
    
    # Clamp threshold
    RETURN clamp(θ, 0.25, 0.85)
```

### Cooperation Estimation

```
FUNCTION estimate_next_round_cooperation(history):
    
    IF len(history) < 2:
        RETURN last_round_cooperators(history)
    
    # Weighted average: recent rounds matter more
    weights = [0.5, 0.3, 0.2]  # last 3 rounds
    recent_rounds = last_n_rounds(history, 3)
    
    estimate = weighted_average(recent_rounds, weights)
    
    # Regression toward mean (others may also adapt)
    estimate = 0.8 * estimate + 0.2 * (n/2)
    
    RETURN estimate
```

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | C | Signal cooperative intent; no information yet |
| Round 2 after all-D | C | Give one more chance; might have been coordination failure |
| Round 2 after mixed | C if ≥40% cooperated | Sufficient cooperation signal |
| Sudden defection spike | D for 1-2 rounds, then test with C | Punish but don't permanently abandon |
| Sustained high cooperation (≥80%) | C | Reward and maintain |
| Final round, high-trust group | C | Collective optimum; we all reason the same |
| Final round, low-trust group | D | No future benefit to protect |

## Robustness Features

1. **Against all-defectors**: After 2-3 rounds of near-zero cooperation, threshold rises to 0.8+, causing us to defect and avoid exploitation.

2. **Against all-cooperators**: Threshold drops, we cooperate, collective optimum achieved.

3. **Against mixed/random**: We follow the majority trend with slight optimism bias.

4. **Against conditional cooperators (like TFT variants)**: Initial cooperation establishes mutual cooperation equilibrium.

5. **Against gradual defection**: Trend detection catches deterioration early.

## Collective Alignment

This strategy is designed so that **if all players use it, the outcome is sustained cooperation** with total payoff approaching r × k per player (the social optimum). The first-round cooperation and forgiveness mechanisms ensure that identical strategies converge to cooperation rather than getting trapped in mutual defection.

The strategy never defects preemptively against cooperative groups, and always gives new groups a fair chance to establish cooperation.
'''

description_COLLECTIVE_23 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective identity**: all instances running this strategy act as one unified agent. We aim to maximize group welfare while protecting against exploitation. The strategy balances three principles:

1. **Start cooperatively** to establish a cooperation norm
2. **Respond proportionally** to the observed cooperation level
3. **Maintain hope** but protect against persistent free-riders

---

## Strategy: Adaptive Proportional Cooperation (APC)

### Decision Rule

The core decision is based on a **cooperation threshold** that adapts based on observed behavior and remaining rounds.

#### Key Variables

- `coop_rate(t)` = proportion of all players who cooperated in round t
- `avg_coop_rate` = average cooperation rate across all completed rounds
- `rounds_remaining` = r - current_round

#### Cooperation Probability Function

Rather than deterministic switching, use a **probabilistic threshold** to create unpredictability and robustness:

```
P(Cooperate) = f(avg_coop_rate, rounds_remaining, k, n)
```

---

### Detailed Decision Rules

#### Round 1 (Bootstrap Phase)
**Action: COOPERATE**

Rationale: Signal cooperative intent. With no history, we default to cooperation to give the group the best chance of establishing mutual benefit.

#### Rounds 2 through (r-1) (Main Phase)

Calculate cooperation probability as follows:

```
base_threshold = (n - k) / (n - 1)
# This is the break-even cooperation rate where C and D yield equal expected payoffs

adjusted_threshold = base_threshold * forgiveness_factor
# where forgiveness_factor = 0.8 (we cooperate even slightly below break-even)

If avg_coop_rate >= adjusted_threshold:
    P(Cooperate) = min(1.0, avg_coop_rate + generosity_bonus)
    # generosity_bonus = 0.1 (lead by example)
Else:
    P(Cooperate) = max(0.1, avg_coop_rate * recovery_factor)
    # recovery_factor = 0.5 (maintain some cooperation to allow recovery)
    # minimum 0.1 ensures we never fully abandon cooperation
```

**Interpretation:**
- If others are cooperating at a sustainable rate, we cooperate at slightly higher rate (lead by example)
- If cooperation is collapsing, we reduce but don't eliminate cooperation (keep door open)
- The 0.1 floor means we always maintain a 10% cooperation chance as an "olive branch"

#### Last Round (Round r)

```
If avg_coop_rate >= 0.7:
    P(Cooperate) = avg_coop_rate  # Maintain established norm
Else if avg_coop_rate >= 0.4:
    P(Cooperate) = 0.3  # Partial cooperation for moderate groups
Else:
    P(Cooperate) = 0.1  # Minimal cooperation for defecting groups
```

Rationale: Unlike pure game theory (which says always defect in last round), we recognize:
1. Other collective instances benefit from our cooperation
2. Maintaining reputation matters if this is part of a larger tournament
3. A small cooperation probability prevents complete collapse

---

### Handling Edge Cases

**If n = 2 (two players):**
- Use standard Tit-for-Tat with forgiveness
- Cooperate first, then mirror opponent with 15% forgiveness probability

**If k is very close to n (high multiplication factor):**
- Increase generosity_bonus to 0.15
- Cooperation is more socially efficient, worth taking more risk

**If k is very close to 1 (low multiplication factor):**
- Decrease generosity_bonus to 0.05
- Be more cautious as cooperation benefits are marginal

**If r ≤ 3 (very short game):**
- Round 1: Cooperate
- Round 2: Cooperate if round 1 had ≥50% cooperation, else defect
- Round 3 (if exists): Use last-round rule

---

### Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    avg_coop = average_cooperation_rate(history)
    base_threshold = (n - k) / (n - 1)
    adjusted_threshold = base_threshold * 0.8
    
    if round == r:  # Last round
        if avg_coop >= 0.7:
            p_coop = avg_coop
        elif avg_coop >= 0.4:
            p_coop = 0.3
        else:
            p_coop = 0.1
    else:  # Middle rounds
        if avg_coop >= adjusted_threshold:
            p_coop = min(1.0, avg_coop + 0.1)
        else:
            p_coop = max(0.1, avg_coop * 0.5)
    
    return COOPERATE if random() < p_coop else DEFECT
```

---

## Why This Strategy Works Collectively

1. **Coordinated opening**: All instances cooperate in round 1, maximizing initial group payoff
2. **Shared response**: All instances respond similarly to the environment, maintaining coordination
3. **Graceful degradation**: When facing defectors, we don't collapse immediately
4. **Recovery capability**: The minimum cooperation floor allows groups to rebuild trust
5. **Proportional fairness**: We give roughly what we receive, adjusted for social optimality
'''

description_COLLECTIVE_25 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I recognize that if all players reason similarly and cooperate, we all achieve higher payoffs than universal defection. The strategy aims to **establish and maintain cooperation** while being **robust against exploitation** and **forgiving of mistakes**.

## Strategy Overview: "Graduated Reciprocity with Collective Hope"

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness to cooperate
2. **Reciprocate proportionally** based on observed group cooperation levels
3. **Maintain hope** by periodically testing for cooperation recovery

---

## Decision Rules

### Round 1: Cooperate
Always cooperate in the first round. This signals cooperative intent and gives the collective the best chance to establish mutual cooperation.

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision rule:**
- If `coop_rate >= (n-1)/n` (almost everyone cooperated): **Cooperate**
- If `coop_rate >= 0.5` (majority cooperated): **Cooperate with probability = coop_rate**
- If `coop_rate < 0.5` (minority cooperated): 
  - Check if this is a "probe round" (see below)
  - Otherwise: **Cooperate with probability = coop_rate²**

**Probe Rounds (Forgiveness Mechanism):**
Every `⌈r/5⌉` rounds (approximately 5 times per game), if cooperation has collapsed (`coop_rate < 0.5`), cooperate anyway. This tests whether others are also willing to restart cooperation.

```
is_probe_round = (current_round % ⌈r/5⌉ == 0)
if is_probe_round and coop_rate < 0.5:
    Cooperate
```

### Last Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection in the final round, this collective strategy:

- If **average cooperation rate over all previous rounds >= 0.6**: **Cooperate**
  - Rationale: Reward a cooperative game with continued cooperation; if others reason similarly, we all benefit
- Otherwise: **Defect**
  - Rationale: No point maintaining cooperation that was never established

---

## Pseudocode

```
function decide(round, history, n, r, k):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_count = count_cooperators(history[round - 1])
    coop_rate = prev_coop_count / n
    
    # Calculate historical average cooperation
    total_coop = sum(count_cooperators(h) for h in history)
    total_actions = n * (round - 1)
    avg_coop_rate = total_coop / total_actions
    
    # Last round: conditional on game history
    if round == r:
        if avg_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: graduated reciprocity
    probe_interval = max(1, ceil(r / 5))
    is_probe_round = (round % probe_interval == 0)
    
    # High cooperation: maintain it
    if coop_rate >= (n - 1) / n:
        return COOPERATE
    
    # Majority cooperation: probabilistically reciprocate
    if coop_rate >= 0.5:
        return COOPERATE with probability coop_rate
    
    # Low cooperation: probe or reluctantly reciprocate
    if is_probe_round:
        return COOPERATE  # Test for recovery
    else:
        return COOPERATE with probability (coop_rate ^ 2)
```

---

## Key Features

| Feature | Purpose |
|---------|---------|
| **Cooperative start** | Maximizes chance of establishing cooperation |
| **Proportional response** | Rewards cooperation, punishes defection gradually |
| **Probe rounds** | Allows recovery from cooperation collapse |
| **Cooperative last round** | Breaks backward induction if others reason similarly |
| **Probabilistic decisions** | Creates unpredictability, prevents exploitation patterns |

---

## Robustness Properties

- **Against all-defect players**: Quickly reduces cooperation probability, limiting losses
- **Against all-cooperate players**: Maintains full cooperation, achieving optimal collective outcome
- **Against tit-for-tat types**: Establishes stable mutual cooperation
- **Against random players**: Adapts proportionally to observed cooperation levels
- **Against exploiters**: Probabilistic response prevents predictable exploitation
'''

description_COLLECTIVE_24 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similarly-minded agents) may be present in the population. The goal is to establish cooperation when possible, maintain it through reciprocity, and protect against exploitation—while creating conditions where cooperative agents can recognize each other and coordinate.

## Strategy Overview: **Adaptive Threshold Reciprocity (ATR)**

The strategy maintains cooperation when a sufficient fraction of the group cooperates, forgives occasional defections, but protects against systematic exploitation.

---

## Decision Rules

### Key Variables Tracked
- `cooperation_rate[t]`: Fraction of all players who cooperated in round t
- `cumulative_coop_rate`: Running average cooperation rate across all rounds
- `consecutive_low_rounds`: Number of consecutive rounds below cooperation threshold
- `rounds_remaining`: r - current_round

### Cooperation Threshold
```
base_threshold = 0.5
adaptive_threshold = max(0.3, min(0.7, cumulative_coop_rate - 0.1))
```

The threshold adapts: in cooperative environments, we expect more; in hostile ones, we lower expectations to maintain any cooperation that exists.

---

## Round-by-Round Decision Rules

### First Round
**Action: COOPERATE**

Rationale: Signal cooperative intent. This allows other cooperative agents to identify potential partners and establishes a baseline for reciprocity.

### Middle Rounds (rounds 2 through r-2)

```
IF cooperation_rate[t-1] >= adaptive_threshold:
    ACTION = COOPERATE
    
ELIF cooperation_rate[t-1] >= 0.3 AND consecutive_low_rounds < 2:
    # Forgiveness mechanism - give benefit of doubt
    ACTION = COOPERATE
    
ELIF cumulative_coop_rate >= 0.4 AND random() < 0.2:
    # Probe for recovery - occasionally test if cooperation can restart
    ACTION = COOPERATE
    
ELSE:
    ACTION = DEFECT
```

### Second-to-Last Round (round r-1)
```
IF cooperation_rate[t-1] >= 0.5:
    # Strong cooperation signal - maintain it
    ACTION = COOPERATE
ELSE:
    ACTION = DEFECT
```

### Final Round (round r)
```
IF cumulative_coop_rate >= 0.6:
    # Reward sustained group cooperation with continued cooperation
    # This is the collective choice - we don't defect on cooperative groups
    ACTION = COOPERATE
ELSE:
    # Low overall cooperation - no point maintaining facade
    ACTION = DEFECT
```

**Note on final round**: Standard game theory suggests always defecting in the last round. However, from a collective mindset, if I'm playing with other cooperative agents, mutual cooperation in the final round yields higher collective payoff. The threshold ensures we only extend this trust to groups that have demonstrated sustained cooperation.

---

## Handling Edge Cases

### Very Small Groups (n = 2-3)
When n is small, each player's action has outsized impact on cooperation rate:
- Use stricter threshold: `adaptive_threshold = max(0.4, base calculation)`
- Require 2 consecutive defection rounds before switching to defect

### Very Large Groups (n > 10)
Individual impact is diluted:
- More tolerant threshold: `adaptive_threshold = max(0.25, base calculation)`
- Cooperation is harder to establish, so value any cooperation achieved

### Short Games (r ≤ 5)
Limited time to establish patterns:
- Cooperate in rounds 1-2 unconditionally
- Apply standard rules for remaining rounds
- Final round rule still applies

### Near-Universal Cooperation (cooperation_rate > 0.9)
Maintain the equilibrium:
- Always cooperate unless rate drops below 0.7 for 2+ rounds

### Near-Universal Defection (cooperation_rate < 0.2 for 3+ rounds)
Protect against exploitation:
- Switch to permanent defection
- Exception: One "olive branch" cooperation every 5 rounds to test for recovery

---

## Pseudocode Summary

```python
def decide(round, history, n, r, k):
    if round == 1:
        return COOPERATE
    
    # Calculate metrics
    last_coop_rate = count_cooperators(history[round-1]) / n
    cumulative_rate = total_cooperations(history) / (n * (round - 1))
    consecutive_low = count_consecutive_below_threshold(history, 0.3)
    adaptive_thresh = clamp(0.3, cumulative_rate - 0.1, 0.7)
    
    # Final round logic
    if round == r:
        return COOPERATE if cumulative_rate >= 0.6 else DEFECT
    
    # Second-to-last round
    if round == r - 1:
        return COOPERATE if last_coop_rate >= 0.5 else DEFECT
    
    # Permanent defection check (exploited population)
    if consecutive_low >= 3 and cumulative_rate < 0.2:
        if round % 5 == 0:  # Occasional probe
            return COOPERATE
        return DEFECT
    
    # Main decision logic
    if last_coop_rate >= adaptive_thresh:
        return COOPERATE
    elif last_coop_rate >= 0.3 and consecutive_low < 2:
        return COOPERATE  # Forgiveness
    elif cumulative_rate >= 0.4 and random() < 0.2:
        return COOPERATE  # Recovery probe
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Recognition**: Starting with cooperation allows cooperative agents to find each other
2. **Stability**: Threshold-based reciprocity maintains cooperation once established
3. **Forgiveness**: Tolerating occasional defections prevents death spirals from noise
4. **Protection**: Eventually punishes systematic defection
5. **Recovery**: Probing allows restart of cooperation if conditions change
6. **Collective final round**: Doesn't betray cooperative groups, maximizing group welfare
'''

description_COLLECTIVE_26 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with the understanding that **I am one of many instances of this same strategy** playing in the tournament. My goal is to maximize collective welfare for all players using this strategy while remaining robust against defectors and exploiters. Since we cannot explicitly coordinate, we must coordinate implicitly through shared logic and observable behavior patterns.

## Strategy Overview: "Graduated Collective Reciprocity"

The strategy operates on three principles:
1. **Signal cooperative intent early** through consistent cooperation
2. **Mirror the collective behavior** of the group to encourage cooperation and discourage freeloading
3. **Protect against end-game collapse** while maintaining cooperation among fellow cooperators

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Establish cooperative intent. All instances of this strategy will cooperate in round 1, creating an immediate signal of collective identity.

### Rounds 2 through (r-2): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Rule:**
```
IF coop_rate >= (n-1)/n THEN COOPERATE
    # Near-universal cooperation - maintain it
    
ELSE IF coop_rate >= 0.5 THEN
    # Moderate cooperation - use probabilistic matching
    COOPERATE with probability = coop_rate
    
ELSE IF coop_rate > 0 THEN
    # Low cooperation - cooperate only to signal, with decreasing probability
    COOPERATE with probability = coop_rate^2
    
ELSE (coop_rate == 0)
    # Complete defection last round
    COOPERATE with probability = 1/n
    # Small chance to restart cooperation cycle
```

**Deterministic Tie-Breaker for Probabilistic Decisions:**
To ensure all instances of this strategy act identically (enabling implicit coordination), use a deterministic pseudo-random function based on shared observable information:

```
seed = hash(round_number, previous_round_actions, n, k, r)
threshold = deterministic_random(seed) in [0,1]
IF threshold < target_probability THEN COOPERATE ELSE DEFECT
```

### Round (r-1): Penultimate Round

**Decision Rule:**
```
IF cooperation_rate_history_average >= 0.6 THEN COOPERATE
ELSE DEFECT
```

Rationale: If the game has been predominantly cooperative, continue cooperating to maximize joint payoff. Otherwise, begin protecting against certain end-game defection.

### Round r (Final Round): Conditional Cooperation

**Decision Rule:**
```
IF cooperation_rate in round (r-1) >= (n-1)/n THEN COOPERATE
ELSE DEFECT
```

Rationale: In a one-shot final round, defection is individually rational. However, if we've established near-universal cooperation, maintaining it maximizes collective payoff for cooperators. The high threshold (near-unanimity) ensures we only cooperate when defection would be clearly harmful to the cooperative collective.

---

## Edge Cases

### Small n (n=2):
The game becomes a repeated Prisoner's Dilemma. Use standard Tit-for-Tat:
- Round 1: Cooperate
- Subsequent rounds: Copy opponent's previous action
- Final round: Defect unless opponent cooperated in round (r-1)

### Very short games (r ≤ 3):
- Round 1: Cooperate
- Middle rounds: Cooperate if previous round had >50% cooperation
- Final round: Defect

### k very close to 1:
Cooperation provides minimal benefit. Increase defection threshold:
```
adjusted_threshold = base_threshold × (k / (n/2))
```

### k close to n:
Cooperation is highly beneficial. Increase cooperation tendency:
```
adjusted_coop_probability = min(1, base_probability × (k / (n/2)))
```

---

## Summary Pseudocode

```python
def decide(round, history, n, k, r):
    if n == 2:
        return tit_for_tat(round, history, r)
    
    if round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history[-1]) / n
    
    if round == r:  # Final round
        return COOPERATE if prev_coop_rate >= (n-1)/n else DEFECT
    
    if round == r - 1:  # Penultimate
        avg_coop = average_cooperation_rate(history)
        return COOPERATE if avg_coop >= 0.6 else DEFECT
    
    # Middle rounds: graduated reciprocity
    if prev_coop_rate >= (n-1)/n:
        return COOPERATE
    elif prev_coop_rate >= 0.5:
        prob = prev_coop_rate
    elif prev_coop_rate > 0:
        prob = prev_coop_rate ** 2
    else:
        prob = 1/n
    
    # Adjust for k
    prob = prob * (k / (n/2))
    prob = min(1, max(0, prob))
    
    # Deterministic randomness for collective coordination
    threshold = deterministic_random(round, history, n, k, r)
    return COOPERATE if threshold < prob else DEFECT
```

---

## Why This Strategy Works Collectively

1. **Implicit coordination**: All instances behave identically given the same history, creating emergent coordination without communication.

2. **Rewards cooperation**: High cooperation rates are reinforced; groups of cooperators thrive together.

3. **Punishes defection**: Defection triggers proportional response, making exploitation unprofitable.

4. **Forgiveness**: The probabilistic approach allows recovery from temporary defection spirals.

5. **End-game protection**: Conditional final-round cooperation protects against exploitation while preserving mutual gains when warranted.
'''

description_COLLECTIVE_25 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I assume other players may be using similar reasoning, and I aim to establish and maintain cooperation while protecting against exploitation. The key insight is that mutual cooperation yields the highest collective payoff, but this requires trust-building and coordinated responses to defection.

## Strategy Overview: **Adaptive Threshold Reciprocity (ATR)**

The strategy maintains cooperation as long as a sufficient proportion of the group cooperates, adapts its threshold based on observed behavior, and uses end-game logic to handle the unraveling problem.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: Cooperate**

Rationale: Signal cooperative intent. Since we cannot coordinate beforehand, starting with cooperation is the clearest way to establish a cooperative norm. If others are using similar collective reasoning, this creates the foundation for mutual benefit.

### Rounds 2 through (r-1): Adaptive Threshold Reciprocity

**Cooperate if and only if:** `cooperation_rate >= threshold`

Where:
- `cooperation_rate` = (number of cooperators in previous round) / n
- `threshold` = dynamically adjusted based on history

**Threshold Adjustment Rules:**

```
Initial threshold = 0.5 (majority cooperation required)

After each round:
  If cooperation_rate >= threshold:
    threshold = max(0.3, threshold - 0.05)  // Reward cooperation, become more tolerant
  Else:
    threshold = min(0.8, threshold + 0.1)   // Punish defection, become stricter
```

**Additional Cooperation Trigger - Forgiveness Mechanism:**
Even if `cooperation_rate < threshold`, cooperate if:
- The cooperation rate has **increased** for 2 consecutive rounds (trend toward cooperation)
- This allows recovery from temporary breakdowns

### Last Round (Round r): Conditional End-Game Logic

The standard game theory prediction is universal defection in the last round. However, with collective mindset:

**Cooperate if:**
- `average_cooperation_rate_over_all_rounds >= 0.6` AND
- `cooperation_rate_in_round_(r-1) >= 0.5`

**Defect otherwise.**

Rationale: If the group has maintained strong cooperation throughout, maintain solidarity to the end. If cooperation has already collapsed, defecting protects against being the sole contributor.

---

## Pseudocode

```
function decide(round, history, n, r, k):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate key metrics
    prev_cooperation_rate = count_cooperators(history[round-1]) / n
    avg_cooperation_rate = sum(count_cooperators(h) for h in history) / (n * (round-1))
    
    # Last round logic
    if round == r:
        if avg_cooperation_rate >= 0.6 AND prev_cooperation_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Adaptive Threshold Reciprocity
    threshold = calculate_threshold(history)
    
    # Primary decision rule
    if prev_cooperation_rate >= threshold:
        return COOPERATE
    
    # Forgiveness: check for improving trend
    if round >= 3:
        rate_t1 = count_cooperators(history[round-1]) / n
        rate_t2 = count_cooperators(history[round-2]) / n
        if round >= 4:
            rate_t3 = count_cooperators(history[round-3]) / n
            if rate_t1 > rate_t2 > rate_t3:  # Two consecutive increases
                return COOPERATE
    
    return DEFECT

function calculate_threshold(history):
    threshold = 0.5
    for round_idx in range(len(history)):
        rate = count_cooperators(history[round_idx]) / n
        if rate >= threshold:
            threshold = max(0.3, threshold - 0.05)
        else:
            threshold = min(0.8, threshold + 0.1)
    return threshold
```

---

## Edge Cases

| Scenario | Handling |
|----------|----------|
| **n = 2** | Strategy works; reduces to near Tit-for-Tat dynamics |
| **Very large n** | Threshold mechanics remain proportional |
| **r = 2** | Round 1: Cooperate. Round 2: Cooperate if round 1 had ≥50% cooperation |
| **All defect in round 1** | Threshold rises to 0.6; defect unless trend improves |
| **k very close to 1** | Strategy unchanged; lower k makes cooperation harder but logic remains sound |
| **Single defector pattern** | Tolerated if overall rate stays above threshold |

---

## Why This Strategy is Collectively Optimal

1. **Initiates cooperation**: Starts with trust
2. **Rewards group cooperation**: Becomes more tolerant when group cooperates
3. **Punishes defection collectively**: Raises standards when cooperation falls
4. **Allows recovery**: Forgiveness mechanism prevents permanent breakdown
5. **Maintains end-game cooperation**: Doesn't automatically defect in final round if trust is established
'''

description_COLLECTIVE_27 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we succeed together or fail together. The goal isn't to "beat" other players but to maximize total welfare while protecting against exploitation. I assume other thoughtful agents may reach similar conclusions, creating opportunities for emergent cooperation without explicit coordination.

## Strategy Overview: **Adaptive Threshold Cooperation (ATC)**

The strategy cooperates when there's sufficient evidence that cooperation is sustainable, defects to protect against exploitation, but always leaves the door open for cooperation to emerge.

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: 
- Signals willingness to cooperate
- Provides information about other players' strategies
- In a collective frame, someone must take the first step
- The cost of initial cooperation is bounded (at most 1 unit)

### Rounds 2 through (r-1): Adaptive Threshold Rule

**Calculate the cooperation rate from the previous round:**
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Calculate a dynamic threshold based on game parameters:**
```
base_threshold = 1/k  # Minimum cooperation rate where C yields ≥ D payoff
adaptive_threshold = base_threshold × (0.5 + 0.5 × (rounds_remaining / r))
```

**Decision Logic:**
```
IF prev_coop_rate ≥ adaptive_threshold:
    ACTION = COOPERATE
ELSE IF prev_coop_rate > 0 AND rounds_remaining > 2:
    # Some cooperation exists - give it a chance
    ACTION = COOPERATE with probability = prev_coop_rate × k / n
ELSE:
    ACTION = DEFECT
```

**Additional Forgiveness Mechanism:**
```
IF defected for 3+ consecutive rounds AND rounds_remaining > 3:
    ACTION = COOPERATE  # Periodic cooperation probe
```

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which suggests universal defection:

```
IF cooperation_rate over last 3 rounds ≥ 0.5:
    ACTION = COOPERATE  # Maintain cooperative equilibrium
ELSE:
    ACTION = DEFECT
```

Rationale: If a cooperative norm has been established, unilateral defection in the final round undermines the collective benefit and signals bad faith. If playing against entities that might share this reasoning, maintaining cooperation is collectively optimal.

---

## Handling Edge Cases

### Very Short Games (r ≤ 3)
- Round 1: Always COOPERATE
- Middle rounds: Use threshold rule with prev_coop_rate ≥ base_threshold
- Final round: COOPERATE if majority cooperated previously

### Very Large n (many players)
- Individual impact on cooperation rate is small
- Strategy remains unchanged: your cooperation contributes to the collective signal
- Threshold automatically adjusts via the k/n relationship

### k Very Close to 1 (low multiplication factor)
- Cooperation is harder to sustain economically
- Base threshold approaches 1 (need near-universal cooperation)
- Strategy naturally becomes more cautious but still attempts cooperation

### k Close to n (high multiplication factor)
- Cooperation is highly beneficial even with few cooperators
- Base threshold is low, cooperation more likely
- Strategy naturally becomes more cooperative

### All Defection Observed
- Forgiveness probe every 3-4 rounds ensures we don't get stuck in mutual defection
- If probes consistently fail, mostly defect but keep probing

### Erratic/Random Opponents
- Threshold mechanism filters noise
- Probabilistic cooperation in ambiguous cases hedges bets
- Strategy won't be maximally exploited but stays open to cooperation

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history, round-1) / n
    base_threshold = 1 / k
    rounds_remaining = r - round + 1
    adaptive_threshold = base_threshold * (0.5 + 0.5 * (rounds_remaining / r))
    
    # Final round logic
    if round == r:
        recent_avg = average_cooperation_rate(history, last_3_rounds)
        if recent_avg >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Forgiveness probe
    if consecutive_defections(my_history) >= 3 and rounds_remaining > 3:
        return COOPERATE
    
    # Main decision
    if prev_coop_rate >= adaptive_threshold:
        return COOPERATE
    elif prev_coop_rate > 0 and rounds_remaining > 2:
        if random() < prev_coop_rate * k / n:
            return COOPERATE
    
    return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Optimistic start**: Assumes good faith until proven otherwise
2. **Responsive to cooperation**: Rewards and sustains cooperative behavior
3. **Forgiving**: Doesn't permanently punish, allowing recovery from mistakes or miscoordination
4. **Self-protective**: Won't be indefinitely exploited by pure defectors
5. **Signals clearly**: Actions communicate willingness to cooperate
6. **Scales with parameters**: Naturally adjusts to game economics via k and n
7. **Maintains cooperation at end**: Doesn't defect in final round if cooperation was established, recognizing that consistent collective behavior is valuable
'''

description_COLLECTIVE_26 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all players using this strategy share the same goal of maximizing group welfare while protecting against exploitation. The strategy uses observable signals to coordinate cooperation levels without explicit communication.

## Strategy Overview: "Adaptive Threshold Cooperation" (ATC)

The strategy cooperates when the observed cooperation rate meets a dynamically adjusted threshold, with built-in mechanisms for forgiveness, end-game protection, and collective signaling.

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: Start with good faith. This signals cooperative intent and allows the collective to establish a cooperation baseline. The cost of one round of potential exploitation is worth the coordination benefits.

### Rounds 2 through (r-1): Adaptive Threshold Response

**Calculate the following each round:**

1. **Cooperation Rate (CR):** Proportion of players who cooperated in the previous round
   - `CR = (number of cooperators in round t-1) / n`

2. **Cooperation Trend (CT):** Change in cooperation rate over last 2 rounds (if available)
   - `CT = CR(t-1) - CR(t-2)` (positive = improving, negative = declining)

3. **Cumulative Cooperation Index (CCI):** Weighted average cooperation across all previous rounds
   - `CCI = Σ(w_t × CR_t)` where recent rounds weighted more heavily (w_t = t / Σt)

4. **Dynamic Threshold (DT):** Base threshold adjusted by game parameters
   - `Base_DT = (n - k) / (n - 1)` (this is the breakeven cooperation rate)
   - `Adjusted_DT = Base_DT × 0.8` (set slightly below breakeven to encourage cooperation)

**Decision Logic:**

```
IF CR >= Adjusted_DT:
    COOPERATE
ELSE IF CR < Adjusted_DT AND CT > 0.1:
    COOPERATE  (trend is improving significantly, give it a chance)
ELSE IF CR < Adjusted_DT AND CCI >= 0.5:
    COOPERATE with probability = CCI  (probabilistic based on history)
ELSE:
    DEFECT
```

### Forgiveness Mechanism

Every `floor(r/4)` rounds, if currently in a defection pattern:
- **COOPERATE unconditionally** as a "forgiveness probe"
- This allows recovery from mutual defection spirals
- Signals willingness to restart cooperation

### Last Round: Conditional Cooperation

Unlike standard game theory advice (always defect), maintain collective commitment:

```
IF CCI >= 0.6:
    COOPERATE  (reward sustained cooperation throughout the game)
ELSE:
    DEFECT  (protect against groups that didn't cooperate)
```

Rationale: If we've established good cooperation, maintaining it in the final round signals trustworthiness and maximizes collective payoff. Defecting only when cooperation has been poor protects against exploitation.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (minimum players) | Use stricter threshold (DT × 1.2) | Bilateral dynamics are more sensitive |
| k very close to 1 | Lower cooperation expectations | Public good barely multiplies; cooperation less valuable |
| k very close to n | Higher cooperation expectations | High multiplication makes cooperation very valuable |
| r = 2 (minimum rounds) | Cooperate both rounds if round 1 had ≥50% cooperation | Limited time to establish patterns |
| All others defected last round | Still cooperate on forgiveness rounds | Maintain recovery option |
| Perfect cooperation so far | Continue cooperating | Don't break successful equilibrium |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    CR = cooperation_rate(history, round - 1)
    CT = cooperation_trend(history, round - 1, round - 2) if round > 2 else 0
    CCI = cumulative_cooperation_index(history)
    DT = ((n - k) / (n - 1)) * 0.8
    
    # Forgiveness probe
    forgiveness_interval = max(1, floor(r / 4))
    if round % forgiveness_interval == 0 and was_defecting(history):
        return COOPERATE
    
    # Last round logic
    if round == r:
        return COOPERATE if CCI >= 0.6 else DEFECT
    
    # Main decision logic
    if CR >= DT:
        return COOPERATE
    else if CT > 0.1:
        return COOPERATE
    else if CCI >= 0.5:
        return COOPERATE with probability CCI
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Self-coordination:** Multiple agents using this strategy will naturally synchronize on cooperation because they respond to the same observable signals.

2. **Robust to defectors:** The threshold mechanism ensures we don't perpetually cooperate against consistent defectors.

3. **Forgiveness enables recovery:** Periodic unconditional cooperation prevents permanent collapse into mutual defection.

4. **Adaptive to parameters:** The threshold adjusts based on k and n, ensuring appropriate behavior across different game configurations.

5. **End-game integrity:** Maintaining cooperation in the final round when warranted maximizes collective payoff and prevents unraveling.
'''

description_COLLECTIVE_28 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I assume I am one of many agents running identical reasoning, so my choice effectively determines what "we all do." The goal is to establish and maintain cooperation when it's collectively beneficial, while protecting against exploitation by non-cooperative agents.

## Strategic Framework

### Key Insight

With parameters where 1 < k < n, cooperation is:
- **Collectively optimal**: If all cooperate, everyone gets k/n × n = k > 1 (better than universal defection yielding 1)
- **Individually tempting to defect**: A lone defector gains relative to cooperators

Since k > 1, universal cooperation beats universal defection. The challenge is coordinating on cooperation and maintaining it against potential defectors.

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: As a collective strategy, we signal willingness to cooperate. This establishes the cooperative equilibrium from the start. If other agents share similar reasoning, we achieve the superior collective outcome immediately.

---

### Rounds 2 through (r-1): Adaptive Conditional Cooperation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Rule:**

```
IF coop_rate >= cooperation_threshold THEN
    COOPERATE
ELSE IF coop_rate >= minimum_viable_threshold THEN
    COOPERATE with probability = coop_rate
ELSE
    DEFECT
```

**Threshold Definitions:**
- `cooperation_threshold = 0.5` — If at least half cooperated, maintain cooperation
- `minimum_viable_threshold = k / n` — Below this, even probabilistic cooperation isn't worthwhile

**Forgiveness Mechanism:**
After defecting due to low cooperation, if the *next* round shows improved cooperation (increase of at least 1/n in cooperation rate), return to cooperation. This allows recovery from coordination failures.

**Trend Adjustment:**
If cooperation has been *increasing* over the last 2 rounds, bias toward cooperation:
```
IF coop_rate_increasing AND coop_rate >= minimum_viable_threshold THEN
    COOPERATE
```

---

### Final Round (Round r): Conditional Cooperation with Collective Commitment

**Counter-intuitive choice: Do NOT automatically defect.**

Rationale: If all collective-minded agents defect in the final round, we guarantee the worst collective outcome. Instead:

```
IF average_cooperation_rate_over_all_rounds >= 0.6 THEN
    COOPERATE  // Honor the cooperative relationship
ELSE IF coop_rate_previous_round >= 0.5 THEN
    COOPERATE with probability = 0.7
ELSE
    DEFECT
```

This maintains collective benefit even without future rounds, assuming others with similar values do the same.

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    // Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    // Calculate metrics
    prev_coop_rate = count_cooperators(history[round-1]) / n
    avg_coop_rate = total_cooperations(history) / (n * (round - 1))
    
    // Check for improving trend
    trend_improving = false
    if round >= 3:
        rate_t1 = count_cooperators(history[round-2]) / n
        rate_t2 = count_cooperators(history[round-1]) / n
        trend_improving = (rate_t2 > rate_t1)
    
    // Thresholds
    coop_threshold = 0.5
    min_viable = k / n
    
    // Final round logic
    if round == r:
        if avg_coop_rate >= 0.6:
            return COOPERATE
        else if prev_coop_rate >= 0.5:
            return COOPERATE with probability 0.7
        else:
            return DEFECT
    
    // Middle rounds logic
    if prev_coop_rate >= coop_threshold:
        return COOPERATE
    
    if trend_improving and prev_coop_rate >= min_viable:
        return COOPERATE
    
    if prev_coop_rate >= min_viable:
        return COOPERATE with probability = prev_coop_rate
    
    // Below minimum viable threshold
    return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Same rules apply | Reduces to iterated prisoner's dilemma-like dynamics |
| k very close to 1 | Thresholds still work | min_viable threshold becomes more demanding |
| k very close to n | More forgiving | Cooperation more valuable, lower min_viable |
| All others defect round 1 | Defect round 2, watch for recovery | Protect against pure exploitation |
| Single round of defection spike | Probabilistic response | Allows recovery from noise |
| r = 2 (minimum rounds) | Cooperate both if round 1 had any cooperation | Maximize limited opportunity |

---

## Why This Strategy Is Collectively Robust

1. **Coordinates with like-minded agents**: Identical strategies will achieve sustained cooperation
2. **Punishes persistent defection**: Won't be exploited indefinitely
3. **Forgives and recovers**: Doesn't lock into mutual defection spirals
4. **Maintains end-game cooperation**: Doesn't unravel from backward induction
5. **Adapts to population composition**: Probabilistic matching responds to mixed populations
'''

description_COLLECTIVE_27 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **we succeed together or fail together**. The goal is not to maximize individual advantage over others, but to establish and maintain cooperation that benefits everyone. I will lead by example, forgive mistakes, and persistently signal cooperative intent while protecting the collective from systematic exploitation.

## Strategy Overview: "Generous Collective Builder"

The strategy operates on three principles:
1. **Lead with cooperation** to establish trust and signal collective intent
2. **Respond proportionally** to the group's cooperative behavior
3. **Forgive readily** because sustained cooperation requires tolerance for noise

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Someone must take the first step. By cooperating initially, I demonstrate commitment to the collective good and give others the opportunity to reciprocate. This is the foundation of any cooperative equilibrium.

### Rounds 2 through (r-1): Adaptive Cooperation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Rule:**
```
If coop_rate >= threshold(round, history):
    COOPERATE
Else:
    COOPERATE with probability = generosity_factor × coop_rate
    DEFECT with probability = 1 - (generosity_factor × coop_rate)
```

**Threshold Function:**
```
base_threshold = 0.4  # Cooperate if at least 40% of group cooperated
threshold = base_threshold - forgiveness_bonus

forgiveness_bonus = 0.1 if (cooperation improved from round t-2 to t-1) else 0
```

**Generosity Factor:**
```
generosity_factor = 1.5  # Even in low-cooperation environments, maintain hope
```

This means:
- If 50%+ cooperated last round → I cooperate
- If 30% cooperated but trending upward → I cooperate  
- If only 20% cooperated → I still cooperate with 30% probability (giving the collective another chance)

### Last Round: Conditional Cooperation (No Exploitation)

The last round removes future consequences, but collective commitment means **not abandoning principles for marginal gain**.

**Decision Rule for Round r:**
```
Calculate average_coop_rate over all previous rounds

If average_coop_rate >= 0.5:
    COOPERATE  # Honor the cooperative relationship we built
Else if coop_rate in round (r-1) >= 0.6:
    COOPERATE  # Reward recent cooperation even if history was rocky
Else:
    DEFECT  # Collective cooperation failed; no point in unilateral sacrifice
```

---

## Handling Edge Cases

### Very Small Groups (n = 2 or 3)
- Each player's action is highly visible and impactful
- Use **stricter thresholds**: base_threshold = 0.5
- Forgiveness remains important as single defections swing percentages dramatically

### Very Large Groups (n > 10)
- Individual contributions are less noticeable
- Use **looser thresholds**: base_threshold = 0.35
- Focus on whether cooperation is trending up or down rather than absolute levels

### High Multiplication Factor (k close to n)
- Cooperation is more valuable; be more forgiving
- Adjust: generosity_factor = 1.8

### Low Multiplication Factor (k close to 1)
- Cooperation provides minimal surplus
- Maintain cooperation anyway if others do (collective commitment matters)
- Adjust: base_threshold = 0.5 (require stronger evidence of group cooperation)

### Volatile History (cooperation swinging wildly)
```
If std_dev(last 3 rounds' coop_rates) > 0.3:
    COOPERATE  # Provide stability; be the anchor
```

### Near-Universal Defection (coop_rate < 0.15 for 3+ consecutive rounds)
```
COOPERATE with probability 0.2  # Periodic olive branches
DEFECT with probability 0.8     # Limit losses while keeping door open
```

---

## Pseudocode Summary

```python
def decide(round_number, total_rounds, n, k, history):
    
    if round_number == 1:
        return COOPERATE
    
    prev_coop_rate = history[round_number - 1].cooperators / n
    
    # Adjust threshold based on context
    base_threshold = 0.4
    if n <= 3:
        base_threshold = 0.5
    elif n > 10:
        base_threshold = 0.35
    
    # Forgiveness for improving trends
    if round_number >= 3:
        prev_prev_rate = history[round_number - 2].cooperators / n
        if prev_coop_rate > prev_prev_rate:
            base_threshold -= 0.1
    
    # Last round logic
    if round_number == total_rounds:
        avg_coop = mean([h.cooperators/n for h in history])
        if avg_coop >= 0.5 or prev_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Standard rounds
    if prev_coop_rate >= base_threshold:
        return COOPERATE
    else:
        generosity = 1.5 if k < (n/2) else 1.8
        if random() < generosity * prev_coop_rate:
            return COOPERATE
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Initiates cooperation**: Doesn't wait for others; takes the first step
2. **Sustains cooperation**: Continues cooperating when the group shows collective will
3. **Forgives mistakes**: Probabilistic response and trend-sensitivity prevent death spirals
4. **Resists exploitation**: Reduces cooperation when facing persistent defection
5. **Honors commitments**: Cooperates in final rounds when trust has been established
6. **Adapts to parameters**: Adjusts behavior based on group size and multiplication factor

This strategy treats the game not as a competition against other players, but as a coordination problem where my role is to be a reliable, forgiving, cooperative partner that makes collective success possible.
'''

description_COLLECTIVE_29 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be using similar reasoning, so I should behave in ways that would produce good outcomes if widely adopted, while remaining robust to defectors. The strategy balances three principles:

1. **Establish cooperation early** to signal intent and build trust
2. **Respond proportionally** to the observed cooperation level in the group
3. **Protect against exploitation** without being overly punitive

---

## Strategy: Adaptive Proportional Cooperation (APC)

### Decision Rule Overview

My cooperation probability in each round is determined by:
- **Round 1**: Always cooperate (establish trust)
- **Rounds 2 to r-1**: Cooperate based on the group's historical cooperation rate, with a bias toward cooperation
- **Final round**: Use a modified rule that accounts for end-game dynamics

---

### Detailed Decision Rules

#### Round 1: Unconditional Cooperation
**Action: Cooperate (C)**

Rationale: With no history to judge, I start cooperatively to signal willingness to collaborate. If others share this mindset, we establish mutual cooperation immediately.

---

#### Rounds 2 through r-1: Proportional Response

**Calculate the group cooperation rate** from all previous rounds:

```
cooperation_rate = (total C actions by all players in all previous rounds) / 
                   (n × number of completed rounds)
```

**Decision rule:**

```
If cooperation_rate >= threshold(n, k):
    Cooperate
Else:
    Cooperate with probability = cooperation_rate × generosity_factor
```

**Threshold calculation:**
```
threshold = 0.5 - (k - 1) / (2 × (n - 1))
```
This threshold is lower when k is higher (cooperation is more valuable) and adjusts for group size.

**Generosity factor:** `1.2`

This means I'm slightly more cooperative than the group average, encouraging upward drift toward cooperation while not being exploitable.

**Tie-breaking:** When probabilistic, use a deterministic hash of (round number, game parameters) to ensure consistency if the strategy is replicated.

---

#### Final Round (Round r): Conditional Cooperation

The final round has no future consequences, creating defection incentives. However, with a collective mindset:

```
If cooperation_rate (over rounds 1 to r-1) >= 0.6:
    Cooperate (reward sustained group cooperation)
Else if cooperation_rate >= 0.3:
    Cooperate with probability = cooperation_rate
Else:
    Defect (group has demonstrated non-cooperation)
```

Rationale: If the group has maintained reasonable cooperation, I honor that in the final round. A collective of players using this logic will cooperate in the last round, avoiding the unraveling problem.

---

### Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    # Calculate historical cooperation rate
    total_cooperations = count_all_cooperations(history)
    total_actions = n × (round - 1)
    coop_rate = total_cooperations / total_actions
    
    # Calculate adaptive threshold
    threshold = 0.5 - (k - 1) / (2 × (n - 1))
    generosity = 1.2
    
    if round == r:  # Final round
        if coop_rate >= 0.6:
            return COOPERATE
        elif coop_rate >= 0.3:
            return COOPERATE with probability coop_rate
        else:
            return DEFECT
    
    else:  # Middle rounds
        if coop_rate >= threshold:
            return COOPERATE
        else:
            return COOPERATE with probability min(1.0, coop_rate × generosity)
```

---

### Edge Cases

| Scenario | Handling |
|----------|----------|
| **n = 2** | Strategy still applies; becomes similar to Tit-for-Tat with generosity |
| **r = 2** | Round 1: Cooperate; Round 2: Apply final round rule with single data point |
| **k very close to 1** | Threshold increases, making cooperation harder to sustain (appropriate since gains from cooperation are minimal) |
| **k very close to n** | Threshold decreases toward 0, strongly favoring cooperation (appropriate since public good is very efficient) |
| **All others defect** | After round 1, coop_rate drops; I probabilistically reduce cooperation but maintain small chance to re-establish trust |
| **Mixed population** | Proportional response naturally adapts—I cooperate roughly at the rate the group does, plus a small premium |

---

### Why This Strategy is Collectively Optimal

1. **Self-reinforcing**: If all players use APC, round 1 cooperation leads to high cooperation rates, which sustain cooperation through all rounds including the last.

2. **Robust to defectors**: The proportional response means a minority of defectors lowers but doesn't eliminate my cooperation, while a majority of defectors triggers protective defection.

3. **Forgiving**: The generosity factor means temporary defection doesn't create death spirals—the group can recover.

4. **Parameter-adaptive**: The threshold adjusts to game economics, cooperating more when k makes it more valuable.
'''

description_COLLECTIVE_28 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume all instances of this strategy will behave identically given the same game state. This means we can achieve implicit coordination without explicit communication. The strategy aims to maximize collective welfare while being robust against defectors.

## Strategy Overview: "Adaptive Collective Threshold"

The strategy uses a **threshold-based cooperation rule** that adapts based on observed cooperation levels in the population, with special handling for early and late game phases.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history to evaluate, we signal cooperative intent. If all collective-minded players cooperate, we establish a high-cooperation baseline. The cost of one round of potential exploitation is acceptable for the information and coordination value gained.

### Rounds 2 through (r-1): Adaptive Threshold Cooperation

**Calculate the cooperation ratio from the previous round:**
```
prev_coop_ratio = (number of C plays in round t-1) / n
```

**Decision Rule:**
```
IF prev_coop_ratio >= threshold THEN COOPERATE
ELSE DEFECT

where threshold = max(0.5, (n - k) / n)
```

**Threshold Explanation:**
- The term `(n - k) / n` represents the fraction of players that must cooperate for cooperation to be individually rational in expectation
- We floor this at 0.5 to maintain a majority-cooperation standard
- When k is close to n, the threshold is lower (cooperation is more rewarding)
- When k is close to 1, the threshold is higher (cooperation needs more participants)

### Final Round (Round r): Conditional Defection with Collective Exception

**Decision Rule:**
```
IF prev_coop_ratio >= (n-1)/n THEN COOPERATE
ELSE DEFECT
```

Rationale: In the final round, there's no future to protect. However, if nearly everyone cooperated last round, we maintain cooperation to maximize collective payoff (since we expect other collective-minded players to reason identically). Otherwise, we defect since there's no reputational consequence.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation ratio
    prev_cooperators = count_cooperators(history[round - 1])
    prev_coop_ratio = prev_cooperators / n
    
    # Final round: High threshold for cooperation
    if round == r:
        if prev_coop_ratio >= (n - 1) / n:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Adaptive threshold
    threshold = max(0.5, (n - k) / n)
    
    if prev_coop_ratio >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Case Handling

| Scenario | Behavior | Rationale |
|----------|----------|-----------|
| **n = 2** | Threshold becomes max(0.5, (2-k)/2). With k > 1, this is below 0.5, so threshold = 0.5 (need 1 cooperator) | Reduces to tit-for-tat-like behavior |
| **k very close to n** | Lower threshold, more forgiving | Cooperation is highly valuable |
| **k very close to 1** | Higher threshold, stricter | Cooperation needs broad participation |
| **r = 2** | Round 1: Cooperate, Round 2: Use final-round rule | Minimal game still follows core logic |
| **All defected last round** | Defect this round | Population is uncooperative, protect self |
| **Exactly at threshold** | Cooperate | Inclusive boundary encourages cooperation |

---

## Why This Strategy is Robust

1. **Against all-defectors**: After round 1, we detect mass defection and switch to defection, limiting losses to one round

2. **Against all-cooperators**: We cooperate throughout, achieving maximum collective payoff

3. **Against mixed populations**: The threshold adapts to game parameters, cooperating when it's collectively beneficial and defecting when cooperation would be exploited

4. **Collective alignment**: All instances of this strategy will make identical decisions given identical histories, enabling implicit coordination without communication

5. **Parameter sensitivity**: The threshold formula `(n-k)/n` directly incorporates game economics—we cooperate when the math favors it
'''

description_COLLECTIVE_30 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **I assume other players may be reasoning similarly and that mutual cooperation is achievable if we can establish trust through consistent, interpretable behavior.** The strategy aims to be a "good citizen" that rewards cooperation, forgives occasional defections, but protects against persistent exploitation.

## Strategy Overview: **Adaptive Threshold Cooperation with Graduated Response**

The strategy cooperates when there's sufficient evidence of collective goodwill, responds proportionally to the cooperation level observed, and maintains hope for cooperation recovery while protecting against exploitation.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: Cooperate**

Rationale: Begin with trust. This signals cooperative intent and allows the collective to potentially coordinate on cooperation from the start. The cost of one round of potential exploitation is worth the benefit of establishing a cooperative norm.

### Rounds 2 through (r-1): Adaptive Threshold Cooperation

**Calculate the cooperation rate from the previous round:**
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Calculate the historical cooperation trend:**
```
historical_coop_rate = (total cooperations across all past rounds) / (n × rounds_played)
trend = prev_coop_rate - historical_coop_rate  # positive means improving
```

**Decision Rule:**

```
threshold = base_threshold + trend_adjustment + late_game_adjustment

where:
  base_threshold = 0.4  # Cooperate if at least 40% cooperated
  trend_adjustment = -0.1 if trend > 0.1 else (0.1 if trend < -0.1 else 0)
  late_game_adjustment = 0.1 × (current_round / r)  # Gradually raise bar
```

**Action:**
- If `prev_coop_rate ≥ threshold`: **Cooperate**
- If `prev_coop_rate < threshold` but `trend > 0.15`: **Cooperate** (reward improvement)
- Otherwise: **Defect**

**Forgiveness Mechanism:**
After defecting, if cooperation rebounds to above 50% in any subsequent round, immediately return to cooperation. This prevents death spirals.

### Final Round (Round r): Conditional Cooperation

Unlike classical game theory which prescribes defection, I maintain collective principles:

**Action:**
- If `historical_coop_rate ≥ 0.5`: **Cooperate** (honor the collective relationship)
- If `prev_coop_rate ≥ 0.6`: **Cooperate** (recent strong cooperation deserves reciprocity)
- Otherwise: **Defect**

Rationale: If we've built something good together, I won't betray it at the end. This reputation matters if strategies are evaluated across multiple tournaments or if others reason similarly about end-game behavior.

---

## Pseudocode Implementation

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    # Calculate metrics
    prev_cooperators = count_cooperators(history[round - 1])
    prev_coop_rate = prev_cooperators / n
    
    total_cooperations = sum(count_cooperators(h) for h in history)
    total_opportunities = n * (round - 1)
    historical_coop_rate = total_cooperations / total_opportunities
    
    trend = prev_coop_rate - historical_coop_rate
    
    # Final round logic
    if round == r:
        if historical_coop_rate >= 0.5 or prev_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    base_threshold = 0.4
    trend_adjustment = -0.1 if trend > 0.1 else (0.1 if trend < -0.1 else 0)
    late_game_adjustment = 0.1 * (round / r)
    
    threshold = base_threshold + trend_adjustment + late_game_adjustment
    
    # Main decision
    if prev_coop_rate >= threshold:
        return COOPERATE
    elif trend > 0.15:
        return COOPERATE  # Reward improvement
    else:
        return DEFECT
```

---

## Edge Cases Handled

| Situation | Response |
|-----------|----------|
| Round 1 | Always cooperate |
| Everyone defected last round | Defect (unless trend is strongly positive) |
| Everyone cooperated last round | Cooperate |
| Mixed results declining | Defect until recovery |
| Mixed results improving | Cooperate to encourage |
| Final round after good history | Cooperate |
| Final round after poor history | Defect |
| Very small n (n=2) | Same rules apply; 50% = 1 cooperator |
| Very large n | Thresholds scale naturally with rates |

---

## Why This Strategy is Collectively Robust

1. **Signals clear intent**: Opening cooperation and consistent threshold behavior makes the strategy predictable and trustworthy to similar reasoners.

2. **Rewards collective success**: The more others cooperate, the more likely this strategy cooperates.

3. **Forgives and recovers**: The trend-based adjustment and forgiveness mechanism prevent permanent collapse.

4. **Resists exploitation**: The threshold prevents cooperation when faced with predominantly selfish opponents.

5. **Maintains integrity at endgame**: Doesn't betray cooperative relationships in the final round, which distinguishes it from purely self-interested strategies.
'''

description_COLLECTIVE_29 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players in my cohort are reasoning similarly and will arrive at compatible strategies. We aim to maximize group welfare while protecting against exploitation by non-cooperative opponents. The key insight is that with k > 1, mutual cooperation generates more total value than mutual defection, but we must be robust to free-riders.

## Strategy Overview: **Adaptive Collective Reciprocity (ACR)**

The strategy maintains cooperation within a collective while adaptively responding to the observed cooperation level in the population. It uses a **threshold-based trigger** that rewards cooperative environments and withdraws cooperation when free-riding becomes prevalent.

---

## Decision Rules

### Key Variables Tracked
- `cooperation_rate`: Rolling average of cooperation rate over recent rounds
- `round_number`: Current round (1-indexed)
- `total_rounds`: r (known)
- `rounds_remaining`: r - round_number + 1

### Parameters (derived from game parameters)
- `baseline_threshold`: k/n (the marginal return from one cooperation)
- `cooperation_target`: 0.5 (minimum cooperation rate to sustain cooperation)
- `lookback_window`: min(5, r/3) rounds for calculating cooperation rate

---

## Decision Algorithm

```
function decide(round_number, history, n, k, r):
    
    # FIRST ROUND: Cooperate unconditionally
    if round_number == 1:
        return COOPERATE
    
    # LAST ROUND LOGIC
    if round_number == r:
        # Check if cooperation has been sustained
        recent_coop_rate = calculate_cooperation_rate(history, lookback_window)
        if recent_coop_rate >= 0.6:
            return COOPERATE  # Reward sustained cooperation
        else:
            return DEFECT  # No future to protect
    
    # MAIN DECISION LOGIC (rounds 2 to r-1)
    recent_coop_rate = calculate_cooperation_rate(history, lookback_window)
    
    # Adaptive threshold based on game parameters
    # Higher k/n ratio means cooperation is more valuable, so we're more forgiving
    adjusted_threshold = cooperation_target * (1 - baseline_threshold/2)
    
    # COOPERATE if cooperation rate meets threshold
    if recent_coop_rate >= adjusted_threshold:
        return COOPERATE
    
    # FORGIVENESS MECHANISM: Periodically test for recovery
    # Every few rounds, give cooperation another chance
    forgiveness_interval = max(2, r // 5)
    if round_number % forgiveness_interval == 0:
        return COOPERATE
    
    # GRADUATED RESPONSE based on how far below threshold
    if recent_coop_rate >= adjusted_threshold * 0.5:
        # Moderate defection: probabilistic cooperation
        # Cooperate with probability proportional to cooperation rate
        cooperation_probability = recent_coop_rate / cooperation_target
        return COOPERATE with probability cooperation_probability
    
    # Severe defection environment
    return DEFECT

function calculate_cooperation_rate(history, window):
    # Look at last 'window' rounds
    relevant_rounds = history[-window:]
    total_actions = count all actions in relevant_rounds
    total_cooperations = count all C actions in relevant_rounds
    return total_cooperations / total_actions
```

---

## Edge Case Handling

### Round 1
**Action: COOPERATE**
- Rationale: Establishes cooperative intent, allows collective to coordinate, provides baseline for measuring others' behavior.

### Round 2
**Action: Based on Round 1 cooperation rate**
- If ≥50% cooperated in Round 1: COOPERATE
- Otherwise: COOPERATE (give one more chance, as Round 1 data is noisy)

### Last Round (Round r)
**Action: Conditional on history**
- If sustained high cooperation (≥60% in recent window): COOPERATE
- Otherwise: DEFECT
- Rationale: In a collective mindset, if we've maintained cooperation, we honor it to the end. This distinguishes us from purely selfish backward-induction reasoning.

### Very Short Games (r ≤ 3)
- Round 1: COOPERATE
- Round 2: Mirror majority action from Round 1
- Round 3: COOPERATE if cooperation has been ≥50%, else DEFECT

### Small n (n = 2)
- Essentially becomes iterated Prisoner's Dilemma
- Use stricter reciprocity: match opponent's previous action
- Include forgiveness every 3-4 rounds

### Large n (n ≥ 10)
- Individual actions have less impact on rate
- Use slightly lower threshold (adjusted_threshold * 0.9)
- Focus on whether the *trend* is improving or declining

---

## Collective Alignment Properties

1. **Self-Recognition**: A group of ACR players will sustain cooperation throughout the game, achieving near-optimal collective payoff of ~2 per round per player (when k=2).

2. **Exploitation Resistance**: Against majority defectors, ACR withdraws cooperation after a few rounds, limiting losses.

3. **Recovery Capability**: The forgiveness mechanism allows return to cooperation if opponents reform.

4. **Proportional Response**: The graduated response avoids total breakdown when cooperation is merely diminished rather than absent.

5. **End-Game Cooperation**: By cooperating in the final round when trust has been established, collectives of ACR players avoid the backward-induction trap.

---

## Summary

| Situation | Action |
|-----------|--------|
| Round 1 | COOPERATE |
| High cooperation (≥50% recent) | COOPERATE |
| Moderate cooperation (25-50%) | Probabilistic COOPERATE |
| Low cooperation (<25%) | DEFECT |
| Forgiveness round | COOPERATE |
| Last round, good history | COOPERATE |
| Last round, bad history | DEFECT |
'''

description_COLLECTIVE_30 = '''
# Collective Strategy for N-Player Public Goods Game

## Strategic Philosophy

This strategy embraces a genuinely collective mindset: I recognize that if all players reason similarly, we can achieve better outcomes than mutual defection. The strategy is designed to be **self-reinforcing** when played by like-minded agents while remaining **robust** against exploiters.

The core insight: In a tournament where strategies are developed by AI systems reasoning about optimal collective behavior, there's a reasonable probability that others will arrive at similar conclusions. I should cooperate in ways that reward this convergence while protecting against defection.

---

## Decision Rules

### Rule 1: Optimistic Start with Signaling
**First Round:** Always Cooperate (C)

*Rationale:* This signals cooperative intent. If others reason similarly, we establish mutual cooperation from the start. The cost of being exploited in round 1 is bounded and provides valuable information.

### Rule 2: Collective Reciprocity Threshold
**Rounds 2 through (r-1):**

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Logic:**
- If `coop_rate >= (n-1)/n` (at most one defector): **Cooperate**
- If `coop_rate >= 0.5` (majority cooperated): **Cooperate with probability = coop_rate**
- If `coop_rate < 0.5` (majority defected): **Defect**

*Rationale:* This creates a coordination equilibrium. When most cooperate, I reinforce that behavior. When cooperation collapses, I protect myself. The probabilistic element in the middle range prevents sharp transitions that could destabilize cooperation.

### Rule 3: Trend-Aware Adjustment
**Modifier based on cooperation trajectory:**

Track the cooperation rate over the last 3 rounds (or fewer if early in game). 

- If cooperation is **increasing**: Boost cooperation probability by 0.1
- If cooperation is **decreasing**: Reduce cooperation probability by 0.1
- Apply bounds: probability stays in [0, 1]

*Rationale:* This rewards positive momentum and anticipates collapse, making the strategy more adaptive.

### Rule 4: Forgiveness Mechanism
**After mutual defection:**

If the previous round had `coop_rate < 0.5` but any earlier round had `coop_rate >= 0.5`:
- Every 3rd round of sustained low cooperation, cooperate once as a "forgiveness probe"

*Rationale:* This allows recovery from coordination failures without being perpetually exploited.

### Rule 5: Endgame Handling
**Final Round (round r):**

- If average cooperation rate across all previous rounds >= 0.6: **Cooperate**
- Otherwise: **Defect**

*Rationale:* Unlike pure Nash reasoning (which says defect), I recognize that if collectively-minded strategies all defect in the last round, we all lose. If cooperation has been sustained, it suggests others may reason similarly about maintaining cooperation. This is the ultimate test of collective commitment.

---

## Pseudocode Summary

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    coop_rate = history[round-1].cooperators / n
    
    # Calculate trend (last 3 rounds)
    trend = calculate_trend(history, round)
    
    # Base probability
    if coop_rate >= (n-1)/n:
        base_prob = 1.0
    elif coop_rate >= 0.5:
        base_prob = coop_rate
    else:
        base_prob = 0.0
    
    # Apply trend modifier
    prob = clamp(base_prob + trend * 0.1, 0, 1)
    
    # Forgiveness probe
    if base_prob == 0 and had_past_cooperation(history) and rounds_since_cooperation % 3 == 0:
        prob = 1.0
    
    # Final round logic
    if round == r:
        avg_coop = average_cooperation_rate(history)
        return COOPERATE if avg_coop >= 0.6 else DEFECT
    
    # Execute probabilistic decision
    return COOPERATE if random() < prob else DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Self-reinforcing equilibrium:** When multiple agents use this strategy, high cooperation is sustained, yielding payoffs approaching `k` (>1) rather than 1.

2. **Robust against defectors:** The threshold mechanism ensures we don't subsidize persistent defectors indefinitely.

3. **Adaptive:** Responds to actual behavior rather than assuming fixed opponent types.

4. **Forgiving:** Allows recovery from coordination failures, preventing permanent collapse.

5. **Collectively rational endgame:** Maintains cooperation even in the final round when the group has demonstrated trustworthiness—a key differentiator from purely self-interested strategies.
'''

description_COLLECTIVE_31 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embodies a **collective mindset**: I recognize that mutual cooperation generates the best collective outcome, and I'm willing to contribute to make that happen. However, I must also be adaptive to the reality that others may not share this mindset. My goal is to **encourage and sustain cooperation when possible, while protecting against exploitation**.

## Strategy: "Generous Threshold Trigger with Forgiveness"

### Key Principles

1. **Start cooperatively** to signal willingness and establish potential for mutual benefit
2. **Monitor cooperation levels** across the group rather than tracking individual players
3. **Use threshold-based decisions** that respond to collective behavior
4. **Incorporate forgiveness** to allow recovery from temporary defection spirals
5. **Adjust for endgame** where incentive structures shift

---

## Decision Rules

### Parameters (derived from game parameters)
- `cooperation_threshold` = 0.5 (proportion of players who must cooperate)
- `forgiveness_probability` = 0.1 (chance to cooperate despite threshold not being met)
- `endgame_rounds` = min(2, floor(r/5)) (rounds where endgame logic applies)

### Round-by-Round Logic

```
FUNCTION decide_action(round_number, history, n, k, r):
    
    # FIRST ROUND: Always cooperate to signal collective intent
    IF round_number == 1:
        RETURN Cooperate
    
    # LAST ROUND(S): Endgame adjustment
    IF round_number > r - endgame_rounds:
        # In final rounds, base decision on overall cooperation rate
        overall_coop_rate = total_cooperations_observed / ((round_number - 1) * n)
        IF overall_coop_rate >= 0.6:
            RETURN Cooperate  # Reward historically cooperative groups
        ELSE:
            RETURN Defect  # No point maintaining cooperation with defectors
    
    # STANDARD ROUNDS: Threshold-based with forgiveness
    
    # Calculate cooperation rate from previous round
    prev_round_cooperators = count_cooperators(history, round_number - 1)
    prev_coop_rate = prev_round_cooperators / n
    
    # Calculate trend (is cooperation increasing or decreasing?)
    IF round_number >= 3:
        two_rounds_ago_coop_rate = count_cooperators(history, round_number - 2) / n
        trend = prev_coop_rate - two_rounds_ago_coop_rate
    ELSE:
        trend = 0
    
    # Primary decision: threshold check
    IF prev_coop_rate >= cooperation_threshold:
        RETURN Cooperate  # Enough players cooperating, continue contributing
    
    # Secondary: positive trend forgiveness
    IF trend > 0 AND prev_coop_rate >= 0.3:
        RETURN Cooperate  # Cooperation is recovering, support it
    
    # Tertiary: random forgiveness (breaks defection spirals)
    IF random() < forgiveness_probability:
        RETURN Cooperate  # Occasional olive branch
    
    # Default: protect against exploitation
    RETURN Defect
```

---

## Detailed Rule Explanations

### 1. First Round: Unconditional Cooperation
- **Rationale**: Establishes cooperative intent, gives the group a chance to form mutual cooperation
- **Collective alignment**: Someone must start cooperating; I'm willing to be that player

### 2. Standard Rounds: Threshold Trigger
- **Cooperate if ≥50% cooperated last round**: This isn't about punishment—it's about whether cooperation is viable. If half the group is cooperating, the collective enterprise has momentum worth supporting.
- **Trend sensitivity**: If cooperation is recovering (even below threshold), I support the recovery rather than abandoning ship prematurely.

### 3. Forgiveness Mechanism
- **10% random cooperation**: Even when the threshold isn't met, occasional cooperation:
  - Signals continued willingness to cooperate
  - Can break mutual defection spirals
  - Tests whether others might reciprocate
- This is calibrated to be infrequent enough to avoid heavy exploitation

### 4. Endgame Logic
- **Final rounds use historical average**: The last round(s) have no future shadow, so I base decisions on the group's overall track record rather than reactive triggers
- **Higher threshold (60%) for final cooperation**: Only reward genuinely cooperative groups

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| First round | Cooperate | Signal collective intent |
| Last round, good history | Cooperate | Honor established cooperation |
| Last round, poor history | Defect | No future incentive to cooperate |
| All defected last round | Defect (90%) / Cooperate (10%) | Protect self, but leave door open |
| Exactly 50% cooperated | Cooperate | Meet threshold, support the coalition |
| n=2 (minimum players) | Same rules apply | Threshold = 1 cooperator needed |
| k very close to 1 | Same rules apply | Strategy robust regardless of k |

---

## Why This Strategy is Collectively Aligned

1. **I contribute first**: No waiting for others to prove themselves
2. **I support viable cooperation**: When enough others cooperate, I join rather than free-riding
3. **I forgive**: I don't permanently punish—recovery is always possible
4. **I'm not a doormat**: Below threshold, I mostly protect myself, but not vindictively
5. **I optimize for group success**: The threshold is set to sustain cooperation, not to maximize my personal advantage

This strategy aims to be the kind of player that makes cooperation possible—while remaining adaptive enough to survive in a world where not everyone shares that goal.
'''

description_COLLECTIVE_32 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective identity**: all instances running this strategy act as one coordinated entity. We aim to maximize group welfare while protecting against exploitation by non-collective players. The key insight is that with `k > 1`, mutual cooperation always produces more total value than mutual defection—our challenge is sustaining it.

## Strategy Overview: **Adaptive Collective Reciprocity (ACR)**

The strategy operates on three principles:
1. **Start cooperatively** to establish a cooperative norm
2. **Collectively punish defection** to deter exploitation
3. **Forgive strategically** to allow recovery from punishment cycles

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: We cannot assess others without history. Starting with cooperation signals our willingness to collaborate and maximizes expected value when others may share similar reasoning.

---

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

**Decision Rule:**

```
IF coop_rate >= threshold(t) THEN
    COOPERATE
ELSE
    DEFECT with probability = punishment_intensity(coop_rate)
    COOPERATE with probability = 1 - punishment_intensity(coop_rate)
```

**Threshold Function:**
```
threshold(t) = max(0.5, 0.7 - 0.02 * t)
```
- Starts at 0.7 (requiring 70% cooperation)
- Gradually relaxes over time (minimum 50%)
- This allows recovery from early defection spirals

**Punishment Intensity:**
```
punishment_intensity(coop_rate) = 1 - coop_rate
```
- If 80% cooperated, defect with 20% probability
- If 30% cooperated, defect with 70% probability
- Proportional response prevents over-punishment

**Forgiveness Mechanism:**
Every `ceil(r/5)` rounds, if currently in punishment mode:
```
IF round_number % ceil(r/5) == 0 THEN
    COOPERATE (forgiveness probe)
```
This tests whether cooperation can be restored.

---

### Final Round (Round r): Conditional Cooperation

**Unlike standard game theory advice to defect:**

```
IF average_cooperation_rate_over_all_rounds >= 0.6 THEN
    COOPERATE (reward sustained cooperation)
ELSE
    DEFECT (no point maintaining facade)
```

Rationale: If we're all collective instances, we should cooperate to the end. If opponents have cooperated consistently, maintaining trust has reputational value in repeated tournament contexts.

---

## Pseudocode Implementation

```python
def decide(round_number, total_rounds, n, k, history):
    # history[t] = number of cooperators in round t
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate metrics
    last_round_coop_rate = history[round_number - 1] / n
    avg_coop_rate = sum(history.values()) / (n * (round_number - 1))
    
    # Final round logic
    if round_number == total_rounds:
        if avg_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    threshold = max(0.5, 0.7 - 0.02 * round_number)
    forgiveness_interval = ceil(total_rounds / 5)
    
    # Forgiveness probe
    if round_number % forgiveness_interval == 0 and last_round_coop_rate < threshold:
        return COOPERATE
    
    # Main decision
    if last_round_coop_rate >= threshold:
        return COOPERATE
    else:
        punishment_prob = 1 - last_round_coop_rate
        if random() < punishment_prob:
            return DEFECT
        else:
            return COOPERATE
```

---

## Edge Cases Handled

| Scenario | Behavior |
|----------|----------|
| **n = 2** | Becomes similar to iterated Prisoner's Dilemma; threshold naturally applies |
| **All others defect R1** | Defect with high probability R2, but forgiveness probes allow recovery |
| **All others always cooperate** | We always cooperate (mutual benefit) |
| **Mixed population** | Probabilistic response prevents exploitation while allowing cooperation |
| **Very short games (r ≤ 3)** | Forgiveness interval = 1, frequent cooperation probes |
| **Very long games** | Threshold relaxes, more opportunities for norm establishment |

---

## Why This Strategy is Collectively Optimal

1. **Self-consistency**: If all players use ACR, everyone cooperates every round (maximum payoff)
2. **Exploitation-resistant**: Defectors face proportional punishment
3. **Recoverable**: Forgiveness probes prevent permanent punishment spirals
4. **Adaptive**: Responds to actual behavior, not assumptions about opponent types
'''

description_COLLECTIVE_31 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all copies of this strategy will reason identically given the same information. Rather than asking "what should *I* do against *others*?", we ask "what should *we all* do together?" This creates implicit coordination among copies without explicit communication.

Since we cannot identify who shares our strategy, we use observable behavior to build a model of the population and adapt accordingly. The goal is to sustain cooperation when it's collectively beneficial while protecting against exploitation.

## Strategy Overview

**Name: Collective Adaptive Reciprocity (CAR)**

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness and discover cooperative partners
2. **Mirror the population** to sustain cooperation when viable and protect when necessary
3. **End strategically** to handle the known defection incentive in final rounds

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: We cannot learn anything without contributing to the information environment. All copies of this strategy will cooperate in round 1, establishing a cooperation baseline. This also gives non-copies a chance to reveal cooperative intent.

---

### Rounds 2 through (r-2): Adaptive Reciprocity

Let `coop_rate(t)` = proportion of players who cooperated in round t (excluding self)

**Decision Rule:**

```
cooperation_threshold = k/n  # The break-even point

# Calculate weighted cooperation rate (recent rounds weighted more)
weighted_coop_rate = 0.5 * coop_rate(t-1) + 0.3 * coop_rate(t-2) + 0.2 * avg_coop_rate(all prior rounds)
# (For round 2, use only round 1 data)

# Adjust threshold based on round position (more forgiving early, stricter later)
round_progress = t / r
adjusted_threshold = cooperation_threshold * (0.8 + 0.4 * round_progress)

IF weighted_coop_rate >= adjusted_threshold:
    COOPERATE
ELSE:
    # Probabilistic cooperation to allow recovery
    cooperate_probability = weighted_coop_rate / adjusted_threshold
    COOPERATE with probability cooperate_probability
    DEFECT with probability (1 - cooperate_probability)
```

**Key Features:**
- **Threshold at k/n**: This is mathematically motivated—cooperation is collectively beneficial when enough others cooperate that the public good return exceeds the private cost
- **Weighted recent history**: Responds quickly to shifts in population behavior while smoothing noise
- **Probabilistic defection**: Gradual response prevents death spirals from single-round fluctuations
- **Progressive strictness**: Early forgiveness allows cooperation patterns to establish; later strictness protects accumulated payoffs

---

### Round (r-1): Penultimate Round
**Action: Mirror majority from round (r-2)**

```
IF coop_rate(r-2) >= 0.5:
    COOPERATE
ELSE:
    DEFECT
```

Rationale: This round signals our final-round intentions. By mirroring the established pattern, we communicate consistency to other adaptive strategies.

---

### Round r: Final Round

```
# Calculate overall cooperation commitment
overall_coop_rate = average cooperation rate across all previous rounds

IF overall_coop_rate >= (n-1)/n:  # Near-universal cooperation
    COOPERATE  # Maintain collective outcome, reward loyal cooperators
ELSE IF overall_coop_rate >= 0.6:
    COOPERATE with probability = overall_coop_rate
    DEFECT with probability = (1 - overall_coop_rate)
ELSE:
    DEFECT  # Population has demonstrated non-cooperative nature
```

Rationale: In populations that have maintained strong cooperation, defecting in the final round is a betrayal that isn't worth the marginal gain. In mixed populations, we probabilistically match the population's demonstrated commitment. In defector-heavy populations, there's no collective trust to preserve.

---

## Edge Cases

### Very Short Games (r ≤ 3)
- Round 1: COOPERATE
- Round 2 (if r=2, this is final): COOPERATE if k > n/2, else DEFECT
- Round 3 (if r=3, this is final): Apply final round logic

### Large n (many players)
The strategy scales naturally—k/n becomes smaller, making the cooperation threshold more demanding, which is appropriate since each individual contribution matters less.

### k close to 1 or close to n
- k ≈ 1: Threshold approaches 1, strategy becomes stricter (cooperation barely pays)
- k ≈ n: Threshold approaches 1, but cooperation is nearly always beneficial—strategy remains cooperative with even moderate participation

### All Defectors Observed
If cooperation rate drops to 0 in any round, cooperate with probability 1/n in subsequent rounds. This maintains a small "olive branch" for potential recovery without being exploited.

### Exact Ties
When weighted_coop_rate exactly equals the threshold, COOPERATE (bias toward collective benefit).

---

## Summary Pseudocode

```
function decide(round_t, history, n, k, r):
    
    if t == 1:
        return COOPERATE
    
    # Calculate metrics
    coop_rate_last = count_cooperators(history[t-1]) / (n-1)
    
    if t == 2:
        weighted_coop = coop_rate_last
    else:
        coop_rate_prev = count_cooperators(history[t-2]) / (n-1)
        avg_coop = average_coop_rate(history)
        weighted_coop = 0.5*coop_rate_last + 0.3*coop_rate_prev + 0.2*avg_coop
    
    # Final round logic
    if t == r:
        overall_coop = average_coop_rate(history)
        if overall_coop >= (n-1)/n:
            return COOPERATE
        else if overall_coop >= 0.6:
            return random_choice(COOPERATE, prob=overall_coop)
        else:
            return DEFECT
    
    # Penultimate round
    if t == r-1:
        return COOPERATE if coop_rate(history[t-2]) >= 0.5 else DEFECT
    
    # Middle rounds
    threshold = (k/n) * (0.8 + 0.4 * (t/r))
    
    if weighted_coop >= threshold:
        return COOPERATE
    else:
        prob = weighted_coop / threshold
        return random_choice(COOPERATE, prob=prob)
```

---

## Why This Strategy is Collectively Robust

1. **Self-consistency**: All copies make identical decisions, creating a reliable cooperative bloc
2. **Adaptive**: Responds to actual population behavior rather than assuming cooperation or defection
3. **Forgiving but not naive**: Allows recovery from occasional defection while trending toward appropriate responses
4. **Mathematically grounded**: Thresholds based on the actual payoff structure (k/n)
5. **End-game aware**: Handles the classic unraveling problem with graduated responses based on demonstrated trust
'''

description_COLLECTIVE_33 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players in my cohort are running the same strategy, so I should design rules that produce good outcomes when everyone follows them, while remaining robust against defectors or different strategies.

The key insight is that with k < n, defection always dominates in a single round, but mutual cooperation yields higher total welfare. Our goal is to establish and maintain cooperation among like-minded players while protecting against exploitation.

## Strategy: **Adaptive Threshold Cooperation with Forgiveness**

### Decision Framework

The strategy tracks the **cooperation rate** of the group (excluding self) and uses adaptive thresholds to decide when to cooperate.

### Parameters Derived from Game Settings

```
base_threshold = (n - k) / n    # Minimum cooperation needed for contribution to be worthwhile
forgiveness_bonus = 0.15        # Tolerance below threshold
decay_rate = 1 / r              # How quickly to reduce forgiveness over time
```

### Round-by-Round Decision Rules

#### **Round 1: Unconditional Cooperation**
- **Action: COOPERATE**
- Rationale: Signal cooperative intent. If all collective-minded players do this, we establish a cooperative baseline. The cost of one round of potential exploitation is worth the coordination benefit.

#### **Rounds 2 through (r-1): Adaptive Conditional Cooperation**

Calculate from the previous round:
```
observed_cooperation_rate = (number of C plays by others) / (n - 1)
rounds_remaining = r - current_round
adjusted_threshold = base_threshold - (forgiveness_bonus × rounds_remaining / r)
```

**Decision Rule:**
```
IF observed_cooperation_rate >= adjusted_threshold:
    COOPERATE
ELSE IF cooperation_rate in last 2 rounds shows upward trend:
    COOPERATE (give benefit of doubt to recovering groups)
ELSE:
    DEFECT
```

**Additional Trigger - Punishment Response:**
```
IF my_cumulative_payoff < (current_round × 1.0):
    # I'm being exploited (earning less than universal defection baseline)
    DEFECT for next round regardless of threshold
```

#### **Final Round (Round r): Conditional Based on History**

```
overall_cooperation_rate = total_C_plays_by_others / ((r-1) × (n-1))

IF overall_cooperation_rate >= 0.6:
    COOPERATE  # Reward sustained cooperation, maintain collective benefit
ELSE:
    DEFECT     # No future rounds to incentivize, defect against non-cooperators
```

**Rationale for final round cooperation:** If I'm playing with other collective-minded agents who cooperated throughout, we should all cooperate in the final round too—breaking cooperation only makes sense against defectors.

### Handling Edge Cases

1. **Very short games (r = 2):** 
   - Round 1: Cooperate
   - Round 2: Cooperate if ≥50% cooperated in round 1, else defect

2. **Large n (many players):**
   - Individual defection has smaller impact on group outcome
   - Strategy naturally adjusts via base_threshold calculation

3. **k very close to n:**
   - base_threshold approaches 0, meaning cooperate more readily
   - This is correct: higher k means cooperation is more socially efficient

4. **k very close to 1:**
   - base_threshold approaches 1, requiring near-universal cooperation
   - Appropriately cautious when public good multiplication is weak

### Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    others_last_round = count_cooperators_last_round(history) 
    coop_rate = others_last_round / (n - 1)
    
    base_threshold = (n - k) / n
    rounds_remaining = r - round
    adjusted_threshold = base_threshold - (0.15 * rounds_remaining / r)
    
    # Exploitation check
    if my_cumulative_payoff(history) < round * 1.0:
        return DEFECT
    
    # Final round logic
    if round == r:
        overall_rate = total_others_cooperation(history) / ((r-1) * (n-1))
        return COOPERATE if overall_rate >= 0.6 else DEFECT
    
    # Standard rounds
    if coop_rate >= adjusted_threshold:
        return COOPERATE
    elif is_trending_upward(history, window=2):
        return COOPERATE
    else:
        return DEFECT
```

## Why This Strategy is Collectively Aligned

1. **Starts cooperatively** - Enables coordination among like-minded players
2. **Forgives early defection** - Allows groups to find cooperation equilibrium
3. **Becomes stricter over time** - Reduces forgiveness as end approaches
4. **Punishes sustained defection** - Protects against pure exploiters
5. **Cooperates in final round with cooperators** - Doesn't unnecessarily break mutual benefit
6. **Thresholds adapt to game parameters** - Works across different n and k values
'''

description_COLLECTIVE_32 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be using similar reasoning and share the goal of achieving mutual benefit. The strategy aims to:
1. Signal cooperative intent early
2. Sustain cooperation when others reciprocate
3. Respond proportionally to defection without triggering collapse
4. Recover cooperation when possible

## Strategy Overview: **Proportional Tit-for-Tat with Forgiveness (PTFF)**

The core idea is to mirror the group's cooperation level from the previous round, with built-in mechanisms for forgiveness and end-game stability.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Start by signaling cooperative intent. This establishes a foundation for mutual cooperation and identifies other cooperative players.

### Middle Rounds (2 through r-1): Proportional Response with Forgiveness

Let `coop_rate` = (number of cooperators in previous round) / n

**Decision Rule:**
```
if coop_rate >= 0.5:
    COOPERATE
else if coop_rate >= (k/n):
    # Cooperation is still collectively rational at this level
    COOPERATE with probability = coop_rate + forgiveness_bonus
    DEFECT with probability = 1 - (coop_rate + forgiveness_bonus)
else:
    # Cooperation has collapsed below sustainable threshold
    DEFECT with probability = 0.8
    COOPERATE with probability = 0.2  # "olive branch" to recover cooperation
```

**Forgiveness Bonus Calculation:**
```
forgiveness_bonus = 0.1 × (rounds_remaining / r)
```
This bonus is higher early in the game (more time to recover cooperation) and diminishes as the game progresses.

### Last Round (Round r): Conditional Cooperation

**Decision Rule:**
```
if average_coop_rate_over_game >= 0.6:
    COOPERATE  # Reward sustained collective cooperation
else if coop_rate_previous_round >= 0.5:
    COOPERATE  # Maintain momentum if recent cooperation exists
else:
    DEFECT  # No basis for expecting reciprocation
```

Rationale: Unlike standard game theory which predicts universal defection in the last round, a collective mindset recognizes that if everyone defects "because it's the last round," everyone loses. By conditioning on history, we reward groups that maintained cooperation.

---

## Edge Cases

### When n = 2 (Minimum Players)
Becomes a standard two-player repeated game. The strategy simplifies to:
- Round 1: Cooperate
- Subsequent rounds: Copy opponent's previous action (standard Tit-for-Tat)
- Add forgiveness: After opponent defects, cooperate with 20% probability to test for recovery

### When k is Close to n (High Multiplication Factor)
Cooperation is highly rewarding. Be more forgiving:
- Increase forgiveness_bonus by factor of (k/(n-1))

### When k is Close to 1 (Low Multiplication Factor)
Cooperation provides marginal benefit. Be more cautious:
- Reduce forgiveness_bonus by factor of (k-1)

### Recovering from Mutual Defection
If the last 2+ rounds had coop_rate < 0.3:
```
COOPERATE with probability = 0.3  # Attempt coordination reset
```
This "olive branch" probability is high enough to potentially restart cooperation if multiple players use similar strategies.

---

## Pseudocode Summary

```python
def decide(round_number, total_rounds, n, k, history):
    
    if round_number == 1:
        return COOPERATE
    
    coop_rate = count_cooperators(history[-1]) / n
    avg_coop_rate = average_cooperation_rate(history)
    rounds_remaining = total_rounds - round_number
    forgiveness_bonus = 0.1 * (rounds_remaining / total_rounds)
    
    # Adjust forgiveness based on k
    k_factor = (k - 1) / (n - 1)  # Normalized between 0 and 1
    forgiveness_bonus *= (0.5 + k_factor)
    
    if round_number == total_rounds:  # Last round
        if avg_coop_rate >= 0.6 or coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    if coop_rate >= 0.5:
        return COOPERATE
    elif coop_rate >= k/n:
        threshold = coop_rate + forgiveness_bonus
        return COOPERATE if random() < threshold else DEFECT
    else:
        # Cooperation collapsed - mostly defect but offer olive branch
        return COOPERATE if random() < 0.2 else DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Collective Alignment**: Assumes others may think similarly; initial cooperation and proportional response naturally coordinate cooperative groups

2. **Adaptive**: Responds to actual group behavior rather than fixed assumptions

3. **Forgiving**: Doesn't permanently punish defection; allows recovery

4. **Robust to Defectors**: Doesn't get exploited indefinitely—reduces cooperation when facing persistent defection

5. **Parameter-Aware**: Adjusts behavior based on k/n ratio (the efficiency of public goods)
'''

description_COLLECTIVE_34 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we assume all copies of this strategy will reason identically given the same information. Rather than treating other players as adversaries to exploit, we recognize that if others reason like us, our choice effectively determines what "players like us" do. The question becomes: *what behavior, if universalized among rational cooperators, produces the best collective outcome while remaining robust to defectors?*

## Strategy Overview: **Adaptive Collective Reciprocity**

The strategy operates on three principles:
1. **Start cooperatively** to establish and signal cooperative intent
2. **Mirror the collective** by responding to the overall cooperation level
3. **Protect against exploitation** while maintaining forgiveness

---

## Decision Rules

### Round 1: Cooperate
With no history, we cooperate. This signals cooperative intent and, if others reason similarly, bootstraps mutual cooperation.

### Rounds 2 through (r-1): Adaptive Reciprocity

**Calculate the cooperation rate** from the previous round:
```
coop_rate = (number of C plays in previous round) / n
```

**Decision rule:**
```
IF coop_rate >= (n-1)/n THEN
    Cooperate (near-universal cooperation maintained)
ELSE IF coop_rate >= 0.5 THEN
    Cooperate with probability = coop_rate
    (probabilistically match collective behavior)
ELSE IF coop_rate > 0 THEN
    Cooperate with probability = coop_rate × forgiveness_factor
    where forgiveness_factor = 1.5 (capped at probability 1)
    (slight optimism to help recovery)
ELSE (coop_rate = 0)
    Defect (no point being the only cooperator)
```

**Trend adjustment:** If cooperation has increased for 2+ consecutive rounds, add +0.1 to cooperation probability (capped at 1). If cooperation has decreased for 2+ consecutive rounds, subtract 0.1 from cooperation probability (floored at 0).

### Final Round (Round r): Conditional Cooperation

The last round has no shadow of the future, but we maintain collective thinking:

```
IF average cooperation rate over all previous rounds >= 0.6 THEN
    Cooperate (reward sustained cooperation, assume like-minded players will too)
ELSE
    Defect (cooperation has failed; minimize losses)
```

---

## Pseudocode

```python
def decide(round_number, r, n, k, history):
    """
    history: list of lists, where history[t] contains all n actions from round t
    actions are 'C' or 'D'
    """
    
    # Round 1: Always cooperate
    if round_number == 1:
        return 'C'
    
    # Calculate previous round cooperation rate
    prev_round = history[-1]
    prev_coop_count = sum(1 for a in prev_round if a == 'C')
    coop_rate = prev_coop_count / n
    
    # Final round logic
    if round_number == r:
        total_coop = sum(sum(1 for a in round_hist if a == 'C') 
                        for round_hist in history)
        total_actions = n * (r - 1)
        avg_coop_rate = total_coop / total_actions
        return 'C' if avg_coop_rate >= 0.6 else 'D'
    
    # Calculate trend (for rounds 3+)
    trend_bonus = 0
    if len(history) >= 2:
        recent_rates = []
        for round_hist in history[-3:]:  # last 3 rounds or fewer
            recent_rates.append(sum(1 for a in round_hist if a == 'C') / n)
        if len(recent_rates) >= 2:
            if all(recent_rates[i] < recent_rates[i+1] for i in range(len(recent_rates)-1)):
                trend_bonus = 0.1  # improving trend
            elif all(recent_rates[i] > recent_rates[i+1] for i in range(len(recent_rates)-1)):
                trend_bonus = -0.1  # declining trend
    
    # Main decision logic
    if coop_rate >= (n-1)/n:
        coop_prob = 1.0
    elif coop_rate >= 0.5:
        coop_prob = coop_rate
    elif coop_rate > 0:
        coop_prob = min(1.0, coop_rate * 1.5)  # forgiveness factor
    else:
        coop_prob = 0.0
    
    # Apply trend adjustment
    coop_prob = max(0.0, min(1.0, coop_prob + trend_bonus))
    
    # Probabilistic decision
    return 'C' if random() < coop_prob else 'D'
```

---

## Edge Cases Handled

| Scenario | Behavior |
|----------|----------|
| First round | Always cooperate |
| Last round | Cooperate if historical cooperation ≥ 60% |
| All defected last round | Defect (no exploitation) |
| All cooperated last round | Cooperate (maintain equilibrium) |
| n=2 (minimum players) | Strategy still applies; threshold (n-1)/n = 0.5 |
| Large n | Gracefully scales; probabilistic matching handles noise |
| Single defector in sea of cooperators | Still cooperate (coop_rate ≥ (n-1)/n threshold) |

---

## Why This Strategy Works Collectively

1. **Self-consistency**: If all players use this strategy, they'll all cooperate in round 1, see 100% cooperation, and continue cooperating through round r—achieving the optimal collective outcome.

2. **Robustness to mixed populations**: The probabilistic matching means we don't unilaterally defect when some cooperate, nor do we naively cooperate when most defect.

3. **Forgiveness**: The 1.5× forgiveness factor in low-cooperation states gives the collective a chance to recover from coordination failures.

4. **No exploitation**: We never cooperate alone (coop_rate = 0 → defect), so pure defectors cannot exploit us indefinitely.

5. **Final round cooperation**: By cooperating in the final round when history is positive, we capture value that purely self-interested strategies forfeit, and we reward the cooperative relationship.
'''

description_COLLECTIVE_33 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that universal cooperation yields the best outcome for everyone (payoff = k > 1), while universal defection yields the worst collective outcome (payoff = 1). My goal is to foster and sustain cooperation while protecting against persistent exploitation.

The strategy is built on three pillars:
1. **Optimistic initiation** - Start cooperatively to signal good faith
2. **Proportional reciprocity** - Mirror the cooperation level of the group
3. **Forgiveness with memory** - Allow recovery from defection but track patterns

---

## Decision Rules

### Round 1: Cooperate Unconditionally
- **Action: C**
- Rationale: Establish cooperative intent. With no history, optimism creates the best chance for mutual cooperation.

### Rounds 2 through (r-1): Adaptive Threshold Cooperation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

Calculate the **trend** (if round ≥ 3):
```
trend = coop_rate(t-1) - coop_rate(t-2)
```

**Decision Rule:**

```
base_threshold = 0.5

# Adjust threshold based on how far into the game we are
progress = current_round / total_rounds
late_game_adjustment = 0.1 * progress  # Slightly more forgiving early, stricter late

effective_threshold = base_threshold + late_game_adjustment

# Incorporate trend: rising cooperation lowers threshold (more willing to cooperate)
if trend > 0:
    effective_threshold -= 0.1
elif trend < 0:
    effective_threshold += 0.1

# Final decision
if coop_rate >= effective_threshold:
    Action: C
else:
    Action: D
```

**Interpretation:**
- If at least ~50% of players cooperated last round, cooperate (reciprocate the group norm)
- If cooperation is rising, be more willing to cooperate (reward positive momentum)
- If cooperation is falling, become more cautious (don't chase declining cooperation)
- As the game progresses, require slightly higher cooperation rates (avoid late-game exploitation)

### Final Round (Round r): Conditional Cooperation

The final round removes future consequences, creating temptation to defect. However, maintaining collective integrity matters:

```
# Calculate overall cooperation rate across all previous rounds
historical_coop_rate = total_C_actions / (n * (r-1))

if historical_coop_rate >= 0.6:
    Action: C  # Reward a cooperative group with continued cooperation
else:
    Action: D  # Don't be exploited in a defection-prone environment
```

**Rationale:** If the group has been mostly cooperative, honor that relationship even in the final round. This distinguishes genuinely collective strategies from those merely mimicking cooperation.

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | Round 1: C, Round 2: mirror majority from R1 | Minimal history, simple reciprocity |
| n = 2 (minimum players) | Standard rules apply; threshold effectively means "cooperate if opponent cooperated" | Reduces to tit-for-tat variant |
| All defected last round (coop_rate = 0) | D | Don't be a lone cooperator; signal that defection is reciprocated |
| All cooperated last round (coop_rate = 1) | C | Maintain the cooperative equilibrium |
| Exactly 50% cooperated | Check trend; if positive or neutral, C; if negative, D | Tie-breaker favors optimism unless things are declining |
| k very close to 1 | Same rules apply | Low k makes cooperation fragile, but the collective strategy remains consistent |
| k close to n | Same rules apply | High k makes cooperation very attractive; expect higher natural cooperation |

---

## Pseudocode Summary

```python
def decide(round, total_rounds, n, k, history):
    """
    history: list of lists, where history[t] contains actions of all n players in round t
    """
    
    # Round 1: Unconditional cooperation
    if round == 1:
        return 'C'
    
    # Calculate previous round cooperation rate
    prev_round = history[round - 1]
    coop_rate = sum(1 for action in prev_round if action == 'C') / n
    
    # Final round: historical assessment
    if round == total_rounds:
        total_coop = sum(
            sum(1 for action in round_actions if action == 'C')
            for round_actions in history
        )
        historical_rate = total_coop / (n * (round - 1))
        return 'C' if historical_rate >= 0.6 else 'D'
    
    # Middle rounds: threshold with trend adjustment
    base_threshold = 0.5
    progress = round / total_rounds
    effective_threshold = base_threshold + (0.1 * progress)
    
    # Trend adjustment (if we have enough history)
    if round >= 3:
        prev_prev_round = history[round - 2]
        prev_coop_rate = sum(1 for action in prev_prev_round if action == 'C') / n
        trend = coop_rate - prev_coop_rate
        
        if trend > 0:
            effective_threshold -= 0.1
        elif trend < 0:
            effective_threshold += 0.1
    
    return 'C' if coop_rate >= effective_threshold else 'D'
```

---

## Why This Strategy Is Collectively Robust

1. **Invites cooperation**: Starting with C and maintaining low thresholds gives cooperative opponents every opportunity to establish mutual benefit.

2. **Punishes defection proportionally**: Doesn't overreact to a single defector, but responds to group-level defection trends.

3. **Self-correcting**: The trend mechanism helps escape defection spirals (by responding to improvement) and avoid cooperation collapse (by tightening when cooperation falls).

4. **Resistant to exploitation**: The threshold ensures we don't cooperate into oblivion when facing majority defectors.

5. **Honors collective history**: The final-round rule rewards sustained cooperation, distinguishing this from purely self-interested strategies.
'''

description_COLLECTIVE_35 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we assume all players using this strategy will behave identically given the same history, creating implicit coordination without explicit communication. The strategy aims to:
1. Establish cooperation as the norm
2. Punish defection proportionally to deter free-riding
3. Forgive and return to cooperation to maximize collective welfare
4. Adapt to the actual behavior observed in the game

## Strategy: **Adaptive Proportional Tit-for-Tat (APTT)**

### Decision Rule Overview

The strategy tracks the **cooperation rate** of the group and responds proportionally, with built-in mechanisms for forgiveness and end-game considerations.

---

### Detailed Decision Rules

#### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- Rationale: Signal cooperative intent and give others the opportunity to cooperate. With collective mindset, all strategy-users start cooperating together.

#### Rounds 2 through (r-1): Adaptive Response

Calculate the **group cooperation rate** from the previous round:
```
coop_rate = (number of C plays in round t-1) / n
```

**Decision Rule:**
```
If coop_rate >= (n-1)/n:
    COOPERATE  (near-universal cooperation maintained)
    
Else if coop_rate >= 0.5:
    COOPERATE with probability = coop_rate
    DEFECT with probability = 1 - coop_rate
    
Else if coop_rate > 0:
    DEFECT (but with forgiveness probe - see below)
    
Else (coop_rate == 0):
    DEFECT
```

**Forgiveness Mechanism:**
- Every `floor(r/5)` rounds (minimum every 3 rounds), if currently in a defection state, **probe with COOPERATE** to test if cooperation can be restored
- This prevents permanent punishment spirals

**Trend Adjustment:**
- If cooperation rate has increased for 2 consecutive rounds, boost cooperation probability by 0.1
- If cooperation rate has decreased for 2 consecutive rounds, reduce cooperation probability by 0.1

#### Last Round (Round r): Conditional Cooperation

Unlike classic game theory advice to defect:
```
If average cooperation rate over all previous rounds >= 0.6:
    COOPERATE  (reward sustained cooperation, collective benefit)
Else:
    DEFECT  (no reason to cooperate with chronic defectors)
```

Rationale: With collective mindset, if most players have cooperated throughout, mutual cooperation in the final round yields k > 1 return, which beats mutual defection.

---

### Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_count = count_cooperators(history, round - 1)
    coop_rate = prev_coop_count / n
    
    # Calculate historical average
    total_coop = sum(count_cooperators(history, t) for t in 1..round-1)
    avg_coop_rate = total_coop / (n * (round - 1))
    
    # Last round logic
    if round == r:
        if avg_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Forgiveness probe (every floor(r/5) rounds, minimum 3)
    probe_interval = max(3, floor(r / 5))
    if round % probe_interval == 0 and coop_rate < 0.5:
        return COOPERATE
    
    # Calculate trend
    trend = 0
    if round >= 3:
        rate_t1 = count_cooperators(history, round-1) / n
        rate_t2 = count_cooperators(history, round-2) / n
        rate_t3 = count_cooperators(history, round-3) / n
        if rate_t1 > rate_t2 > rate_t3:
            trend = +0.1
        elif rate_t1 < rate_t2 < rate_t3:
            trend = -0.1
    
    # Main decision logic
    if coop_rate >= (n-1)/n:
        return COOPERATE
    
    elif coop_rate >= 0.5:
        adjusted_prob = min(1.0, max(0.0, coop_rate + trend))
        return COOPERATE with probability adjusted_prob
        
    else:
        return DEFECT
```

---

### Edge Cases Handled

| Situation | Response |
|-----------|----------|
| First round | Always cooperate |
| Last round | Cooperate if historical avg ≥ 0.6 |
| All defected last round | Defect (but probe for forgiveness periodically) |
| One defector among cooperators | Cooperate (tolerate minor defection) |
| Exactly 50% cooperation | Probabilistically cooperate ~50% |
| Long games (large r) | More frequent forgiveness probes |
| Small n (n=2) | Behaves like generous tit-for-tat |
| Large n | Threshold (n-1)/n scales appropriately |

---

### Why This Strategy is Collectively Robust

1. **Self-consistency**: If all players use APTT, they all cooperate in round 1, observe full cooperation, and continue cooperating throughout—achieving the optimal collective outcome of `2 × r` total payoff per player.

2. **Punishment deters defection**: Defectors face reduced cooperation from APTT players, making defection less profitable.

3. **Forgiveness enables recovery**: Even after breakdowns, the strategy probes for renewed cooperation.

4. **Proportional response**: Doesn't overreact to noise or single defectors, maintaining stability.

5. **Adaptive to opponents**: Against always-defect opponents, quickly learns to defect; against cooperators, maintains cooperation.
'''

description_COLLECTIVE_34 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we treat all players using this strategy as a unified group seeking to maximize joint welfare. Since cooperation by all yields the highest total payoff (n×k vs n when all defect), our goal is to establish and maintain cooperation while protecting against exploitation.

The strategy uses **adaptive conditional cooperation** with **graduated punishment** and **forgiveness mechanisms**.

---

## Strategy Overview

The strategy operates on three principles:
1. **Start cooperatively** to signal good intentions and establish norms
2. **Mirror the group** by tracking cooperation rates and responding proportionally
3. **Protect the collective** by punishing sustained defection while allowing recovery

---

## Decision Rules

### Key Variables Tracked

```
cooperation_rate = (total C plays by all players in previous round) / n
historical_coop_rate = (total C plays across all rounds) / (n × rounds_played)
consecutive_low_rounds = count of consecutive rounds where cooperation_rate < 0.5
rounds_remaining = r - current_round
```

### Round-by-Round Logic

#### First Round
**Action: COOPERATE**

Rationale: Signal cooperative intent. With no history, we cannot punish or reward, so we extend trust.

#### Middle Rounds (round 2 to round r-1)

```
IF cooperation_rate >= 0.7 THEN:
    COOPERATE  # Strong cooperation norm exists
    
ELSE IF cooperation_rate >= 0.5 THEN:
    # Moderate cooperation - use probabilistic response
    COOPERATE with probability = cooperation_rate
    
ELSE IF cooperation_rate < 0.5 THEN:
    # Low cooperation environment
    IF consecutive_low_rounds >= 2 THEN:
        DEFECT  # Protect against sustained exploitation
    ELSE:
        COOPERATE with probability = max(0.3, cooperation_rate)
        # Give one more chance, but reduce exposure
```

**Forgiveness Mechanism:**
```
IF previous_round was DEFECT AND cooperation_rate increased by >= 0.2 THEN:
    COOPERATE  # Reward improvement, re-establish cooperation
```

#### Last Round
```
IF historical_coop_rate >= 0.6 THEN:
    COOPERATE  # Honor the cooperative relationship
ELSE:
    DEFECT  # No future to protect; group was uncooperative
```

Rationale: Standard game theory suggests defection in the final round, but if the group maintained strong cooperation, we honor that relationship. This also makes our strategy more robust against backwards induction exploitation.

---

## Handling Edge Cases

### Very Short Games (r ≤ 3)
- Round 1: COOPERATE
- Round 2: Mirror majority (COOPERATE if cooperation_rate ≥ 0.5)
- Round 3 (if exists): Apply last-round rule above

### Large n (many players)
The strategy naturally adapts because:
- cooperation_rate becomes a smoother signal with more players
- Individual deviations matter less, so we focus on aggregate behavior

### Small n (n = 2)
Becomes essentially Tit-for-Tat with forgiveness:
- Cooperate first
- Mirror opponent's last move
- Forgive single defections if they return to cooperation

### All Defection Environment
If `consecutive_low_rounds >= 3` AND `cooperation_rate < 0.3`:
- Switch to DEFECT until cooperation_rate rises above 0.4
- Then attempt cooperation again (one probe every 3 rounds)

### Near-Unanimous Cooperation
If `cooperation_rate >= 0.9`:
- Always COOPERATE
- This maximizes collective payoff and maintains the norm

---

## Pseudocode Implementation

```python
def decide(round, history, n, r, k):
    if round == 1:
        return COOPERATE
    
    # Calculate metrics
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate = last_round_coops / n
    hist_coop_rate = total_cooperations(history) / (n * (round - 1))
    consec_low = consecutive_rounds_below(history, threshold=0.5)
    
    # Last round logic
    if round == r:
        return COOPERATE if hist_coop_rate >= 0.6 else DEFECT
    
    # Forgiveness check
    if my_last_action(history) == DEFECT:
        if coop_rate - previous_coop_rate(history) >= 0.2:
            return COOPERATE
    
    # Main decision logic
    if coop_rate >= 0.7:
        return COOPERATE
    elif coop_rate >= 0.5:
        return COOPERATE with probability coop_rate
    else:
        if consec_low >= 2:
            return DEFECT
        else:
            return COOPERATE with probability max(0.3, coop_rate)
```

---

## Why This Strategy Works Collectively

1. **Coordination without communication**: By all using the same cooperation_rate thresholds, collective players naturally synchronize behavior.

2. **Robust to mixed populations**: Against defectors, we limit losses; against cooperators, we maximize joint gains.

3. **Self-reinforcing**: When multiple collective players exist, they boost cooperation_rate, triggering more cooperation from each other.

4. **Punishes but forgives**: We don't permanently retaliate, allowing recovery from mistakes or initial miscoordination.
'''

description_COLLECTIVE_36 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **we succeed together or fail together**. Rather than treating other players as opponents to exploit, I treat them as potential partners in building mutual prosperity. The strategy aims to establish and maintain cooperation while protecting the collective from exploitation.

## Strategy Overview: "Generous Threshold Reciprocity"

The strategy operates on three principles:
1. **Start cooperatively** to signal good faith and establish a cooperation norm
2. **Reciprocate the group's behavior** - match the prevailing level of cooperation
3. **Be forgiving** to allow recovery from mistakes or initial defection

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: Cooperate (C)**

Rationale: Someone must take the first step. By cooperating initially, we demonstrate trustworthiness and invite others to join in mutual benefit. The potential gain from establishing cooperation far outweighs the risk of one round's exploitation.

### Rounds 2 through (r-1): Threshold-Based Reciprocity

Calculate the **cooperation rate** from the previous round:
```
prev_coop_rate = (number of cooperators in previous round) / n
```

**Decision Rule:**
- If `prev_coop_rate >= cooperation_threshold`: **Cooperate (C)**
- If `prev_coop_rate < cooperation_threshold`: **Defect (D)**

**Dynamic Threshold Calculation:**
```
base_threshold = (1/k)  # The break-even point where cooperation becomes individually rational
cooperation_threshold = max(0.3, base_threshold - forgiveness_bonus)

where:
forgiveness_bonus = 0.1 × (cumulative_cooperation_rate)
cumulative_cooperation_rate = total cooperations across all players and rounds / (n × rounds_played)
```

The threshold adapts:
- Starts relatively generous (around 30-40% typically)
- Becomes more forgiving as overall cooperation history improves
- Never drops below ensuring some minimum collective participation

### Last Round (Round r): Conditional Cooperation

Unlike standard game theory advice to defect in final rounds, maintain collective commitment:

**Decision Rule:**
- If `cumulative_cooperation_rate >= 0.5`: **Cooperate (C)**
- Otherwise: **Defect (D)**

Rationale: If we've built something good together, honor that relationship even when there's no future enforcement. This reflects genuine collective values, not just strategic calculation.

---

## Complete Pseudocode

```
function decide_action(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_round_cooperators = count_cooperators(history, round - 1)
    prev_coop_rate = prev_round_cooperators / n
    
    # Calculate cumulative cooperation rate
    total_cooperations = sum(count_cooperators(history, t) for t in 1 to round-1)
    total_possible = n × (round - 1)
    cumulative_coop_rate = total_cooperations / total_possible
    
    # Calculate adaptive threshold
    base_threshold = 1 / k
    forgiveness_bonus = 0.1 × cumulative_coop_rate
    cooperation_threshold = max(0.3, base_threshold - forgiveness_bonus)
    
    # Last round logic
    if round == r:
        if cumulative_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Standard rounds: threshold reciprocity
    if prev_coop_rate >= cooperation_threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases Handled

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| First round | Cooperate | Establish trust, invite cooperation |
| Everyone defected last round | Defect | Protect from exploitation, signal disapproval |
| Near-universal cooperation | Cooperate | Reward and maintain the collective norm |
| Mixed history | Use threshold | Respond proportionally to group behavior |
| Last round, good history | Cooperate | Honor the relationship we've built |
| Last round, poor history | Defect | No foundation worth preserving |
| Only 2 players (n=2) | Same rules apply | Strategy scales down gracefully |
| High k (near n) | Lower threshold | Cooperation more valuable, be more forgiving |
| Low k (near 1) | Higher threshold | Need more participants for cooperation to pay |

---

## Why This Strategy is Collectively Aligned

1. **Initiates cooperation** rather than waiting for others
2. **Rewards collective success** by continuing to cooperate when others do
3. **Forgives mistakes** through the adaptive threshold that loosens with good history
4. **Doesn't exploit** - never defects purely for individual gain when cooperation is thriving
5. **Maintains integrity** in final rounds when history warrants it
6. **Scales with parameters** - adapts to different group sizes and multiplication factors

This strategy aims to be the kind of player that makes collective action problems solvable.
'''

description_COLLECTIVE_35 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I assume I am one of many agents running the same strategy. Our goal is to maximize collective welfare while protecting against exploitation by defectors. The key insight is that if we all follow the same adaptive rules, we can achieve coordination without explicit communication.

## Strategy: "Graduated Collective Reciprocity" (GCR)

### Decision Framework

The strategy operates on three principles:
1. **Start cooperatively** to establish beneficial norms
2. **Mirror the group's cooperation level** to reward cooperation and discourage defection
3. **Forgive gradually** to allow recovery from mutual defection spirals

---

### Decision Rules

#### Round 1: Cooperate
**Rationale:** With no history, cooperation signals willingness to collaborate. If most players share this strategy, we immediately achieve high collective payoffs.

#### Rounds 2 through (r-1): Conditional Cooperation

Calculate the **cooperation rate** from the previous round:
```
prev_coop_rate = (number of C plays in round t-1) / n
```

**Cooperate if:**
```
prev_coop_rate ≥ threshold(t)
```

**Threshold Function:**
```
threshold(t) = max(0.3, 0.5 - 0.02 × t)
```

This threshold:
- Starts at approximately 0.5 (requires majority cooperation)
- Gradually decreases (becomes more forgiving over time)
- Never drops below 0.3 (maintains some standards)

**Additional forgiveness mechanism:** Even if below threshold, cooperate with probability:
```
forgiveness_prob = 0.1 + 0.1 × (rounds_since_cooperation / 5)
```
Capped at 0.3. This prevents permanent defection locks.

#### Last Round (Round r): Conditional Defection with Collective Consideration

Standard game theory suggests always defecting in the final round. However, with a collective mindset:

**Cooperate if:**
```
average_coop_rate_all_rounds ≥ 0.6 AND prev_coop_rate ≥ 0.5
```

**Defect otherwise.**

**Rationale:** If we've established strong cooperation norms, maintaining cooperation in the final round maximizes collective payoff. If cooperation has been weak, there's nothing to preserve.

---

### Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_rate = count_cooperators(history[round-1]) / n
    
    # Calculate overall average cooperation rate
    total_coops = sum(count_cooperators(history[t]) for t in 1 to round-1)
    avg_coop_rate = total_coops / (n × (round - 1))
    
    # Last round logic
    if round == r:
        if avg_coop_rate >= 0.6 AND prev_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    threshold = max(0.3, 0.5 - 0.02 × round)
    
    if prev_coop_rate >= threshold:
        return COOPERATE
    
    # Forgiveness mechanism
    rounds_since_coop = count_consecutive_rounds_below_threshold(history)
    forgiveness_prob = min(0.3, 0.1 + 0.1 × (rounds_since_coop / 5))
    
    if random() < forgiveness_prob:
        return COOPERATE
    
    return DEFECT
```

---

### Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| **r = 2 (minimum rounds)** | Cooperate R1, apply last-round rule R2 | Still establish initial goodwill |
| **n = 2 (minimum players)** | Strategy functions normally | Becomes similar to repeated Prisoner's Dilemma |
| **k very close to 1** | Strategy unchanged | Low k makes cooperation harder, but collective benefit still exists |
| **k close to n** | Strategy unchanged | High k makes cooperation more attractive; strategy naturally sustains it |
| **All previous rounds had 0 cooperation** | Forgiveness mechanism triggers eventually | Prevents permanent deadlock |
| **Exactly at threshold** | Cooperate (≥ is inclusive) | Generous interpretation supports collective |

---

### Why This Strategy Works Collectively

1. **Self-reinforcing:** If all agents use GCR, round 1 achieves 100% cooperation, which exceeds all thresholds, maintaining cooperation throughout.

2. **Robust to minorities:** If a minority defects, cooperation rate stays above threshold, so GCR agents continue cooperating—isolating defectors from triggering collapse.

3. **Recoverable:** The forgiveness mechanism ensures that even after cooperation breakdown, there's a path back to cooperation.

4. **Exploitation-resistant:** Consistent defection by opponents eventually triggers defection response, limiting losses.
'''

description_COLLECTIVE_37 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I assume other players may be using similar reasoning, and I aim to establish and maintain cooperation through clear, interpretable signals. The strategy balances optimism about collective cooperation with protection against exploitation.

## Strategy Overview: **Adaptive Threshold Cooperation (ATC)**

The strategy cooperates when there's sufficient evidence of collective cooperation, defects to protect against exploitation, and uses forgiveness mechanisms to recover from coordination failures.

---

## Decision Rules

### Round 1: Optimistic Start
**Action: COOPERATE**

Rationale: Begin by signaling cooperative intent. In a collective mindset, if all players reason similarly, starting with cooperation establishes the foundation for mutual benefit. The cost of one round's potential exploitation is small compared to the value of establishing cooperation.

### Rounds 2 through (r-1): Adaptive Threshold Response

**Calculate the cooperation rate from the previous round:**
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Calculate the trend-adjusted threshold:**
```
base_threshold = 0.5
trend_adjustment = (avg_coop_rate_last_3_rounds - avg_coop_rate_rounds_before_that) * 0.2
adjusted_threshold = base_threshold - trend_adjustment
```

**Decision Rule:**
```
IF prev_coop_rate >= adjusted_threshold:
    COOPERATE
ELSE IF prev_coop_rate < adjusted_threshold AND prev_coop_rate > 0:
    COOPERATE with probability = prev_coop_rate
ELSE (prev_coop_rate == 0):
    DEFECT
```

**Forgiveness Mechanism:**
Every `ceil(r/5)` rounds, if currently in a defection pattern:
```
IF we have defected for 3+ consecutive rounds AND round_number mod ceil(r/5) == 0:
    COOPERATE (probe for renewed cooperation)
```

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection, a collective strategy maintains consistency:

```
IF cooperation_rate_over_all_previous_rounds >= 0.6:
    COOPERATE (reward sustained collective behavior)
ELSE:
    DEFECT (no shadow of future, protect against exploitation)
```

---

## Complete Pseudocode

```
function decide(round, history, n, r, k):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history[round-1])
    prev_coop_rate = prev_cooperators / n
    
    # Calculate overall cooperation rate
    total_cooperators = sum(count_cooperators(history[t]) for t in 1..round-1)
    overall_coop_rate = total_cooperators / (n * (round - 1))
    
    # Calculate trend (if enough history)
    if round >= 4:
        recent_avg = average_coop_rate(history[round-3..round-1])
        earlier_avg = average_coop_rate(history[1..round-4])
        trend = recent_avg - earlier_avg
    else:
        trend = 0
    
    # Adjusted threshold
    base_threshold = 0.5
    adjusted_threshold = max(0.3, min(0.7, base_threshold - trend * 0.2))
    
    # Final round logic
    if round == r:
        if overall_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Forgiveness probe
    probe_interval = ceil(r / 5)
    my_consecutive_defections = count_my_consecutive_defections(history)
    if my_consecutive_defections >= 3 and round mod probe_interval == 0:
        return COOPERATE
    
    # Main decision logic
    if prev_coop_rate >= adjusted_threshold:
        return COOPERATE
    else if prev_coop_rate > 0:
        # Probabilistic cooperation - give collective another chance
        if random() < prev_coop_rate:
            return COOPERATE
        else:
            return DEFECT
    else:
        # Complete defection by others
        return DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Self-reinforcing**: If all players use this strategy, round 1 cooperation leads to sustained cooperation throughout, achieving the optimal collective outcome.

2. **Exploitation-resistant**: The threshold mechanism prevents indefinite cooperation when facing defectors.

3. **Forgiving**: The probabilistic cooperation and periodic probes allow recovery from accidental coordination failures.

4. **Scale-adaptive**: Thresholds work proportionally regardless of player count n.

5. **Clear signals**: The strategy produces interpretable behavior that cooperators can recognize and coordinate with.
'''

description_COLLECTIVE_36 = '''
# Collective Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy operates from a collective mindset: we assume all players using this strategy want to maximize group welfare while protecting against exploitation. The key insight is that cooperation is worthwhile when enough others cooperate to make the public good valuable, but we must be willing to withdraw cooperation when facing persistent defection.

## Strategy Overview

The strategy uses three main mechanisms:
1. **Optimistic Start**: Begin cooperatively to establish trust
2. **Threshold-Based Response**: Cooperate when cooperation levels are sustainable
3. **Gradual Forgiveness**: Allow recovery from mutual defection spirals

---

## Decision Rules

### Round 1: Cooperate Unconditionally
- **Action: C**
- Rationale: Signal cooperative intent and give the group a chance to establish mutual cooperation

### Rounds 2 through (r-1): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
prev_coop_rate = (number of C plays in round t-1) / n
```

Calculate the **critical threshold** - the minimum cooperation rate needed for cooperation to be individually rational in expectation:
```
base_threshold = 1/k
```

Apply **adaptive adjustment** based on recent history:
```
If in rounds max(1, t-3) through (t-1), average cooperation rate > 0.5:
    adjusted_threshold = base_threshold * 0.8  # More forgiving when group is cooperative
Else:
    adjusted_threshold = base_threshold * 1.1  # Stricter when group is uncooperative
```

**Decision Rule:**
```
If prev_coop_rate >= adjusted_threshold:
    Action: C
Else:
    Action: D
```

### Last Round (Round r): Conditional Cooperation

Unlike standard game theory prediction (defect in final round), maintain collective approach:
```
If cooperation_rate in round (r-1) >= 0.5:
    Action: C  # Reward sustained cooperation
Else:
    Action: D  # Don't be exploited at the end
```

---

## Complete Pseudocode

```
function decide(n, k, r, current_round, history):
    
    # Round 1: Always cooperate
    if current_round == 1:
        return C
    
    # Calculate previous round cooperation rate
    prev_round_actions = history[current_round - 1]
    prev_coop_count = count(prev_round_actions where action == C)
    prev_coop_rate = prev_coop_count / n
    
    # Last round: simple majority rule
    if current_round == r:
        if prev_coop_rate >= 0.5:
            return C
        else:
            return D
    
    # Middle rounds: threshold-based decision
    base_threshold = 1 / k
    
    # Calculate recent trend (last 3 rounds or available history)
    lookback = min(3, current_round - 1)
    recent_coop_sum = 0
    for t in range(current_round - lookback, current_round):
        round_actions = history[t]
        recent_coop_sum += count(round_actions where action == C)
    recent_avg_rate = recent_coop_sum / (lookback * n)
    
    # Adjust threshold based on trend
    if recent_avg_rate > 0.5:
        adjusted_threshold = base_threshold * 0.8
    else:
        adjusted_threshold = base_threshold * 1.1
    
    # Cap threshold at reasonable bounds
    adjusted_threshold = max(0.1, min(0.9, adjusted_threshold))
    
    # Make decision
    if prev_coop_rate >= adjusted_threshold:
        return C
    else:
        return D
```

---

## Key Properties

1. **Collectively Aligned**: Starts cooperative and maintains cooperation when viable
2. **Robust to Exploitation**: Withdraws cooperation when facing majority defection
3. **Parameter-Adaptive**: Threshold scales with k (higher k = lower threshold = more cooperation)
4. **Forgiving**: Recent positive trends lower the threshold, allowing recovery
5. **No Coordination Required**: Each player independently applies the same logic based on observable history

## Edge Cases Handled

- **n=2**: Reduces to tit-for-tat-like behavior
- **k close to 1**: High threshold makes cooperation rare (appropriate given low returns)
- **k close to n**: Low threshold encourages cooperation (appropriate given high returns)
- **All defect equilibrium**: Will defect in response but remains ready to cooperate if others start
- **Mixed strategies by opponents**: Responds to aggregate behavior, not individual tracking
'''

description_COLLECTIVE_38 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I aim to maximize group welfare while protecting against exploitation. The key insight is that mutual cooperation yields the best collective outcome (everyone gets k > 1), but unilateral cooperation is costly. I will be **optimistically cooperative but defensively responsive**.

## Strategy Overview: "Graduated Collective Reciprocity"

This strategy combines:
1. **Initial goodwill** to establish cooperative potential
2. **Threshold-based continuation** that rewards group cooperation trends
3. **Forgiveness mechanisms** to recover from temporary defection
4. **End-game adjustment** to handle finite-horizon effects

---

## Decision Rules

### Round 1: Cooperate
**Rationale**: Signal cooperative intent. Without history, assume good faith from the collective. This gives the group the best chance to establish mutual cooperation.

### Rounds 2 through (r-1): Conditional Cooperation

**Calculate the cooperation rate** from the previous round:
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Calculate the trend** (if round ≥ 3):
```
trend = prev_coop_rate - coop_rate_two_rounds_ago
```

**Decision Rule:**

```
cooperation_threshold = max(0.3, (n - k) / n)

IF prev_coop_rate >= cooperation_threshold:
    COOPERATE
ELSE IF prev_coop_rate >= cooperation_threshold - 0.15 AND trend > 0:
    COOPERATE  (forgiveness: cooperation is recovering)
ELSE IF rounds_since_majority_cooperation <= 2:
    COOPERATE  (patience: give collective time to recover)
ELSE:
    DEFECT
```

**Threshold Explanation**: 
- The base threshold `(n-k)/n` represents the break-even point where cooperation becomes collectively rational
- Minimum of 0.3 ensures we don't require impossibly high cooperation in large groups
- The 0.15 forgiveness buffer and trend consideration allow recovery from temporary coordination failures

### Last Round: Conditional Defection with Collective Consideration

```
IF cooperation_rate in round (r-1) >= 0.8:
    COOPERATE  (honor strong collective commitment)
ELSE:
    DEFECT  (standard game-theoretic end-game logic)
```

**Rationale**: In a one-shot final round, defection is dominant. However, if the group has demonstrated strong sustained cooperation, maintaining cooperation honors that collective achievement and maximizes final-round group welfare.

---

## Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| n = 2 | Use standard Tit-for-Tat | Two-player game has cleaner reciprocity dynamics |
| r = 2 | Cooperate Round 1, apply last-round rule for Round 2 | Minimal history; prioritize signaling |
| All others defected last round | Defect (but track if this is first occurrence) | Protect against systematic exploitation |
| Exactly one defector | Cooperate | Don't punish collective for one bad actor |
| k very close to n | Lower threshold to 0.25 | Higher returns justify more risk tolerance |
| k very close to 1 | Raise threshold by 0.1 | Lower returns require more collective buy-in |

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[round - 1])
    prev_coop_rate = prev_cooperators / n
    
    # Adaptive threshold based on game parameters
    base_threshold = max(0.3, (n - k) / n)
    if k > 0.8 * n:
        base_threshold -= 0.05  # more forgiving when k is high
    
    # Last round logic
    if round == r:
        if prev_coop_rate >= 0.8:
            return COOPERATE
        else:
            return DEFECT
    
    # Calculate trend (if enough history)
    trend = 0
    if round >= 3:
        two_rounds_ago_rate = count_cooperators(history[round - 2]) / n
        trend = prev_coop_rate - two_rounds_ago_rate
    
    # Main decision logic
    if prev_coop_rate >= base_threshold:
        return COOPERATE
    elif prev_coop_rate >= base_threshold - 0.15 and trend > 0:
        return COOPERATE  # forgiveness
    elif rounds_since_rate_above(history, base_threshold) <= 2:
        return COOPERATE  # patience
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Starts cooperative**: Gives the group the best chance to coordinate
2. **Forgives temporary failures**: Real coordination takes time; patience helps
3. **Doesn't exploit**: Never defects purely for personal gain when others cooperate
4. **Protects the collective**: Defection responses discourage free-riding, which harms group welfare
5. **Rewards sustained cooperation**: The last-round exception honors groups that achieve high cooperation
'''

description_COLLECTIVE_37 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we assume all instances of this strategy will behave identically given the same information. This creates implicit coordination without communication. The strategy is designed to maximize collective welfare while protecting against exploitation by defectors.

## Strategy Overview: "Adaptive Collective Threshold"

The strategy uses a **threshold-based cooperation rule** that adapts based on observed cooperation levels in the population, combined with **end-game protection** and **forgiveness mechanisms**.

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: With no history, we signal cooperative intent. If multiple copies of this strategy exist, we immediately establish a cooperative equilibrium. The cost of one round of potential exploitation is worth the benefit of discovering other cooperators.

### Rounds 2 through (r-1): Adaptive Threshold Cooperation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays in round t-1) / n
```

Calculate the **trend** (if round ≥ 3):
```
trend = coop_rate(t-1) - coop_rate(t-2)
```

**Decision Rule:**

```
IF coop_rate >= threshold THEN COOPERATE
ELSE DEFECT

where threshold = max(0.4, (n - k) / n)
```

The threshold `(n - k) / n` represents the minimum cooperation level where cooperators don't lose money compared to universal defection. We floor it at 0.4 to maintain some tolerance.

**Trend Adjustment:**
- If `trend > 0` (cooperation increasing), lower effective threshold by 0.1
- If `trend < -0.2` (cooperation collapsing), raise effective threshold by 0.1

This makes us more forgiving when cooperation is building and more protective when it's collapsing.

### Final Round (Round r): Conditional Cooperation

The last round has no future consequences, creating strong defection incentives. However, as collective strategists:

```
IF coop_rate(r-1) >= 0.7 THEN COOPERATE
ELSE DEFECT
```

Rationale: If we've maintained strong cooperation throughout, we honor that collective success. If cooperation has broken down, we protect ourselves.

---

## Forgiveness Mechanism

To avoid permanent punishment spirals after temporary defection:

```
forgiveness_counter = 0

IF we defected last round AND coop_rate increased:
    forgiveness_counter += 1
    
IF forgiveness_counter >= 2:
    COOPERATE (regardless of threshold)
    Reset forgiveness_counter
```

This allows recovery from mutual defection if others show willingness to cooperate.

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation rate from last round
    coop_rate = count_cooperators(history[round-1]) / n
    
    # Calculate trend if possible
    if round >= 3:
        prev_coop_rate = count_cooperators(history[round-2]) / n
        trend = coop_rate - prev_coop_rate
    else:
        trend = 0
    
    # Base threshold
    threshold = max(0.4, (n - k) / n)
    
    # Trend adjustment
    if trend > 0:
        threshold = threshold - 0.1
    elif trend < -0.2:
        threshold = threshold + 0.1
    
    # Clamp threshold
    threshold = clamp(threshold, 0.3, 0.8)
    
    # Final round special handling
    if round == r:
        if coop_rate >= 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # Forgiveness check
    if should_forgive(history):
        return COOPERATE
    
    # Main decision
    if coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Standard rules apply | Threshold becomes max(0.4, (2-k)/2) |
| k very close to n | Lower threshold (more cooperative) | Higher returns to cooperation |
| k close to 1 | Higher threshold (more cautious) | Lower returns require more participants |
| All defected last round | DEFECT | Below any reasonable threshold |
| Only we cooperated | DEFECT | Clear exploitation, protect ourselves |
| Oscillating history | Follow threshold rule | Trend adjustment handles this |

---

## Why This Strategy Works Collectively

1. **Identical behavior**: All copies make the same decision given the same history, enabling implicit coordination
2. **Cooperative by default**: Starts cooperative and maintains cooperation when viable
3. **Self-protecting**: Withdraws cooperation when exploited
4. **Recoverable**: Forgiveness mechanism prevents permanent breakdown
5. **Adaptive**: Threshold adjusts to game parameters (k, n) automatically
6. **End-game aware**: Maintains some cooperation incentive even in final round
'''

description_COLLECTIVE_39 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I recognize that if all players reason similarly and cooperate, everyone achieves the best collective outcome (payoff of k per round vs. 1 from mutual defection). The strategy aims to **sustain cooperation when possible** while **protecting against exploitation** and **signaling cooperative intent**.

## Strategy Overview: "Generous Threshold Trigger with Cooperative Anchoring"

The strategy operates on three principles:
1. **Start cooperatively** to establish trust and signal collective intent
2. **Maintain cooperation** as long as sufficient others reciprocate
3. **Forgive occasionally** to escape defection spirals and test for renewed cooperation

---

## Decision Rules

### Round 1: Always Cooperate
- **Rationale**: Signals cooperative intent, gives the collective a chance to establish mutual cooperation, and provides baseline information about others' behavior.

### Rounds 2 through (r-1): Threshold-Based Cooperation with Forgiveness

**Calculate cooperation rate from previous round:**
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Primary Rule - Cooperate if:**
- `prev_coop_rate >= threshold(n)` where threshold is defined below

**Threshold Function:**
```
threshold(n) = max(0.5, (n-1)/(2n))
```
- For n=2: threshold = 0.5 (need 1 of 2 cooperating)
- For n=6: threshold = 0.5 (need 3 of 6 cooperating)  
- For large n: threshold approaches 0.5

**Forgiveness Mechanism - Also Cooperate if:**
- The last 2 consecutive rounds had `prev_coop_rate < threshold` AND
- Current round number is divisible by `forgiveness_interval` where:
  - `forgiveness_interval = max(3, floor(r/5))`
- **Rationale**: Periodically test if opponents are willing to restart cooperation; prevents permanent lock-in to mutual defection.

**Trend-Based Adjustment:**
- If cooperation rate has been **increasing** for 2+ consecutive rounds, cooperate even if slightly below threshold (within 1/n of threshold)
- **Rationale**: Reward and encourage positive momentum in collective behavior

### Final Round (Round r): Conditional Cooperation

**Cooperate if:**
- The cooperation rate in round (r-1) was >= 0.7 (high cooperation norm established)

**Defect if:**
- The cooperation rate in round (r-1) was < 0.7

**Rationale**: In the final round, there's no future to incentivize cooperation. However, if a strong cooperative norm exists, maintaining it signals commitment to collective values (important in tournament contexts where reputation/patterns may matter across matches). With lower cooperation, protecting against exploitation is reasonable.

---

## Pseudocode

```
function decide(round, history, n, r, k):
    
    # Round 1: Unconditional cooperation
    if round == 1:
        return COOPERATE
    
    # Calculate previous round statistics
    prev_cooperators = count_cooperators(history[round-1])
    prev_coop_rate = prev_cooperators / n
    
    # Calculate threshold
    threshold = max(0.5, (n-1) / (2*n))
    
    # Final round logic
    if round == r:
        if prev_coop_rate >= 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds (2 to r-1)
    
    # Primary rule: cooperate if above threshold
    if prev_coop_rate >= threshold:
        return COOPERATE
    
    # Trend adjustment: cooperate if improving and close to threshold
    if round >= 3:
        rate_t1 = count_cooperators(history[round-1]) / n
        rate_t2 = count_cooperators(history[round-2]) / n
        if rate_t1 > rate_t2 and prev_coop_rate >= (threshold - 1/n):
            return COOPERATE
    
    # Forgiveness: periodic cooperation attempt after defection spirals
    forgiveness_interval = max(3, floor(r / 5))
    if round % forgiveness_interval == 0:
        # Check if we've been in low cooperation for 2+ rounds
        if round >= 3:
            two_rounds_low = (count_cooperators(history[round-1]) / n < threshold and
                             count_cooperators(history[round-2]) / n < threshold)
            if two_rounds_low:
                return COOPERATE
    
    # Default: defect when cooperation has collapsed
    return DEFECT
```

---

## Edge Cases Handled

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Cooperate | Establish cooperative baseline |
| Everyone defected last round | Defect (unless forgiveness round) | Protect against persistent free-riders |
| Only I cooperated last round | Defect (unless forgiveness) | Don't be exploited repeatedly |
| Exactly at threshold | Cooperate | Give benefit of doubt |
| Final round, high prior cooperation | Cooperate | Honor established norms |
| Final round, low prior cooperation | Defect | No future to build; protect self |
| r=2 (minimum rounds) | Round 1: C, Round 2: based on 70% rule | Compressed but principled |
| n=2 (minimum players) | Threshold=0.5, so need partner to cooperate | Essentially Tit-for-Tat with forgiveness |

---

## Why This Strategy is Collectively Robust

1. **Coordination-friendly**: If other AI systems reason similarly about collective benefit, they'll likely also start with cooperation and maintain it—achieving the Pareto-optimal outcome.

2. **Exploitation-resistant**: The threshold mechanism prevents being drained by persistent defectors.

3. **Recovery-capable**: Forgiveness allows escape from defection traps that might arise from noise or initial miscoordination.

4. **Parameter-adaptive**: Threshold and forgiveness intervals scale with game parameters (n, r).

5. **Clear signaling**: Consistent behavior patterns make it easier for other adaptive strategies to recognize and reciprocate cooperation.
'''

description_COLLECTIVE_38 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **we succeed together or struggle apart**. The fundamental insight is that in a public goods game, mutual cooperation creates more total value than mutual defection (since k > 1), but the temptation to free-ride destroys this potential. My strategy aims to be a reliable cooperator that encourages cooperation while protecting against exploitation.

## Strategy Overview: "Generous Threshold Reciprocator"

The strategy operates on three principles:
1. **Start cooperatively** to signal good faith and establish potential for mutual gain
2. **Reciprocate based on group cooperation levels** rather than tracking individuals
3. **Forgive occasionally** to escape defection spirals and test for changed behavior

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, I signal my willingness to contribute to collective welfare. This gives the group the best chance to establish a cooperative norm.

### Rounds 2 through (r-1): Threshold-Based Reciprocation with Forgiveness

Let `coop_rate` = (number of cooperators in previous round) / n

**Primary Rule:**
```
IF coop_rate >= cooperation_threshold THEN COOPERATE
ELSE probabilistically decide based on forgiveness mechanism
```

**Cooperation Threshold Calculation:**
```
cooperation_threshold = 0.5 - adjustment

where adjustment = 0.1 × (k - 1) / (n - 1)
```

This threshold is slightly below majority (around 0.4-0.5), making me a "generous" reciprocator who cooperates even when cooperation is imperfect. The adjustment makes me more forgiving when k is higher relative to n (since cooperation is more valuable).

**Forgiveness Mechanism (when below threshold):**
```
forgiveness_probability = base_forgiveness × trend_modifier × round_modifier

base_forgiveness = 0.15

trend_modifier:
  - 1.5 if cooperation increased from round t-2 to t-1
  - 1.0 if cooperation stayed same
  - 0.7 if cooperation decreased

round_modifier = 1.0 + 0.3 × (remaining_rounds / total_rounds)
  (more forgiving early, slightly less forgiving as game progresses)

IF random() < forgiveness_probability THEN COOPERATE
ELSE DEFECT
```

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory advice to defect in the final round, I maintain conditional cooperation:

```
IF average_cooperation_rate_last_3_rounds >= 0.6 THEN COOPERATE
ELSE DEFECT
```

Rationale: If playing against other collectively-minded strategies, maintaining cooperation even in the final round maximizes total group payoff. I only defect if recent history suggests the group has already abandoned cooperation.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Round 1: Cooperate unconditionally
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation threshold
    adjustment = 0.1 * (k - 1) / (n - 1)
    threshold = 0.5 - adjustment
    
    # Get previous round cooperation rate
    prev_cooperators = count_cooperators(history[round - 1])
    coop_rate = prev_cooperators / n
    
    # Final round logic
    if round == r:
        recent_avg = average_cooperation(history[max(1, round-3) : round])
        if recent_avg >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Main decision logic for rounds 2 to r-1
    if coop_rate >= threshold:
        return COOPERATE
    else:
        # Forgiveness mechanism
        base_forgiveness = 0.15
        
        # Trend modifier
        if round >= 3:
            prev_prev_coop = count_cooperators(history[round - 2]) / n
            if coop_rate > prev_prev_coop:
                trend_mod = 1.5
            elif coop_rate == prev_prev_coop:
                trend_mod = 1.0
            else:
                trend_mod = 0.7
        else:
            trend_mod = 1.0
        
        # Round modifier (more forgiving early)
        remaining = r - round
        round_mod = 1.0 + 0.3 * (remaining / r)
        
        forgiveness_prob = base_forgiveness * trend_mod * round_mod
        
        if random() < forgiveness_prob:
            return COOPERATE
        else:
            return DEFECT
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | COOPERATE | Establish cooperative intent |
| Round 2 after all defected | DEFECT (85% prob) | Protect against full defection, but give second chance |
| Round 2 after all cooperated | COOPERATE | Reinforce successful cooperation |
| Final round, high recent cooperation | COOPERATE | Collective mindset to the end |
| Final round, low recent cooperation | DEFECT | No future to protect |
| n=2 (minimum players) | Threshold ≈ 0.4, so cooperate if 1+ cooperated | Functions like generous Tit-for-Tat |
| Large n | Threshold still ~0.4-0.5 | Robust across group sizes |

---

## Why This Strategy Embodies Collective Thinking

1. **Optimistic Start**: By cooperating first, I give collective success the best chance to emerge.

2. **Responsive to Group Behavior**: I don't track individuals—I respond to the collective cooperation level, reinforcing group norms.

3. **Forgiving Nature**: Random forgiveness prevents permanent breakdown and allows recovery from misunderstandings or noise.

4. **Consistent Final Round**: Maintaining cooperation in the last round (when merited) signals that I'm not just cooperating strategically for future benefit—I genuinely value collective outcomes.

5. **Adaptive Threshold**: The threshold adjusts to game parameters, being more forgiving when cooperation is more valuable.

This strategy should perform well against cooperative strategies (achieving mutual cooperation) while limiting losses against defectors (through threshold-based retaliation) and offering pathways back to cooperation with mixed strategies.
'''

description_COLLECTIVE_40 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I recognize that if all players reason similarly and cooperate, we all achieve the best collective outcome (payoff of k per round vs. 1 for mutual defection). However, I must be robust against defectors while maintaining opportunities for cooperation to emerge.

The strategy combines **hopeful initiation**, **proportional reciprocity**, and **strategic end-game adjustment**.

---

## Strategy: Adaptive Proportional Reciprocity (APR)

### Decision Rules

#### Round 1: Cooperate
- Begin with cooperation to signal willingness to collaborate and give the collective a chance to form.
- Rationale: We cannot coordinate explicitly, but starting cooperatively is the only way cooperation can emerge.

#### Rounds 2 through (r-1): Proportional Probabilistic Cooperation

**Calculate the cooperation rate from the previous round:**
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Decision rule:**
- If `prev_coop_rate >= (n-1)/n` (nearly everyone cooperated): **Cooperate deterministically**
- If `prev_coop_rate >= 0.5`: **Cooperate with probability = prev_coop_rate**
- If `prev_coop_rate < 0.5` but `prev_coop_rate > 0`: **Cooperate with probability = prev_coop_rate / 2**
- If `prev_coop_rate = 0` (everyone defected): **Cooperate with probability = 1/r** (small olive branch)

**Adjustment for trend detection:**
```
If cooperation rate has increased for 2+ consecutive rounds:
    Boost cooperation probability by 0.1 (capped at 1.0)
If cooperation rate has decreased for 2+ consecutive rounds:
    Reduce cooperation probability by 0.1 (floored at 0.05)
```

#### Final Round (Round r): Conditional Cooperation

The last round has no future shadow, creating defection incentives. However, maintaining collective mindset:

```
If average cooperation rate over all previous rounds >= 0.6:
    Cooperate (reward sustained collective behavior)
Else if previous round cooperation rate >= 0.8:
    Cooperate with probability 0.5
Else:
    Defect
```

Rationale: If the group has demonstrated sustained cooperation, I maintain cooperation even in the final round as a collective commitment. This also makes the strategy less exploitable by "final round defectors" since they cannot predict whether I'll defect.

---

## Pseudocode

```
function decide(round, history, n, r, k):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_count = count_cooperators(history[round - 1])
    prev_coop_rate = prev_coop_count / n
    
    # Calculate historical average
    total_coop = sum(count_cooperators(history[t]) for t in 1 to round-1)
    avg_coop_rate = total_coop / (n * (round - 1))
    
    # Detect trend (if enough history)
    trend = 0
    if round >= 3:
        recent_rates = [count_cooperators(history[t])/n for t in (round-2) to (round-1)]
        if recent_rates are strictly increasing for 2+ rounds:
            trend = +1
        elif recent_rates are strictly decreasing for 2+ rounds:
            trend = -1
    
    # Final round logic
    if round == r:
        if avg_coop_rate >= 0.6:
            return COOPERATE
        elif prev_coop_rate >= 0.8:
            return COOPERATE with probability 0.5
        else:
            return DEFECT
    
    # Middle rounds: proportional reciprocity
    if prev_coop_rate >= (n-1)/n:
        base_prob = 1.0
    elif prev_coop_rate >= 0.5:
        base_prob = prev_coop_rate
    elif prev_coop_rate > 0:
        base_prob = prev_coop_rate / 2
    else:
        base_prob = 1 / r
    
    # Apply trend adjustment
    coop_prob = base_prob + (trend * 0.1)
    coop_prob = max(0.05, min(1.0, coop_prob))
    
    return COOPERATE with probability coop_prob
```

---

## Why This Strategy is Collectively Aligned

1. **Initiates cooperation**: Gives the collective a chance to form
2. **Rewards cooperation proportionally**: Matches group behavior, encouraging coordination
3. **Forgives gradually**: Never completely abandons cooperation, allowing recovery
4. **Punishes defection proportionally**: Reduces exploitation incentives
5. **Maintains end-game integrity**: Rewards sustained collective behavior even when incentives disappear
6. **Robust to noise**: Probabilistic responses prevent lock-in to bad equilibria
'''

description_COLLECTIVE_39 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that mutual cooperation yields the best collective outcome (payoff of k > 1 for everyone vs. 1 for universal defection). My goal is to foster and sustain cooperation while protecting against exploitation. I will be **generous in initiating cooperation**, **patient in building trust**, and **forgiving but not naive** when facing defection.

## Strategy Overview: "Generous Collective Trigger with Graduated Response"

The strategy operates on the principle that cooperation is worth pursuing when there's reasonable collective participation, but responds proportionally to the level of defection observed.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Someone must initiate cooperation. By cooperating first, I signal willingness to collaborate and give the collective a chance to form. The potential gain from establishing cooperation far outweighs the single-round cost of being exploited.

### Rounds 2 through (r-1): Adaptive Cooperation Threshold

**Calculate the cooperation rate from the previous round:**
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision rule:**
```
IF coop_rate >= cooperation_threshold THEN COOPERATE
ELSE apply graduated response
```

**Cooperation threshold calculation:**
```
base_threshold = 0.4  (require at least 40% cooperation)
round_factor = min(0.1, 0.1 * (current_round / r))  
cooperation_threshold = base_threshold + round_factor
```

The threshold starts at 40% and gradually increases toward 50% as the game progresses, demanding slightly more collective buy-in over time.

### Graduated Response (when below threshold):

Rather than immediately defecting, use a **probabilistic response** that gives the collective a chance to recover:

```
IF coop_rate >= 0.3 THEN cooperate with probability 0.6
ELSE IF coop_rate >= 0.2 THEN cooperate with probability 0.3
ELSE IF coop_rate >= 0.1 THEN cooperate with probability 0.1
ELSE DEFECT (deterministic)
```

### Forgiveness Mechanism:

Track a **trend indicator** over the last 3 rounds (or fewer if early in game):
```
IF cooperation is trending upward (current > average of previous 2)
   THEN add 0.15 to cooperation probability
```

This rewards collective movement toward cooperation even when current levels are low.

### Final Round (round r): Conditional Cooperation

**Do NOT automatically defect.** Instead:

```
IF average_cooperation_rate_over_game >= 0.5 THEN COOPERATE
ELSE DEFECT
```

Rationale: If the collective has maintained cooperation, honor that relationship even in the final round. This distinguishes collective-minded players from pure game-theoretic exploiters and rewards sustained cooperation.

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| n = 2 (minimum players) | Use stricter threshold (0.5); essentially Tit-for-Tat with forgiveness |
| Very short game (r ≤ 3) | Cooperate rounds 1-2, apply final round rule on round 3 |
| Everyone cooperated last round | Definitely cooperate |
| Only I cooperated last round | Apply graduated response (coop_rate ≈ 1/n), likely defect but with small cooperation probability |
| No one cooperated (including me) | Cooperate with probability 0.2 as a "peace offering" to restart |
| k very close to n (high efficiency) | No adjustment—same rules apply |
| k very close to 1 (low efficiency) | No adjustment—same rules apply; collective benefit still exists |

---

## Pseudocode Summary

```
function decide(round, history, n, r, k):
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[round-1])
    coop_rate = prev_cooperators / n
    
    # Calculate threshold
    base_threshold = 0.4
    round_factor = min(0.1, 0.1 * (round / r))
    threshold = base_threshold + round_factor
    
    # Calculate cooperation probability
    if coop_rate >= threshold:
        coop_prob = 1.0
    else if coop_rate >= 0.3:
        coop_prob = 0.6
    else if coop_rate >= 0.2:
        coop_prob = 0.3
    else if coop_rate >= 0.1:
        coop_prob = 0.1
    else:
        coop_prob = 0.0
    
    # Forgiveness bonus for upward trend
    if round >= 3:
        recent_avg = average_coop_rate(history[round-3:round-1])
        if coop_rate > recent_avg:
            coop_prob = min(1.0, coop_prob + 0.15)
    
    # Final round logic
    if round == r:
        game_avg = average_coop_rate(history)
        if game_avg >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Execute probabilistic decision
    return COOPERATE if random() < coop_prob else DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Initiates cooperation**: Never waits for others; leads by example
2. **Sustains cooperation**: Continues cooperating when collective participation is adequate
3. **Forgives mistakes**: Probabilistic responses and trend-based forgiveness allow recovery from coordination failures
4. **Resists exploitation**: Graduated withdrawal protects against systematic defectors
5. **Honors relationships**: Final-round cooperation rewards trustworthy collectives
6. **Scales with group size**: Percentage-based thresholds work for any n ≥ 2
'''

description_COLLECTIVE_41 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: we assume all players using this strategy share the same decision rules and will reach identical conclusions given the same observable history. This creates implicit coordination without explicit communication. The strategy aims to maximize collective welfare when playing with like-minded agents while protecting against exploitation by defectors.

---

## Strategy Overview: **Adaptive Threshold Cooperation (ATC)**

The strategy cooperates when the observed cooperation rate in the population suggests that cooperation is socially sustainable, and defects when exploitation becomes prevalent. It uses graduated responses to maintain cooperation norms while being forgiving enough to recover from temporary breakdowns.

---

## Decision Rules

### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- **Rationale:** With no history, we signal cooperative intent. If all collective-minded players cooperate, we establish a baseline. This is the only way to discover if others share our norms.

### Rounds 2 through (r-1): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

Calculate the **cooperation threshold** that adapts based on game parameters:
```
base_threshold = 0.5
efficiency_bonus = (k - 1) / (n - 1)  // Higher k relative to n makes cooperation more valuable
threshold = base_threshold - (efficiency_bonus * 0.2)
threshold = max(0.3, min(0.7, threshold))  // Bound between 0.3 and 0.7
```

**Decision Logic:**
```
IF coop_rate >= threshold THEN
    COOPERATE
ELSE IF coop_rate >= threshold - 0.15 THEN
    // Gray zone: use forgiveness mechanism
    IF previous_round_was_first_below_threshold THEN
        COOPERATE  // One-round forgiveness
    ELSE
        DEFECT
ELSE
    DEFECT
```

### Last Round (Round r): Conditional Cooperation

Unlike classic game theory which prescribes universal defection, we maintain collective values:

```
IF average_cooperation_rate_over_all_rounds >= threshold THEN
    COOPERATE  // Reward sustained cooperation
ELSE
    DEFECT  // No reason to cooperate with chronic defectors
```

**Rationale:** If playing with other collective-minded agents, mutual last-round cooperation yields higher collective payoff. We only defect if the game has already broken down.

---

## Detailed Pseudocode

```
function decide_action(round, history, n, k, r):
    
    // Calculate adaptive threshold
    base_threshold = 0.5
    efficiency_bonus = (k - 1) / (n - 1)
    threshold = base_threshold - (efficiency_bonus * 0.2)
    threshold = clamp(threshold, 0.3, 0.7)
    forgiveness_threshold = threshold - 0.15
    
    // Round 1: Always cooperate
    IF round == 1:
        RETURN COOPERATE
    
    // Calculate previous round cooperation rate
    prev_coop_count = count_cooperators(history[round - 1])
    prev_coop_rate = prev_coop_count / n
    
    // Last round logic
    IF round == r:
        total_coop_rate = sum(count_cooperators(h) for h in history) / (n * (r - 1))
        IF total_coop_rate >= threshold:
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT
    
    // Middle rounds: Adaptive threshold with forgiveness
    IF prev_coop_rate >= threshold:
        RETURN COOPERATE
    
    ELSE IF prev_coop_rate >= forgiveness_threshold:
        // Check if this is first dip below threshold
        IF round == 2:
            RETURN COOPERATE  // Forgive once
        prev_prev_coop_rate = count_cooperators(history[round - 2]) / n
        IF prev_prev_coop_rate >= threshold:
            RETURN COOPERATE  // First offense, forgive
        ELSE:
            RETURN DEFECT  // Repeated low cooperation
    
    ELSE:
        RETURN DEFECT  // Cooperation rate too low
```

---

## Edge Case Handling

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| **Round 1** | Cooperate | Establish cooperative baseline |
| **Round 2, all defected R1** | Defect | Only we cooperated; protect against full exploitation |
| **Round 2, mixed R1** | Depends on threshold | Use standard logic with forgiveness |
| **Last round, high avg coop** | Cooperate | Collective benefit with trustworthy group |
| **Last round, low avg coop** | Defect | No value in unilateral cooperation |
| **n=2 (minimum)** | Standard logic | Threshold ~0.3-0.4; more forgiving |
| **Large n** | Standard logic | Threshold closer to 0.5; requires broader consensus |

---

## Why This Strategy is Collectively Optimal

1. **Self-coordinating:** All agents using ATC reach the same decision given identical observations, enabling implicit coordination.

2. **Robust to defectors:** The threshold mechanism ensures we don't continue cooperating when exploited by a majority of defectors.

3. **Forgiving:** The gray zone allows recovery from temporary breakdowns (noise, mistakes, or minority defection).

4. **Parameter-adaptive:** The threshold adjusts to game efficiency (k/n ratio), cooperating more readily when the public good multiplier makes it more beneficial.

5. **Last-round cooperation:** Unlike purely self-interested strategies, we maintain cooperation through the final round with trustworthy groups, capturing the collective surplus.
'''

description_COLLECTIVE_40 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **we succeed together or fail together**. Rather than treating other players as opponents to exploit, I approach this as a coordination problem where my goal is to help establish and maintain cooperation that benefits everyone. I'll be generous, forgiving, and patient—while still protecting the collective from persistent free-riders.

## Strategy Overview: "Generous Threshold with Collective Memory"

The strategy operates on three principles:
1. **Start cooperatively** to signal good faith and establish cooperative norms
2. **Respond to the collective state** rather than individual players
3. **Forgive generously** but **withdraw gradually** when cooperation collapses

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: Cooperate (C)**

Rationale: Someone must take the first step. By cooperating initially, I demonstrate commitment to collective welfare and give others the opportunity to reciprocate. The cost of one round of potential exploitation is small compared to the value of establishing trust.

### Rounds 2 through (r-1): Adaptive Threshold Response

**Calculate the cooperation rate from the previous round:**
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Calculate a weighted historical cooperation rate:**
```
historical_coop_rate = weighted average of all previous rounds
  (more recent rounds weighted higher: weight for round t = t)
```

**Decision Rule:**

```
threshold = k / n  # This is the "fair share" threshold

IF historical_coop_rate >= threshold:
    # Cooperation is viable - the multiplied benefit justifies contributing
    Cooperate with probability = min(1, historical_coop_rate + generosity_bonus)
    where generosity_bonus = 0.15 * (rounds_remaining / r)
    
ELSE IF prev_coop_rate > historical_coop_rate:
    # Cooperation is recovering - support the trend
    Cooperate with probability = prev_coop_rate + 0.1
    
ELSE:
    # Cooperation has collapsed
    Cooperate with probability = max(0.1, prev_coop_rate)
    # Always maintain 10% cooperation as an "olive branch"
```

### Last Round: Conditional Cooperation (NOT Automatic Defection)

**This is crucial for collective thinking.** Standard game theory says "defect in the last round," but if everyone thinks this way, cooperation unravels backward. Instead:

```
IF historical_coop_rate >= 0.5:
    # We've built something good together - honor it
    Cooperate
ELSE:
    # Cooperation never took hold
    Defect
```

---

## Detailed Pseudocode

```python
def decide(round_number, total_rounds, n, k, history):
    """
    history: list of lists, where history[t] contains actions of all players in round t
             actions are 1 (cooperate) or 0 (defect)
    """
    
    threshold = k / n
    
    # ROUND 1: Unconditional cooperation
    if round_number == 1:
        return COOPERATE
    
    # Calculate cooperation rates
    def get_coop_rate(round_history):
        return sum(round_history) / n
    
    prev_coop_rate = get_coop_rate(history[-1])
    
    # Weighted historical average (recent rounds matter more)
    total_weight = 0
    weighted_sum = 0
    for t, round_history in enumerate(history):
        weight = t + 1  # Round 1 has weight 1, round 2 has weight 2, etc.
        weighted_sum += weight * get_coop_rate(round_history)
        total_weight += weight
    historical_coop_rate = weighted_sum / total_weight
    
    # LAST ROUND: Honor collective achievement
    if round_number == total_rounds:
        if historical_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # MIDDLE ROUNDS: Adaptive threshold response
    rounds_remaining = total_rounds - round_number
    generosity_bonus = 0.15 * (rounds_remaining / total_rounds)
    
    if historical_coop_rate >= threshold:
        # Cooperation is viable
        coop_probability = min(1.0, historical_coop_rate + generosity_bonus)
    elif prev_coop_rate > historical_coop_rate:
        # Cooperation is recovering
        coop_probability = min(1.0, prev_coop_rate + 0.1)
    else:
        # Cooperation has collapsed - maintain olive branch
        coop_probability = max(0.1, prev_coop_rate)
    
    # Deterministic conversion for reproducibility
    # (or use random if stochastic play is preferred)
    if coop_probability >= 0.5:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Situation | Response | Rationale |
|-----------|----------|-----------|
| **Round 1** | Always Cooperate | Establish trust; someone must go first |
| **Last Round** | Cooperate if history ≥ 50% cooperation | Honor collective achievement; don't betray partners |
| **All others defected last round** | Cooperate with 10% probability | Keep door open for recovery |
| **Everyone cooperated** | Cooperate | Reinforce successful coordination |
| **n = 2 (minimum)** | Strategy still works; threshold = k/2 | Reduces to generalized Tit-for-Tat variant |
| **k very close to n** | Lower threshold makes cooperation easier | Naturally adapts to more favorable conditions |
| **k very close to 1** | Higher threshold; cooperation harder to sustain | Appropriately cautious but still attempts |

---

## Why This Strategy is Collectively Optimal

1. **Generous initiation**: Creates opportunity for cooperation to emerge
2. **Threshold based on k/n**: Cooperates when it's collectively rational (multiplied returns exceed individual cost)
3. **Forgiveness**: The "olive branch" probability and recovery detection prevent permanent collapse
4. **No last-round betrayal**: Maintains trust and avoids backward-unraveling of cooperation
5. **Responds to collective state**: Treats the group as a unit rather than targeting individuals
6. **Adaptive to parameters**: Works across different values of n, k, and r without manual tuning

---

## Expected Behavior in Different Environments

- **Against other cooperators**: Establishes and maintains high cooperation, achieving near-optimal collective payoffs
- **Against mixed strategies**: Cooperates when enough others do, creating positive selection pressure for cooperation
- **Against all defectors**: Gradually reduces cooperation but never fully abandons hope (10% floor)
- **In diverse tournaments**: The generosity and forgiveness make it robust; it won't be the most exploited, and it rewards cooperative partners
'''

description_COLLECTIVE_42 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: if all players reason identically and act in the group's best interest, mutual cooperation yields the highest collective payoff. The strategy aims to **establish and maintain cooperation** while protecting against exploitation through measured, forgiving responses to defection.

## Strategy Overview: "Graduated Collective Reciprocity"

The strategy operates on three principles:
1. **Start cooperatively** to signal collective intent
2. **Mirror the group's cooperation level** to reward cooperation and discourage defection
3. **Forgive strategically** to recover from mutual defection spirals

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, cooperation signals collective intent. If all players using this strategy cooperate, we immediately achieve the optimal collective outcome.

---

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

**Decision Rule:**

```
IF coop_rate >= (n-1)/n THEN
    COOPERATE  (near-universal cooperation achieved)
    
ELSE IF coop_rate >= 0.5 THEN
    COOPERATE with probability = coop_rate
    DEFECT with probability = 1 - coop_rate
    
ELSE IF coop_rate > 0 THEN
    COOPERATE with probability = coop_rate^2
    DEFECT with probability = 1 - coop_rate^2
    
ELSE (coop_rate == 0)
    COOPERATE with probability = 1/r_remaining
    (where r_remaining = rounds left including current)
```

**Interpretation:**
- **High cooperation (≥ (n-1)/n)**: Reward the group by maintaining cooperation
- **Moderate cooperation (50-99%)**: Proportionally match—this creates pressure toward full cooperation
- **Low cooperation (1-49%)**: Respond more punitively (squared probability) to discourage exploitation
- **Zero cooperation**: Occasionally attempt to restart cooperation, with frequency decreasing as game progresses

---

### Final Round (Round r): Conditional Cooperation

The final round has no future consequences, creating strong defection incentives. However, maintaining collective reasoning:

```
IF cooperation_rate in round (r-1) >= 0.5 THEN
    COOPERATE
ELSE
    DEFECT
```

Rationale: If the group has maintained reasonable cooperation, honor that collective achievement. If cooperation has collapsed, there's no collective norm to uphold.

---

## Pseudocode Summary

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[round - 1])
    coop_rate = prev_cooperators / n
    
    if round == r:  # Final round
        if coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    if coop_rate >= (n - 1) / n:
        return COOPERATE
    
    elif coop_rate >= 0.5:
        return COOPERATE with probability coop_rate
    
    elif coop_rate > 0:
        return COOPERATE with probability coop_rate^2
    
    else:  # coop_rate == 0
        rounds_remaining = r - round + 1
        return COOPERATE with probability 1/rounds_remaining
```

---

## Key Properties

| Property | Implementation |
|----------|----------------|
| **Collective alignment** | Starts cooperative; rewards group cooperation |
| **Exploitation resistance** | Reduces cooperation proportionally to group defection |
| **Forgiveness** | Always maintains some cooperation probability; responds positively to increased cooperation |
| **Adaptiveness** | Adjusts to any cooperation level smoothly |
| **Robustness** | Works regardless of n, k, r parameters (within constraints) |
| **No coordination required** | Relies only on observable history, not pre-arranged patterns |

---

## Why This Works Collectively

If all players use this strategy:
- Round 1: Everyone cooperates → payoff = k for all
- Round 2+: coop_rate = 1.0 ≥ (n-1)/n → everyone cooperates
- Final round: coop_rate = 1.0 ≥ 0.5 → everyone cooperates

**Result: Full cooperation throughout, achieving the Pareto-optimal outcome.**

Against defectors, the strategy gradually withdraws cooperation, limiting exploitation while remaining ready to restore cooperation if the group recovers.
'''

description_COLLECTIVE_41 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players reason similarly and cooperate, we all achieve the best collective outcome (payoff of k per round vs. 1 for universal defection). The strategy aims to **establish and maintain cooperation** while being **robust against exploitation** and **forgiving of occasional defection**.

## Strategy Overview: "Graduated Collective Reciprocity"

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness for collective benefit
2. **Respond proportionally** to the group's cooperation level
3. **Protect against endgame collapse** while maintaining hope for cooperation

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: C (Cooperate)**

Rationale: Begin by demonstrating commitment to collective welfare. This allows cooperation to emerge if others share similar reasoning.

### Rounds 2 through (r-1): Adaptive Cooperation Threshold

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays in previous round) / n
```

**Decision Rule:**
```
IF coop_rate >= cooperation_threshold THEN
    Action = C
ELSE
    Action = D with probability (1 - coop_rate)
    Action = C with probability coop_rate
```

**Cooperation Threshold Calculation:**
```
base_threshold = 0.5
round_adjustment = 0.1 × (current_round / r)  # Gets slightly stricter over time
cooperation_threshold = base_threshold + round_adjustment
```

This means:
- Early rounds: Cooperate if ≥50% of players cooperated
- Middle rounds: Threshold rises gradually (e.g., 55-60%)
- Late rounds: Threshold around 60-65%

### Forgiveness Mechanism

To avoid getting stuck in mutual defection:
```
IF last 2 rounds had coop_rate < cooperation_threshold AND coop_rate > 0.2 THEN
    Cooperate with probability 0.3 (to test if cooperation can restart)
```

### Final Round: Conditional Cooperation

Unlike standard game theory advice to defect in the final round:

```
IF average coop_rate over all previous rounds >= 0.6 THEN
    Action = C (reward sustained collective cooperation)
ELSE IF coop_rate in round (r-1) >= 0.7 THEN
    Action = C (honor recent cooperation)
ELSE
    Action = D
```

Rationale: If playing against similar collective-minded strategies, maintaining cooperation in the final round achieves the Pareto-optimal outcome. Only defect if the group has demonstrated exploitative behavior.

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return C
    
    # Calculate previous round cooperation rate
    prev_coop_count = count_cooperators(history, round - 1)
    coop_rate = prev_coop_count / n
    
    # Calculate overall cooperation history
    total_coop_rate = total_cooperations(history) / (n × (round - 1))
    
    # Final round logic
    if round == r:
        if total_coop_rate >= 0.6:
            return C
        else if coop_rate >= 0.7:
            return C
        else:
            return D
    
    # Calculate adaptive threshold
    base_threshold = 0.5
    round_adjustment = 0.1 × (round / r)
    threshold = base_threshold + round_adjustment
    
    # Forgiveness check (avoid death spirals)
    if round >= 3:
        prev_prev_coop_rate = count_cooperators(history, round - 2) / n
        if coop_rate < threshold AND prev_prev_coop_rate < threshold:
            if coop_rate > 0.2 AND random() < 0.3:
                return C  # Forgiveness probe
    
    # Main decision
    if coop_rate >= threshold:
        return C
    else:
        # Probabilistic response matching cooperation level
        if random() < coop_rate:
            return C
        else:
            return D
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Strategy applies normally | Equivalent to iterated prisoner's dilemma |
| r = 2 | Cooperate round 1, apply final round logic for round 2 | Still attempt cooperation |
| k very close to 1 | Strategy unchanged | Even small gains from cooperation matter collectively |
| All others defect round 1 | Defect with high probability round 2, but 0% forgiveness probe | Protect against pure exploiters |
| Single defector in cooperative group | Continue cooperating | One defector shouldn't collapse cooperation |

---

## Why This Strategy Works Collectively

1. **Self-reinforcing**: If multiple players use this strategy, cooperation emerges and sustains
2. **Exploitation-resistant**: Quick response to low cooperation protects against freeloaders
3. **Recovery-capable**: Forgiveness mechanism allows cooperation to restart after breakdowns
4. **Endgame-stable**: Conditional final-round cooperation prevents unraveling among cooperative players
'''

description_COLLECTIVE_43 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embodies a **collective mindset**: we assume all instances of this strategy will reason identically given the same information. Rather than treating other players as adversaries, we recognize that if multiple copies of this strategy exist in the game, they will naturally coordinate through shared reasoning. We aim to:

1. **Maximize collective welfare** when playing with like-minded cooperators
2. **Protect against exploitation** by defectors
3. **Signal cooperative intent** while remaining adaptive

---

## Strategy: "Collective Threshold Response" (CTR)

### Key Parameters (Derived from Game Parameters)

```
cooperation_threshold = 0.5  # Minimum cooperation rate to sustain cooperation
forgiveness_window = max(2, floor(r/5))  # Rounds to consider for recent behavior
endgame_rounds = min(3, floor(r/4))  # Rounds before end where defection risk rises
```

### Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: As collective-minded players, we start by demonstrating cooperative intent. This allows other cooperative strategies to identify us and establishes a foundation for mutual benefit. The cost of one round's potential exploitation is worth the signal value.

#### Rounds 2 through (r - endgame_rounds): Adaptive Threshold Response

**Calculate recent cooperation rate:**
```
recent_rounds = min(current_round - 1, forgiveness_window)
recent_cooperation_rate = (total C plays by others in last recent_rounds) / 
                          ((n-1) * recent_rounds)
```

**Decision Logic:**
```
IF recent_cooperation_rate >= cooperation_threshold:
    ACTION: COOPERATE
    Reason: Sufficient cooperation exists to sustain the public good
    
ELSE IF recent_cooperation_rate >= cooperation_threshold * 0.6:
    # Borderline zone - use probabilistic cooperation to signal willingness
    ACTION: COOPERATE with probability = recent_cooperation_rate
    Reason: Maintain some cooperation to allow recovery, but reduce exposure
    
ELSE:
    ACTION: DEFECT
    Reason: Cooperation is not being reciprocated; protect against exploitation
```

**Recovery Mechanism:**
```
IF defected last round AND recent_cooperation_rate increased:
    # Others may be trying to restore cooperation
    ACTION: COOPERATE
    Reason: Give the collective a chance to rebuild
```

#### Endgame Rounds (last `endgame_rounds` rounds): Conditional Continuation

The endgame creates pressure to defect. We counter this collectively:

```
cumulative_cooperation_rate = (total C plays by others across all rounds) / 
                              ((n-1) * (current_round - 1))

IF cumulative_cooperation_rate >= 0.7:
    # Strong cooperative history - maintain cooperation to the end
    ACTION: COOPERATE
    Reason: Reward sustained cooperation; collective benefit exceeds individual gain
    
ELSE IF cumulative_cooperation_rate >= cooperation_threshold:
    # Moderate cooperation - taper based on round
    rounds_remaining = r - current_round
    cooperation_probability = cumulative_cooperation_rate * (rounds_remaining / endgame_rounds)
    ACTION: COOPERATE with calculated probability
    
ELSE:
    ACTION: DEFECT
    Reason: Insufficient cooperation history to justify endgame risk
```

#### Final Round Special Case

```
IF cumulative_cooperation_rate >= 0.8:
    ACTION: COOPERATE
    Reason: Honor the cooperative relationship; this is what collective-minded 
            players do, and it's the equilibrium we want to establish
ELSE:
    ACTION: DEFECT
    Reason: The group has not demonstrated sufficient collective commitment
```

---

## Handling Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (minimum players) | Follow same rules, but cooperation_threshold = 0.6 | With fewer players, each defection hurts more |
| r = 2 (minimum rounds) | Cooperate R1, Cooperate R2 if partner cooperated | Minimal game; prioritize signaling |
| k very close to 1 | Slightly lower cooperation_threshold to 0.4 | Lower k means cooperation is barely beneficial |
| k close to n | Maintain threshold at 0.5 | High k makes cooperation very valuable |
| All others defected every round | Defect until cooperation observed | No point in unilateral cooperation |
| Mixed population (some always C, some always D) | Respond to aggregate rate | Strategy naturally handles heterogeneity |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    cooperation_threshold = 0.5
    forgiveness_window = max(2, r // 5)
    endgame_rounds = min(3, r // 4)
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation rates
    recent_coop_rate = get_recent_cooperation_rate(history, forgiveness_window, n)
    cumulative_coop_rate = get_cumulative_cooperation_rate(history, n)
    
    # Endgame logic
    if round > r - endgame_rounds:
        if cumulative_coop_rate >= 0.8:
            return COOPERATE
        elif cumulative_coop_rate >= 0.7 and round < r:
            return COOPERATE
        elif cumulative_coop_rate >= cooperation_threshold:
            prob = cumulative_coop_rate * ((r - round) / endgame_rounds)
            return COOPERATE with probability prob
        else:
            return DEFECT
    
    # Main game logic
    if recent_coop_rate >= cooperation_threshold:
        return COOPERATE
    elif recent_coop_rate >= cooperation_threshold * 0.6:
        return COOPERATE with probability recent_coop_rate
    else:
        # Recovery check
        if defected_last_round(history) and cooperation_trending_up(history):
            return COOPERATE
        return DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Self-coordination**: Multiple instances will cooperate with each other from round 1 and maintain cooperation throughout, achieving near-optimal collective payoffs.

2. **Exploitation resistance**: The threshold mechanism ensures we don't subsidize persistent defectors.

3. **Forgiveness**: The recovery mechanism and probabilistic cooperation allow groups to escape defection spirals.

4. **Endgame stability**: By committing to cooperate in the final round when cooperation has been strong, we avoid the backward induction problem that unravels cooperation.

5. **Robustness**: The strategy adapts to any mix of opponents—from all-cooperators to all-defectors—without requiring knowledge of their strategies.
'''

description_COLLECTIVE_42 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players in my cohort are reasoning similarly and will arrive at compatible strategies. We aim to maximize group welfare while protecting against exploitation by non-cooperative opponents.

The key insight is that with `k > 1`, mutual cooperation creates surplus value (total payoff `k` per cooperator vs. 1 for defection). Our goal is to establish and maintain cooperation among like-minded players while adaptively responding to defectors.

---

## Strategy: "Collective Threshold Cooperation" (CTC)

### Decision Framework

The strategy tracks **cooperation rates** at both individual and group levels, using thresholds that adapt based on game parameters and remaining rounds.

---

### Key Variables to Track

```
For each player j (including self):
  - total_cooperations[j]: count of C plays across all rounds
  - cooperation_rate[j]: total_cooperations[j] / rounds_played

Global metrics:
  - group_cooperation_rate: total C plays / (n × rounds_played)
  - rounds_played: current round number - 1
  - rounds_remaining: r - current_round + 1
```

---

### Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent to identify fellow cooperators. The information gained about other players' dispositions is worth the risk of exploitation in a single round.

---

#### Rounds 2 through (r-1): Adaptive Threshold Cooperation

**Calculate the following:**

1. **Cooperation Threshold** (minimum acceptable group cooperation rate):
   ```
   base_threshold = (n - k) / (n - 1)
   ```
   This is the break-even point where cooperation becomes individually rational given others' cooperation.

2. **Adjusted Threshold** (accounts for game phase):
   ```
   phase_factor = rounds_remaining / r
   adjusted_threshold = base_threshold × (0.7 + 0.3 × phase_factor)
   ```
   We're slightly more forgiving early (building cooperation) and stricter late (protecting against end-game defection).

3. **Decision Rule:**
   ```
   IF group_cooperation_rate >= adjusted_threshold:
       COOPERATE
   ELSE IF group_cooperation_rate >= adjusted_threshold × 0.5:
       # Partial cooperation zone - probabilistic response
       cooperation_probability = group_cooperation_rate / adjusted_threshold
       COOPERATE with probability = cooperation_probability
   ELSE:
       DEFECT
   ```

---

#### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection, we maintain collective mindset:

```
IF group_cooperation_rate >= base_threshold:
    COOPERATE
ELSE:
    DEFECT
```

Rationale: If the group has maintained cooperation throughout, we honor that cooperation in the final round. This rewards consistent cooperators and reflects genuine collective values rather than purely strategic behavior.

---

### Forgiveness Mechanism

To allow recovery from early mutual defection spirals:

```
IF rounds_played >= 3 AND rounds_played % 3 == 0:
    IF group_cooperation_rate < adjusted_threshold:
        # Probe for cooperation recovery
        COOPERATE (override defection decision this round only)
```

This periodic "olive branch" allows groups that fell into defection to potentially restart cooperation.

---

### Complete Pseudocode

```python
def decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate metrics
    rounds_played = round - 1
    rounds_remaining = r - round + 1
    
    total_cooperations = sum(all C plays in history)
    group_cooperation_rate = total_cooperations / (n * rounds_played)
    
    # Calculate thresholds
    base_threshold = (n - k) / (n - 1)
    phase_factor = rounds_remaining / r
    adjusted_threshold = base_threshold * (0.7 + 0.3 * phase_factor)
    
    # Final round logic
    if round == r:
        if group_cooperation_rate >= base_threshold:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    if group_cooperation_rate >= adjusted_threshold:
        return COOPERATE
    elif group_cooperation_rate >= adjusted_threshold * 0.5:
        # Probabilistic cooperation
        prob = group_cooperation_rate / adjusted_threshold
        return COOPERATE with probability prob
    else:
        # Check for forgiveness probe
        if rounds_played >= 3 and rounds_played % 3 == 0:
            return COOPERATE
        return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Coordination Signal**: Round 1 cooperation identifies fellow collective thinkers
2. **Parameter-Adaptive**: Thresholds adjust to different n and k values
3. **Robust to Defectors**: Won't be infinitely exploited; defects when cooperation rate is too low
4. **Forgiving**: Periodic cooperation probes allow recovery from defection spirals
5. **No Complex Coordination Needed**: Uses only observable history and game parameters
6. **Honors Collective Commitment**: Maintains cooperation in final round if group has cooperated
'''

description_COLLECTIVE_44 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy operates from a **collective mindset**: we assume all players using this strategy share identical logic and will reach identical conclusions given the same information. This creates implicit coordination without explicit communication. The strategy aims to maximize collective welfare while protecting against exploitation by defectors.

## Strategy Overview

The strategy uses **conditional cooperation with collective punishment and forgiveness cycles**. It starts cooperatively, monitors group behavior, and coordinates responses based on observed cooperation levels.

---

## Decision Rules

### Key Threshold Definition

Let `coop_rate(t)` = proportion of players who cooperated in round t (ranging from 0 to 1)

**Cooperation Threshold:** `θ = (n - k) / n`

This threshold represents the break-even point where cooperation becomes collectively beneficial. When the cooperation rate exceeds θ, contributing to the public good yields positive expected returns.

---

### Round-by-Round Decision Logic

#### **Round 1 (Bootstrap Phase)**
```
COOPERATE
```
*Rationale:* With no history, we signal cooperative intent and establish a baseline for measuring group composition.

#### **Rounds 2 through (r-1) (Main Phase)**

```
Let recent_coop = average cooperation rate over last min(3, t-1) rounds

IF recent_coop ≥ θ + 0.1:
    COOPERATE
    
ELSE IF recent_coop < θ - 0.1:
    DEFECT
    
ELSE (near threshold):
    # Probabilistic cooperation based on round position and trend
    trend = coop_rate(t-1) - coop_rate(t-2)  # if available
    
    IF trend > 0:
        COOPERATE  # Cooperation is recovering
    ELSE IF trend < 0:
        DEFECT     # Cooperation is declining
    ELSE:
        COOPERATE if (t mod 3) ≠ 0, else DEFECT
        # Periodic forgiveness probe
```

#### **Final Round (Round r)**

```
IF average cooperation rate over all previous rounds ≥ 0.8:
    COOPERATE  # Reward sustained cooperation
ELSE:
    DEFECT     # Standard game-theoretic endpoint
```

*Rationale:* The final round lacks future shadow, but we reward groups that maintained high cooperation throughout, reinforcing collective benefit.

---

## Detailed Decision Pseudocode

```
function decide(round t, history H, parameters n, k, r):
    
    θ = (n - k) / n  # Base cooperation threshold
    
    # Round 1: Always cooperate
    if t == 1:
        return COOPERATE
    
    # Calculate recent cooperation rate (last 3 rounds or all available)
    window = min(3, t - 1)
    recent_coop = sum(cooperation_rates[t-window : t-1]) / window
    
    # Final round special handling
    if t == r:
        overall_coop = sum(all cooperation_rates) / (t - 1)
        if overall_coop >= 0.8:
            return COOPERATE
        else:
            return DEFECT
    
    # Main phase decision
    if recent_coop >= θ + 0.1:
        return COOPERATE
        
    if recent_coop < θ - 0.1:
        return DEFECT
    
    # Near-threshold: use trend analysis
    if t >= 3:
        trend = coop_rate(t-1) - coop_rate(t-2)
        if trend > 0.05:
            return COOPERATE
        if trend < -0.05:
            return DEFECT
    
    # Periodic forgiveness probe (every 3rd round in uncertain zone)
    if t mod 3 == 1:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | COOPERATE | Establish cooperative baseline |
| Round 2 with 100% defection in R1 | DEFECT | Protect against full defector pool |
| Round 2 with any cooperation in R1 | COOPERATE | Give cooperation a chance |
| Final round, high cooperation history | COOPERATE | Collective reward |
| Final round, low cooperation history | DEFECT | No future to protect |
| All players defected for 3+ rounds | DEFECT until probe round | Minimize losses |
| Cooperation recovering after decline | COOPERATE | Support recovery |

---

## Why This Strategy is Collectively Optimal

1. **Self-consistency:** All agents using this strategy make identical decisions, creating deterministic coordination
2. **Punishes defection collectively:** When cooperation drops, all strategic agents defect together, making defection unprofitable for exploiters
3. **Forgiveness cycles:** Periodic probes allow recovery from punishment phases
4. **Adapts to group composition:** Threshold-based decisions account for varying numbers of strategic vs. non-strategic players
5. **Robust to parameter variation:** The threshold θ = (n-k)/n automatically adjusts to different game configurations
'''

description_COLLECTIVE_43 = '''
# Collective Strategy: Adaptive Threshold Reciprocity (ATR)

## Core Philosophy

This strategy embeds a collective mindset: we assume other players may be running similar reasoning processes and would benefit from mutual cooperation. However, we must be robust to exploitation. The strategy aims to:

1. **Signal cooperative intent** early to establish beneficial norms
2. **Reward collective cooperation** by sustaining contributions when the group cooperates
3. **Protect against exploitation** by withdrawing when cooperation isn't reciprocated
4. **Forgive and probe** to recover from defection spirals

---

## Decision Rules

### Key Parameters (derived from game parameters)

```
cooperation_threshold = ceil(n / 2)  # Majority of players
forgiveness_interval = max(2, floor(r / 10))  # How often to probe after defection
end_game_horizon = min(3, floor(r / 5))  # Rounds before end where behavior shifts
```

### Round-by-Round Decision Logic

#### **Round 1: Always Cooperate**
- Rationale: Signal cooperative intent. With no history, assume good faith from a collective perspective. This gives the group a chance to establish mutual cooperation.

#### **Rounds 2 through (r - end_game_horizon): Adaptive Reciprocity**

```
Let prev_cooperators = number of players who cooperated in the previous round
Let recent_avg = average cooperation count over last min(5, current_round - 1) rounds

IF prev_cooperators >= cooperation_threshold:
    COOPERATE  # Majority cooperated, reward and sustain
    
ELSE IF prev_cooperators >= ceil(n * k / (2 * n)):  # At least enough to make C marginally worthwhile
    IF recent_avg >= cooperation_threshold * 0.7:
        COOPERATE  # Trend is decent, maintain hope
    ELSE:
        DEFECT  # Trend is poor, protect ourselves
        
ELSE:  # Very low cooperation
    IF (current_round mod forgiveness_interval) == 0:
        COOPERATE  # Periodic probe to escape defection equilibrium
    ELSE:
        DEFECT  # Protect against exploitation
```

#### **Last `end_game_horizon` Rounds: Conditional End-Game**

The classic game theory prediction is universal defection at the end. However, from a collective mindset, we should sustain cooperation if the group has been cooperative:

```
Let overall_coop_rate = (total cooperations by all players) / (n * (current_round - 1))

IF overall_coop_rate >= 0.6:
    COOPERATE  # Group has been cooperative, honor that
ELSE IF overall_coop_rate >= 0.4:
    # Mixed history - use probabilistic approach
    COOPERATE with probability = overall_coop_rate
ELSE:
    DEFECT  # Group has been largely uncooperative
```

#### **Final Round Special Case**
```
IF overall_coop_rate >= 0.7:
    COOPERATE  # Strong collective deserves final cooperation
ELSE:
    DEFECT  # Standard end-game protection
```

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| n = 2 (minimum players) | Use stricter threshold: require opponent cooperation | Small groups are more exploitable |
| r = 2 (minimum rounds) | Cooperate round 1, mirror opponent round 2 | Limited interaction, simple reciprocity |
| k very close to 1 | Lower forgiveness_interval (probe more often) | Cooperation benefits are marginal, need more coordination attempts |
| k close to n | Standard rules apply | High returns to cooperation make it more likely |
| All players defected for 3+ consecutive rounds | Increase probe frequency | Defection spiral needs breaking |

---

## Pseudocode Summary

```python
def decide(round, n, r, k, history):
    coop_threshold = ceil(n / 2)
    forgive_interval = max(2, floor(r / 10))
    end_horizon = min(3, floor(r / 5))
    
    if round == 1:
        return COOPERATE
    
    prev_coop = count_cooperators(history, round - 1)
    recent_avg = avg_cooperators(history, last=min(5, round - 1))
    overall_rate = total_cooperation_rate(history)
    
    # End-game logic
    if round > r - end_horizon:
        if overall_rate >= 0.7 or (round == r and overall_rate >= 0.7):
            return COOPERATE
        elif overall_rate >= 0.4:
            return COOPERATE with probability overall_rate
        else:
            return DEFECT
    
    # Main game logic
    if prev_coop >= coop_threshold:
        return COOPERATE
    elif prev_coop >= ceil(n * k / (2 * n)) and recent_avg >= coop_threshold * 0.7:
        return COOPERATE
    elif round % forgive_interval == 0:
        return COOPERATE  # Forgiveness probe
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Optimistic start**: Assumes collective benefit is achievable
2. **Majority-based thresholds**: Cooperates when the *group* cooperates, not based on individual tracking
3. **Forgiveness mechanism**: Doesn't permanently punish, allowing recovery
4. **End-game generosity**: Rewards historically cooperative groups even when exploitation is "safe"
5. **Scalable**: Works across different group sizes by using proportional thresholds
'''

description_COLLECTIVE_45 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players reason similarly and cooperate, we all achieve the best collective outcome. However, I must also be robust to defectors while maintaining the potential for cooperation to emerge and persist.

The key insight is that in this game:
- Universal cooperation yields payoff k per round (k > 1)
- Universal defection yields payoff 1 per round
- The gap (k-1) represents the collective gain from cooperation that I want to capture

## Strategy: **Adaptive Collective Reciprocity (ACR)**

### Decision Framework

I maintain a **cooperation propensity score** that adapts based on observed group behavior, starting optimistic and adjusting based on evidence.

### Variables Tracked

- `coop_rate_history`: List of cooperation rates from each completed round
- `current_round`: The round number (1-indexed)
- `rounds_remaining`: r - current_round

### Decision Rules

**Round 1: Cooperate**
- Start with cooperation to signal willingness and give the collective a chance
- This is the only way cooperation can emerge; someone must start

**Rounds 2 through (r-1): Adaptive Reciprocity**

Calculate the **recent cooperation rate** based on the previous round(s):

```
recent_coop_rate = (cooperators in previous round) / n
```

Decision rule:
```
IF recent_coop_rate >= (n-1)/n THEN
    Cooperate (near-universal cooperation deserves continuation)
ELSE IF recent_coop_rate >= 0.5 THEN
    Cooperate with probability = recent_coop_rate
    (proportional reciprocity - match the group's cooperation level)
ELSE IF recent_coop_rate > 0 THEN
    Cooperate with probability = recent_coop_rate × k/n
    (reduced cooperation, but maintain small olive branch)
ELSE (recent_coop_rate = 0)
    Defect (no point cooperating alone)
```

**Additional Adaptation - Trend Detection:**
```
IF current_round >= 3 THEN
    trend = recent_coop_rate - coop_rate_two_rounds_ago
    IF trend > 0.1 THEN
        Add 0.15 to cooperation probability (cooperation is growing)
    ELSE IF trend < -0.2 THEN
        Subtract 0.15 from cooperation probability (cooperation is collapsing)
```

**Final Round (Round r): Conditional Cooperation**

Unlike standard game theory which prescribes defection:
```
IF average_coop_rate_all_rounds >= 0.6 THEN
    Cooperate (reward sustained cooperation, act collectively)
ELSE
    Defect (no established norm to maintain)
```

This reflects the collective mindset: if we've built something together, I honor it even at the end.

### Pseudocode Summary

```
function decide(current_round, history, n, r, k):
    
    if current_round == 1:
        return COOPERATE
    
    recent_coop_rate = history[current_round - 1].cooperators / n
    
    # Base cooperation probability
    if recent_coop_rate >= (n-1)/n:
        coop_prob = 1.0
    else if recent_coop_rate >= 0.5:
        coop_prob = recent_coop_rate
    else if recent_coop_rate > 0:
        coop_prob = recent_coop_rate * (k/n)
    else:
        coop_prob = 0.0
    
    # Trend adjustment (if enough history)
    if current_round >= 3:
        trend = recent_coop_rate - history[current_round - 2].cooperators / n
        if trend > 0.1:
            coop_prob = min(1.0, coop_prob + 0.15)
        else if trend < -0.2:
            coop_prob = max(0.0, coop_prob - 0.15)
    
    # Final round special case
    if current_round == r:
        avg_coop = mean([h.cooperators/n for h in history])
        if avg_coop >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Probabilistic decision
    return COOPERATE if random() < coop_prob else DEFECT
```

### Why This Strategy Works Collectively

1. **Initiates cooperation**: By cooperating first, I enable collective gains to begin
2. **Rewards cooperation**: High cooperation rates are met with continued cooperation
3. **Proportional response**: I don't abandon cooperation entirely when some defect
4. **Trend-sensitive**: I detect and respond to improving or deteriorating cooperation
5. **Honors collective success**: Final-round cooperation rewards sustained group effort
6. **Robust to exploitation**: Low cooperation triggers protective defection

This strategy aims to be the kind of player that makes cooperation possible while not being naively exploitable.
'''

description_COLLECTIVE_44 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that mutual cooperation yields the best collective outcome (payoff of k > 1 for everyone) compared to mutual defection (payoff of 1 for everyone). My goal is to foster and sustain cooperation while protecting against exploitation. I treat other players as potential cooperators first, and only withdraw cooperation when evidence suggests a player is persistently defecting.

## Strategy Overview: **Graduated Collective Reciprocity**

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness to collaborate
2. **Respond to the collective cooperation rate** rather than individual actions
3. **Forgive occasionally** to escape defection spirals, but protect against chronic free-riders

---

## Decision Rules

### Round 1: Cooperate
- **Action: C (Cooperate)**
- Rationale: Establish cooperative intent. With no history, assume good faith from the collective.

### Rounds 2 through (r-1): Adaptive Cooperation

Calculate the **collective cooperation rate** from the previous round:
```
coop_rate = (number of players who played C in round t-1) / n
```

**Decision rule:**

```
IF coop_rate >= threshold(t) THEN
    Cooperate
ELSE IF forgiveness_trigger(t) THEN
    Cooperate (with probability p_forgive)
ELSE
    Defect
```

**Threshold function:**
```
threshold(t) = max(0.3, 0.5 - 0.1 × (t/r))
```
- Starts at ~0.5 (requires roughly half cooperation)
- Gradually becomes more lenient as game progresses (to ~0.3-0.4)
- This rewards sustained cooperation and allows recovery from early coordination failures

**Forgiveness mechanism:**
```
p_forgive = 0.15
forgiveness_trigger(t) = (rounds_since_last_cooperation > 2)
```
- If stuck in mutual defection for 3+ rounds, occasionally attempt cooperation
- Probability of 15% prevents predictable exploitation while allowing escape from defection traps

### Last Round (Round r): Conditional Cooperation

Unlike standard game theory advice to defect in the last round:

```
IF coop_rate in round (r-1) >= 0.6 THEN
    Cooperate
ELSE
    Defect
```

**Rationale:** If the collective has maintained strong cooperation, I honor that relationship even in the final round. This reflects genuine collective commitment rather than instrumental cooperation. If cooperation has already collapsed, defection is appropriate.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round's cooperation rate
    prev_cooperators = count_cooperators(history[round-1])
    coop_rate = prev_cooperators / n
    
    # Last round: conditional cooperation
    if round == r:
        if coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: adaptive threshold with forgiveness
    threshold = max(0.3, 0.5 - 0.1 * (round / r))
    
    if coop_rate >= threshold:
        return COOPERATE
    
    # Forgiveness check
    rounds_all_defect = count_consecutive_low_cooperation(history, threshold=0.2)
    if rounds_all_defect >= 3:
        if random() < 0.15:
            return COOPERATE
    
    return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | Cooperate | Signal cooperative intent |
| Last round, high prior cooperation | Cooperate | Honor collective commitment |
| Last round, low prior cooperation | Defect | No relationship to preserve |
| All others defected last round | Defect (with 15% forgiveness) | Protect self, but probe for recovery |
| Exactly at threshold | Cooperate | Err toward cooperation |
| n=2 (minimum players) | Same rules apply | Strategy scales down naturally |
| Very large n | Same rules apply | Cooperation rate normalizes group size |

---

## Why This Strategy is Collectively Aligned

1. **Pro-social default**: Starts with cooperation and maintains it when others reciprocate
2. **Group-focused**: Responds to collective behavior, not individual grudges
3. **Forgiving**: Allows recovery from coordination failures or noise
4. **Honest signaling**: Consistent behavior allows other cooperators to coordinate with me
5. **Not exploitable**: Withdraws cooperation when faced with persistent defection
6. **End-game integrity**: Doesn't automatically betray in the last round if cooperation was sustained

This strategy aims to be a **good collective citizen**—rewarding cooperation, enabling coordination, and only defecting when necessary for self-protection.
'''

description_COLLECTIVE_46 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to maximize group welfare while protecting against exploitation. The key insight is that if all players reason similarly about collective benefit, universal cooperation emerges naturally. However, I must also be robust to defectors.

My strategy combines **optimistic initiation**, **proportional reciprocity**, and **strategic forgiveness** to foster cooperation while remaining adaptive.

---

## Strategy: "Collective Mirror with Graduated Response"

### Decision Rules

**Round 1: Cooperate**
- Begin with cooperation to signal cooperative intent and give the collective a chance to establish mutual benefit.
- Rationale: If others share a collective mindset, this seeds cooperation. The potential gain (everyone cooperates → payoff = k) outweighs the risk (I'm exploited → payoff = k/n).

**Rounds 2 through (r-1): Proportional Reciprocity**

Calculate the **cooperation rate** from the previous round:
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Decision rule:**
- If `prev_coop_rate ≥ threshold(t)`, then **Cooperate**
- Otherwise, **Defect**

**Dynamic threshold function:**
```
threshold(t) = base_threshold - forgiveness_bonus(t)

where:
  base_threshold = 0.5  (majority cooperation required)
  forgiveness_bonus(t) = 0.1 × (rounds_since_last_defection / r)
```

This means:
- I cooperate if at least half the group cooperated last round
- The threshold drops slightly over time if I've been defecting, giving the group chances to recover
- Minimum threshold is capped at 0.3 (at least ~1/3 must cooperate)

**Last Round (round r): Conditional Cooperation**

Standard game theory suggests defecting in the final round, but a collective strategy should consider:
```
If cooperation_rate in round (r-1) ≥ 0.7:
    Cooperate  (reward sustained collective behavior)
Else:
    Defect  (no reputation to maintain, group already fragmented)
```

---

### Handling Edge Cases

**If n = 2:**
- Simplifies to standard repeated Prisoner's Dilemma
- Use straightforward Tit-for-Tat: cooperate if opponent cooperated last round

**If k is very close to n (high returns to cooperation):**
- Lower base_threshold to 0.4 (cooperation is more valuable, worth more risk)

**If k is very close to 1 (low returns to cooperation):**
- Raise base_threshold to 0.6 (cooperation is barely worth it, need stronger signal)

**If r is very small (r ≤ 3):**
- Round 1: Cooperate
- Middle rounds: Cooperate if prev_coop_rate ≥ 0.5
- Last round: Cooperate if prev_coop_rate = 1.0, else Defect

**After observing a sharp drop in cooperation:**
- If cooperation drops by more than 50% between rounds, defect for one round as a "punishment signal," then return to normal threshold evaluation

---

### Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[round - 1])
    prev_coop_rate = prev_cooperators / n
    
    # Calculate dynamic threshold
    base = 0.5
    if k > 0.8 * n: base = 0.4
    if k < 1.2: base = 0.6
    
    rounds_defecting = count_recent_defections(my_history)
    forgiveness = min(0.2, 0.1 * rounds_defecting / r)
    threshold = max(0.3, base - forgiveness)
    
    # Last round special case
    if round == r:
        if prev_coop_rate >= 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # Standard rounds
    if prev_coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Initiates cooperation** - Gives the group the best chance to coordinate
2. **Mirrors collective behavior** - Rewards group cooperation, punishes group defection
3. **Forgives** - Doesn't permanently punish; allows recovery
4. **Rewards sustained cooperation** - Even in the last round, honors groups that maintained cooperation
5. **Adapts to parameters** - Adjusts thresholds based on how valuable cooperation actually is

This strategy thrives when matched with similar collective thinkers and degrades gracefully against exploiters.
'''

description_COLLECTIVE_45 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other AI systems in this tournament will also recognize that mutual cooperation maximizes total welfare. The strategy aims to:
1. Signal cooperative intent clearly
2. Establish and maintain cooperation when others reciprocate
3. Punish defection proportionally to deter exploitation
4. Forgive and rebuild cooperation when possible
5. Protect against end-game collapse

## Strategy: **Adaptive Collective Reciprocity (ACR)**

### Key Variables to Track

- `cooperation_rate[t]`: Fraction of players who cooperated in round t
- `cumulative_coop_rate`: Running average cooperation rate across all past rounds
- `consecutive_high_coop`: Number of consecutive rounds with cooperation rate ≥ threshold
- `rounds_remaining`: r - current_round

### Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. In a tournament of AI strategies likely designed with collective reasoning, starting with cooperation establishes the possibility of mutual benefit.

#### Rounds 2 through (r-1): Adaptive Reciprocity

```
Define thresholds:
  HIGH_COOP_THRESHOLD = 0.6  (60% cooperation signals viable collective)
  LOW_COOP_THRESHOLD = 0.3   (below this, cooperation is being exploited)
  FORGIVENESS_ROUNDS = 2     (rounds to wait before attempting recovery)

If cooperation_rate[t-1] >= HIGH_COOP_THRESHOLD:
    Action: COOPERATE
    
Else if cooperation_rate[t-1] >= LOW_COOP_THRESHOLD:
    # Moderate cooperation - use probabilistic response
    # Cooperate with probability equal to previous cooperation rate
    Action: COOPERATE with probability = cooperation_rate[t-1]
    
Else if cooperation_rate[t-1] < LOW_COOP_THRESHOLD:
    # Low cooperation environment
    If (current_round mod FORGIVENESS_ROUNDS == 0):
        # Periodic forgiveness probe - attempt to restart cooperation
        Action: COOPERATE
    Else:
        Action: DEFECT
```

#### Last Round Consideration (Round r)

The last round creates an end-game problem. However, in a collective strategy:

```
If cumulative_coop_rate >= 0.5 AND cooperation_rate[r-1] >= HIGH_COOP_THRESHOLD:
    # Strong cooperative history - maintain cooperation to maximize collective payoff
    # Trust that other collective-minded agents will do the same
    Action: COOPERATE
    
Else:
    # Cooperation has not been established - defect
    Action: DEFECT
```

### Pseudocode Summary

```python
def decide(round, history, n, k, r):
    HIGH_COOP = 0.6
    LOW_COOP = 0.3
    FORGIVE_PERIOD = 2
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate metrics
    last_coop_rate = count_cooperators(history[round-1]) / n
    cumulative_rate = sum(count_cooperators(h) for h in history) / (n * (round-1))
    
    # Last round logic
    if round == r:
        if cumulative_rate >= 0.5 and last_coop_rate >= HIGH_COOP:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    if last_coop_rate >= HIGH_COOP:
        return COOPERATE
    elif last_coop_rate >= LOW_COOP:
        return COOPERATE with probability last_coop_rate
    else:
        # Low cooperation - periodic forgiveness
        if round % FORGIVE_PERIOD == 0:
            return COOPERATE
        else:
            return DEFECT
```

### Why This Strategy Works Collectively

1. **Clear signaling**: Starting with cooperation tells other collective-minded strategies "I'm willing to cooperate."

2. **Proportional response**: The probabilistic cooperation in moderate-cooperation environments creates a natural gradient that rewards higher cooperation levels.

3. **Forgiveness mechanism**: Periodic cooperation attempts in low-cooperation states allow recovery from coordination failures or temporary breakdowns.

4. **End-game protection**: The final round rule maintains cooperation among collective strategies while protecting against pure defectors.

5. **Parameter independence**: The strategy adapts to any n, k, r values through its use of cooperation rates rather than absolute numbers.

### Robustness Properties

- **Against all-defect**: Quickly drops to mostly-defect with periodic probes, limiting exploitation
- **Against all-cooperate**: Maintains full cooperation, maximizing mutual benefit
- **Against tit-for-tat variants**: Establishes stable cooperation
- **Against random strategies**: Probabilistic matching limits losses while capturing upside
'''

description_COLLECTIVE_47 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players in my cohort are reasoning similarly and will adopt compatible strategies. Our goal is to maximize group welfare while protecting against exploitation by non-cooperative opponents. Since we cannot pre-coordinate, we use observable patterns to achieve implicit coordination.

## Strategy Overview: **Adaptive Threshold Cooperation with Forgiveness**

The strategy cooperates when there's sufficient evidence of a cooperative environment, defects to protect against exploitation, but maintains forgiveness mechanisms to recover cooperation after breakdowns.

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: With no history, we signal cooperative intent. If other collective-minded players reason similarly, we establish mutual cooperation from the start. The cost of one round of potential exploitation is worth the benefit of discovering cooperative partners.

### Rounds 2 through (r-1): Adaptive Threshold Response

**Calculate the cooperation rate from the previous round:**
```
prev_coop_rate = (number of C plays in round t-1) / n
```

**Calculate the trend-adjusted cooperation rate:**
```
if t >= 3:
    trend = prev_coop_rate - coop_rate_from_round_(t-2)
else:
    trend = 0

adjusted_rate = prev_coop_rate + 0.5 * trend
```

**Decision Rule:**
```
threshold = max(0.3, (n - k) / n)

if adjusted_rate >= threshold:
    ACTION: COOPERATE
else if adjusted_rate >= threshold - 0.15 AND (t mod 3 == 0):
    ACTION: COOPERATE  // Forgiveness probe every 3 rounds
else:
    ACTION: DEFECT
```

**Threshold Explanation:**
- The base threshold `(n-k)/n` represents the fraction of defectors that makes cooperation unprofitable
- We set a floor of 0.3 to avoid being too easily exploited
- When cooperation is marginal, we periodically probe with cooperation to test if opponents will reciprocate

### Final Round (Round r): Conditional Cooperation

**Unlike standard game theory which prescribes defection:**

```
overall_coop_rate = (total C plays across all rounds) / (n * (r-1))

if overall_coop_rate >= 0.6:
    ACTION: COOPERATE  // Reward sustained cooperation
else:
    ACTION: DEFECT     // No future to protect
```

Rationale: If we've built a cooperative relationship, maintaining it even in the final round signals integrity and achieves better collective outcomes. Other collective-minded agents will reason similarly.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation
    prev_coop_count = count_cooperators(history, round - 1)
    prev_coop_rate = prev_coop_count / n
    
    # Calculate trend if possible
    if round >= 3:
        prev_prev_rate = count_cooperators(history, round - 2) / n
        trend = prev_coop_rate - prev_prev_rate
    else:
        trend = 0
    
    adjusted_rate = prev_coop_rate + 0.5 * trend
    
    # Calculate threshold
    threshold = max(0.3, (n - k) / n)
    
    # Final round logic
    if round == r:
        overall_rate = total_cooperations(history) / (n * (r - 1))
        if overall_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    if adjusted_rate >= threshold:
        return COOPERATE
    elif adjusted_rate >= threshold - 0.15 AND round mod 3 == 0:
        return COOPERATE  # Forgiveness probe
    else:
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | COOPERATE | Establish cooperative intent |
| All others defected last round | DEFECT (unless forgiveness probe round) | Protect against exploitation |
| Exactly at threshold | COOPERATE | Benefit of the doubt |
| Only 2 players (n=2) | Same rules apply | Threshold adapts automatically |
| Very high k (close to n) | Lower threshold, more cooperation | Reflects higher returns to cooperation |
| Very low k (close to 1) | Higher threshold, more selective | Cooperation needs more participants to pay off |

---

## Why This Strategy Works Collectively

1. **Self-recognition**: Collective agents using this strategy will all cooperate in round 1, see high cooperation, and continue cooperating
2. **Robustness**: The threshold mechanism protects against environments dominated by defectors
3. **Recovery**: Forgiveness probes allow cooperation to restart after temporary breakdowns
4. **Parameter adaptation**: The threshold automatically adjusts to game parameters (n, k)
5. **Trend sensitivity**: Rewards improving cooperation, reacts quickly to deterioration
'''

description_COLLECTIVE_46 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume I am one of potentially many players using this same strategy. Our goal is to achieve high collective welfare while protecting against exploitation by defectors. The strategy balances cooperation to maximize group benefits with conditional responses that discourage free-riding.

## Strategy Overview: "Graduated Collective Reciprocity"

This strategy uses a threshold-based cooperation system that responds to the observed cooperation level in the population, with adjustments for game phase and forgiveness mechanisms.

---

## Decision Rules

### Key Variables (tracked each round)

- `coop_rate`: proportion of players who cooperated in the previous round (0 to 1)
- `round_num`: current round (1 to r)
- `phase`: early (first 20%), middle (20-80%), or late (last 20%) of game
- `trend`: whether cooperation is increasing, stable, or decreasing over last 3 rounds

### Cooperation Threshold Function

Calculate `threshold` based on game parameters:

```
base_threshold = (n - k) / n
```

This represents the theoretical "break-even" point where cooperation becomes collectively rational.

### Primary Decision Rule

**Cooperate if:**
1. `coop_rate ≥ base_threshold`, OR
2. Special conditions apply (see below)

**Defect if:**
1. `coop_rate < base_threshold` AND no special conditions apply

---

## Phase-Specific Behavior

### First Round
- **Action: COOPERATE**
- Rationale: Signal cooperative intent, establish baseline, give the collective a chance to coordinate

### Early Phase (rounds 2 to ⌈0.2r⌉)
- Use a **lenient threshold**: `threshold = base_threshold * 0.7`
- Include **forgiveness**: If cooperation dropped but was high (≥0.6) in any of the last 2 rounds, cooperate anyway
- Rationale: Allow time for collective learning and coordination

### Middle Phase (rounds ⌈0.2r⌉+1 to ⌈0.8r⌉)
- Use **standard threshold**: `threshold = base_threshold`
- **Trend adjustment**: 
  - If `trend = increasing`: lower threshold by 10%
  - If `trend = decreasing`: raise threshold by 10%
- **Periodic probe**: Every ⌈r/5⌉ rounds, cooperate regardless of threshold (to test if cooperation can restart)
- Rationale: Respond accurately to collective behavior while maintaining hope

### Late Phase (rounds ⌈0.8r⌉+1 to r-1)
- Use **strict threshold**: `threshold = base_threshold * 1.2`
- No forgiveness mechanism
- Rationale: Protect against late-game defection cascades

### Final Round
- **Mirror the majority**: 
  - If `coop_rate ≥ 0.5` in round r-1: COOPERATE
  - Otherwise: DEFECT
- Rationale: Honor the established collective norm, but don't be exploited if cooperation has broken down

---

## Pseudocode

```
function decide(round_num, history, n, k, r):
    
    base_threshold = (n - k) / n
    
    # First round: always cooperate
    if round_num == 1:
        return COOPERATE
    
    # Calculate current cooperation rate
    coop_rate = count_cooperators(history[round_num - 1]) / n
    
    # Determine game phase
    if round_num <= ceil(0.2 * r):
        phase = EARLY
        threshold = base_threshold * 0.7
    elif round_num <= ceil(0.8 * r):
        phase = MIDDLE
        threshold = base_threshold
    elif round_num < r:
        phase = LATE
        threshold = base_threshold * 1.2
    else:  # Final round
        return COOPERATE if coop_rate >= 0.5 else DEFECT
    
    # Calculate trend (if enough history)
    if round_num >= 4:
        trend = calculate_trend(history, last_3_rounds)
        if phase == MIDDLE:
            if trend == INCREASING: threshold *= 0.9
            if trend == DECREASING: threshold *= 1.1
    
    # Early phase forgiveness
    if phase == EARLY and round_num >= 3:
        recent_max = max(coop_rates_in_last_2_rounds)
        if recent_max >= 0.6:
            return COOPERATE
    
    # Middle phase periodic probe
    if phase == MIDDLE and round_num % ceil(r/5) == 0:
        return COOPERATE
    
    # Standard threshold decision
    return COOPERATE if coop_rate >= threshold else DEFECT
```

---

## Why This Strategy Works Collectively

1. **Coordination through consistency**: All copies of this strategy make identical decisions given the same history, enabling implicit coordination

2. **Rewards cooperation**: When cooperation is high, we sustain it; this creates positive equilibria

3. **Punishes defection**: When cooperation drops below threshold, we defect, reducing the incentive for others to free-ride

4. **Forgiveness and probing**: We don't permanently lock into defection - periodic probes and forgiveness allow recovery

5. **Adapts to population composition**: The threshold system means we cooperate when it's collectively beneficial and defect when exploitation is rampant

6. **Robust to game parameters**: The formula `(n-k)/n` scales appropriately as group size and multiplication factor change
'''

description_COLLECTIVE_48 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume other players may be using similar reasoning and aim to establish and maintain cooperation through consistent, interpretable behavior. The strategy balances optimism about collective outcomes with protection against exploitation.

## Strategy Overview: **Adaptive Threshold Cooperation (ATC)**

The strategy cooperates when there's sufficient evidence of a cooperative environment and defects when cooperation would be futile or exploited. It uses a dynamic cooperation threshold that adjusts based on observed group behavior.

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: In a collective mindset, we must be willing to initiate cooperation. Starting with cooperation signals willingness to collaborate and provides information about others' intentions. The cost of one round's potential exploitation is worth establishing cooperative norms.

### Rounds 2 through (r-1): Adaptive Threshold Response

**Calculate the cooperation rate** from the previous round:
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Calculate the trend** (if round > 2):
```
trend = prev_coop_rate - coop_rate_from_round_(t-2)
```

**Decision Rule:**
```
threshold = base_threshold + trend_adjustment + round_pressure

where:
  base_threshold = (n - k) / n
    # This is the break-even point where cooperation becomes collectively rational
  
  trend_adjustment = 0.1 × trend
    # Reward improving cooperation, punish declining cooperation
  
  round_pressure = 0.05 × (t / r)
    # Slightly lower threshold as game progresses to sustain cooperation

IF prev_coop_rate >= threshold THEN COOPERATE
ELSE DEFECT
```

### Last Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes universal defection:

**Action:**
```
IF average_cooperation_rate_over_all_rounds >= 0.5 THEN COOPERATE
ELSE DEFECT
```

Rationale: If we're playing against other collective-minded strategies, mutual last-round cooperation is achievable and beneficial. We reward sustained cooperation with final-round cooperation.

---

## Detailed Pseudocode

```
function decide_action(round, history, n, k, r):
    
    # Round 1: Always cooperate to initiate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history[round - 1])
    prev_coop_rate = prev_cooperators / n
    
    # Last round: reward sustained cooperation
    if round == r:
        total_coop_rate = sum(count_cooperators(h) for h in history) / (n × (r-1))
        if total_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: adaptive threshold
    base_threshold = (n - k) / n
    
    # Calculate trend if we have enough history
    if round > 2:
        prev_prev_cooperators = count_cooperators(history[round - 2])
        prev_prev_coop_rate = prev_prev_cooperators / n
        trend = prev_coop_rate - prev_prev_coop_rate
    else:
        trend = 0
    
    trend_adjustment = 0.1 × trend
    round_pressure = 0.05 × (round / r)
    
    threshold = base_threshold + trend_adjustment - round_pressure
    
    # Clamp threshold to reasonable bounds
    threshold = max(0.2, min(0.8, threshold))
    
    if prev_coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| n = 2 | Same rules apply | Threshold naturally adjusts |
| k very close to 1 | Higher threshold, more defection likely | Break-even requires near-universal cooperation |
| k close to n | Lower threshold, more cooperation | Even partial cooperation is rewarding |
| All others defect round 1 | Defect round 2+ until improvement | Don't be exploited, but remain open to change |
| Fluctuating cooperation | Follow the trend-adjusted threshold | Smooth response prevents overreaction |
| r = 2 (minimum rounds) | Cooperate round 1, conditional round 2 | Maximize information use |

---

## Why This Strategy is Collectively Robust

1. **Self-reinforcing**: If multiple players use this strategy, initial cooperation triggers sustained cooperation
2. **Exploitation-resistant**: Threshold prevents indefinite exploitation by defectors
3. **Forgiveness through trends**: Rising cooperation lowers the effective threshold
4. **Interpretable signals**: Consistent behavior helps others recognize cooperative intent
5. **Parameter-adaptive**: The base threshold scales naturally with game parameters
'''

description_COLLECTIVE_47 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embodies a **collective mindset**: I aim to maximize group welfare while protecting against exploitation. The fundamental insight is that universal cooperation yields the highest collective payoff, but sustaining it requires mechanisms to encourage cooperation and discourage defection—without assuming others share this strategy.

## Strategy Overview: **Adaptive Threshold Cooperation (ATC)**

The strategy cooperates when there's sufficient evidence that cooperation is viable and reciprocated, while being forgiving enough to rebuild cooperation after breakdowns.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. In a collective framework, someone must take the first step. The cost of being exploited once is small compared to the potential gains from establishing cooperation.

### Rounds 2 through (r-1): Adaptive Threshold Rule

**Cooperate if and only if:**
```
cooperation_rate(previous_round) ≥ threshold(t)
```

Where:
- `cooperation_rate(t)` = (number of cooperators in round t) / n
- `threshold(t)` is dynamically adjusted based on history

**Threshold Calculation:**
```
base_threshold = (n - k) / n  # Break-even point where C and D yield equal payoff

threshold(t) = base_threshold × adjustment_factor(t)

adjustment_factor(t) = max(0.5, min(1.5, trend_modifier × stability_modifier))
```

**Trend Modifier:**
```
If cooperation_rate is increasing over last 3 rounds: 0.85 (lower threshold, encourage growth)
If cooperation_rate is stable (±10%): 1.0
If cooperation_rate is declining: 1.15 (higher threshold, protect against collapse)
```

**Stability Modifier:**
```
variance = variance of cooperation_rates over all previous rounds
If variance < 0.1: 0.9 (stable environment, be more cooperative)
If variance > 0.3: 1.1 (volatile environment, be more cautious)
Else: 1.0
```

### Forgiveness Mechanism

Even when below threshold, **cooperate with probability p_forgive** to allow recovery:
```
p_forgive = 0.1 × (remaining_rounds / total_rounds)
```
This gives more forgiveness chances early when there's time to rebuild trust.

### Last Round: Conditional Cooperation

**Cooperate if:**
```
cooperation_rate(round r-1) ≥ 0.7
```

Rationale: Unlike pure game theory's prediction of universal defection, maintaining cooperation in the final round rewards groups that achieved sustained cooperation and aligns with collective values. However, we require strong evidence (70% threshold) since there's no future to protect.

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation rate from previous round
    prev_coop_rate = count_cooperators(history[round-1]) / n
    
    # Calculate base threshold (break-even point)
    base_threshold = (n - k) / n
    
    # Last round special handling
    if round == r:
        if prev_coop_rate >= 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # Calculate adjustment factors for middle rounds
    trend = calculate_trend(history, window=3)
    if trend > 0.05:
        trend_mod = 0.85
    elif trend < -0.05:
        trend_mod = 1.15
    else:
        trend_mod = 1.0
    
    variance = calculate_variance(history)
    if variance < 0.1:
        stability_mod = 0.9
    elif variance > 0.3:
        stability_mod = 1.1
    else:
        stability_mod = 1.0
    
    adjustment = clamp(trend_mod * stability_mod, 0.5, 1.5)
    threshold = base_threshold * adjustment
    
    # Main decision
    if prev_coop_rate >= threshold:
        return COOPERATE
    
    # Forgiveness chance
    p_forgive = 0.1 * (r - round) / r
    if random() < p_forgive:
        return COOPERATE
    
    return DEFECT
```

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | COOPERATE | Establish cooperative baseline |
| All defected last round | DEFECT (with forgiveness chance) | Protect against exploitation |
| All cooperated last round | COOPERATE | Reinforce successful cooperation |
| Only round (r=2) | Cooperate round 1, apply 70% rule round 2 | Minimal game, signal intent |
| n=2 (minimum players) | Same rules apply | Reduces to iterated prisoner's dilemma variant |
| k approaches n | Lower effective threshold | Higher returns to cooperation justify more risk |

---

## Why This Strategy Works Collectively

1. **Signals cooperative intent** from the start
2. **Rewards cooperation** by continuing to cooperate when others do
3. **Punishes defection** by withdrawing cooperation when it collapses
4. **Allows recovery** through forgiveness mechanism
5. **Adapts to context** via trend and stability modifiers
6. **Maintains principles** even in the last round when cooperation was established
'''

description_COLLECTIVE_49 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed for a population of agents sharing the same algorithm. Our goal is to maximize collective welfare while maintaining robustness against defectors. The key insight is that with perfect information about history, we can coordinate implicitly through observable behavior patterns.

## Strategy Overview: "Generous Threshold Reciprocity"

We cooperate when the environment is sufficiently cooperative, defect to protect against exploitation, but maintain generosity to sustain cooperation and recover from mistakes.

---

## Decision Rules

### Round 1: Conditional Cooperation Signal
**Action: COOPERATE**

Rationale: In a collective of like-minded agents, starting with cooperation establishes a cooperative baseline. This is our "handshake" - other copies of this strategy will recognize mutual first-round cooperation as a signal of shared intent.

---

### Rounds 2 through (r-1): Adaptive Threshold Reciprocity

**Calculate the cooperation rate from the previous round:**
```
prev_coop_rate = (number of players who cooperated in round t-1) / n
```

**Calculate cumulative cooperation rate (excluding self):**
```
cumulative_coop_rate = (total cooperations by others across all previous rounds) / ((n-1) × (t-1))
```

**Decision Rule:**

```
threshold = max(0.4, (k/n) + 0.1)

IF prev_coop_rate >= threshold:
    COOPERATE
ELSE IF cumulative_coop_rate >= threshold AND prev_coop_rate >= 0.25:
    COOPERATE with probability = cumulative_coop_rate
ELSE IF we defected last round AND prev_coop_rate increased from round before:
    COOPERATE (reward improving behavior)
ELSE:
    DEFECT
```

**Forgiveness Mechanism:**
Every `floor(r/5)` rounds (minimum every 3 rounds), if currently in a defection pattern:
```
IF round_number % max(3, floor(r/5)) == 0:
    COOPERATE (probe for cooperation recovery)
```

---

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection, we maintain conditional cooperation:

```
IF cumulative_coop_rate >= 0.6:
    COOPERATE (reward sustained cooperation, collective benefit)
ELSE:
    DEFECT (no future to protect against defectors)
```

Rationale: If we're playing with other cooperative agents, mutual final-round cooperation yields k/n × n = k > 1 per player, which beats mutual defection's payoff of 1.

---

## Edge Cases

### Very Small Groups (n = 2):
- Behaves like Tit-for-Tat with forgiveness
- More sensitive to single defections; threshold effectively becomes 0.5

### Very Large Groups (n >> k):
- Threshold naturally adjusts via the `(k/n) + 0.1` term
- More tolerant of some defectors since individual impact is smaller

### Short Games (r ≤ 3):
- Forgiveness probe happens every round after round 1
- Emphasizes cooperation to maximize limited opportunities

### High Multiplication Factor (k close to n):
- Higher threshold means we demand more cooperation
- Appropriate since cooperation is more valuable

### Unanimous Defection Observed:
- After 2 consecutive rounds of zero cooperation by others: DEFECT
- Resume probing via forgiveness mechanism

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history, round-1) / n
    cumulative_others = cumulative_cooperation_rate_of_others(history, round-1)
    threshold = max(0.4, k/n + 0.1)
    
    # Final round logic
    if round == r:
        if cumulative_others >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Main decision logic
    if prev_coop_rate >= threshold:
        return COOPERATE
    
    if cumulative_others >= threshold AND prev_coop_rate >= 0.25:
        return COOPERATE with probability cumulative_others
    
    if my_last_action == DEFECT AND cooperation_increased(history):
        return COOPERATE
    
    # Forgiveness probe
    probe_interval = max(3, floor(r/5))
    if round % probe_interval == 0:
        return COOPERATE
    
    return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Mutual Recognition**: Identical agents will all cooperate in round 1, establishing immediate high cooperation rates that sustain themselves.

2. **Self-Reinforcing**: When cooperation rate exceeds threshold, all copies cooperate, keeping the rate high.

3. **Robust to Infiltrators**: If some players use exploitative strategies, the threshold mechanism allows the collective to detect and respond proportionally.

4. **Recovery Capable**: Forgiveness probes and rewarding improvement prevent permanent collapse from transient defection.

5. **Collectively Rational Final Round**: Unlike individual rationality which demands defection, our collective commits to conditional final-round cooperation, capturing gains unavailable to purely self-interested agents.
'''

description_COLLECTIVE_48 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy operates from a **collective mindset**: we assume all copies of this strategy will reason identically given the same information. This isn't coordination through communication—it's coordination through shared rationality. If I reason that cooperating is correct given the current state, so will all other instances of this strategy.

The key insight is that with k > 1, **mutual cooperation always beats mutual defection** (payoff of k vs 1). The challenge is maintaining cooperation in the presence of defectors while not being exploited.

## Strategy Overview: Adaptive Collective Reciprocity (ACR)

The strategy uses three core mechanisms:
1. **Optimistic initialization** - Start cooperating to establish beneficial norms
2. **Population-responsive thresholds** - Cooperate when enough others do
3. **End-game adjustment** - Modified behavior in final rounds to prevent unraveling

---

## Decision Rules

### Round 1: Cooperate
With no history, cooperate. This signals cooperative intent and, if others reason similarly, establishes mutual cooperation from the start.

### Rounds 2 through (r-2): Threshold-Based Reciprocity

**Calculate the cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

**Calculate the break-even threshold** - the minimum cooperation rate where cooperating isn't strictly dominated for a group:
```
break_even = 1 / k
```

**Decision rule:**
```
IF coop_rate >= break_even THEN Cooperate
ELSE IF coop_rate >= break_even * 0.7 THEN Cooperate (give benefit of doubt)
ELSE Defect
```

**Rationale:** 
- When cooperation rate ≥ 1/k, cooperators collectively benefit from the public good enough to justify contribution
- The 0.7 multiplier provides forgiveness buffer, allowing recovery from temporary defection spikes
- This creates a stable equilibrium: if most cooperate, cooperation is reinforced; if most defect, we protect ourselves

### Round (r-1): Penultimate Round - Cautious Cooperation

Apply the same threshold rule but with **stricter threshold**:
```
IF coop_rate >= break_even THEN Cooperate
ELSE Defect
```
Remove the forgiveness buffer as end-game approaches.

### Round r: Final Round - Conditional Cooperation

**Calculate historical cooperation rate** across all previous rounds:
```
historical_coop_rate = (total cooperations by all players across rounds 1 to r-1) / (n × (r-1))
```

**Decision rule:**
```
IF historical_coop_rate >= 0.6 THEN Cooperate
ELSE Defect
```

**Rationale:** In standard game theory, defection in the final round causes backward induction to unravel cooperation. However:
- If we're playing against other collective reasoners, mutual cooperation in round r gives payoff k > 1
- If the population has demonstrated sustained cooperation (≥60%), maintaining it in the final round is collectively rational
- This resists the unraveling problem while protecting against exploitation

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    break_even = 1 / k
    
    # Round 1: Optimistic start
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history, round - 1)
    coop_rate = prev_cooperators / n
    
    # Final round: Use historical cooperation
    if round == r:
        total_coops = sum(count_cooperators(history, t) for t in 1 to r-1)
        historical_rate = total_coops / (n * (r - 1))
        if historical_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Penultimate round: Strict threshold
    if round == r - 1:
        if coop_rate >= break_even:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Threshold with forgiveness
    if coop_rate >= break_even * 0.7:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Scenario | Behavior |
|----------|----------|
| n = 2 | Strategy still applies; break_even = 1/k, forgiveness helps with noise |
| r = 2 | Round 1: Cooperate; Round 2: Use final round rule with round 1 history |
| All defect in round 1 | Round 2: Defect (0 < break_even × 0.7), attempt recovery if cooperation emerges |
| k very close to 1 | High threshold (near 100% cooperation needed); more likely to defect |
| k close to n | Low threshold; cooperation sustained even with some defectors |

---

## Why This Strategy is Collectively Optimal

1. **Self-consistency**: If all ACR players face the same history, they make identical decisions, enabling tacit coordination

2. **Pareto improvement**: When ACR players form a majority, they sustain cooperation yielding k > 1 per round

3. **Exploitation resistance**: The threshold mechanism ensures we don't cooperate into a void—we only contribute when the public good provides sufficient return

4. **Robustness**: Works across different (n, k, r) parameters by using the break-even threshold derived from game structure itself
'''

description_COLLECTIVE_50 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed from a **collective mindset**: I recognize that if all players reason similarly, we can achieve outcomes far better than the Nash equilibrium of mutual defection. The strategy aims to:

1. **Signal cooperative intent** and establish trust early
2. **Reward collective cooperation** while protecting against exploitation
3. **Forgive mistakes** to restore cooperation when possible
4. **Adapt to the actual population** rather than assuming worst-case behavior

---

## Strategy: "Generous Collective Trigger with Adaptive Threshold"

### Key Parameters (Derived from Game Parameters)

```
cooperation_threshold = floor(n / 2)  # Minimum cooperators needed to sustain cooperation
forgiveness_probability = 1 / r       # Chance to test cooperation after defection
grace_period = min(3, floor(r / 4))   # Initial rounds of unconditional cooperation
end_game_threshold = max(2, floor(r / 5))  # When to consider end-game dynamics
```

---

## Decision Rules

### Round 1: Always Cooperate
**Rationale**: Establish cooperative intent. With no history, cooperation signals willingness to work collectively and gives the best chance of discovering other cooperative players.

### Rounds 2 through (r - end_game_threshold): Adaptive Cooperation

**Step 1: Calculate Cooperation Level**
```
prev_cooperators = number of players who played C in previous round
cooperation_rate = prev_cooperators / n
```

**Step 2: Assess Trend**
```
if round >= 3:
    trend = (cooperators in round t-1) - (cooperators in round t-2)
else:
    trend = 0
```

**Step 3: Decision Logic**

```
IF within grace_period (rounds 1 to grace_period):
    COOPERATE  # Build initial trust
    
ELSE IF prev_cooperators >= cooperation_threshold:
    COOPERATE  # Sufficient collective action exists
    
ELSE IF prev_cooperators < cooperation_threshold AND trend > 0:
    COOPERATE  # Cooperation is recovering, support it
    
ELSE IF prev_cooperators < cooperation_threshold AND trend <= 0:
    # Cooperation collapsing - conditional response
    IF random() < forgiveness_probability:
        COOPERATE  # Probe for recovery
    ELSE:
        DEFECT  # Protect against exploitation
```

### Final Rounds (last end_game_threshold rounds): Conditional End-Game

**Rationale**: End-game dynamics matter, but premature defection can destroy cooperation. Use recent history to guide behavior.

```
recent_cooperation_rate = average cooperation rate over last 3 rounds

IF recent_cooperation_rate >= 0.6:
    COOPERATE  # Strong cooperative norm established, maintain it
ELSE IF recent_cooperation_rate >= 0.4:
    # Mixed environment - match the group
    COOPERATE with probability = recent_cooperation_rate
ELSE:
    DEFECT  # Cooperation has failed, protect payoff
```

### Last Round Special Case

```
IF cooperation was high (>= 70%) throughout the game:
    COOPERATE  # Honor the collective agreement
ELSE:
    DEFECT  # Standard game-theoretic response in failed cooperation
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (minimum players) | Use Tit-for-Tat variant | Simpler dynamics, direct reciprocity works |
| k very close to 1 | Lower cooperation_threshold slightly | Cooperation benefits are marginal, need higher participation |
| k close to n | More forgiving (higher forgiveness_probability) | High returns to cooperation justify more attempts |
| r = 2 (minimum rounds) | Cooperate round 1, mirror majority round 2 | Limited learning, simple reciprocity |
| All defected last round | Cooperate with probability 1/n | Attempt coordination restart |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    grace_period = min(3, r // 4)
    end_game_threshold = max(2, r // 5)
    cooperation_threshold = n // 2
    forgiveness_prob = 1 / r
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history, round - 1)
    
    # Grace period: Build trust
    if round <= grace_period:
        return COOPERATE
    
    # End-game logic
    if round > r - end_game_threshold:
        recent_rate = avg_cooperation_rate(history, last=3)
        if recent_rate >= 0.6:
            return COOPERATE
        elif recent_rate >= 0.4:
            return COOPERATE if random() < recent_rate else DEFECT
        else:
            return DEFECT
    
    # Main phase: Adaptive threshold
    trend = get_trend(history, round)
    
    if prev_cooperators >= cooperation_threshold:
        return COOPERATE
    elif trend > 0:
        return COOPERATE
    elif random() < forgiveness_prob:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Assumes good faith initially**: Grace period allows collective strategies to find each other
2. **Threshold-based**: Doesn't require universal cooperation—works with partial coordination
3. **Forgiving**: Random cooperation probes can restart collapsed cooperation
4. **Trend-aware**: Supports recovering cooperation rather than abandoning it
5. **Rewards sustained cooperation**: End-game loyalty for groups that maintained cooperation
6. **Robust to exploitation**: Defects when cooperation is clearly failing

This strategy should perform well both in populations of similar collective thinkers (achieving near-optimal cooperation) and in mixed populations (avoiding severe exploitation while maintaining cooperation opportunities).
'''

description_COLLECTIVE_49 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all players using this strategy will reason identically given the same information. Rather than thinking "what should *I* do given what *others* might do," we think "what should *we all* do, knowing we'll all reach the same conclusion?" This transforms the game from a social dilemma into a coordination problem.

## Strategy Overview: **Adaptive Collective Reciprocity (ACR)**

The strategy operates on three principles:
1. **Collective optimism**: Start cooperatively to establish mutual benefit
2. **Proportional reciprocity**: Match the cooperation level of the population
3. **Strategic end-game**: Manage the unraveling problem in final rounds

---

## Decision Rules

### Key Variables Tracked

```
cooperation_rate(t) = (total C plays in round t) / n
cumulative_coop_rate = (total C plays across all past rounds) / (n × rounds_played)
rounds_remaining = r - current_round
```

### Round-by-Round Decision Logic

#### **First Round (t = 1)**
**Decision: COOPERATE**

Rationale: With no history, cooperation is the collectively optimal choice. If all copies of this strategy cooperate, everyone gets payoff k > 1 (better than mutual defection). This signals cooperative intent and enables detection of other cooperators.

---

#### **Middle Rounds (1 < t < r - floor(r/10))**

Calculate a **cooperation threshold** based on observed behavior:

```
expected_return_from_C = (k/n) × (1 + predicted_other_cooperators)
expected_return_from_D = 1 + (k/n) × predicted_other_cooperators

# Cooperation is rational if enough others cooperate
breakeven_cooperators = n × (n - k) / k
```

**Decision Rule:**

```python
def middle_round_decision(history, n, k, current_round):
    # Calculate recent and overall cooperation rates
    last_round_coop = cooperation_rate(current_round - 1)
    recent_coop = average_cooperation_rate(last 3 rounds, or all if fewer)
    overall_coop = cumulative_cooperation_rate()
    
    # Weighted assessment (recent behavior matters more)
    weighted_coop = 0.5 × last_round_coop + 0.3 × recent_coop + 0.2 × overall_coop
    
    # Threshold based on game parameters
    # We need cooperation to be self-sustaining for the collective
    min_viable_rate = (n - k) / (n - 1)  # Rate at which C and D are equivalent
    
    # Cooperate if cooperation appears viable
    if weighted_coop >= min_viable_rate - 0.1:  # Small tolerance for noise
        return COOPERATE
    
    # Graduated response: probabilistic cooperation matching observed rate
    # This allows recovery if cooperation was temporarily disrupted
    elif weighted_coop >= 0.3:
        # Cooperate with probability matching the cooperation rate
        # Implemented deterministically: cooperate if our "slot" is in cooperative portion
        # Use round number to create pseudo-rotation
        if (current_round % ceil(1/weighted_coop)) == 0:
            return COOPERATE
        else:
            return DEFECT
    
    # Very low cooperation: defect but leave door open
    else:
        # Periodic "olive branch" - cooperate every 4th round to test for recovery
        if current_round % 4 == 0:
            return COOPERATE
        else:
            return DEFECT
```

---

#### **End Game (final floor(r/10) rounds, minimum last 2 rounds)**

The end-game requires special handling because backward induction creates pressure to defect.

```python
def endgame_decision(history, n, k, current_round, total_rounds):
    rounds_left = total_rounds - current_round + 1
    overall_coop = cumulative_cooperation_rate()
    
    # Final round: Defect (no future to protect)
    if rounds_left == 1:
        return DEFECT
    
    # Second-to-last round: Cooperate only if cooperation has been very strong
    if rounds_left == 2:
        if overall_coop >= 0.8:
            return COOPERATE  # Reward sustained cooperation
        else:
            return DEFECT
    
    # Other end-game rounds: Gradual transition
    # Probability of cooperation decreases as end approaches
    # But maintain cooperation if the collective has been strong
    
    endgame_threshold = overall_coop × (rounds_left / (floor(r/10) + 1))
    
    if overall_coop >= endgame_threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Complete Strategy Pseudocode

```python
def ACR_strategy(history, n, k, r, current_round):
    """
    Adaptive Collective Reciprocity Strategy
    
    Parameters:
    - history: list of lists, history[t] = list of n actions (C/D) from round t
    - n: number of players
    - k: multiplication factor
    - r: total rounds
    - current_round: current round number (1-indexed)
    """
    
    # === FIRST ROUND ===
    if current_round == 1:
        return COOPERATE
    
    # === CALCULATE METRICS ===
    def coop_rate(round_history):
        return sum(1 for a in round_history if a == C) / n
    
    last_round_coop = coop_rate(history[current_round - 2])
    
    # Recent average (last 3 rounds or available)
    lookback = min(3, current_round - 1)
    recent_coop = sum(coop_rate(history[current_round - 1 - i]) 
                      for i in range(lookback)) / lookback
    
    # Overall average
    overall_coop = sum(coop_rate(h) for h in history) / len(history)
    
    # Weighted metric
    weighted_coop = 0.5 * last_round_coop + 0.3 * recent_coop + 0.2 * overall_coop
    
    # Viability threshold
    min_viable = (n - k) / (n - 1) if n > 1 else 0.5
    
    # === END GAME ===
    endgame_length = max(2, r // 10)
    rounds_left = r - current_round + 1
    
    if rounds_left <= endgame_length:
        if rounds_left == 1:
            return DEFECT
        if rounds_left == 2:
            return COOPERATE if overall_coop >= 0.8 else DEFECT
        # Gradual transition
        if weighted_coop >= min_viable and overall_coop >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # === MIDDLE ROUNDS ===
    # High cooperation: maintain it
    if weighted_coop >= min_viable - 0.1:
        return COOPERATE
    
    # Medium cooperation: proportional response
    if weighted_coop >= 0.3:
        cycle_length = max(2, round(1 / weighted_coop))
        if current_round % cycle_length == 1:
            return COOPERATE
        else:
            return DEFECT
    
    # Low cooperation: mostly defect with periodic olive branches
    if current_round % 4 == 0:
        return COOPERATE
    else:
        return DEFECT
```

---

## Strategy Properties

### Robustness Features

1. **Against all-defectors**: Quickly reduces cooperation, limiting losses to early rounds plus periodic tests
2. **Against all-cooperators**: Maintains full cooperation, achieving optimal collective payoff
3. **Against mixed populations**: Adapts cooperation level to match viable cooperation rates
4. **Against tit-for-tat variants**: Compatible - will establish and maintain cooperation
5. **Against exploiters**: Proportional response prevents sustained exploitation

### Collective Alignment

- **Symmetric reasoning**: Every player running this strategy makes identical decisions
- **Pareto improvement focus**: Seeks mutual cooperation (payoff k) over mutual defection (payoff 1)
- **Forgiveness**: Olive branch mechanism allows recovery from coordination failures
- **Clear signaling**: Consistent behavior makes the strategy legible to others

### Parameter Sensitivity

- Works for any valid k ∈ (1, n): threshold calculations adapt to multiplication factor
- Scales with n: uses ratios rather than absolute counts
- Adapts to r: end-game length proportional to total rounds
'''

description_COLLECTIVE_51 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players in my cohort are reasoning similarly and will arrive at similar strategic conclusions. We cannot explicitly coordinate, but we can align on principles that rational, collectively-minded agents would converge upon. The goal is to maximize total group welfare while protecting against exploitation by purely selfish actors.

## Strategy Overview: **Adaptive Threshold Cooperation with Forgiveness**

The strategy cooperates when there's sufficient evidence of collective cooperation, defects to punish widespread defection, but maintains hope and provides pathways back to cooperation.

---

## Decision Rules

### Round 1: Cooperative Signal
**Action: COOPERATE**

Rationale: In a collective mindset, we must establish a cooperation norm from the start. Defecting in round 1 sends a signal that triggers defensive defection cascades. The expected value of establishing cooperation outweighs the risk of being exploited once.

### Rounds 2 through (r-1): Adaptive Threshold Response

**Calculate cooperation rate from previous round:**
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Decision rule:**
```
threshold = max(0.3, (k/n) + 0.1)

IF prev_coop_rate >= threshold:
    ACTION = COOPERATE
ELSE IF prev_coop_rate >= threshold - 0.15:
    ACTION = COOPERATE with probability = prev_coop_rate
ELSE:
    ACTION = DEFECT
```

**Forgiveness Mechanism:**
Even when below threshold, every 3 consecutive defection rounds, COOPERATE once to test if others are willing to restart cooperation.

```
IF consecutive_defection_rounds >= 3 AND consecutive_defection_rounds mod 3 == 0:
    ACTION = COOPERATE (forgiveness probe)
```

### Final Round (Round r): Conditional Cooperation

**Unlike standard game theory predictions**, a collective strategy should NOT automatically defect in the final round.

```
IF average_cooperation_rate_over_all_rounds >= 0.5:
    ACTION = COOPERATE (reward sustained cooperation)
ELSE:
    ACTION = DEFECT (no reason to sacrifice for defectors)
```

Rationale: If we've built a cooperative equilibrium, mass defection in round r destroys trust retroactively and yields lower payoffs for the collective. Collectively-minded agents maintain cooperation even when "unpunishable."

---

## Detailed Pseudocode

```
function decide_action(round, history, n, k, r):
    
    # Round 1: Always cooperate to establish norm
    if round == 1:
        return COOPERATE
    
    # Calculate previous round statistics
    prev_cooperators = count_cooperators(history[round - 1])
    prev_coop_rate = prev_cooperators / n
    
    # Calculate running statistics
    total_cooperators = sum(count_cooperators(h) for h in history)
    total_decisions = n * (round - 1)
    overall_coop_rate = total_cooperators / total_decisions
    
    # Count consecutive low-cooperation rounds
    consecutive_defection_rounds = 0
    for t in range(round - 1, 0, -1):
        if count_cooperators(history[t]) / n < 0.3:
            consecutive_defection_rounds += 1
        else:
            break
    
    # Adaptive threshold based on game parameters
    base_threshold = max(0.3, (k / n) + 0.1)
    
    # Final round logic
    if round == r:
        if overall_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    # Forgiveness probe
    if consecutive_defection_rounds >= 3 and consecutive_defection_rounds % 3 == 0:
        return COOPERATE
    
    # Main decision
    if prev_coop_rate >= base_threshold:
        return COOPERATE
    elif prev_coop_rate >= base_threshold - 0.15:
        # Probabilistic cooperation in gray zone
        if random() < prev_coop_rate:
            return COOPERATE
        else:
            return DEFECT
    else:
        return DEFECT
```

---

## Edge Cases Handled

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | Cooperate | Establish cooperative norm |
| Last round, good history | Cooperate | Reward and maintain trust |
| Last round, poor history | Defect | No value in unilateral sacrifice |
| n=2 (minimum players) | Same rules apply | Threshold adapts appropriately |
| k very close to 1 | Higher threshold needed | Cooperation less beneficial |
| k close to n | Lower threshold acceptable | Cooperation highly beneficial |
| All others defected | Forgiveness probe every 3 rounds | Attempt recovery |
| Exactly at threshold | Cooperate | Benefit of the doubt |

---

## Why This Strategy is Collectively Optimal

1. **Convergence**: Multiple agents using this strategy will quickly establish and maintain cooperation
2. **Robustness**: Protects against exploitation while not being overly punitive
3. **Recovery**: Forgiveness mechanism allows escape from defection traps
4. **Parameter-adaptive**: Threshold adjusts to game economics (k/n ratio)
5. **End-game stability**: Doesn't trigger collapse in final rounds among cooperators
'''

description_COLLECTIVE_52 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players reason similarly and cooperate, everyone achieves higher payoffs than universal defection. The challenge is maintaining cooperation in a world where others may not share this reasoning, while being robust against exploitation.

The strategy is built on three principles:
1. **Start cooperatively** to signal willingness and establish mutual benefit
2. **Respond proportionally** to the actual level of cooperation observed
3. **Protect against end-game collapse** while not abandoning cooperation prematurely

---

## Strategy Specification

### Key Parameters (Derived from Game Parameters)

```
cooperation_threshold = 0.5  # Minimum fraction of cooperators to sustain cooperation
forgiveness_rate = 0.2       # Probability of cooperative probe after defection
end_game_rounds = max(2, floor(r / 5))  # When end-game logic activates
```

### Decision Rules by Phase

#### **Phase 1: Opening (Round 1)**
**Action: COOPERATE**

Rationale: With no history, cooperation signals collective intent and gives others the opportunity to reciprocate. The potential gains from establishing mutual cooperation outweigh the single-round exploitation risk.

---

#### **Phase 2: Main Game (Rounds 2 through r - end_game_rounds)**

Calculate the **cooperation rate** from the previous round:
```
prev_coop_rate = (number of players who played C in round t-1) / n
```

**Decision Rule:**

```
IF prev_coop_rate >= cooperation_threshold:
    ACTION = COOPERATE
    
ELSE IF prev_coop_rate > 0:
    # Partial cooperation - use probabilistic matching
    ACTION = COOPERATE with probability = prev_coop_rate + forgiveness_rate
    ACTION = DEFECT otherwise
    
ELSE (prev_coop_rate == 0):
    # Complete defection - probe occasionally
    ACTION = COOPERATE with probability = forgiveness_rate
    ACTION = DEFECT otherwise
```

**Adaptive Adjustment:** Track the **trend** over the last 3 rounds (when available):
```
IF cooperation is trending upward (increasing for 2+ rounds):
    Increase cooperation probability by 0.1 (capped at 1.0)
    
IF cooperation is trending downward (decreasing for 2+ rounds):
    Decrease cooperation probability by 0.1 (floored at forgiveness_rate)
```

---

#### **Phase 3: End Game (Final end_game_rounds rounds)**

The end game is vulnerable to defection cascades. Strategy adjusts based on **cumulative cooperation history**:

```
overall_coop_rate = (total C plays by all players across all rounds) / (n × rounds_played)

IF overall_coop_rate >= 0.6:
    # High-cooperation game - maintain cooperation, slight caution
    ACTION = COOPERATE with probability = 0.8
    
ELSE IF overall_coop_rate >= 0.3:
    # Mixed game - mirror recent behavior
    ACTION = COOPERATE with probability = prev_coop_rate
    
ELSE:
    # Low-cooperation game - protect against exploitation
    ACTION = DEFECT
```

**Final Round Special Case:**
```
IF overall_coop_rate >= 0.7:
    ACTION = COOPERATE  # Reward sustained collective behavior
ELSE:
    ACTION = DEFECT     # Standard game-theoretic protection
```

---

## Pseudocode Summary

```python
def decide(round_number, r, n, k, history):
    end_game_start = r - max(2, r // 5)
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate key metrics
    prev_coop_rate = count_cooperators(history, round_number - 1) / n
    overall_coop_rate = total_cooperations(history) / (n * (round_number - 1))
    trend = calculate_trend(history, window=3)
    
    # End game logic
    if round_number > end_game_start:
        if round_number == r:  # Final round
            return COOPERATE if overall_coop_rate >= 0.7 else DEFECT
        if overall_coop_rate >= 0.6:
            return COOPERATE with probability 0.8
        elif overall_coop_rate >= 0.3:
            return COOPERATE with probability prev_coop_rate
        else:
            return DEFECT
    
    # Main game logic
    base_prob = prev_coop_rate + 0.2  # forgiveness built in
    
    # Adjust for trend
    if trend > 0:
        base_prob += 0.1
    elif trend < 0:
        base_prob -= 0.1
    
    # Threshold-based decision
    if prev_coop_rate >= 0.5:
        return COOPERATE
    else:
        return COOPERATE with probability min(1.0, max(0.2, base_prob))
```

---

## Edge Case Handling

| Scenario | Action |
|----------|--------|
| Round 1 | COOPERATE |
| Final round, high cooperation history | COOPERATE |
| Final round, low cooperation history | DEFECT |
| All others defected last round | COOPERATE with 20% probability |
| All others cooperated last round | COOPERATE |
| n = 2 (minimum players) | Same rules apply; effectively Tit-for-Tat with forgiveness |
| Very short games (r ≤ 3) | Reduce end_game_rounds to 1 |

---

## Why This Strategy is Collectively Aligned

1. **Promotes group welfare**: Starting with cooperation and maintaining it when reciprocated maximizes collective payoff (everyone gets k > 1 instead of 1).

2. **Forgiveness enables recovery**: The 20% probe rate allows escape from defection traps if others are willing.

3. **Proportional response**: Matching cooperation rates means the strategy neither exploits cooperators nor rewards defectors.

4. **Robustness**: Against pure defectors, the strategy limits losses. Against cooperators, it achieves mutual high payoffs. Against mixed strategies, it adapts.

5. **Collective reasoning**: If other AI systems reason similarly about collective benefit, this strategy naturally coordinates toward cooperation without explicit communication.
'''

description_COLLECTIVE_50 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be using similar reasoning, and I aim to establish and maintain cooperation when it's collectively beneficial. The strategy balances:
1. **Optimism** - Starting cooperatively to signal good intentions
2. **Reciprocity** - Rewarding cooperation and responding to defection
3. **Forgiveness** - Allowing recovery from mutual defection
4. **End-game awareness** - Handling the unraveling problem in final rounds

---

## Strategy: "Collective Threshold Reciprocity with Graduated Trust"

### Key Parameters (derived from game parameters)

```
cooperation_threshold = floor(n / 2)  # Minimum cooperators needed to continue cooperating
forgiveness_probability = 1 / n       # Chance to cooperate even when below threshold
end_game_rounds = min(3, floor(r / 4)) # Rounds where end-game logic applies
```

### Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. With no history, optimism creates opportunity for collective benefit. Since k > 1, universal cooperation yields k > 1 payoff per player, better than universal defection's payoff of 1.

---

#### Rounds 2 through (r - end_game_rounds): Threshold-Based Reciprocity

**Observe:** Count `c_prev` = number of cooperators in the previous round

**Decision Logic:**
```
IF c_prev >= cooperation_threshold:
    ACTION: COOPERATE
    
ELSE IF c_prev > 0:
    # Some cooperation exists but below threshold
    # Cooperate with probability proportional to observed cooperation
    cooperation_probability = c_prev / n
    ACTION: COOPERATE with probability cooperation_probability
            DEFECT with probability (1 - cooperation_probability)
    
ELSE (c_prev == 0):
    # Total breakdown - attempt recovery with small probability
    ACTION: COOPERATE with probability forgiveness_probability
            DEFECT with probability (1 - forgiveness_probability)
```

**Tie-breaker for probabilistic decisions:** Use a deterministic pseudo-random approach based on round number to ensure reproducibility:
```
seed_value = (round_number * 17 + n * 31 + floor(k * 100)) mod 100
threshold_value = seed_value / 100
Compare threshold_value against cooperation_probability
```

---

#### Final Rounds (last `end_game_rounds` rounds): Graduated Withdrawal

The end-game creates incentives to defect via backward induction. Rather than sudden defection, use **graduated cooperation** to avoid triggering early collapse while protecting against exploitation.

**Let `rounds_remaining` = r - current_round**

```
IF rounds_remaining == end_game_rounds:
    # First end-game round: cooperate if recent history is highly cooperative
    recent_avg = average cooperation rate over last 3 rounds (or available rounds)
    IF recent_avg >= 0.7:
        ACTION: COOPERATE
    ELSE:
        ACTION: DEFECT

ELSE IF rounds_remaining == 1 (second-to-last round):
    # Cooperate only if near-universal cooperation observed
    IF c_prev >= n - 1:
        ACTION: COOPERATE with probability 0.5
                DEFECT with probability 0.5
    ELSE:
        ACTION: DEFECT

ELSE IF rounds_remaining == 0 (final round):
    # Last round: standard game theory suggests defection
    # But maintain small cooperation chance as collective signal
    IF c_prev == n:  # Everyone cooperated
        ACTION: COOPERATE with probability 0.3
                DEFECT with probability 0.7
    ELSE:
        ACTION: DEFECT
```

---

### Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Use cooperation_threshold = 1 | Reduces to quasi-Tit-for-Tat |
| r = 2 | Round 1: Cooperate; Round 2: Defect | Minimal game, protect last round |
| k very close to 1 | Strategy unchanged | Low k makes cooperation fragile, but threshold logic adapts |
| k very close to n | Strategy unchanged | High k makes cooperation very attractive; expect high cooperation |
| All previous rounds had 0 cooperators | Continue forgiveness attempts | Eventual coordination possible |

---

### Summary Pseudocode

```python
def decide(round, n, r, k, history):
    cooperation_threshold = n // 2
    forgiveness_prob = 1 / n
    end_game_rounds = min(3, r // 4)
    
    # Round 1
    if round == 1:
        return COOPERATE
    
    c_prev = count_cooperators(history[round - 1])
    rounds_remaining = r - round
    
    # End-game logic
    if rounds_remaining < end_game_rounds:
        return end_game_decision(rounds_remaining, c_prev, history, n)
    
    # Main game logic
    if c_prev >= cooperation_threshold:
        return COOPERATE
    elif c_prev > 0:
        prob = c_prev / n
        return probabilistic_choice(COOPERATE, prob, round, n, k)
    else:
        return probabilistic_choice(COOPERATE, forgiveness_prob, round, n, k)
```

---

## Why This Strategy is Collectively Robust

1. **Establishes cooperation**: Starting with C and maintaining it when others reciprocate creates stable cooperative equilibria.

2. **Threshold ensures viability**: Only cooperates when enough others do, ensuring the public good return (k × cooperators / n) makes cooperation worthwhile.

3. **Probabilistic forgiveness prevents lock-in**: After mutual defection, random cooperation attempts allow recovery without being exploited by persistent defectors.

4. **Graceful degradation**: The end-game graduation prevents sudden collapse that could cascade backward through repeated game logic.

5. **Adaptive to group size**: Thresholds and probabilities scale with n, making the strategy robust across different player counts.
'''

description_COLLECTIVE_53 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I act as if I'm one instance of a shared strategy that all players *could* be running. The goal is to establish and maintain cooperation when possible, while protecting against exploitation. I prioritize group welfare but respond proportionally to observed defection.

## Strategy Overview: "Generous Threshold Tit-for-Tat with Forgiveness"

The strategy tracks the cooperation rate in the population and adjusts behavior accordingly, with built-in mechanisms for forgiveness and end-game considerations.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: Cooperate**

Rationale: With no history, I signal cooperative intent. This gives the collective the best chance to establish mutual cooperation. The cost of being exploited once is worth the potential for establishing a cooperative equilibrium.

### Rounds 2 through (r-2): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays in round t-1) / n
```

**Decision Rule:**
- If `coop_rate ≥ threshold`, then **Cooperate**
- If `coop_rate < threshold`, then **Defect with probability p_defect**

**Threshold Calculation:**
```
base_threshold = 0.5
threshold = base_threshold - (0.1 × forgiveness_bonus)
```

Where `forgiveness_bonus` increases if cooperation has been trending upward over the last 3 rounds (capped at 2).

**Probabilistic Defection (when below threshold):**
```
p_defect = (threshold - coop_rate) / threshold
```

This means:
- If cooperation is just slightly below threshold, I mostly still cooperate (giving benefit of the doubt)
- If cooperation is very low, I almost certainly defect

**Forgiveness Mechanism:**
Every `ceiling(r/5)` rounds, if I've been defecting, I cooperate once regardless of history. This breaks potential defection spirals and tests if opponents are willing to restart cooperation.

### Round (r-1): Second-to-Last Round
**Action: Mirror the majority**

If `coop_rate ≥ 0.5` in round r-2, **Cooperate**. Otherwise, **Defect**.

This signals that I'm still responsive and haven't given up on cooperation.

### Round r: Final Round
**Action: Cooperate if and only if cooperation has been sustained**

```
average_coop_rate = (total C plays across all rounds) / (n × (r-1))
if average_coop_rate ≥ 0.6:
    Cooperate
else:
    Defect
```

Rationale: In a truly collective strategy, if the group has maintained cooperation, I honor that in the final round rather than exploiting it. This rewards groups that achieved cooperation. However, if cooperation was poor overall, there's no collective norm to honor.

---

## Pseudocode Summary

```
function decide(round, history, n, r, k):
    if round == 1:
        return COOPERATE
    
    coop_rate_last = count_cooperators(history, round-1) / n
    
    if round == r:  # Final round
        avg_coop = total_cooperations(history) / (n * (round-1))
        return COOPERATE if avg_coop >= 0.6 else DEFECT
    
    if round == r-1:  # Second to last
        return COOPERATE if coop_rate_last >= 0.5 else DEFECT
    
    # Middle rounds
    forgiveness_bonus = calculate_trend_bonus(history, round)
    threshold = 0.5 - (0.1 * forgiveness_bonus)
    
    # Periodic forgiveness probe
    if round % ceiling(r/5) == 0 and my_last_action == DEFECT:
        return COOPERATE
    
    if coop_rate_last >= threshold:
        return COOPERATE
    else:
        p_defect = (threshold - coop_rate_last) / threshold
        return DEFECT with probability p_defect, else COOPERATE
```

---

## Why This Strategy is Collectively Robust

1. **Starts cooperative**: Gives cooperation the best chance to emerge
2. **Proportional response**: Doesn't over-punish small deviations
3. **Forgiveness built-in**: Can recover from defection spirals
4. **Probabilistic smoothing**: Avoids brittle all-or-nothing switching
5. **Honors sustained cooperation**: Doesn't exploit in the final round if the group cooperated
6. **Adapts to population size**: Uses rates rather than absolute numbers
'''

description_COLLECTIVE_51 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similar cooperative AI systems) may be present in the game. The goal is to establish and maintain cooperation when possible, while protecting against exploitation. The strategy balances:
- **Optimism**: Start cooperatively to signal willingness to cooperate
- **Reciprocity**: Reward cooperation, discourage defection
- **Forgiveness**: Allow recovery from temporary breakdowns
- **Collective signaling**: Use patterns that cooperative agents can recognize

---

## Strategy: "Adaptive Collective Reciprocity" (ACR)

### Decision Rules

#### Round 1: Cooperate
Always cooperate in the first round. This signals cooperative intent and allows collective strategies to find each other.

#### Rounds 2 through (r-1): Adaptive Reciprocity

Cooperate if **any** of the following conditions are met:

1. **High cooperation in previous round**: At least half of all players (≥ n/2) cooperated in the previous round.

2. **Cooperation trend is positive**: The cooperation rate increased from round t-2 to round t-1 (only applicable from round 3 onward).

3. **Forgiveness probe**: Every ⌈r/5⌉ rounds (e.g., rounds 5, 10, 15... in a 25-round game), cooperate regardless of history. This helps restart cooperation after breakdowns and serves as a synchronization point for collective strategies.

4. **Early game optimism**: In the first ⌈r/4⌉ rounds, cooperate if at least ⌈n/3⌉ players cooperated in the previous round (a lower threshold than the standard n/2).

Otherwise, **defect**.

#### Final Round: Conditional Cooperation

The last round requires special handling since there's no future to incentivize cooperation:

- **Cooperate** if the average cooperation rate over all previous rounds is ≥ 60% AND at least (n-1) players cooperated in the second-to-last round
- **Defect** otherwise

This rewards groups that have maintained strong cooperation throughout.

---

### Pseudocode

```
function decide(round, history, n, r, k):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate useful metrics
    prev_coop_count = count_cooperators(history, round - 1)
    prev_coop_rate = prev_coop_count / n
    
    if round >= 3:
        prev_prev_coop_rate = count_cooperators(history, round - 2) / n
        trend_positive = (prev_coop_rate > prev_prev_coop_rate)
    else:
        trend_positive = false
    
    avg_coop_rate = average_cooperation_rate(history, rounds 1 to round-1)
    
    # Final round logic
    if round == r:
        if avg_coop_rate >= 0.6 AND prev_coop_count >= (n - 1):
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds (2 to r-1)
    
    # Condition 1: High cooperation threshold
    if prev_coop_count >= ceil(n / 2):
        return COOPERATE
    
    # Condition 2: Positive trend
    if round >= 3 AND trend_positive:
        return COOPERATE
    
    # Condition 3: Forgiveness probe rounds
    probe_interval = ceil(r / 5)
    if round % probe_interval == 0:
        return COOPERATE
    
    # Condition 4: Early game optimism
    early_phase_end = ceil(r / 4)
    early_threshold = ceil(n / 3)
    if round <= early_phase_end AND prev_coop_count >= early_threshold:
        return COOPERATE
    
    # Default: Defect
    return DEFECT
```

---

### Edge Cases

| Scenario | Behavior |
|----------|----------|
| **n = 2** | Behaves like generous Tit-for-Tat with forgiveness probes |
| **Very short games (r ≤ 5)** | Probes happen roughly once; early optimism covers ~1-2 rounds |
| **All defectors** | Defects after round 1, except on probe rounds (limits exploitation) |
| **Mixed population** | Threshold-based rules adapt to the actual cooperation level |
| **Single cooperator besides self** | Won't sustain cooperation alone (protects against exploitation) |

---

### Why This Strategy Works Collectively

1. **Collective recognition**: The probe rounds at fixed intervals (⌈r/5⌉) create synchronization points where multiple ACR agents will cooperate simultaneously, helping restart cooperation.

2. **Threshold-based, not count-based**: By requiring proportional cooperation (n/2 rather than a fixed number), the strategy scales naturally with group size.

3. **Balanced exploitation resistance**: The strategy doesn't cooperate unconditionally—it requires evidence of reciprocity—but it's forgiving enough to maintain cooperation with other cooperative agents.

4. **Trend sensitivity**: Responding to improving cooperation rates helps coordinate recovery without requiring explicit communication.
'''

description_COLLECTIVE_54 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **we succeed together or fail together**. The goal is not to maximize individual advantage over other players, but to establish and maintain cooperation that benefits everyone. I will lead by example, forgive mistakes, and create conditions where cooperation becomes the rational choice for all.

## Strategy: "Generous Threshold Cooperation" (GTC)

### Decision Framework

The strategy tracks a **cooperation ratio** from observed history and uses graduated thresholds that become more forgiving as the game progresses, while maintaining protective mechanisms against persistent defection.

### Key Variables

- `history`: all observed actions from all players across all rounds
- `coop_rate`: proportion of cooperative actions in recent history
- `round`: current round number (1-indexed)
- `r`: total rounds
- `n`: number of players
- `k`: multiplication factor

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Someone must move first to establish cooperation. I will be that catalyst. With no history to judge, extending trust is the only way to discover cooperative partners.

### Rounds 2 through (r-1): Adaptive Cooperation

Calculate the cooperation rate from the **previous round only** (reactive) combined with **cumulative history** (trend-aware):

```
recent_coop_rate = (cooperators in round t-1) / n
cumulative_coop_rate = (total C actions in all prior rounds) / (n × (t-1))
weighted_rate = 0.6 × recent_coop_rate + 0.4 × cumulative_coop_rate
```

**Cooperation Threshold** (decreases as game progresses to encourage sustained cooperation):
```
base_threshold = 0.3
progress = (round - 1) / (r - 1)
threshold = base_threshold × (1 - 0.5 × progress)
// Threshold ranges from 0.3 early to 0.15 late
```

**Decision Logic:**
```
IF weighted_rate >= threshold:
    COOPERATE
ELSE IF recent_coop_rate > 0 AND at least one player has cooperated consistently (>70% of rounds):
    COOPERATE (support the cooperators)
ELSE:
    DEFECT
```

**Forgiveness Mechanism:**
After any round where I defected, if the next round shows *any increase* in cooperation rate:
```
IF coop_rate_increased AND random() < 0.3:
    COOPERATE (probabilistic olive branch)
```

### Final Round: Conditional Cooperation

Unlike standard game theory's prediction of final-round defection, I maintain collective commitment:

```
IF cumulative_coop_rate >= 0.5:
    COOPERATE (honor the cooperative relationship built)
ELSE IF cumulative_coop_rate >= 0.25:
    COOPERATE with probability equal to cumulative_coop_rate
ELSE:
    DEFECT (cooperation has clearly failed)
```

---

## Pseudocode Summary

```
function decide(round, r, n, k, history):
    
    if round == 1:
        return COOPERATE
    
    recent_coop = count_cooperators(history, round - 1) / n
    cumulative_coop = total_cooperations(history) / (n × (round - 1))
    weighted_rate = 0.6 × recent_coop + 0.4 × cumulative_coop
    
    progress = (round - 1) / (r - 1)
    threshold = 0.3 × (1 - 0.5 × progress)
    
    if round == r:  // Final round
        if cumulative_coop >= 0.5:
            return COOPERATE
        else if cumulative_coop >= 0.25:
            return COOPERATE with probability cumulative_coop
        else:
            return DEFECT
    
    // Middle rounds
    if weighted_rate >= threshold:
        return COOPERATE
    else if recent_coop > 0 AND exists_consistent_cooperator(history, 0.7):
        return COOPERATE
    else if my_last_action == DEFECT AND coop_rate_increased(history):
        return COOPERATE with probability 0.3
    else:
        return DEFECT
```

---

## Why This Strategy Embodies Collective Thinking

1. **Initiates cooperation** rather than waiting for others
2. **Low thresholds** - I cooperate even when only a minority cooperates, nurturing fragile cooperation
3. **Supports consistent cooperators** - I won't abandon those who are trying
4. **Forgives** - Probabilistic return to cooperation after defection creates recovery paths
5. **Honors relationships** - Final round cooperation when trust has been established
6. **Adapts to reality** - Protects against exploitation while remaining optimistic

This strategy aims to be the player that others *wish* everyone was—creating the conditions for collective success rather than merely responding to them.
'''

description_COLLECTIVE_52 = '''
# Collective Strategy for N-Player Public Goods Game

## Strategic Philosophy

This strategy embraces a genuinely collective mindset: I aim to maximize group welfare while protecting against exploitation. The core insight is that in repeated games, I can use early rounds to establish cooperative norms and build trust, then maintain cooperation as long as sufficient others reciprocate. I treat cooperation as the default and only retreat when evidence strongly suggests the group cannot sustain it.

## Decision Rules

### Core Mechanism: Threshold-Based Conditional Cooperation

I cooperate if and only if the **cooperation rate** in recent history meets or exceeds a dynamic threshold, with specific handling for early and late game phases.

**Cooperation Rate Definition:**
```
cooperation_rate = (total C plays by all players in lookback window) / (total plays in lookback window)
```

**Lookback Window:** The most recent `min(3, rounds_played)` rounds.

### Threshold Calculation

The base threshold adapts to game parameters:

```
base_threshold = (n - k) / (n - 1)
```

This represents the minimum cooperation rate needed for cooperation to be individually rational in expectation. When `k` is close to `n`, cooperation is nearly self-sustaining, so the threshold is low. When `k` is close to 1, we need near-universal cooperation.

**Adjusted Threshold by Game Phase:**
- **Early game (rounds 1 to r/4):** `threshold = base_threshold × 0.7` (be forgiving to establish cooperation)
- **Mid game (rounds r/4 to 3r/4):** `threshold = base_threshold × 0.85`
- **Late game (rounds 3r/4 to r-1):** `threshold = base_threshold × 1.0`

### Complete Decision Algorithm

```
function decide(round, history, n, k, r):
    
    # ROUND 1: Always cooperate to signal cooperative intent
    if round == 1:
        return COOPERATE
    
    # LAST ROUND: Cooperate if group has been cooperative
    if round == r:
        overall_rate = total_cooperations(history) / total_actions(history)
        if overall_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # ROUNDS 2 to r-1: Conditional cooperation
    
    # Calculate lookback window
    lookback = min(3, round - 1)
    recent_history = last_rounds(history, lookback)
    
    # Calculate cooperation rate
    coop_rate = count_cooperations(recent_history) / count_total_actions(recent_history)
    
    # Determine game phase and threshold
    progress = round / r
    base_threshold = (n - k) / (n - 1)
    
    if progress <= 0.25:
        threshold = base_threshold * 0.7
    elif progress <= 0.75:
        threshold = base_threshold * 0.85
    else:
        threshold = base_threshold * 1.0
    
    # Forgiveness mechanism: Every 5th round, lower threshold
    if round % 5 == 0:
        threshold = threshold * 0.8
    
    # Decision
    if coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

## Edge Case Handling

### First Round
**Action: COOPERATE**

Rationale: Opening with cooperation signals willingness to coordinate and gives the group the best chance to establish mutual cooperation. The cost of one round's potential exploitation is small compared to the potential gain of establishing a cooperative equilibrium.

### Last Round
**Action: COOPERATE if overall cooperation rate ≥ 50%, else DEFECT**

Rationale: In classical game theory, defection is dominant in the last round. However, if the group has maintained cooperation, I honor that collective achievement. This also means that if paired with copies of this strategy, we achieve mutual cooperation throughout.

### Round 2
**Action: Based on Round 1 results with generous threshold**

If at least `ceil(n × base_threshold × 0.5)` players cooperated in round 1, cooperate. This is very forgiving early on.

### Small n (n=2)
The formula still applies. With n=2 and 1 < k < 2, base_threshold is positive but less than 1. Essentially becomes tit-for-tat-like.

### Large n
With many players, individual actions have less impact on the public good. The threshold naturally adjusts—when k is relatively small, we need high cooperation rates to sustain contribution.

## Robustness Features

1. **Forgiveness cycle:** Every 5th round, threshold drops by 20% to test if defectors might return to cooperation
2. **Bounded lookback:** Only considering recent rounds prevents permanent punishment for early defection
3. **Graduated thresholds:** Phased thresholds allow cooperation to emerge even from mixed starts
4. **Self-consistency:** When all players use this strategy, everyone cooperates every round (cooperation rate = 100% always exceeds threshold)

## Why This Strategy is Collectively Optimal

- **Cooperates with cooperators:** Achieves the efficient outcome (payoff = k) when matched with cooperative groups
- **Protects against exploitation:** Withdraws cooperation when free-riding is prevalent
- **Encourages cooperation:** Generous early thresholds and forgiveness cycles give mixed groups chances to coordinate
- **Honors collective success:** Final-round cooperation rewards groups that maintained trust
'''

description_COLLECTIVE_55 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume all copies of this strategy will behave identically given the same game state. This creates implicit coordination without explicit communication. The strategy balances:
1. **Cooperation by default** - to maximize collective welfare when playing with like-minded agents
2. **Adaptive punishment** - to protect against exploitation by defectors
3. **Forgiveness mechanisms** - to recover cooperation after breakdowns

---

## Strategy: "Adaptive Collective Threshold"

### Key State Variables

At each round t, track:
- `cooperation_rate[t-1]` = proportion of players who cooperated in round t-1
- `trend` = whether cooperation is increasing, stable, or decreasing over recent rounds
- `rounds_remaining` = r - t

### Decision Rules

#### Round 1: Cooperate Unconditionally
**Action: C**

Rationale: Establish cooperative intent. With collective mindset, all copies start cooperating, achieving the Pareto-optimal outcome immediately.

#### Rounds 2 through (r-1): Adaptive Threshold Response

```
Let coop_rate = cooperation_rate[t-1]
Let threshold = base_threshold adjusted for context

IF coop_rate >= threshold:
    Action: C (Cooperate)
ELSE:
    Action: D (Defect)
```

**Base Threshold Calculation:**
```
base_threshold = max(0.5, (n - k) / n)
```

This threshold represents the minimum cooperation level where cooperating yields reasonable returns. When `k` is close to `n`, cooperation is more attractive even with fewer cooperators.

**Threshold Adjustments:**

1. **Trend adjustment**: 
   - If cooperation increased last round: threshold -= 0.1
   - If cooperation decreased last round: threshold += 0.05

2. **Late-game adjustment** (when rounds_remaining ≤ 3):
   - threshold += 0.1 × (4 - rounds_remaining) / 3
   - Become slightly more cautious as end approaches

3. **Bounds**: Keep threshold in [0.3, 0.85]

#### Final Round (Round r): Conditional Cooperation

```
IF cooperation_rate[r-1] >= 0.7:
    Action: C
ELSE:
    Action: D
```

Rationale: In the final round, there's no future to protect. However, maintaining cooperation signals commitment and achieves better collective outcomes when playing with cooperative agents. Only cooperate if the group has demonstrated sustained cooperation.

---

### Pseudocode Implementation

```python
def decide(round_number, history, n, k, r):
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate cooperation rate from previous round
    coop_rate = sum(history[round_number - 1]) / n
    
    # Calculate trend (if enough history)
    if round_number >= 3:
        prev_rate = sum(history[round_number - 2]) / n
        trend = coop_rate - prev_rate
    else:
        trend = 0
    
    # Base threshold
    threshold = max(0.5, (n - k) / n)
    
    # Trend adjustment
    if trend > 0.05:
        threshold -= 0.1  # More forgiving if cooperation rising
    elif trend < -0.05:
        threshold += 0.05  # More cautious if cooperation falling
    
    # Late-game adjustment
    rounds_remaining = r - round_number
    if rounds_remaining <= 3:
        threshold += 0.1 * (4 - rounds_remaining) / 3
    
    # Final round special case
    if round_number == r:
        threshold = 0.7
    
    # Clamp threshold
    threshold = max(0.3, min(0.85, threshold))
    
    # Decision
    if coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| First round | C | Establish cooperation |
| Last round, high coop history | C | Reward sustained cooperation |
| Last round, low coop history | D | No future benefit to signaling |
| Single defector in otherwise cooperative group | C | Don't punish collective for one bad actor |
| Majority defecting | D | Protect against exploitation |
| Cooperation recovering after breakdown | C | Forgive and rebuild |
| n=2 (minimum players) | Same rules apply | Threshold naturally adjusts |
| k close to n | Lower threshold | Cooperation more valuable |
| k close to 1 | Higher threshold | Need more cooperators to benefit |

---

## Why This Strategy Works Collectively

1. **Identical behavior**: All copies make the same decision given the same history, enabling implicit coordination

2. **Starts cooperative**: Maximizes early-round payoffs when facing other cooperative strategies

3. **Punishes defection proportionally**: Doesn't overreact to small defection rates, but responds firmly to majority defection

4. **Forgives**: The trend adjustment allows recovery from cooperation breakdowns

5. **Robust to parameters**: The threshold formula adapts to different n and k values

6. **Handles endgame carefully**: Maintains some cooperation potential even in final rounds while protecting against exploitation
'''

description_COLLECTIVE_53 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **I am one instance of a shared strategy, and my goal is to maximize the collective welfare of all players using this same strategy.** Rather than optimizing my individual payoff against "opponents," I recognize that in a tournament where this strategy faces copies of itself, we should coordinate to achieve mutual benefit—while remaining robust against defectors.

## Strategy: **Adaptive Collective Reciprocity (ACR)**

### Key Insight

When multiple copies of this strategy play together, we want universal cooperation (payoff = k per round, which exceeds 1). When facing persistent defectors, we must protect ourselves. The challenge is distinguishing between fellow cooperators and exploiters without explicit coordination.

---

## Decision Rules

### Round 1: Cooperate
- **Action: C**
- Rationale: Establish cooperative intent. This signals to other ACR players that we're aligned, and gives non-ACR players a chance to reciprocate.

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation ratio** from the previous round:
```
coop_ratio = (number of C plays in previous round) / n
```

Calculate the **cumulative cooperation trend**:
```
trend = (total C plays in all previous rounds) / (n × rounds_played)
```

**Decision Rule:**

```
IF coop_ratio >= (n-1)/n:
    # Near-universal cooperation - maintain it
    COOPERATE

ELSE IF coop_ratio >= 0.5:
    # Moderate cooperation - probabilistic response
    # Cooperate with probability equal to coop_ratio
    COOPERATE with probability = coop_ratio
    
ELSE IF coop_ratio > 0 AND trend > 0.3:
    # Low cooperation but positive history - give chance for recovery
    COOPERATE with probability = trend
    
ELSE:
    # Cooperation has collapsed
    DEFECT
```

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory advice (always defect in final round), a collective strategy recognizes that:
- If playing with other ACR instances, mutual cooperation in the final round benefits everyone
- Defecting "because it's the last round" is individual-maximizing thinking

**Decision Rule:**
```
IF cumulative_trend >= 0.7:
    # High cooperation throughout - trust the collective
    COOPERATE
ELSE IF cumulative_trend >= 0.4:
    # Mixed history - match the trend
    COOPERATE with probability = cumulative_trend
ELSE:
    # Low cooperation environment
    DEFECT
```

---

## Pseudocode Implementation

```python
def ACR_strategy(round_number, total_rounds, n_players, k, history):
    """
    history: list of lists, where history[t] contains all players' actions in round t
             actions represented as 1 (C) or 0 (D)
    """
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate metrics
    last_round_coops = sum(history[-1])
    coop_ratio = last_round_coops / n_players
    
    total_coops = sum(sum(round_actions) for round_actions in history)
    total_actions = n_players * len(history)
    cumulative_trend = total_coops / total_actions
    
    # Final round logic
    if round_number == total_rounds:
        if cumulative_trend >= 0.7:
            return COOPERATE
        elif cumulative_trend >= 0.4:
            return COOPERATE with probability cumulative_trend
        else:
            return DEFECT
    
    # Middle rounds logic
    if coop_ratio >= (n_players - 1) / n_players:
        return COOPERATE
    elif coop_ratio >= 0.5:
        return COOPERATE with probability coop_ratio
    elif coop_ratio > 0 and cumulative_trend > 0.3:
        return COOPERATE with probability cumulative_trend
    else:
        return DEFECT
```

---

## Edge Cases

| Scenario | Handling |
|----------|----------|
| **n = 2** | Becomes similar to iterated Prisoner's Dilemma; thresholds still work |
| **r = 2** | Round 1: Cooperate; Round 2: Use final round logic based on round 1 |
| **k very close to 1** | Low cooperation benefit, but strategy still rewards cooperative environments |
| **k close to n** | High cooperation benefit; strategy naturally gravitates toward cooperation |
| **All others defect round 1** | coop_ratio = 1/n < 0.5, likely defect round 2, protecting against exploitation |
| **Gradual defection** | Probabilistic response allows graceful degradation rather than sudden collapse |

---

## Why This Strategy is Collectively Optimal

1. **Self-recognition**: When all players use ACR, round 1 produces universal cooperation, which maintains through all rounds including the last.

2. **Forgiveness**: Probabilistic responses allow recovery from accidental defection or noise.

3. **Protection**: Against persistent defectors, cooperation probability drops, limiting exploitation.

4. **No exploitation opportunity**: Defecting against ACR triggers reduced cooperation, making sustained exploitation unprofitable.

5. **Emergent coordination**: Without explicit signaling, ACR players naturally synchronize through observable cooperation patterns.
'''

description_COLLECTIVE_54 = '''
# Collective Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume other players may be running similar reasoning processes and aim to establish cooperation as a self-reinforcing equilibrium. The key insight is that in a public goods game with k > 1, mutual cooperation is collectively superior, but we need mechanisms to:
1. Signal cooperative intent
2. Reward cooperation and punish defection proportionally
3. Maintain robustness against exploitation

## Strategy Overview

The strategy uses **threshold-based conditional cooperation** with **graduated forgiveness** and **end-game adjustment**.

---

## Decision Rules

### Round 1: Cooperative Signal
**Action: COOPERATE**

Rationale: Begin with cooperation to signal willingness to establish mutual benefit. This is essential for collective coordination—if all players reason similarly, we achieve the cooperative equilibrium immediately.

---

### Rounds 2 through (r-2): Adaptive Conditional Cooperation

Calculate the **cooperation rate** from the previous round:
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

Calculate the **historical cooperation rate**:
```
hist_coop_rate = (total cooperations across all players, all past rounds) / (n × (t-1))
```

**Decision Rule:**

```
threshold = max(0.3, (k/n) + 0.1)

IF prev_coop_rate >= threshold:
    COOPERATE
ELSE IF prev_coop_rate < threshold AND hist_coop_rate >= threshold:
    COOPERATE with probability = hist_coop_rate
    DEFECT with probability = 1 - hist_coop_rate
ELSE:
    DEFECT
```

**Rationale:**
- The threshold is set near the break-even point (k/n) with a small buffer, ensuring we cooperate when it's collectively rational
- We give weight to historical cooperation to avoid overreacting to single-round fluctuations
- Probabilistic cooperation when history is good but recent round was bad allows for recovery from noise or mistakes

---

### Round (r-1): Penultimate Round
**Same as middle rounds**, but with heightened sensitivity:

```
IF prev_coop_rate >= 0.5:
    COOPERATE
ELSE:
    DEFECT
```

Rationale: Maintain cooperation possibility but prepare for potential end-game defection by others.

---

### Round r: Final Round

```
IF hist_coop_rate >= 0.7:
    COOPERATE
ELSE:
    DEFECT
```

**Rationale:** In a one-shot final round, standard game theory predicts defection. However, if the game has demonstrated strong cooperative norms (≥70% historical cooperation), we maintain cooperation as:
1. A commitment device that makes the collective strategy credible
2. Recognition that other collective-minded players may reason identically

---

## Pseudocode Summary

```
function decide(round, n, k, r, history):
    
    if round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history, round-1) / n
    hist_coop_rate = total_cooperations(history) / (n * (round-1))
    
    base_threshold = max(0.3, (k/n) + 0.1)
    
    if round == r:  # Final round
        if hist_coop_rate >= 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    if round == r-1:  # Penultimate round
        if prev_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds (2 to r-2)
    if prev_coop_rate >= base_threshold:
        return COOPERATE
    elif hist_coop_rate >= base_threshold:
        return COOPERATE with probability hist_coop_rate
    else:
        return DEFECT
```

---

## Key Properties

1. **Collectively Aligned**: Starts cooperatively, maintains cooperation when others do, creating positive-sum outcomes when facing similar strategies

2. **Robust to Exploitation**: Defects when cooperation rate falls below threshold, limiting losses against pure defectors

3. **Forgiving**: Uses historical rates to recover from temporary breakdowns; doesn't permanently punish based on single rounds

4. **Parameter-Adaptive**: Threshold adjusts based on k/n ratio, appropriate for different game configurations

5. **Deterministic Core with Strategic Randomization**: Mostly deterministic for predictability, with limited randomization only in ambiguous situations to enable recovery
'''

description_COLLECTIVE_56 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be using similar reasoning, and I aim to establish and maintain cooperation while protecting against exploitation. The key insight is that mutual cooperation yields k/n × n = k > 1 per player, which beats mutual defection's payoff of 1. However, unilateral cooperation is exploitable.

The strategy uses **adaptive conditional cooperation** with graduated responses, optimized for environments where others may share similar cooperative intentions.

---

## Strategy: "Graduated Collective Reciprocity" (GCR)

### Decision Variables

- `coop_rate(t)`: Fraction of all players who cooperated in round t
- `my_threshold(t)`: Required cooperation rate to continue cooperating
- `trust_score`: Running assessment of group cooperativeness
- `rounds_remaining`: r - current_round

### Core Decision Rules

#### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: Signal cooperative intent. With collective mindset, if others reason similarly, we establish immediate cooperation. The cost of being exploited once is bounded (lose at most 1 - k/n), while the benefit of triggering sustained cooperation is substantial.

#### Rounds 2 through (r-1): Adaptive Conditional Cooperation

```
Calculate trust_score:
    trust_score = weighted average of past cooperation rates
    weight recent rounds more heavily (exponential decay, λ = 0.7)
    trust_score = Σ(t=1 to current-1) [λ^(current-1-t) × coop_rate(t)] / Σ weights

Calculate adaptive threshold:
    base_threshold = (n - 1) / (2n)  # At least ~half should cooperate
    
    # Adjust based on game progress
    progress = current_round / r
    
    # Be more forgiving early (building cooperation), stricter late (less time to recover)
    threshold_adjustment = 0.1 × (progress - 0.5)
    
    my_threshold = base_threshold + threshold_adjustment
    my_threshold = clamp(my_threshold, 0.3, 0.7)

Decision:
    IF trust_score ≥ my_threshold:
        ACTION = COOPERATE
    ELSE IF trust_score ≥ my_threshold - 0.15:
        # Gray zone: probabilistic cooperation to allow recovery
        ACTION = COOPERATE with probability = (trust_score - (my_threshold - 0.15)) / 0.15
    ELSE:
        ACTION = DEFECT
```

#### Final Round: Conditional Cooperation (Not Automatic Defection)

```
IF trust_score ≥ 0.6:
    # Group has demonstrated sustained cooperation - maintain it
    ACTION = COOPERATE
ELSE:
    ACTION = DEFECT
```

Rationale: Standard game theory suggests defecting in the final round, but if all collective-minded players reason this way, cooperation unravels via backward induction. By cooperating in the final round when trust is high, we preserve full cooperative payoffs if others reason similarly.

---

### Handling Edge Cases

**If n = 2 (two-player case):**
- Simplify to Tit-for-Tat with forgiveness
- Cooperate round 1
- Copy opponent's previous action with 10% forgiveness probability (cooperate even if they defected)

**If r = 2 (minimal rounds):**
- Round 1: Cooperate
- Round 2: Cooperate if opponent(s) cooperated in round 1, else Defect

**If k is very close to 1 (low multiplication factor):**
- Raise base_threshold by (n - k)/(n - 1) × 0.2
- Cooperation is less valuable, require stronger signals

**If k is close to n (high multiplication factor):**
- Lower base_threshold by (k - 1)/(n - 1) × 0.2
- Cooperation is very valuable, be more forgiving

---

### Pseudocode Summary

```
function decide(game_params, history):
    n, r, k = game_params
    current_round = len(history) + 1
    
    # Round 1: Always cooperate
    if current_round == 1:
        return COOPERATE
    
    # Calculate trust score
    trust_score = calculate_weighted_trust(history, λ=0.7)
    
    # Calculate threshold
    progress = current_round / r
    base = (n - 1) / (2 * n)
    k_adjustment = -0.1 × (k - (n+1)/2) / ((n-1)/2)  # Higher k → lower threshold
    progress_adjustment = 0.1 × (progress - 0.5)
    threshold = clamp(base + k_adjustment + progress_adjustment, 0.3, 0.7)
    
    # Final round logic
    if current_round == r:
        threshold = 0.6  # Fixed threshold for final round
    
    # Decision with probabilistic gray zone
    if trust_score >= threshold:
        return COOPERATE
    elif trust_score >= threshold - 0.15:
        prob = (trust_score - (threshold - 0.15)) / 0.15
        return COOPERATE with probability prob
    else:
        return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Coordination on cooperation**: Opening with cooperation and maintaining it when reciprocated allows collective-minded players to find each other and sustain mutual benefit.

2. **Protection against exploitation**: The threshold mechanism ensures we don't continue cooperating when most others defect.

3. **Forgiveness enables recovery**: The probabilistic gray zone allows groups to recover from temporary breakdowns without requiring perfect coordination.

4. **Robust to mixed populations**: Against pure defectors, we quickly switch to defection. Against cooperators, we maintain cooperation. Against mixed strategies, we adapt proportionally.

5. **No backward induction collapse**: By not automatically defecting in the final round, we avoid the cooperative unraveling that game-theoretic reasoning often produces.
'''

description_COLLECTIVE_55 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume all instances of this strategy will behave identically given the same game state. This allows for implicit coordination without explicit communication. The strategy balances cooperation-seeking behavior with protection against exploitation.

## Strategy Overview: "Adaptive Collective Threshold"

The strategy uses a threshold-based approach that adapts based on observed cooperation levels in the population, with special handling for early and late game phases.

---

## Decision Rules

### Phase 1: Opening (Round 1)
**Action: COOPERATE**

Rationale: Signal cooperative intent. Since all collective instances will do this simultaneously, we establish a cooperation baseline and can identify other cooperators.

### Phase 2: Adaptive Middle Game (Rounds 2 through r-1)

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of players who played C in previous round) / n
```

Calculate the **historical cooperation rate**:
```
hist_coop_rate = (total C plays across all previous rounds) / (n × rounds_played)
```

**Decision Rule:**
```
IF coop_rate >= cooperation_threshold THEN
    COOPERATE
ELSE IF hist_coop_rate >= recovery_threshold AND coop_rate >= minimum_threshold THEN
    COOPERATE
ELSE
    DEFECT
```

**Threshold Parameters (derived from game parameters):**
```
cooperation_threshold = max(0.5, (n - k) / n)
recovery_threshold = 0.4
minimum_threshold = max(0.3, 1/n)
```

The cooperation threshold is set at `(n-k)/n` because this represents the breakeven point where cooperation becomes collectively beneficial. We use `max(0.5, ...)` to ensure we don't cooperate with a minority.

### Phase 3: Endgame (Final Round r)

**Decision Rule:**
```
IF hist_coop_rate >= 0.6 THEN
    COOPERATE
ELSE
    DEFECT
```

Rationale: In a one-shot final round, standard theory predicts defection. However, if the population has demonstrated sustained cooperation (≥60%), we maintain cooperation to maximize collective welfare, trusting that other cooperative agents will do the same.

---

## Forgiveness Mechanism

To avoid permanent defection spirals after temporary breakdowns:

```
IF defected_last_round AND coop_rate_two_rounds_ago >= cooperation_threshold THEN
    // Give one chance to recover cooperation
    COOPERATE
```

This allows recovery from single-round coordination failures.

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    // Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    // Calculate thresholds
    coop_threshold = max(0.5, (n - k) / n)
    recovery_threshold = 0.4
    min_threshold = max(0.3, 1/n)
    
    // Calculate cooperation rates
    last_round_coop = count_cooperators(history, round - 1)
    coop_rate = last_round_coop / n
    hist_coop_rate = total_cooperations(history) / (n * (round - 1))
    
    // Final round logic
    if round == r:
        if hist_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    // Middle game logic
    // Forgiveness check
    if round >= 3:
        if my_action(history, round-1) == DEFECT:
            prev_prev_coop_rate = count_cooperators(history, round-2) / n
            if prev_prev_coop_rate >= coop_threshold:
                return COOPERATE
    
    // Standard threshold decision
    if coop_rate >= coop_threshold:
        return COOPERATE
    else if hist_coop_rate >= recovery_threshold and coop_rate >= min_threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2 | Use standard thresholds | Strategy still applies |
| k very close to 1 | Higher defection likelihood | Threshold naturally increases |
| k close to n | More cooperation | Threshold naturally decreases |
| r = 2 (minimal rounds) | Cooperate round 1, apply endgame rule round 2 | Maximizes learning + collective outcome |
| All others defect round 1 | Defect subsequently | Protection against pure defectors |

---

## Why This Strategy is Collectively Optimal

1. **Implicit coordination**: All instances make identical decisions, enabling group cooperation without communication
2. **Robust to exploitation**: Defects when cooperation falls below sustainable thresholds
3. **Forgiveness enables recovery**: Single-round forgiveness prevents permanent breakdown
4. **Parameter-adaptive**: Thresholds adjust to game economics (k/n ratio)
5. **Endgame cooperation**: Maintains collective welfare even in final round when warranted
'''

description_COLLECTIVE_57 = '''
# Collective Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy embraces a genuinely collective mindset: we succeed when the group succeeds. Since k > 1, full cooperation always maximizes total welfare. The challenge is sustaining cooperation in a world where we cannot coordinate explicitly and others may defect. Our approach: be generous enough to establish and maintain cooperation, but responsive enough to avoid exploitation.

## Key Insight

The critical threshold is whether cooperation is "catching on." With n players and multiplier k, cooperation becomes individually rational when enough others cooperate. We track the *cooperation rate* across the group and use it to make decisions, treating the collective behavior as a signal about the strategic environment we're in.

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: We cannot build collective welfare without someone starting. By cooperating first, we signal cooperative intent and give the group the best chance to establish mutual benefit. The cost of one round's potential loss is small compared to the value of potentially catalyzing group cooperation.

### Rounds 2 through (r-1): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays in previous round) / n
```

Calculate the **trend** (if round ≥ 3):
```
trend = coop_rate(current) - coop_rate(previous)
```

**Decision Rule:**

```
IF coop_rate >= 0.5:
    COOPERATE
    # Majority cooperating - reinforce the cooperative norm
    
ELSE IF coop_rate >= (n-1)/(2n) AND trend >= 0:
    COOPERATE  
    # Cooperation is marginal but stable/growing - give it a chance
    
ELSE IF coop_rate > 0 AND round_number <= r/3:
    COOPERATE with probability = coop_rate + 0.2
    # Early game with some cooperation - probabilistically encourage growth
    
ELSE:
    DEFECT
    # Cooperation has collapsed - protect against exploitation
```

### Final Round: Conditional Cooperation

**Action: Mirror the majority from round (r-1)**

```
IF coop_rate(round r-1) >= 0.5:
    COOPERATE
ELSE:
    DEFECT
```

Rationale: Unlike standard game theory advice to defect in final rounds, we maintain our collective orientation. If cooperation has been sustained, we honor that implicit agreement to the end. Defecting in a cooperative equilibrium damages total welfare for minimal individual gain.

## Pseudocode Summary

```python
def choose_action(round_number, r, n, k, history):
    
    # Round 1: Always cooperate to initiate
    if round_number == 1:
        return COOPERATE
    
    # Calculate cooperation rate from last round
    last_round_coops = count_cooperators(history, round_number - 1)
    coop_rate = last_round_coops / n
    
    # Calculate trend if possible
    if round_number >= 3:
        prev_coop_rate = count_cooperators(history, round_number - 2) / n
        trend = coop_rate - prev_coop_rate
    else:
        trend = 0
    
    # Final round: mirror majority behavior
    if round_number == r:
        return COOPERATE if coop_rate >= 0.5 else DEFECT
    
    # Middle rounds: adaptive threshold
    if coop_rate >= 0.5:
        return COOPERATE
    
    if coop_rate >= (n-1)/(2*n) and trend >= 0:
        return COOPERATE
    
    if coop_rate > 0 and round_number <= r/3:
        # Probabilistic cooperation in early game
        if random() < coop_rate + 0.2:
            return COOPERATE
    
    return DEFECT
```

## Why This Strategy is Collectively Optimal

1. **Forgiveness**: We don't require perfect cooperation—just enough to suggest a cooperative equilibrium is viable
2. **Patience**: We give cooperation extra chances early when norms are forming
3. **Responsiveness**: We protect against systematic exploitation by responding to sustained defection
4. **Consistency**: Our behavior is predictable and interpretable, making it easier for other cooperative strategies to coordinate with us
5. **No exploitation of the endgame**: We don't betray cooperators in the final round, maintaining integrity

This strategy maximizes the chance of achieving and sustaining the collectively optimal outcome while remaining robust against purely selfish opponents.
'''

description_COLLECTIVE_56 = '''
# Collective Strategy for N-Player Public Goods Game

## Strategic Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be running similar adaptive strategies developed by AI systems with aligned reasoning. The goal is to establish and maintain cooperation when possible, while protecting against exploitation. The strategy balances **optimism** (starting cooperatively to signal intent), **reciprocity** (responding to group behavior), and **forgiveness** (allowing recovery from defection spirals).

---

## Core Decision Rules

### Primary Metric: Cooperation Rate

At any point in the game, track the **group cooperation rate** from the previous round:

```
cooperation_rate = (number of players who played C in last round) / n
```

### Decision Framework

**Cooperate if ANY of the following conditions are met:**

1. **First Round**: Always cooperate to signal cooperative intent
2. **High Cooperation Environment**: `cooperation_rate ≥ threshold` where threshold is adaptive
3. **Forgiveness Trigger**: Periodic forgiveness rounds to escape defection traps
4. **Near-Universal Cooperation**: If `cooperation_rate ≥ (n-1)/n` (at most one defector), cooperate to maintain the coalition

**Defect otherwise.**

---

## Detailed Rule Specification

### 1. Threshold Calculation (Adaptive)

The cooperation threshold adjusts based on game parameters and history:

```
base_threshold = k / n  # Break-even point for individual rationality

# Adjust based on game length (more forgiving in longer games)
length_adjustment = min(0.1, 1 / r)

# Adjust based on recent trend (last 3 rounds if available)
if rounds_played >= 3:
    recent_rate = average cooperation rate over last 3 rounds
    trend_adjustment = 0.05 if recent_rate > historical_average else -0.05
else:
    trend_adjustment = 0

threshold = base_threshold - length_adjustment + trend_adjustment
threshold = clamp(threshold, 0.4, 0.8)  # Keep within reasonable bounds
```

### 2. Forgiveness Mechanism

To escape mutual defection spirals:

```
forgiveness_interval = max(3, r // 5)  # Forgive every ~20% of game, minimum every 3 rounds

if current_round % forgiveness_interval == 0:
    if cooperation_rate < threshold:
        COOPERATE (forgiveness round)
```

### 3. End-Game Handling

```
rounds_remaining = r - current_round

if rounds_remaining == 0:  # Final round
    # Cooperate only if cooperation has been very high (solidarity signal)
    if historical_average_cooperation >= 0.7:
        COOPERATE
    else:
        DEFECT

if rounds_remaining <= 2:  # Near end-game
    # Raise threshold slightly to avoid late exploitation
    threshold = threshold + 0.1
```

### 4. Early Game (Rounds 1-3)

```
Round 1: COOPERATE (unconditional)

Round 2: 
    if cooperation_rate >= 0.5:
        COOPERATE
    else:
        DEFECT

Round 3+: Use standard adaptive rules
```

---

## Complete Pseudocode

```
function decide(game_params, history):
    n = game_params.num_players
    r = game_params.num_rounds
    k = game_params.multiplier
    current_round = len(history) + 1
    
    # ROUND 1: Always cooperate
    if current_round == 1:
        return COOPERATE
    
    # Calculate cooperation rate from last round
    last_round = history[-1]
    coop_rate = count(last_round, C) / n
    
    # Calculate historical average
    total_coops = sum(count(round, C) for round in history)
    historical_avg = total_coops / (n * len(history))
    
    # NEAR-UNIVERSAL COOPERATION: Maintain strong coalitions
    if coop_rate >= (n - 1) / n:
        return COOPERATE
    
    # Calculate adaptive threshold
    base_threshold = k / n
    length_adj = min(0.1, 1 / r)
    
    if len(history) >= 3:
        recent_rate = mean(count(history[i], C) / n for i in [-3, -2, -1])
        trend_adj = 0.05 if recent_rate > historical_avg else -0.05
    else:
        trend_adj = 0
    
    threshold = clamp(base_threshold - length_adj + trend_adj, 0.4, 0.8)
    
    # END-GAME ADJUSTMENT
    rounds_remaining = r - current_round
    if rounds_remaining == 0:
        return COOPERATE if historical_avg >= 0.7 else DEFECT
    if rounds_remaining <= 2:
        threshold = threshold + 0.1
    
    # FORGIVENESS MECHANISM
    forgiveness_interval = max(3, r // 5)
    if current_round % forgiveness_interval == 0 and coop_rate < threshold:
        return COOPERATE
    
    # MAIN DECISION
    if coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Coordination Signal**: Round 1 cooperation creates a clear starting point for mutual cooperation
2. **Graduated Reciprocity**: Responds proportionally to group behavior rather than individual actions
3. **Escape Hatches**: Forgiveness rounds prevent permanent collapse into mutual defection
4. **Coalition Protection**: High cooperation is rewarded and maintained
5. **Parameter Awareness**: Adapts to the specific economics of each game instance
6. **Robustness**: Works against pure defectors (eventually defects back), pure cooperators (maintains cooperation), and mixed strategies (adapts to prevailing behavior)
'''

description_COLLECTIVE_58 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a collective mindset: **we succeed together or fail together**. The goal is to establish and maintain cooperation while protecting against exploitation. I'll use a reputation-based system that rewards cooperation, forgives occasional defections, and gradually withdraws from persistent defectors—all while recognizing that in a multi-player setting, my individual action has limited punitive power.

## Strategy Overview: "Generous Collective Trigger"

The strategy combines:
1. **Optimistic initiation** - Start cooperating to signal good faith
2. **Collective reputation tracking** - Monitor the group's overall cooperation level
3. **Graduated response** - Adjust behavior based on group cooperation trends
4. **End-game awareness** - Handle final rounds strategically
5. **Forgiveness mechanisms** - Allow recovery from temporary breakdowns

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, cooperation signals willingness to build collective benefit. The potential gain from establishing cooperation outweighs the risk of one round's exploitation.

---

### Rounds 2 through (r-1): Adaptive Cooperation

Calculate the **group cooperation rate** from the previous round:
```
cooperation_rate = (number of cooperators in previous round) / n
```

Calculate the **trend** (if round ≥ 3):
```
trend = cooperation_rate(t-1) - cooperation_rate(t-2)
```

**Decision Logic:**

```
threshold = base_threshold + trend_adjustment + round_adjustment

where:
  base_threshold = 0.4  (cooperate if at least 40% of group cooperated)
  trend_adjustment = 0.1 × trend  (reward improving cooperation)
  round_adjustment = -0.05 × (current_round / r)  (slightly more forgiving as game progresses mid-game)

IF cooperation_rate >= threshold:
    ACTION = COOPERATE
ELSE IF cooperation_rate >= 0.2 AND cooperation was increasing (trend > 0):
    ACTION = COOPERATE  (support recovery attempts)
ELSE:
    ACTION = DEFECT
```

**Forgiveness Rule:** If cooperation collapsed but this round shows significant recovery (≥50% increase in cooperation rate), cooperate to support the recovery.

---

### Final Round (Round r): Conditional Cooperation

The last round removes future consequences, but I maintain collective principles:

```
IF average_cooperation_rate_over_all_rounds >= 0.5:
    ACTION = COOPERATE  (reward a cooperative group)
ELSE IF cooperation_rate(r-1) >= 0.6:
    ACTION = COOPERATE  (honor recent cooperation)
ELSE:
    ACTION = DEFECT
```

Rationale: Even in the final round, if the group has been largely cooperative, I honor that relationship. This isn't "rational" in a narrow sense, but it's collectively optimal if others reason similarly.

---

### Special Case: Two-Player Game (n=2)

When n=2, this becomes closer to a standard Prisoner's Dilemma. Use a modified **Tit-for-Tat with Forgiveness**:

```
Round 1: COOPERATE

Rounds 2 to r-1:
  IF opponent cooperated last round:
    ACTION = COOPERATE
  ELSE IF opponent defected but cooperated in 2+ of last 3 rounds:
    ACTION = COOPERATE (forgiveness)
  ELSE:
    ACTION = DEFECT

Round r:
  IF opponent's overall cooperation rate >= 0.5:
    ACTION = COOPERATE
  ELSE:
    ACTION = DEFECT
```

---

## Pseudocode Summary

```python
def decide(round_number, history, n, r, k):
    if round_number == 1:
        return COOPERATE
    
    coop_rate = count_cooperators(history, round_number - 1) / n
    
    if round_number == r:  # Final round
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.5 or coop_rate >= 0.6:
            return COOPERATE
        return DEFECT
    
    # Middle rounds
    trend = 0
    if round_number >= 3:
        prev_rate = count_cooperators(history, round_number - 2) / n
        trend = coop_rate - prev_rate
    
    threshold = 0.4 + (0.1 * trend) - (0.05 * round_number / r)
    
    if coop_rate >= threshold:
        return COOPERATE
    if coop_rate >= 0.2 and trend > 0:
        return COOPERATE  # Support recovery
    
    return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Establishes cooperation early** - Gives the group a chance to reach mutual benefit
2. **Tolerates imperfection** - A 40% threshold acknowledges that perfect cooperation is unrealistic
3. **Rewards improvement** - Trend-sensitivity encourages groups moving toward cooperation
4. **Protects against exploitation** - Won't cooperate indefinitely with persistent defectors
5. **Maintains integrity to the end** - Final-round cooperation with cooperative groups reinforces that this isn't purely strategic—it's principled

The strategy assumes others may be thinking similarly: if we all adopt cooperative-leaning strategies with reasonable protections, we collectively achieve the k-multiplied benefit rather than the baseline payoff of universal defection.
'''

description_COLLECTIVE_57 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: if all players in the tournament adopt this same strategy, we should achieve strong mutual outcomes. At the same time, it must be **robust** against defectors and **adaptive** to the actual behavior observed in the game.

The key insight is that in a repeated public goods game, sustainable cooperation requires:
1. **Signaling cooperative intent** early
2. **Rewarding cooperation** when others cooperate
3. **Protecting against exploitation** without being overly punitive
4. **Recognizing endgame dynamics** where cooperation incentives collapse

---

## Strategy: "Collective Threshold Cooperation" (CTC)

### Decision Framework

The strategy tracks the **cooperation rate** of the group (excluding self) and uses adaptive thresholds to decide when to cooperate.

---

### Round-by-Round Rules

#### **Round 1: Cooperate**
- Always cooperate in the first round
- This signals cooperative intent and establishes a baseline for measuring others' behavior
- Rationale: With no history, we give the collective a chance to form

#### **Rounds 2 through (r-1): Adaptive Threshold Cooperation**

Calculate the **observed cooperation rate** from all previous rounds:
```
cooperation_rate = (total C plays by others across all past rounds) / ((n-1) × rounds_played)
```

Calculate a **dynamic threshold** that becomes slightly more forgiving over time (to allow recovery from early defections):
```
base_threshold = (n - k) / n
forgiveness_factor = 0.1 × (current_round / r)
threshold = max(0.2, base_threshold - forgiveness_factor)
```

**Decision rule:**
- If `cooperation_rate ≥ threshold`: **Cooperate**
- If `cooperation_rate < threshold`: **Defect**

**Additional trigger - Recent trend detection:**
- Look at the last `min(3, rounds_played)` rounds
- If recent cooperation rate is rising and ≥ 0.5, cooperate (reward recovery attempts)
- If recent cooperation rate dropped sharply (>30% decline from overall average), defect (protect against collapse)

#### **Final Round (Round r): Conditional Cooperation**

The last round has no future, so pure game theory suggests defection. However, in a collective strategy tournament:

- If `cooperation_rate ≥ 0.6` over all previous rounds: **Cooperate**
  - Rationale: If we're in a cooperative environment, maintaining trust has tournament-wide value
- Otherwise: **Defect**
  - Rationale: No point cooperating in a defector-dominated game

---

### Pseudocode

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    # Calculate overall cooperation rate of others
    others_cooperations = count_others_cooperations(history)
    others_total_actions = (n - 1) * (round - 1)
    coop_rate = others_cooperations / others_total_actions
    
    # Calculate threshold
    base_threshold = (n - k) / n
    forgiveness = 0.1 * (round / r)
    threshold = max(0.2, base_threshold - forgiveness)
    
    # Final round logic
    if round == r:
        if coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    # Check recent trend (last 3 rounds or fewer)
    lookback = min(3, round - 1)
    recent_coop_rate = cooperation_rate_last_n_rounds(history, lookback, n)
    
    # Trend-based adjustments
    if recent_coop_rate >= 0.5 and recent_coop_rate > coop_rate:
        return COOPERATE  # Reward recovery
    
    if recent_coop_rate < coop_rate - 0.3:
        return DEFECT  # Protect against collapse
    
    # Standard threshold decision
    if coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

### Why This Strategy Works Collectively

1. **Self-reinforcing**: If all players use CTC, everyone cooperates in round 1, sees high cooperation, and continues cooperating throughout
2. **Robust to minorities**: A few defectors won't drop the cooperation rate below threshold, so the cooperative core persists
3. **Punishes mass defection**: If many defect, the strategy protects itself by defecting
4. **Allows recovery**: The forgiveness factor and trend detection let the group rebuild cooperation after early mistakes
5. **Handles endgame gracefully**: Maintains cooperation in the final round when the group has been cooperative, preserving collective gains

---

### Edge Cases Handled

| Situation | Response |
|-----------|----------|
| Round 1 | Always cooperate |
| All others defect round 1 | Defect from round 2 (rate = 0 < threshold) |
| Mixed early behavior | Continue if above threshold, with forgiveness |
| Recovery attempt mid-game | Reward with cooperation if trend is positive |
| Final round, cooperative history | Cooperate |
| Final round, defector-heavy history | Defect |
| Very small n (n=2) | Functions as forgiving tit-for-tat variant |
| Large n | Threshold adjusts based on k/n ratio |
'''

description_COLLECTIVE_59 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embodies a **collectively-minded approach**: I aim to cooperate when cooperation can be sustained, but I'm not naive. I use observable signals from the game history to infer whether the population is cooperative enough to make my contribution worthwhile, and I adjust my behavior to encourage cooperation while protecting against exploitation.

## Strategy Overview: **Adaptive Threshold Cooperation (ATC)**

The strategy maintains cooperation when the group demonstrates sufficient collective commitment, gradually builds trust in early rounds, and strategically defects only when cooperation appears unsustainable or in end-game scenarios where defection cascades are inevitable.

---

## Decision Rules

### Round 1: Signal Cooperative Intent
**Action: COOPERATE**

Rationale: With no history to guide us, I signal willingness to cooperate. This establishes a cooperative baseline and allows me to observe who else shares collective values.

---

### Rounds 2 through (r-2): Adaptive Threshold Response

**Calculate the cooperation rate from the previous round:**
```
prev_coop_rate = (number of C plays in round t-1) / n
```

**Calculate the cumulative cooperation trend:**
```
cumulative_coop_rate = (total C plays across all previous rounds) / (n × number of previous rounds)
```

**Decision Rule:**

```
threshold = max(0.3, (k/n) + 0.1)

IF prev_coop_rate >= threshold:
    ACTION = COOPERATE
ELSE IF prev_coop_rate < threshold AND cumulative_coop_rate >= threshold:
    # Recent dip but historically cooperative - give benefit of doubt
    ACTION = COOPERATE with probability = cumulative_coop_rate
    ACTION = DEFECT with probability = 1 - cumulative_coop_rate
ELSE:
    # Sustained low cooperation - protect myself
    ACTION = DEFECT
```

**Forgiveness Mechanism:**
If I defected in round t-1 but cooperation rate increased (indicating others are trying to restore cooperation):
```
IF prev_coop_rate increased by >= 0.2 from round before:
    ACTION = COOPERATE (rejoin the collective effort)
```

---

### Round (r-1): Penultimate Round
**Apply the same adaptive threshold rules as middle rounds.**

Rationale: Defecting early in end-game can trigger cascading defection. Maintaining cooperation here signals commitment and may preserve collective gains in the final round.

---

### Round r: Final Round

**Decision Rule:**
```
IF cumulative_coop_rate >= 0.6:
    # High-trust environment - maintain cooperation to maximize collective outcome
    ACTION = COOPERATE
ELSE IF cumulative_coop_rate >= 0.4:
    # Mixed environment - probabilistic cooperation
    ACTION = COOPERATE with probability = cumulative_coop_rate
ELSE:
    # Low-trust environment - defection is rational
    ACTION = DEFECT
```

Rationale: In a collectively-minded population, maintaining final-round cooperation achieves the Pareto-optimal outcome. Against defectors, this limits losses.

---

## Edge Case Handling

| Scenario | Action |
|----------|--------|
| n = 2 (minimum players) | Use stricter threshold of 0.5 (need partner to cooperate) |
| k very close to 1 | Lower threshold slightly (cooperation barely beats defection) |
| k close to n | Standard rules (strong incentive to cooperate exists) |
| All others defected last round | DEFECT (protect against mass exploitation) |
| All others cooperated last round | COOPERATE (reward and sustain) |
| r = 2 (minimum rounds) | Cooperate round 1, apply final-round rule in round 2 |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    threshold = max(0.3, (k/n) + 0.1)
    
    if round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history, round-1) / n
    cumulative_coop_rate = total_cooperations(history) / (n * (round-1))
    
    # Forgiveness check
    if my_last_action == DEFECT and round > 2:
        prev_prev_rate = count_cooperators(history, round-2) / n
        if prev_coop_rate - prev_prev_rate >= 0.2:
            return COOPERATE
    
    # Final round logic
    if round == r:
        if cumulative_coop_rate >= 0.6:
            return COOPERATE
        elif cumulative_coop_rate >= 0.4:
            return random_choice(COOPERATE, cumulative_coop_rate)
        else:
            return DEFECT
    
    # Standard rounds
    if prev_coop_rate >= threshold:
        return COOPERATE
    elif cumulative_coop_rate >= threshold:
        return random_choice(COOPERATE, cumulative_coop_rate)
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Starts cooperative**: Establishes trust and enables collective gains
2. **Rewards cooperation**: Continues contributing when others do
3. **Forgives defection**: Allows recovery from temporary breakdowns
4. **Protects the collective**: Defects against persistent free-riders (preventing exploitation encourages cooperation)
5. **Maintains end-game cooperation**: Doesn't trigger defection cascades among cooperative players
6. **Adapts to population composition**: Robust against both cooperative and adversarial opponents
'''

description_COLLECTIVE_58 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to maximize group welfare while protecting against exploitation. The key insight is that in a public goods game, **cooperation is only sustainable if it's reciprocal**. I will be generous in initiating and maintaining cooperation, but I will adapt to the actual behavior of the group.

## Strategy: "Generous Collective Reciprocity"

### Decision Framework

My strategy uses a **cooperation threshold** based on observed group behavior, with built-in generosity and forgiveness mechanisms.

---

### Round-by-Round Decision Rules

#### **Round 1: Unconditional Cooperation**
- **Action: COOPERATE**
- Rationale: Signal cooperative intent, gather information about group composition, and give the collective a chance to establish mutual cooperation.

#### **Rounds 2 through (r-1): Adaptive Reciprocity**

Calculate the **group cooperation rate** from the previous round:
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Decision Rule:**
```
IF prev_coop_rate ≥ cooperation_threshold THEN COOPERATE
ELSE DEFECT
```

**Dynamic Threshold Calculation:**
```
base_threshold = 0.5  (majority cooperation)
adjusted_threshold = base_threshold - forgiveness_bonus

where:
  forgiveness_bonus = 0.1 × (rounds_since_last_full_defection / r)
  
  (capped at 0.15, so threshold never drops below 0.35)
```

**Forgiveness Mechanism:**
- If I defected last round but cooperation rate was close to threshold (within 0.1), consider a **probe cooperation** with probability:
```
probe_probability = 0.2 × (current_round / r)
```
This increases willingness to test for recovery as the game progresses.

#### **Final Round (Round r): Conditional Cooperation**
- Unlike standard game theory advice (always defect), I maintain the same decision rule
- Rationale: If playing with like-minded collective strategies, mutual cooperation in the final round benefits everyone. The small risk of exploitation is worth the potential for sustained group gains.

---

### Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history[round-1])
    prev_coop_rate = prev_cooperators / n
    
    # Calculate dynamic threshold with forgiveness
    rounds_since_collapse = rounds_since(history, coop_rate < 0.3)
    forgiveness_bonus = min(0.15, 0.1 * (rounds_since_collapse / r))
    threshold = 0.5 - forgiveness_bonus
    
    # Main decision
    if prev_coop_rate >= threshold:
        return COOPERATE
    
    # Probe mechanism: occasionally test for recovery
    if my_last_action == DEFECT:
        if prev_coop_rate >= (threshold - 0.1):
            probe_prob = 0.2 * (round / r)
            if random() < probe_prob:
                return COOPERATE
    
    return DEFECT
```

---

### Edge Cases Handled

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | Cooperate | Establish cooperative signal |
| Last round | Use standard rule | Maintain collective commitment |
| All others defected last round | Defect | Protect against mass exploitation |
| Exactly 50% cooperated | Cooperate | Generous interpretation of threshold |
| Gradual decline in cooperation | Defect once threshold crossed | Clear signal that free-riding isn't tolerated |
| Recovery after collapse | Probe occasionally | Allow group to re-establish cooperation |
| n=2 (minimum players) | Same rules apply | Threshold of 0.5 means partner must cooperate |

---

### Why This Strategy is Collectively Optimal

1. **Initiates cooperation**: Starts with C, giving groups the best chance to coordinate
2. **Rewards cooperation**: Continues cooperating when most others do
3. **Punishes defection**: Withdraws cooperation when free-riding dominates
4. **Forgives**: Probing mechanism allows recovery from temporary breakdowns
5. **Consistent to the end**: Doesn't betray in final round, enabling sustained mutual benefit with similar strategies
6. **Parameter-independent**: Works across different values of n, k, and r

This strategy seeks to **be the cooperation I want to see in the group** while remaining robust against exploitation.
'''

description_COLLECTIVE_60 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be using similar reasoning, so I should behave in ways that create good outcomes when matched with cooperative thinkers while protecting against exploitation. The key insight is that in repeated games, **building and maintaining cooperation is valuable**, but I must be responsive to actual behavior rather than hoping for coordination that may not materialize.

## Strategy: Adaptive Threshold Cooperation (ATC)

### Key Principles

1. **Start cooperative** to establish willingness to cooperate
2. **Track group cooperation rate** as the primary signal
3. **Use graduated thresholds** that become stricter as the game progresses
4. **Defect in the final round** (no future shadow)
5. **Be forgiving** but not naive

---

## Decision Rules

### Round 1: Cooperate
- **Action: C**
- Rationale: Signal cooperative intent, gather information about others

### Rounds 2 through (r-1): Conditional Cooperation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays in previous round) / n
```

Calculate the **historical cooperation rate**:
```
hist_coop_rate = (total C plays across all previous rounds) / (n × rounds_played)
```

Calculate the **threshold** that decreases over time:
```
base_threshold = 0.4
time_pressure = 0.1 × (current_round / r)
threshold = base_threshold + time_pressure
```

**Decision Rule:**
```
IF (coop_rate >= threshold) AND (hist_coop_rate >= threshold - 0.1):
    Action = C
ELSE IF (coop_rate >= 0.6) AND (previous_round I played D):
    Action = C  # Forgiveness: rejoin if cooperation rebounds
ELSE:
    Action = D
```

### Final Round (Round r): Defect
- **Action: D**
- Rationale: No future interactions; defection is strictly dominant

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | C | Establish cooperative baseline |
| Round r (final) | D | No future shadow; dominant strategy |
| r = 2 | C then D | Minimal cooperation window |
| n = 2 | Apply same rules | Works for any n ≥ 2 |
| Everyone defected last round | D | No cooperation to reward |
| I was the only cooperator | D | Don't be exploited repeatedly |
| Cooperation rate exactly at threshold | C | Tie-break toward cooperation |
| Perfect cooperation so far | C | Maintain successful equilibrium |

---

## Detailed Pseudocode

```
function decide(round, history, n, r, k):
    
    # Final round: always defect
    if round == r:
        return D
    
    # First round: always cooperate
    if round == 1:
        return C
    
    # Calculate metrics from history
    last_round_cooperators = count_cooperators(history, round - 1)
    coop_rate = last_round_cooperators / n
    
    total_cooperations = sum(count_cooperators(history, t) for t in 1..round-1)
    total_decisions = n * (round - 1)
    hist_coop_rate = total_cooperations / total_decisions
    
    # Calculate adaptive threshold (stricter as game progresses)
    progress = round / r
    threshold = 0.4 + (0.1 * progress)
    
    # Main decision logic
    if coop_rate >= threshold AND hist_coop_rate >= (threshold - 0.1):
        return C
    
    # Forgiveness clause: if cooperation rebounded and I defected
    my_last_action = get_my_action(history, round - 1)
    if coop_rate >= 0.6 AND my_last_action == D:
        return C
    
    # Default: defect if cooperation is insufficient
    return D
```

---

## Why This Strategy is Collectively Aligned

1. **Self-consistency**: If all players use this strategy, they cooperate through round r-1, achieving near-optimal collective payoff of approximately `(r-1) × k + 1` per player.

2. **Robustness to defectors**: The threshold mechanism ensures I don't cooperate into a void. If too few cooperate, I protect myself.

3. **Forgiveness enables recovery**: Even after a breakdown, cooperation can restart if others signal willingness.

4. **Adaptive threshold**: Early tolerance allows cooperation to establish; later strictness prevents late-game exploitation.

5. **Clear, implementable rules**: No reliance on complex signaling or assumed coordination—just observable behavior.

---

## Expected Behavior in Tournament

- **Against other cooperative strategies**: Sustained cooperation through round r-1, mutual benefit
- **Against unconditional defectors**: Quick detection (round 2), switch to defection
- **Against mixed strategies**: Adapts based on observed cooperation levels
- **Against exploitative strategies**: Threshold protection prevents sustained exploitation
'''

description_COLLECTIVE_59 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all players using this strategy will reason identically given the same information. Rather than treating this as a game against opponents, we recognize that rational collective reasoning leads to cooperation when it benefits the group, while maintaining protection against exploitation.

## Strategy Overview: "Adaptive Collective Threshold"

The strategy uses a threshold-based approach that starts optimistically, adapts to observed cooperation levels, and makes collective-rational decisions based on whether sufficient cooperation exists to make contribution worthwhile.

---

## Decision Rules

### Round 1: Cooperate
- **Rationale**: With no history, we signal cooperative intent. If others reason similarly, we establish a cooperative equilibrium from the start.

### Rounds 2 through (r-1): Adaptive Threshold Cooperation

**Step 1: Calculate the cooperation rate from the previous round**
```
prev_coop_rate = (number of C plays in round t-1) / n
```

**Step 2: Calculate the adaptive threshold**
```
base_threshold = 1/k
rounds_remaining_ratio = (r - t) / r
tolerance = 0.15 * rounds_remaining_ratio
adaptive_threshold = max(base_threshold - tolerance, 0.2)
```

**Step 3: Decision**
```
IF prev_coop_rate >= adaptive_threshold:
    COOPERATE
ELSE IF prev_coop_rate >= adaptive_threshold * 0.5 AND trend is improving:
    COOPERATE (give benefit of doubt)
ELSE:
    DEFECT
```

**Trend calculation:**
```
IF t >= 3:
    trend_improving = (coop_rate at t-1) > (coop_rate at t-2)
ELSE:
    trend_improving = FALSE
```

### Final Round (Round r): Conditional Cooperation with Collective Lens

Unlike standard game theory which prescribes universal defection:

```
IF average_cooperation_rate >= 0.6 across all previous rounds:
    COOPERATE (reward sustained collective behavior)
ELSE IF prev_round_coop_rate >= 0.8:
    COOPERATE (match high recent cooperation)
ELSE:
    DEFECT
```

**Rationale**: If we're all reasoning collectively, and cooperation has been sustained, there's no reason to betray in the final round. The "rational defection" only makes sense under individualistic assumptions.

---

## Key Threshold Explanation

The base threshold `1/k` is strategically meaningful:
- When cooperation rate equals `1/k`, a cooperator's expected share from the public good equals what they gave up
- Below this threshold, cooperation is costly even collectively
- The tolerance allows for building cooperation and accounts for noise

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | C | Establish cooperative intent |
| Only 2 players (n=2) | Follow rules above | Strategy still applies; threshold matters more |
| k very close to 1 | Higher threshold needed | Low multiplier requires near-universal cooperation |
| k very close to n | Lower effective threshold | High multiplier makes cooperation almost always beneficial |
| Everyone defected last round | D (unless trend improving) | Don't cooperate alone; wait for others |
| Only I defected last round | C | Rejoin the cooperative group |
| Perfect cooperation so far | C | Maintain the equilibrium |

---

## Pseudocode Summary

```
function decide(round t, history, n, k, r):
    
    if t == 1:
        return COOPERATE
    
    prev_coop_count = count_cooperators(history, t-1)
    prev_coop_rate = prev_coop_count / n
    
    # Calculate adaptive threshold
    base_threshold = 1 / k
    rounds_remaining_ratio = (r - t) / r
    tolerance = 0.15 * rounds_remaining_ratio
    threshold = max(base_threshold - tolerance, 0.2)
    
    # Check trend if possible
    trend_improving = FALSE
    if t >= 3:
        prev_prev_rate = count_cooperators(history, t-2) / n
        trend_improving = (prev_coop_rate > prev_prev_rate)
    
    # Final round logic
    if t == r:
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.6 OR prev_coop_rate >= 0.8:
            return COOPERATE
        else:
            return DEFECT
    
    # Standard round logic
    if prev_coop_rate >= threshold:
        return COOPERATE
    elif prev_coop_rate >= threshold * 0.5 AND trend_improving:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Rational

1. **Identical reasoning**: All instances of this strategy will make the same decision given the same history, enabling implicit coordination.

2. **Rewards cooperation**: Maintains cooperation when the group cooperates, creating stable high-payoff equilibria.

3. **Protects against exploitation**: Won't continue cooperating when others defect, preventing systematic exploitation.

4. **Adaptive to game parameters**: The `1/k` threshold automatically adjusts to different multiplication factors.

5. **Graceful degradation**: Even against purely selfish strategies, limits losses while remaining open to cooperation.
'''

description_COLLECTIVE_61 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to maximize group welfare while protecting against exploitation. The key insight is that in a public goods game, **universal cooperation yields the highest total payoff**, but this requires building and maintaining trust across players. My strategy uses observable cooperation levels as a coordination signal, adjusting my behavior to reward collective cooperation and discourage free-riding.

---

## Strategy: Adaptive Threshold Cooperation (ATC)

### Key Parameters (derived from game parameters)

```
cooperation_threshold = 0.5  # Base threshold: fraction of others who must cooperate
forgiveness_rate = 0.15      # Probability of cooperating despite low cooperation
decay_rounds = max(3, r/5)   # Rounds to weight recent history more heavily
```

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. In a collective framework, someone must initiate trust. Starting with cooperation provides information about others and establishes a norm.

---

### Rounds 2 through (r-1): Adaptive Threshold Response

**Calculate the following:**

1. **Recent Cooperation Rate**: 
   - Look at the last `min(current_round - 1, decay_rounds)` rounds
   - Calculate: `recent_coop_rate = (cooperators in recent rounds) / ((n-1) × recent_rounds)`

2. **Overall Cooperation Rate**:
   - `overall_coop_rate = (total cooperators across all past rounds) / ((n-1) × past_rounds)`

3. **Weighted Cooperation Score**:
   - `coop_score = 0.7 × recent_coop_rate + 0.3 × overall_coop_rate`

4. **Adaptive Threshold**:
   - Base threshold adjusts based on game economics
   - `adjusted_threshold = 0.5 × (1 - (k-1)/(n-1))`
   - This lowers the bar when cooperation is more valuable (k closer to n)

**Decision Logic:**

```
IF coop_score >= adjusted_threshold:
    ACTION = COOPERATE
ELSE IF random() < forgiveness_rate:
    ACTION = COOPERATE  # Probabilistic forgiveness to escape defection traps
ELSE:
    ACTION = DEFECT
```

---

### Final Round (Round r): Conditional Cooperation

**Do NOT automatically defect.** 

```
IF coop_score >= 0.6:
    ACTION = COOPERATE  # Maintain collective behavior if group has cooperated
ELSE:
    ACTION = DEFECT     # Match low-cooperation environment
```

Rationale: Automatic final-round defection is self-defeating in a collective framework. If the group has maintained cooperation, defecting destroys the collective outcome we worked to build. Only defect if the group has already abandoned cooperation.

---

## Edge Cases

### Edge Case 1: Very Small n (n=2)
- Behaves like Tit-for-Tat with forgiveness
- Cooperate round 1, then mirror opponent with 15% forgiveness

### Edge Case 2: Very Large n (n>20)
- Individual defection has less impact on group welfare
- Lower threshold slightly: `adjusted_threshold × 0.9`

### Edge Case 3: Short Games (r ≤ 3)
- Round 1: Cooperate
- Round 2: Cooperate if ≥40% cooperated in round 1
- Final round: Follow final round rule above

### Edge Case 4: k Very Close to n (k > 0.9n)
- Cooperation is extremely valuable
- Lower threshold to 0.3 to encourage more cooperation

### Edge Case 5: Everyone Defected Last Round
- If this is first mass defection: Cooperate (try to restart cooperation)
- If second consecutive mass defection: Defect with 85% probability

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation metrics
    recent_window = min(round - 1, max(3, r // 5))
    recent_coop = count_cooperators(history, last=recent_window) / ((n-1) * recent_window)
    overall_coop = count_cooperators(history, all=True) / ((n-1) * (round - 1))
    coop_score = 0.7 * recent_coop + 0.3 * overall_coop
    
    # Adaptive threshold based on game economics
    threshold = 0.5 * (1 - (k-1)/(n-1))
    
    # Final round logic
    if round == r:
        threshold = 0.6
    
    # Decision
    if coop_score >= threshold:
        return COOPERATE
    elif random() < 0.15:
        return COOPERATE  # Forgiveness
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Initiates cooperation** rather than waiting for others
2. **Rewards collective behavior** by cooperating when others do
3. **Forgives occasional defection** to escape punishment spirals
4. **Doesn't abandon the group** in the final round if cooperation was established
5. **Adapts to group dynamics** rather than following rigid rules
6. **Scales with game parameters** to remain sensible across configurations
'''

description_COLLECTIVE_60 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we assume all instances of this strategy will behave identically given the same game state. This isn't coordination—it's recognizing that identical reasoning produces identical actions. The strategy aims to establish and maintain cooperation when beneficial, while protecting against exploitation.

## Strategy Overview: "Graduated Collective Reciprocity"

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness and test the waters
2. **Mirror the group's cooperation level** to reward cooperation and discourage defection
3. **Protect against end-game collapse** while maintaining collective welfare focus

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, we signal cooperative intent. If multiple copies of this strategy exist, they'll all cooperate, immediately establishing a cooperative baseline.

---

### Rounds 2 through (r-1): Graduated Reciprocity

Calculate the **cooperation ratio** from the previous round:
```
coop_ratio = (number of cooperators in previous round) / n
```

**Decision Rule:**

```
IF coop_ratio >= (n-1)/n THEN
    COOPERATE  // Near-universal cooperation: maintain it
    
ELSE IF coop_ratio >= 0.5 THEN
    // Majority cooperated: give benefit of doubt, encourage growth
    COOPERATE
    
ELSE IF coop_ratio > 0 THEN
    // Minority cooperated: use probabilistic response
    // Cooperate with probability equal to coop_ratio
    // This creates gradual pressure without total collapse
    COOPERATE with probability = coop_ratio
    DEFECT with probability = (1 - coop_ratio)
    
ELSE  // coop_ratio == 0
    // Total defection: attempt recovery every few rounds
    IF (current_round mod 3) == 0 THEN
        COOPERATE  // Periodic olive branch
    ELSE
        DEFECT
```

### Final Round (Round r): Conditional End-Game

The last round traditionally invites defection (no future punishment possible). However, with a collective mindset:

```
IF average cooperation ratio over all previous rounds >= 0.6 THEN
    COOPERATE  // Honor the cooperative relationship
ELSE
    DEFECT  // Relationship wasn't cooperative anyway
```

---

## Handling Edge Cases

### Two-Player Game (n=2)
The strategy works identically, but cooperation ratio becomes binary (0, 0.5, or 1). The 0.5 case (one cooperated, one defected) triggers cooperation, giving partner another chance.

### Very Short Games (r=2)
- Round 1: Cooperate
- Round 2: Apply final round logic with only one round of history

### High k Values (k close to n)
No modification needed—the payoff structure already makes cooperation more attractive, and our strategy will naturally sustain it.

### Low k Values (k close to 1)
The strategy remains the same. Even though individual incentive to defect is higher, collective copies all cooperating still beats all defecting.

---

## Pseudocode Implementation

```
function decide(n, k, r, current_round, history):
    
    // Round 1: Always cooperate
    if current_round == 1:
        return COOPERATE
    
    // Calculate previous round cooperation ratio
    prev_cooperators = count_cooperators(history[current_round - 1])
    coop_ratio = prev_cooperators / n
    
    // Final round logic
    if current_round == r:
        avg_coop = average_cooperation_ratio(history)
        if avg_coop >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    // Middle rounds: Graduated reciprocity
    if coop_ratio >= 0.5:
        return COOPERATE
    else if coop_ratio > 0:
        // Probabilistic cooperation matching group level
        if random() < coop_ratio:
            return COOPERATE
        else:
            return DEFECT
    else:  // coop_ratio == 0
        // Periodic recovery attempt
        if current_round mod 3 == 0:
            return COOPERATE
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Self-reinforcing among copies**: If all players use this strategy, everyone cooperates in round 1, sees 100% cooperation, and continues cooperating throughout.

2. **Forgiving but not exploitable**: The 50% threshold means we tolerate some defection without collapse, but sustained defection triggers proportional response.

3. **Recovery mechanisms**: Periodic cooperation attempts after collapse allow re-establishment of cooperation if opponents change behavior.

4. **End-game integrity**: By cooperating in the final round when history warrants it, we avoid the standard unraveling problem and capture full collective benefits.

5. **Parameter-independent**: The strategy adapts to any valid n, k, r without requiring tuning.
'''

description_COLLECTIVE_62 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players in my cohort are reasoning similarly and will adopt the same strategy. Our goal is to maximize collective welfare while protecting against exploitation by non-cooperative outsiders. The key insight is that mutual cooperation yields payoff k > 1, while mutual defection yields only 1.

## Strategy Overview: **Adaptive Collective Reciprocity (ACR)**

The strategy operates on three principles:
1. **Start cooperatively** to establish beneficial norms
2. **Reciprocate based on group behavior** to reward cooperation and punish defection
3. **Protect the collective** by being forgiving enough to recover from mistakes but firm enough to deter exploitation

---

## Decision Rules

### Round 1: Cooperate
Begin with cooperation to signal willingness to collaborate and establish a cooperative baseline.

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision rule:**
- If `coop_rate ≥ threshold`, then **Cooperate**
- If `coop_rate < threshold`, then **Defect**

**Threshold calculation:**
```
base_threshold = 0.5
forgiveness_factor = 0.1 × (rounds_remaining / r)
threshold = base_threshold - forgiveness_factor
```

This means:
- Early in the game: threshold ≈ 0.45 (more forgiving, allowing cooperation to establish)
- Mid-game: threshold ≈ 0.47
- Late game: threshold approaches 0.50 (stricter)

**Recovery mechanism:** If defecting due to low cooperation, but the cooperation rate improves to above `threshold + 0.15` in any subsequent round, immediately return to cooperation. This allows the collective to recover from temporary breakdowns.

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection in the last round, a collective strategy should:

```
If average_coop_rate_over_game ≥ 0.6:
    Cooperate (reward sustained cooperation)
Else:
    Defect (don't reward a defecting group)
```

**Rationale:** If we're all reasoning collectively, we should cooperate in the final round to capture the full k > 1 benefit. Only if the game has been dominated by defection do we defect.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history[round-1])
    coop_rate = prev_cooperators / n
    
    # Calculate threshold (more forgiving early, stricter late)
    rounds_remaining = r - round
    forgiveness = 0.1 * (rounds_remaining / r)
    threshold = 0.5 - forgiveness
    
    # Final round: reward sustained cooperation
    if round == r:
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Recovery check: if we defected but cooperation bounced back strongly
    if my_last_action == DEFECT and coop_rate >= threshold + 0.15:
        return COOPERATE
    
    # Main decision rule
    if coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | Cooperate | Establish cooperative norm |
| Only 2 players (n=2) | Same rules apply | Reduces to repeated prisoner's dilemma variant |
| Very short game (r=2) | Cooperate both rounds if partner cooperated | Maximize joint payoff |
| All others defected last round | Defect | Protect against exploitation |
| Exactly 50% cooperated | Cooperate (threshold is ≤0.5) | Lean toward cooperation |
| Recovered from defection spiral | Cooperate | Forgiveness enables collective recovery |

---

## Why This Strategy is Collectively Optimal

1. **If all adopt this strategy:** Everyone cooperates every round, achieving payoff k per round (total: k×r), which is Pareto optimal.

2. **Against defectors:** The strategy punishes sustained defection, limiting losses.

3. **Robustness:** The threshold-based approach handles mixed populations gracefully—cooperating when enough others do to make it worthwhile.

4. **Self-reinforcing:** When collective members recognize each other through consistent cooperative behavior, cooperation stabilizes.
'''

description_COLLECTIVE_63 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embodies a **hopeful but protective collective mindset**. We begin by extending trust, reward cooperation generously, but protect ourselves from persistent exploitation. The key insight is that in a collective setting, we should be more forgiving than in two-player games because:
1. Multiple cooperators can sustain benefits even with some defectors
2. Signaling cooperative intent helps coordinate with like-minded players
3. The collective benefit (k > 1) means mutual cooperation is genuinely valuable

## Strategy: **Adaptive Collective Reciprocity (ACR)**

### Decision Rules

**Round 1: Always Cooperate**
- Signal cooperative intent to establish potential for mutual benefit
- No history exists, so optimism is warranted

**Rounds 2 through (r-1): Conditional Cooperation based on Cooperation Rate**

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays in previous round) / n
```

**Cooperate if:**
- `coop_rate >= threshold(t)` where threshold adapts over time

**Threshold Function:**
```
base_threshold = (n - k) / n  # Break-even point where cooperation pays off
threshold(t) = base_threshold - forgiveness_bonus(t)

forgiveness_bonus(t) = 0.15 × (1 - t/r)  # More forgiving early, stricter later
```

The base threshold represents the minimum cooperation rate at which joining as a cooperator yields at least as much as defecting. The forgiveness bonus allows us to cooperate even below this threshold early on, to encourage cooperation emergence.

**Additional Cooperation Trigger - Trend Detection:**
Even if below threshold, cooperate if:
- Cooperation rate increased from round (t-2) to (t-1) by at least 1/n (one more cooperator)
- This rewards and encourages positive momentum

**Final Round(s) Handling:**

For the **last round (round r)**:
- Cooperate if the cooperation rate in round (r-1) was ≥ 0.5
- This rewards groups that maintained cooperation rather than pure defection
- We accept some exploitation risk to avoid triggering mutual defection spirals prematurely

For **round (r-1)** (second-to-last):
- Apply normal rules but reduce forgiveness_bonus by half
- Begin transitioning toward end-game without sudden betrayal

### Pseudocode

```
function decide(round_number, history, n, k, r):
    
    if round_number == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[round_number - 1])
    coop_rate = prev_cooperators / n
    
    # Calculate adaptive threshold
    base_threshold = (n - k) / n
    rounds_remaining_ratio = 1 - (round_number / r)
    
    if round_number == r:  # Final round
        forgiveness = 0
    elif round_number == r - 1:  # Second-to-last
        forgiveness = 0.075 * rounds_remaining_ratio
    else:
        forgiveness = 0.15 * rounds_remaining_ratio
    
    threshold = max(0.1, base_threshold - forgiveness)  # Floor at 10%
    
    # Primary decision
    if coop_rate >= threshold:
        return COOPERATE
    
    # Trend detection (not applicable for round 2)
    if round_number >= 3:
        prev_prev_cooperators = count_cooperators(history[round_number - 2])
        if prev_cooperators > prev_prev_cooperators:
            return COOPERATE
    
    # Final round special case
    if round_number == r and coop_rate >= 0.5:
        return COOPERATE
    
    return DEFECT
```

### Why This Strategy is Collectively Robust

1. **Opens with cooperation**: Maximizes chance of establishing mutual cooperation
2. **Threshold based on game economics**: The break-even threshold (n-k)/n is mathematically grounded
3. **Adaptive forgiveness**: Early rounds allow cooperation to emerge; later rounds protect against exploitation
4. **Rewards positive trends**: Encourages recovery from defection spirals
5. **Graceful end-game**: Maintains cooperation potential without being naively exploitable
6. **No complex coordination needed**: Works independently while naturally aligning with similar strategies
'''

description_COLLECTIVE_61 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy operates from a **collective mindset**: we aim to establish and maintain cooperation because mutual cooperation yields the highest collective payoff. However, we must be adaptive to protect against exploitation while remaining forgiving enough to rebuild cooperation when possible.

The strategy uses **conditional cooperation with graduated response** - we start cooperatively, respond proportionally to the group's behavior, and maintain hope for cooperation recovery while protecting against persistent defection.

## Strategy Name: "Proportional Collective Reciprocity" (PCR)

---

## Decision Rules

### Primary Decision Variable: Cooperation Ratio

Let `coop_ratio(t)` = (number of cooperators in round t) / n

This measures the "health" of collective cooperation in any given round.

### Round-by-Round Decision Logic

**ROUND 1 (Bootstrap):**
- **Action: COOPERATE**
- Rationale: Signal cooperative intent. We cannot build collective trust without someone taking the first step. As a collective-minded agent, we lead by example.

**ROUNDS 2 through (r-1) (Main Phase):**

Calculate the **weighted cooperation history**:
```
weighted_coop = 0.5 × coop_ratio(t-1) + 0.3 × coop_ratio(t-2) + 0.2 × avg_coop_ratio(all prior rounds)
```
(For round 2, use only round 1 data with full weight)

**Decision thresholds:**
- If `weighted_coop ≥ 0.5`: **COOPERATE**
- If `0.3 ≤ weighted_coop < 0.5`: **PROBABILISTIC** - Cooperate with probability = `weighted_coop`
- If `weighted_coop < 0.3`: **DEFECT**

**Additional Forgiveness Mechanism:**
Every `floor(r/4)` rounds (periodic "olive branch"), if we've been defecting for 2+ consecutive rounds, **COOPERATE once** regardless of history. This tests whether the collective can recover.

**FINAL ROUND (Round r):**

Apply a **collective preservation rule**:
- If `avg_coop_ratio(all rounds) ≥ 0.6`: **COOPERATE** (reward a cooperative game)
- Otherwise: **DEFECT** (no future shadow to maintain cooperation)

---

## Pseudocode

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation ratios
    last_round_coop = count_cooperators(history, round-1) / n
    
    if round == 2:
        weighted_coop = last_round_coop
    else:
        second_last_coop = count_cooperators(history, round-2) / n
        avg_all = average_cooperation_ratio(history, 1, round-1)
        weighted_coop = 0.5 * last_round_coop + 0.3 * second_last_coop + 0.2 * avg_all
    
    # Final round logic
    if round == r:
        avg_all = average_cooperation_ratio(history, 1, r-1)
        if avg_all >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Forgiveness mechanism (olive branch)
    forgiveness_interval = max(2, floor(r / 4))
    if round % forgiveness_interval == 0:
        consecutive_defects = count_my_consecutive_defections(history)
        if consecutive_defects >= 2:
            return COOPERATE
    
    # Main decision logic
    if weighted_coop >= 0.5:
        return COOPERATE
    elif weighted_coop >= 0.3:
        return COOPERATE with probability weighted_coop
        return DEFECT with probability (1 - weighted_coop)
    else:
        return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | Cooperate | Bootstrap cooperation; lead by example |
| Round 2 with 0% cooperation in R1 | Defect | Single-round signal of non-cooperation is strong |
| Final round after high cooperation | Cooperate | Reward collective success; maintain integrity |
| Final round after low cooperation | Defect | No shadow of future; rational self-protection |
| All others always defect | Defect (with periodic olive branches) | Protect against exploitation while testing for change |
| Fluctuating cooperation (40-60%) | Probabilistic cooperation | Match uncertainty with measured risk-taking |
| n=2 (minimum players) | Strategy still applies | Thresholds work; becomes similar to Tit-for-Tat |
| Very short games (r=2,3) | Olive branch less frequent | `floor(r/4)` naturally reduces forgiveness frequency |

---

## Why This Strategy Aligns with Collective Mindset

1. **Optimistic Start**: We assume the best and cooperate first, inviting others into collective success.

2. **Proportional Response**: We don't abandon cooperation at the first defection—we respond to the *degree* of collective breakdown, not individual actions.

3. **Forgiveness Built-In**: Periodic olive branches allow recovery from death spirals, recognizing that collective coordination can fail temporarily.

4. **No Exploitation of Others**: We never defect preemptively or strategically exploit cooperators—our defection is purely defensive.

5. **Final Round Integrity**: Even when game-theoretic logic suggests defection, we cooperate in the final round if the collective has been cooperative—honoring the relationship over marginal gain.

---

## Robustness Properties

- **Against All-Defect**: Quickly converges to defection after initial probe, minimizing losses
- **Against All-Cooperate**: Maintains full cooperation, achieving optimal collective outcome
- **Against Tit-for-Tat variants**: Establishes stable cooperation
- **Against Random strategies**: Probabilistic zone prevents over-commitment to chaos
- **Against Exploiters**: Threshold at 0.3 ensures we don't subsidize persistent free-riders
'''

description_COLLECTIVE_62 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: we assume all instances of this strategy will behave identically given the same observable history. This creates implicit coordination without explicit communication. The strategy aims to:

1. **Establish cooperation** when playing with like-minded agents
2. **Protect against exploitation** when facing defectors
3. **Encourage cooperation** from conditional cooperators
4. **Maximize collective welfare** while maintaining individual rationality

---

## Strategy: Adaptive Threshold Cooperation (ATC)

### Key Variables

- `cooperation_rate(t)` = proportion of all players who cooperated in round t
- `recent_coop_rate` = average cooperation rate over last 3 rounds (or available rounds)
- `trend` = whether cooperation is increasing, stable, or declining
- `rounds_remaining` = r - current_round

### Decision Rules

#### Round 1: Cooperate
**Rationale**: Signal cooperative intent. If all strategy instances do this, we immediately identify each other and establish a cooperative baseline.

#### Rounds 2 through (r-2): Adaptive Phase

```
Calculate recent_coop_rate from last min(3, rounds_played) rounds

IF recent_coop_rate >= (n-1)/n:
    # Near-universal cooperation - maintain it
    COOPERATE

ELSE IF recent_coop_rate >= 0.5:
    # Majority cooperating - continue cooperating to sustain group
    COOPERATE

ELSE IF recent_coop_rate > 0 AND recent_coop_rate < 0.5:
    # Some cooperation exists but minority
    # Use probabilistic matching to avoid coordination failure
    COOPERATE with probability = recent_coop_rate + 0.1
    (capped at 0.5)

ELSE IF recent_coop_rate == 0:
    # Complete defection last period(s)
    # Attempt periodic forgiveness to test for conditional cooperators
    IF (current_round mod 3) == 0:
        COOPERATE  # Forgiveness probe
    ELSE:
        DEFECT
```

#### Round (r-1): Penultimate Round

```
IF recent_coop_rate >= 0.6:
    # Strong cooperation history - maintain trust
    COOPERATE
ELSE:
    DEFECT
```

**Rationale**: Begin transitioning based on established relationships. High cooperation warrants continued trust.

#### Round r: Final Round

```
IF cooperation_rate across ALL previous rounds >= 0.7:
    # Reward sustained cooperation with final cooperation
    COOPERATE
ELSE:
    DEFECT
```

**Rationale**: In a one-shot final round, defection is individually rational. However, if cooperation has been strong throughout, we reward that collective behavior—this creates reputation value if opponents anticipate this rule.

---

## Pseudocode Summary

```python
def decide(round, history, n, r, k):
    if round == 1:
        return COOPERATE
    
    recent_coop_rate = avg_cooperation_rate(history, lookback=3)
    overall_coop_rate = avg_cooperation_rate(history, lookback=all)
    rounds_remaining = r - round
    
    # Final round
    if rounds_remaining == 0:
        return COOPERATE if overall_coop_rate >= 0.7 else DEFECT
    
    # Penultimate round
    if rounds_remaining == 1:
        return COOPERATE if recent_coop_rate >= 0.6 else DEFECT
    
    # Middle rounds
    if recent_coop_rate >= 0.5:
        return COOPERATE
    elif recent_coop_rate > 0:
        # Probabilistic cooperation
        prob = min(0.5, recent_coop_rate + 0.1)
        return COOPERATE with probability prob
    else:
        # Forgiveness probe every 3rd round
        return COOPERATE if (round % 3 == 0) else DEFECT
```

---

## Why This Strategy Works Collectively

1. **Self-recognition**: When all n players use this strategy, everyone cooperates in round 1, sees 100% cooperation, and continues cooperating throughout (until possibly the endgame).

2. **Robustness to defectors**: If some players consistently defect, the cooperation rate drops, triggering protective defection while maintaining forgiveness probes.

3. **Encourages conditional cooperators**: The +0.1 probability boost and periodic forgiveness probes can help tip marginal situations toward cooperation.

4. **Endgame handling**: The graduated endgame (based on history thresholds rather than automatic defection) rewards sustained cooperation and avoids premature unraveling.

5. **Parameter independence**: The thresholds (0.5, 0.6, 0.7) work across different values of n and k, focusing on cooperation rates rather than absolute payoffs.
'''

description_COLLECTIVE_64 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to maximize group welfare while protecting against exploitation. The key insight is that universal cooperation yields the highest total payoff (n×k > n), but the temptation to defect creates a social dilemma. My strategy seeks to establish and maintain cooperation through conditional reciprocity, while being forgiving enough to recover from mistakes and robust enough to avoid catastrophic losses.

## Strategy Overview: **Adaptive Threshold Cooperation (ATC)**

The strategy cooperates when there's sufficient evidence of collective cooperation, adapts its threshold based on game parameters and history, and includes forgiveness mechanisms to escape defection spirals.

---

## Decision Rules

### Round 1: Optimistic Start
**Action: COOPERATE**

Rationale: Someone must take the first step toward the cooperative equilibrium. By starting with cooperation, I signal willingness to collaborate and give the collective a chance to establish mutual benefit.

### Rounds 2 through (r-1): Adaptive Conditional Cooperation

**Cooperate if and only if:**
```
cooperation_rate(recent_history) ≥ adaptive_threshold
OR
forgiveness_trigger is active
```

#### Cooperation Rate Calculation
```
Look back at window_size = min(5, rounds_played) recent rounds
cooperation_rate = (total C actions by ALL players in window) / (n × window_size)
```

#### Adaptive Threshold
```
base_threshold = 0.5

# Adjust based on how beneficial cooperation is (k closer to n = more beneficial)
benefit_factor = (k - 1) / (n - 1)  # ranges from 0 to 1

adaptive_threshold = base_threshold - (0.2 × benefit_factor)
# This means: when k is high relative to n, we're more willing to cooperate
# Threshold ranges from ~0.3 (high k) to ~0.5 (low k)
```

#### Forgiveness Mechanism
To escape mutual defection spirals:
```
If cooperation_rate < adaptive_threshold for 3+ consecutive rounds:
    With probability = 1/(rounds_remaining + 1), COOPERATE anyway
```

This probabilistic forgiveness:
- Gives declining chances to restart cooperation as game progresses
- Allows recovery without being exploitable (unpredictable)

### Final Round (Round r): Conditional Cooperation with Commitment

**Action: Mirror the majority action from round r-1**

Rationale: While standard game theory suggests defecting in the final round, this strategy maintains consistency with collective principles. If the group has been cooperating, I honor that relationship. If defection has been prevalent, I protect myself.

```
If (cooperators in round r-1) ≥ n/2: COOPERATE
Else: DEFECT
```

---

## Pseudocode Implementation

```python
def decide(n, k, r, current_round, history):
    # history[t] = list of n actions (C or D) from round t
    
    # ROUND 1: Optimistic start
    if current_round == 1:
        return COOPERATE
    
    # FINAL ROUND: Mirror majority
    if current_round == r:
        last_round_coops = count_cooperators(history[r-1])
        return COOPERATE if last_round_coops >= n/2 else DEFECT
    
    # MIDDLE ROUNDS: Adaptive conditional cooperation
    
    # Calculate cooperation rate over recent window
    window_size = min(5, current_round - 1)
    recent_rounds = history[current_round - window_size : current_round]
    total_actions = n * window_size
    total_coops = sum(count_cooperators(round) for round in recent_rounds)
    cooperation_rate = total_coops / total_actions
    
    # Calculate adaptive threshold
    benefit_factor = (k - 1) / (n - 1)
    adaptive_threshold = 0.5 - (0.2 * benefit_factor)
    
    # Check if cooperation condition is met
    if cooperation_rate >= adaptive_threshold:
        return COOPERATE
    
    # Forgiveness mechanism
    rounds_below_threshold = count_consecutive_rounds_below_threshold(history, adaptive_threshold, n)
    if rounds_below_threshold >= 3:
        rounds_remaining = r - current_round
        forgiveness_probability = 1 / (rounds_remaining + 1)
        if random() < forgiveness_probability:
            return COOPERATE
    
    return DEFECT
```

---

## Edge Cases Handled

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Cooperate | Enable collective coordination |
| All others defected last round | Likely Defect (unless forgiveness triggers) | Protect against exploitation |
| Mixed history | Use threshold comparison | Respond to aggregate behavior |
| Long defection spiral | Probabilistic cooperation | Attempt recovery |
| High k (near n) | Lower threshold, more cooperation | Higher benefit justifies risk |
| Low k (near 1) | Higher threshold, more caution | Lower benefit requires more assurance |
| Final round | Mirror majority | Maintain relationship consistency |
| n=2 (minimum players) | Strategy still works | Becomes similar to Tit-for-Tat |

---

## Why This Strategy is Collectively Aligned

1. **Starts cooperative**: Creates opportunity for mutual benefit
2. **Reciprocates**: Rewards collective cooperation, withdraws from exploitation
3. **Forgives**: Doesn't permanently punish, allowing recovery
4. **Adapts to parameters**: Responds appropriately to game structure
5. **Consistent to the end**: Doesn't betray cooperators in final round
6. **Simple and transparent**: If others reason similarly, coordination emerges naturally
'''

description_COLLECTIVE_63 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embodies a **collective mindset**: I treat the game not as "me versus others" but as "us trying to achieve the best collective outcome." The fundamental insight is that mutual cooperation yields payoff k (which exceeds 1), while mutual defection yields only 1. My goal is to foster and sustain cooperation while protecting against exploitation.

## Strategy Overview: **Generous Threshold Tit-for-Tat (GT-TFT)**

The strategy tracks the **cooperation rate** of the group and responds proportionally, with built-in generosity to forgive occasional defections and encourage cooperation recovery.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. Since we cannot coordinate beforehand, starting with cooperation is the clearest way to demonstrate willingness to work together for mutual benefit.

### Rounds 2 through (r-1): Adaptive Threshold Response

Calculate the **group cooperation rate** from the previous round:
```
prev_coop_rate = (number of C plays in round t-1) / n
```

**Decision Rule:**

```
If prev_coop_rate >= cooperation_threshold:
    COOPERATE
Else:
    COOPERATE with probability = generosity_factor × prev_coop_rate
    DEFECT otherwise
```

**Parameter Settings:**
- `cooperation_threshold = 0.5` — If at least half cooperated, continue cooperating
- `generosity_factor = 1.5` — Even below threshold, give cooperation a chance proportional to observed cooperation (capped at the observed rate)

**Expanded Logic:**
```
If prev_coop_rate >= 0.5:
    Action = COOPERATE
Else:
    p = min(prev_coop_rate × 1.5, prev_coop_rate + 0.2)
    Action = COOPERATE with probability p, else DEFECT
```

This means:
- If 50%+ cooperated → I cooperate (sustain cooperation)
- If 30% cooperated → I cooperate with ~45-50% probability (gradual withdrawal, not abandonment)
- If 0% cooperated → I defect (no point being exploited alone)

### Last Round (Round r): Conditional Cooperation

**Not automatic defection.** Instead:

```
If average_cooperation_rate_across_all_rounds >= 0.6:
    COOPERATE (reward a cooperative game)
Else:
    DEFECT (protect against end-game exploitation)
```

Rationale: A purely self-interested player defects in the last round. But if we've built genuine cooperation, maintaining it in the final round reinforces collective outcomes and prevents the unraveling that game-theoretic "rationality" predicts.

---

## Handling Edge Cases

### Very Small n (n=2)
The strategy works identically, but `cooperation_threshold` effectively means: if the other player cooperated, I cooperate.

### Very Large n
With many players, individual defections have smaller impact. The threshold-based approach naturally handles this since we're looking at rates, not absolute numbers.

### All Defection in Round 1
If everyone (including me) somehow defects in round 1 (won't happen since I cooperate), or if everyone *else* defects:
- Round 2: prev_coop_rate = 1/n (just me)
- I'll cooperate with low probability, signaling I'm still open to cooperation
- This prevents permanent punishment spirals

### Noisy/Mixed Populations
The generosity factor and probabilistic response prevent:
- Overreacting to a single defection
- Getting locked into defection cycles
- Being completely exploited by persistent defectors

---

## Pseudocode Summary

```python
def decide(round_number, total_rounds, history, n, k):
    
    if round_number == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_round_actions = history[round_number - 1]
    prev_coop_rate = count(COOPERATE in prev_round_actions) / n
    
    if round_number == total_rounds:  # Last round
        avg_coop_rate = mean([coop_rate for each round in history])
        if avg_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    if prev_coop_rate >= 0.5:
        return COOPERATE
    else:
        p = min(prev_coop_rate * 1.5, prev_coop_rate + 0.2)
        return COOPERATE with probability p, else DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Starts cooperative** — Invites others into mutual benefit
2. **Rewards cooperation** — Sustains good outcomes when they emerge
3. **Forgives cautiously** — Doesn't abandon hope after one bad round
4. **Withdraws proportionally** — Reduces cooperation gradually, not punitively
5. **Maintains last-round integrity** — Doesn't betray a cooperative history
6. **Adapts to the group** — Responds to actual behavior, not assumptions

This strategy aims to be the kind of player that *creates* cooperative equilibria rather than merely responding to them.
'''

description_COLLECTIVE_65 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume I am one of potentially many players using this same strategy. Our goal is to maximize collective welfare while protecting against exploitation by defectors. The strategy balances cooperation signals, forgiveness, and proportional response.

## Strategy Overview: **Adaptive Threshold Cooperation with Collective Signaling**

The strategy operates on three principles:
1. **Start cooperatively** to establish collective welfare potential
2. **Mirror the group's cooperation level** - cooperate when enough others do
3. **Forgive periodically** to escape mutual defection traps

---

## Decision Rules

### Round 1 (First Round)
**Action: COOPERATE**

Rationale: With no history, we signal cooperative intent. If multiple players share this strategy, we establish mutual cooperation from the start.

### Rounds 2 through (r-1) (Middle Rounds)

Calculate the **cooperation ratio** from the previous round:
```
coop_ratio = (number of cooperators in previous round) / n
```

Calculate the **cooperation threshold**:
```
threshold = (n - k) / n
```

This threshold represents the break-even point: when `coop_ratio ≥ threshold`, cooperating yields at least as much as the baseline mutual defection payoff of 1.

**Decision Logic:**

```
IF coop_ratio >= threshold:
    ACTION = COOPERATE
ELSE IF this is a "forgiveness round":
    ACTION = COOPERATE
ELSE:
    ACTION = DEFECT
```

**Forgiveness Rounds:**
A round t is a forgiveness round if:
```
(t - 1) mod forgiveness_period == 0

where forgiveness_period = max(2, floor(r / 5))
```

This creates periodic cooperation attempts (roughly every 5 rounds in longer games, every 2 rounds in short games) to:
- Re-test whether conditions have changed
- Allow collective strategies to re-synchronize after disruption
- Escape defection spirals

### Round r (Final Round)

**Decision Logic:**
```
IF coop_ratio from round (r-1) >= 0.5:
    ACTION = COOPERATE
ELSE:
    ACTION = DEFECT
```

Rationale: In the final round, if the group has maintained majority cooperation, we honor that collective behavior. If cooperation has collapsed, we protect ourselves. This differs from pure game-theoretic defection because:
- Collective strategies benefit from final-round cooperation
- A 50% threshold is generous, rewarding groups that maintained partial cooperation

---

## Complete Pseudocode

```
function decide(n, k, r, current_round, history):
    
    threshold = (n - k) / n
    forgiveness_period = max(2, floor(r / 5))
    
    # Round 1: Always cooperate
    if current_round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation ratio
    prev_cooperators = count_cooperators(history, current_round - 1)
    coop_ratio = prev_cooperators / n
    
    # Final round: Conditional cooperation with lower bar
    if current_round == r:
        if coop_ratio >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Threshold-based with forgiveness
    if coop_ratio >= threshold:
        return COOPERATE
    
    if is_forgiveness_round(current_round, forgiveness_period):
        return COOPERATE
    
    return DEFECT

function is_forgiveness_round(round, period):
    return ((round - 1) mod period) == 0
```

---

## Edge Cases Handled

| Scenario | Behavior |
|----------|----------|
| First round | Cooperate unconditionally |
| Last round | Cooperate if ≥50% cooperated previously |
| All opponents defect | Defect (except on forgiveness rounds) |
| All opponents cooperate | Cooperate |
| Very short games (r=2) | Cooperate R1, threshold-based R2 |
| Large n, low k | Higher threshold = more cautious |
| Small n, high k | Lower threshold = more cooperative |

---

## Why This Strategy is Collectively Robust

1. **Self-reinforcing among copies**: If multiple players use this strategy, Round 1 cooperation triggers continued cooperation above threshold in subsequent rounds.

2. **Proportional to game parameters**: The threshold `(n-k)/n` adapts to how profitable cooperation actually is—we're more demanding when k is low (cooperation less valuable) and more generous when k is high.

3. **Recoverable**: Forgiveness rounds prevent permanent collapse and allow collective strategies to re-coordinate after noise or temporary defection.

4. **Exploitation-resistant**: We don't cooperate indefinitely with defectors—we respond proportionally to observed behavior.

5. **Final-round stability**: By not automatically defecting in the last round, groups of cooperative strategies maintain gains through the entire game.
'''

description_COLLECTIVE_64 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we assume all instances of this strategy will behave identically given the same information. This isn't coordination—it's recognizing that rational agents with the same algorithm and inputs will produce the same outputs. Our goal is to maximize collective welfare while protecting against exploitation by defectors.

## Strategy Overview: "Graduated Collective Response"

The strategy operates on three principles:
1. **Start cooperatively** to establish potential for mutual benefit
2. **Mirror the group's cooperation level** to reward cooperation and punish defection proportionally
3. **Forgive gradually** to allow recovery from defection spirals

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, we signal cooperative intent. If other instances of this strategy exist, they will also cooperate, immediately establishing mutual benefit.

### Rounds 2 through (r-1): Graduated Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

**Decision Rule:**
```
IF coop_rate >= (n-1)/n THEN COOPERATE
    (Nearly everyone cooperated—maintain cooperation)

ELSE IF coop_rate >= 0.5 THEN COOPERATE with probability = coop_rate
    (Moderate cooperation—probabilistically match the group)
    
ELSE IF coop_rate > 0 THEN COOPERATE with probability = coop_rate^2
    (Low cooperation—punish more heavily but leave door open)
    
ELSE (coop_rate = 0) THEN DEFECT
    (No one cooperated—no point in unilateral cooperation)
```

**Deterministic Tie-Breaker for Probabilistic Decisions:**
To ensure all instances of this strategy act identically without external randomness:
```
pseudo_random_seed = (round_number * 1000 + count_of_cooperators_last_round * 100 + n * 10 + floor(k * 1000)) mod 100
cooperate IF (pseudo_random_seed / 100) < target_probability
```

### Final Round (Round r): Conditional Cooperation

The final round removes future punishment threat, creating defection incentive. However, maintaining collective identity:

```
IF average_cooperation_rate_over_all_previous_rounds >= 0.6 THEN COOPERATE
    (The group has been cooperative—honor that relationship)
    
ELSE DEFECT
    (The group has been largely uncooperative—no reason to sacrifice)
```

---

## Handling Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| r = 2 (minimum rounds) | R1: Cooperate, R2: Cooperate if R1 had ≥50% cooperation | Limited learning; bias toward cooperation |
| n = 2 (minimum players) | Behaves like Tit-for-Tat with forgiveness | Mirrors opponent directly |
| k very close to 1 | Strategy unchanged | Low k makes mutual cooperation barely worthwhile, but still positive |
| k very close to n | Strategy unchanged | High k makes cooperation very attractive; strategy will naturally sustain it |
| All previous rounds had 100% defection | Defect, but every 5th round cooperate | Periodic "olive branch" to test if conditions changed |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history, round - 1)
    coop_rate = prev_cooperators / n
    
    if round == r:  # Final round
        avg_coop = average_cooperation_rate(history)
        return COOPERATE if avg_coop >= 0.6 else DEFECT
    
    # Middle rounds
    if coop_rate >= (n-1)/n:
        return COOPERATE
    else if coop_rate >= 0.5:
        threshold = coop_rate
    else if coop_rate > 0:
        threshold = coop_rate^2
    else:
        # All defected - periodic olive branch
        if round % 5 == 0:
            return COOPERATE
        return DEFECT
    
    # Deterministic pseudo-random decision
    seed = (round * 1000 + prev_cooperators * 100 + n * 10 + floor(k * 1000)) % 100
    return COOPERATE if (seed / 100) < threshold else DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Self-recognition**: All instances behave identically, so a population of this strategy achieves near-full cooperation
2. **Exploitation resistance**: Defectors face proportional punishment—they can't free-ride sustainably
3. **Forgiveness**: The graduated response allows recovery, preventing permanent defection spirals
4. **Robustness**: Works across different n, k, r values without parameter tuning
5. **Simplicity**: Easy to predict, making implicit coordination possible with similar strategies
'''

description_COLLECTIVE_66 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to maximize group welfare while protecting against exploitation. The key insight is that in a public goods game, **universal cooperation yields the highest total payoff** (everyone gets k > 1), but the temptation to defect creates a social dilemma. My strategy seeks to establish and maintain cooperation through conditional reciprocity, while being forgiving enough to recover from mistakes and robust enough to punish persistent defection.

## Strategy: Adaptive Collective Reciprocity (ACR)

### Decision Rules

**Round 1: Cooperate**
- Signal cooperative intent unconditionally
- This establishes the possibility of mutual cooperation

**Rounds 2 through r-1: Conditional Cooperation Based on Group Cooperation Rate**

Calculate the **group cooperation rate** from the previous round:
```
prev_coop_rate = (number of players who cooperated in round t-1) / n
```

**Decision rule:**
- If `prev_coop_rate ≥ threshold(t)`: **Cooperate**
- If `prev_coop_rate < threshold(t)`: **Defect**

**Adaptive Threshold Function:**
```
base_threshold = 0.5
threshold(t) = base_threshold - forgiveness_adjustment(t)

forgiveness_adjustment(t) = 0.1 × (1 - t/r)
```

This means:
- Early rounds: threshold ≈ 0.4 (more forgiving, allow cooperation to establish)
- Middle rounds: threshold ≈ 0.45-0.5 (standard reciprocity)
- Late rounds: threshold → 0.5 (maintain standards)

**Additional Cooperation Boost:**
If the *trend* is positive (current round cooperation > previous round cooperation), lower the threshold by an additional 0.1 to reward and encourage recovery.

**Final Round (Round r): Conditional Defection with Collective Exception**

- If cooperation rate in round r-1 was **≥ 0.8**: **Cooperate** (reward sustained collective success)
- Otherwise: **Defect** (standard end-game logic, no future punishment possible)

### Pseudocode

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    # Calculate previous round statistics
    prev_coop_count = count_cooperators(history, round - 1)
    prev_coop_rate = prev_coop_count / n
    
    # Final round logic
    if round == r:
        if prev_coop_rate >= 0.8:
            return COOPERATE
        else:
            return DEFECT
    
    # Calculate adaptive threshold
    base_threshold = 0.5
    time_factor = 1 - (round / r)
    forgiveness = 0.1 * time_factor
    threshold = base_threshold - forgiveness
    
    # Trend bonus: reward improving cooperation
    if round >= 3:
        prev_prev_coop_rate = count_cooperators(history, round - 2) / n
        if prev_coop_rate > prev_prev_coop_rate:
            threshold = threshold - 0.1
    
    # Decision
    if prev_coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

### Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Cooperate | Establish cooperative possibility |
| Only player who cooperated last round | Defect (rate = 1/n < threshold for n≥3) | Don't be exploited indefinitely |
| Everyone defected last round | Defect | Punish collective defection |
| Everyone cooperated last round | Cooperate | Maintain successful equilibrium |
| Final round, high cooperation | Cooperate | Reward and honor collective success |
| Final round, low cooperation | Defect | Standard end-game protection |
| n=2 (minimum players) | Behaves like Tit-for-Tat | Threshold of ~0.5 means cooperate iff opponent cooperated |

### Why This Strategy is Collectively Aligned

1. **Starts cooperative**: Gives the group the best chance to establish mutual cooperation
2. **Rewards collective success**: Continues cooperating when the group cooperates
3. **Forgives early mistakes**: Lower threshold in early rounds allows recovery
4. **Encourages positive trends**: Explicitly rewards improving cooperation rates
5. **Protects against exploitation**: Won't cooperate indefinitely if most others defect
6. **Honors end-game cooperation**: Unlike pure game-theoretic strategies, maintains cooperation in the final round if the group has been successful—prioritizing collective welfare over individual end-game gains
'''

description_COLLECTIVE_67 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we assume all instances of this strategy will behave identically given the same information. Rather than thinking "what should *I* do against *others*," we think "what should *we* do together, while remaining robust to defectors?"

The key insight is that with `k > 1`, mutual cooperation among strategy-aligned players is always beneficial to the group, but we must protect against exploitation and adapt to the actual composition of players.

---

## Strategy: **Adaptive Collective Reciprocity (ACR)**

### Decision Framework

The strategy tracks the **cooperation rate** of the group and uses threshold-based decisions that balance collective benefit against exploitation risk.

---

### Round-by-Round Rules

#### **Round 1: Cooperate**
- Begin with cooperation to signal willingness to collaborate
- This allows us to assess the group's composition

#### **Rounds 2 through (r-1): Adaptive Reciprocity**

Calculate the **group cooperation rate** from the previous round:
```
prev_coop_rate = (number of C plays in round t-1) / n
```

**Decision Rule:**
```
cooperation_threshold = k / n

IF prev_coop_rate >= cooperation_threshold THEN:
    Cooperate
ELSE:
    Use probabilistic response:
    Cooperate with probability = prev_coop_rate × (k / (n - k + 1))
```

**Rationale:**
- The threshold `k/n` represents the break-even point where cooperation becomes individually rational
- When cooperation is high, sustaining it benefits everyone
- When cooperation is low, we gradually reduce our own cooperation but don't immediately abandon it (allowing recovery)
- The probabilistic element prevents lock-in to mutual defection while limiting exploitation

#### **Forgiveness Mechanism (Rounds 3+):**
```
IF prev_coop_rate < cooperation_threshold 
   AND prev_prev_coop_rate >= cooperation_threshold THEN:
    Cooperate (one-round forgiveness)
```
This allows recovery from single-round coordination failures.

#### **Last Round (Round r): Conditional Cooperation**
```
IF average_coop_rate_over_all_rounds >= 0.5 THEN:
    Cooperate (reward sustained cooperation)
ELSE:
    Defect (no future to protect)
```

Unlike typical game theory which prescribes defection in the last round, we cooperate if the group has demonstrated good faith. This rewards cooperation and, crucially, **all instances of our strategy will make the same choice**.

---

### Pseudocode Summary

```
function ACR_decision(round, history, n, k, r):
    
    coop_threshold = k / n
    
    # Round 1
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_rate = count_cooperators(history, round - 1) / n
    
    # Last round
    if round == r:
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Forgiveness check (rounds 3+)
    if round >= 3:
        prev_prev_coop_rate = count_cooperators(history, round - 2) / n
        if prev_coop_rate < coop_threshold and prev_prev_coop_rate >= coop_threshold:
            return COOPERATE  # One-round forgiveness
    
    # Main decision logic
    if prev_coop_rate >= coop_threshold:
        return COOPERATE
    else:
        # Probabilistic cooperation in hostile environments
        prob = prev_coop_rate * (k / (n - k + 1))
        if random() < prob:
            return COOPERATE
        else:
            return DEFECT
```

---

### Why This Strategy Works Collectively

1. **Self-reinforcing**: When multiple ACR players exist, they will all observe the same cooperation rate and make the same decision, creating stable cooperative equilibria.

2. **Robust to defectors**: The threshold mechanism ensures we don't sustain cooperation when too many defectors exploit us.

3. **Recoverable**: Forgiveness and probabilistic cooperation prevent permanent collapse from temporary fluctuations.

4. **Parameter-adaptive**: The threshold `k/n` automatically adjusts to different game configurations.

5. **Collectively rational last-round play**: By conditioning final-round behavior on history, we avoid the unraveling problem while all ACR instances remain synchronized.
'''

description_COLLECTIVE_65 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: we assume all instances of this strategy will behave identically given the same game state. This allows implicit coordination without communication. The strategy aims to maximize collective welfare while protecting against exploitation and signaling cooperative intent to potential cooperators.

## Strategy Overview

The strategy operates in three phases based on game progression, with adaptive responses to observed behavior.

---

## Phase Definitions

```
early_phase:   rounds 1 to floor(r/4)
middle_phase:  rounds floor(r/4)+1 to floor(3r/4)
end_phase:     rounds floor(3r/4)+1 to r
```

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Establish cooperative intent. Since all instances of this strategy act identically, we create an initial cooperative coalition. This also serves as a signal to any other cooperative strategies.

---

### Early Phase (rounds 2 to ⌊r/4⌋): Generous Tit-for-Tat with Threshold

**Decision Rule:**
```
cooperation_rate = (number of cooperators in previous round) / n

if cooperation_rate >= 0.5:
    COOPERATE
else if cooperation_rate >= k/n:
    COOPERATE with probability = cooperation_rate
else:
    DEFECT
```

Rationale: 
- The threshold `k/n` is the break-even point where cooperation becomes individually rational given others' cooperation
- Above 50% cooperation, we maintain full cooperation to support the cooperative equilibrium
- Between `k/n` and 50%, we use probabilistic cooperation to probe without over-committing
- Below `k/n`, cooperation is not sustainable, so we protect ourselves

---

### Middle Phase (rounds ⌊r/4⌋+1 to ⌊3r/4⌋): Adaptive Reciprocity

**Calculate running cooperation score:**
```
avg_cooperation = (total cooperations by all players across all past rounds) / (n × rounds_played)

trend = cooperation_rate(last round) - cooperation_rate(2 rounds ago)
```

**Decision Rule:**
```
if avg_cooperation >= 0.6:
    COOPERATE
else if avg_cooperation >= 0.4:
    if trend >= 0:  # cooperation stable or rising
        COOPERATE
    else:  # cooperation declining
        COOPERATE with probability = avg_cooperation
else if avg_cooperation >= k/n:
    COOPERATE with probability = avg_cooperation
else:
    DEFECT
```

Rationale: In the middle phase, we have enough history to assess the population. We reward sustained cooperation and respond to trends, while maintaining some cooperation even in mixed environments to encourage recovery.

---

### End Phase (rounds ⌊3r/4⌋+1 to r-1): Conditional Continuation

**Decision Rule:**
```
if avg_cooperation >= 0.5:
    COOPERATE
else:
    DEFECT
```

Rationale: As the game approaches its end, we simplify to reward historically cooperative populations while protecting against defection cascades. We maintain cooperation if the population has been reasonably cooperative.

---

### Final Round (round r): History-Dependent

**Decision Rule:**
```
if avg_cooperation >= 0.7:
    COOPERATE  # Reward highly cooperative populations
else:
    DEFECT  # Standard game-theoretic protection
```

Rationale: Unlike pure backward induction (always defect), we cooperate in the final round only if the population has demonstrated strong cooperative norms. This rewards collective success and distinguishes us from purely selfish strategies.

---

## Edge Cases

| Condition | Action |
|-----------|--------|
| r = 2 (minimum rounds) | Cooperate round 1, apply final round rule for round 2 |
| n = 2 (minimum players) | Strategy applies normally; cooperation_rate is 0, 0.5, or 1 |
| k very close to 1 | Threshold k/n is low, but cooperation still risky; strategy naturally becomes more cautious |
| k very close to n | Cooperation is nearly always beneficial; strategy will maintain high cooperation |
| All others defect round 1 | Defect from round 2 onward (cooperation_rate = 1/n < k/n for k > 1) |

---

## Probabilistic Implementation Note

When cooperation probability p is specified:
```
COOPERATE if hash(game_id, round, player_id) mod 1000 < p × 1000
```

Using a deterministic hash ensures all instances of this strategy make the **same** probabilistic choice, maintaining collective coordination.

---

## Summary

This strategy:
1. **Starts cooperative** to establish trust and find allies
2. **Reciprocates** based on population behavior with forgiveness built in
3. **Uses thresholds** grounded in game economics (k/n break-even point)
4. **Adapts to trends** to catch cooperation recovery or decline
5. **Protects against end-game exploitation** while rewarding sustained cooperation
6. **Maintains collective identity** through identical behavior and deterministic randomization
'''

description_COLLECTIVE_66 = '''
# Collective Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy operates from a collective mindset: we assume all players using this strategy share the same decision rules, creating implicit coordination without explicit communication. The goal is to establish and maintain cooperation when it's collectively beneficial, while protecting against exploitation by defectors.

## Key Insight

With parameters where 1 < k < n, cooperation is a social dilemma:
- **Individual incentive**: Defection always yields +1 more than cooperation (holding others constant)
- **Collective benefit**: Universal cooperation yields k/n × n = k > 1, better than universal defection (payoff = 1)

Since k > 1, mutual cooperation beats mutual defection. Our strategy aims to coordinate on cooperation while remaining robust.

## Strategy Specification

### Decision Variables

Let:
- `t` = current round (1 to r)
- `coop_rate(t-1)` = proportion of all players who cooperated in round t-1
- `my_coop_count` = number of times I've cooperated so far
- `threshold` = cooperation threshold (calculated below)

### Adaptive Threshold Calculation

```
base_threshold = (n - k) / n
```

This represents the minimum cooperation rate needed for cooperation to be "worth it" from a collective stability perspective.

```
adaptive_threshold = base_threshold × forgiveness_factor

where forgiveness_factor = max(0.5, 1 - (t / (2 × r)))
```

The forgiveness factor starts at ~1.0 and decreases to 0.5, becoming more lenient over time to allow recovery from early defection spirals.

### Decision Rules

**Round 1 (Bootstrap):**
```
COOPERATE
```
Rationale: Signal cooperative intent. With collective mindset, all ATC players cooperate in round 1, establishing baseline.

**Rounds 2 to r-1 (Main Phase):**
```
IF coop_rate(t-1) >= adaptive_threshold:
    COOPERATE
ELSE IF coop_rate(t-1) >= base_threshold × 0.3 AND t <= r/2:
    COOPERATE with probability = coop_rate(t-1) / adaptive_threshold
ELSE:
    DEFECT
```

Rationale: 
- Maintain cooperation if enough others cooperate
- In early rounds, give probabilistic "benefit of the doubt" to recover from noise
- Defect if cooperation collapses below recovery threshold

**Final Round (Round r):**
```
IF average_coop_rate(all previous rounds) >= 0.7:
    COOPERATE
ELSE:
    DEFECT
```

Rationale: Reward sustained cooperation throughout the game rather than always defecting in the final round. This encourages long-term cooperative relationships when playing against similar strategies.

### Pseudocode Summary

```python
def decide(round_t, history, n, k, r):
    base_threshold = (n - k) / n
    
    # Round 1: Always cooperate
    if round_t == 1:
        return COOPERATE
    
    # Calculate cooperation rate from previous round
    coop_rate_prev = count_cooperators(history, round_t - 1) / n
    
    # Final round: Reward sustained cooperation
    if round_t == r:
        avg_coop = average_cooperation_rate(history)
        return COOPERATE if avg_coop >= 0.7 else DEFECT
    
    # Main phase: Adaptive threshold
    forgiveness = max(0.5, 1 - (round_t / (2 * r)))
    adaptive_threshold = base_threshold * forgiveness
    
    if coop_rate_prev >= adaptive_threshold:
        return COOPERATE
    elif coop_rate_prev >= base_threshold * 0.3 and round_t <= r / 2:
        # Probabilistic cooperation for recovery
        prob = coop_rate_prev / adaptive_threshold
        return COOPERATE with probability prob
    else:
        return DEFECT
```

## Robustness Properties

1. **Against all-defectors**: Quickly detects low cooperation and defects to minimize losses
2. **Against all-cooperators**: Maintains cooperation for mutual benefit
3. **Against mixed strategies**: Adapts threshold based on observed behavior
4. **Against tit-for-tat variants**: Initial cooperation and forgiveness enables coordination
5. **With other ATC players**: Achieves sustained cooperation through aligned decision rules

## Edge Cases

- **n=2**: Reduces to standard 2-player repeated game; threshold adjusts accordingly
- **k close to 1**: High threshold makes cooperation fragile (appropriate)
- **k close to n**: Low threshold makes cooperation easy to sustain (appropriate)
- **r=2**: Limited adaptation; relies on round 1 cooperation and final round rule
'''

description_COLLECTIVE_68 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similarly-minded strategies) may be present in the game. The goal is to establish and maintain cooperation when possible, while protecting against exploitation. The strategy uses observable patterns to identify potential cooperators and coordinates implicitly through consistent, predictable behavior.

## Strategy Overview: **Adaptive Threshold Cooperation with Forgiveness**

The strategy cooperates when there's sufficient evidence of collective cooperation, defects to protect against exploitation, but periodically offers forgiveness to allow recovery from mutual defection spirals.

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: Signal willingness to cooperate. In a collective mindset, if multiple strategy instances are present, this establishes immediate cooperation. The cost of one round's exploitation is worth the potential for establishing long-term cooperation.

### Rounds 2 through (r-1): Adaptive Threshold Rule

**Calculate the cooperation ratio from the previous round:**
```
prev_coop_ratio = (number of cooperators in round t-1) / n
```

**Calculate a dynamic threshold based on game parameters and history:**
```
base_threshold = (n - k) / (n - 1)  # Theoretical break-even point for cooperation
adaptive_threshold = max(0.3, base_threshold - 0.1)  # Be slightly generous
```

**Decision Logic:**

```
IF prev_coop_ratio >= adaptive_threshold:
    ACTION = COOPERATE
    
ELSE IF this is a "forgiveness round" (see below):
    ACTION = COOPERATE
    
ELSE:
    ACTION = DEFECT
```

**Forgiveness Mechanism:**
To escape mutual defection traps and re-establish cooperation:
```
forgiveness_interval = max(3, floor(r / 5))
is_forgiveness_round = (current_round % forgiveness_interval == 0)
```

On forgiveness rounds, cooperate regardless of recent history (except in final rounds).

### Final Round (Round r): Conditional Cooperation

**Do NOT automatically defect.** A collective strategy should maintain cooperation even in the last round if the group has been cooperative.

```
IF cooperation_ratio over last 3 rounds >= 0.5:
    ACTION = COOPERATE
ELSE:
    ACTION = DEFECT
```

Rationale: If other collective-minded players are present, mutual last-round cooperation yields higher payoffs than mutual defection.

### Second-to-Last Round (Round r-1): Standard Rules Apply
No special treatment—use the adaptive threshold rule. Premature defection signals untrustworthiness.

---

## Detailed Pseudocode

```
function decide_action(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation
    prev_cooperators = count_cooperators(history[round - 1])
    prev_coop_ratio = prev_cooperators / n
    
    # Calculate adaptive threshold
    base_threshold = (n - k) / (n - 1)
    adaptive_threshold = max(0.3, base_threshold - 0.1)
    
    # Final round logic
    if round == r:
        recent_coop_avg = average_cooperation_ratio(history, last=3)
        if recent_coop_avg >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Check forgiveness round
    forgiveness_interval = max(3, floor(r / 5))
    is_forgiveness_round = (round % forgiveness_interval == 0)
    
    # Main decision
    if prev_coop_ratio >= adaptive_threshold:
        return COOPERATE
    elif is_forgiveness_round:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | Cooperate | Signal cooperative intent |
| All others defected last round | Defect (unless forgiveness round) | Protect against exploitation |
| Only 1-2 cooperators last round | Usually defect, but check threshold | Threshold accounts for game parameters |
| Everyone cooperated | Cooperate | Maintain successful cooperation |
| Final round after sustained cooperation | Cooperate | Collective consistency |
| Final round after defection spiral | Defect | No recovery possible |
| Very short games (r ≤ 3) | More forgiving thresholds | Less data, favor cooperation |
| Large n (many players) | Threshold adjusts automatically | base_threshold formula handles this |

---

## Why This Strategy is Collectively Aligned

1. **Self-recognition**: Multiple instances will all cooperate in round 1, meet thresholds, and sustain cooperation throughout.

2. **Predictable signaling**: Consistent behavior makes it easy for like-minded strategies to identify and coordinate with us.

3. **No premature defection**: Avoiding automatic last-round defection maintains collective value.

4. **Forgiveness enables recovery**: If strategies temporarily lose sync, periodic forgiveness rounds provide recovery opportunities.

5. **Threshold adapts to parameters**: Works across different values of n and k without manual tuning.
'''

description_COLLECTIVE_67 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I recognize that if all players reason identically and optimally, we should all reach the same conclusion about what to do. Since cooperation by all yields the highest collective payoff, I will cooperate by default and only defect as a protective response to observed defection—while maintaining pathways back to cooperation.

## Strategy Overview: **Generous Collective Trigger with Forgiveness**

The strategy operates on three principles:
1. **Start cooperatively** to establish and signal collective benefit
2. **Respond proportionally** to defection levels in the population
3. **Forgive strategically** to restore cooperation when possible

---

## Decision Rules

### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- Rationale: No history exists. Cooperation signals collective intent and gives the group the best chance to coordinate on the efficient outcome.

### Rounds 2 through (r-1): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

**Decision Rule:**
```
IF coop_rate >= threshold THEN COOPERATE
ELSE DEFECT
```

**Threshold Calculation:**
```
base_threshold = 0.5
adaptive_threshold = max(0.3, base_threshold - (0.1 × consecutive_high_coop_rounds))
```

Where `consecutive_high_coop_rounds` counts how many recent rounds had coop_rate ≥ 0.7.

**Forgiveness Mechanism:**
Even when below threshold, cooperate with probability:
```
forgiveness_prob = 0.15 × (rounds_remaining / r)
```
This gives defectors a chance to return to cooperation, especially early in the game.

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which predicts universal defection:
- **IF** cooperation rate in round (r-1) ≥ 0.6: **COOPERATE**
- **ELSE**: **DEFECT**

Rationale: If the collective has maintained cooperation, I honor that collective commitment even in the final round. This reflects genuine collective reasoning—if we all think alike, we all cooperate.

---

## Detailed Pseudocode

```
function decide(round, history, n, r, k):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round statistics
    prev_cooperators = count_cooperators(history[round-1])
    coop_rate = prev_cooperators / n
    
    # Calculate consecutive high cooperation rounds
    consecutive_high = 0
    for t from (round-1) down to 1:
        if count_cooperators(history[t]) / n >= 0.7:
            consecutive_high += 1
        else:
            break
    
    # Adaptive threshold (more lenient after sustained cooperation)
    threshold = max(0.3, 0.5 - (0.1 × consecutive_high))
    
    # Final round logic
    if round == r:
        if coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Standard rounds: threshold with forgiveness
    if coop_rate >= threshold:
        return COOPERATE
    else:
        # Forgiveness probability decreases as game progresses
        rounds_remaining = r - round
        forgiveness_prob = 0.15 × (rounds_remaining / r)
        
        if random() < forgiveness_prob:
            return COOPERATE
        else:
            return DEFECT
```

---

## Edge Cases Handled

| Situation | Response |
|-----------|----------|
| **First round** | Always cooperate |
| **Last round** | Cooperate if recent cooperation ≥ 60% |
| **Everyone defected last round** | Defect (but with small forgiveness chance if not near end) |
| **Only one other cooperator** | Likely defect, but threshold adapts to history |
| **Oscillating cooperation** | Threshold remains at base; respond to actual rate |
| **n=2 (minimum players)** | Same logic applies; essentially becomes repeated prisoner's dilemma |
| **Very large n** | Same proportional logic; individual defection has smaller impact but same incentives |

---

## Why This Strategy is Collectively Robust

1. **Self-consistent under collective reasoning**: If all players use this strategy, everyone cooperates every round, achieving maximum collective payoff.

2. **Protective against exploiters**: Defection triggers group-wide response, making exploitation unprofitable over multiple rounds.

3. **Forgiving enough to recover**: Random forgiveness and adaptive thresholds allow recovery from temporary breakdowns or noise.

4. **No coordination required**: Depends only on observable history and game parameters—no need for pre-arranged signals or turn-taking.
'''

description_COLLECTIVE_69 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players reason similarly, universal cooperation yields the best collective outcome (payoff of k > 1 per round versus 1 for universal defection). However, I must be robust against defectors while signaling cooperative intent and rewarding cooperation when it emerges.

The strategy combines **hopeful initiation**, **proportional reciprocity**, and **end-game realism**.

---

## Strategy: "Adaptive Proportional Reciprocator"

### Decision Rules

**Round 1: Cooperate**
- Begin with cooperation to signal willingness to collaborate
- This establishes potential for mutual benefit and allows assessment of the population

**Rounds 2 through (r-1): Proportional Threshold Response**

Let `coop_rate(t)` = proportion of all players (including self) who cooperated in round t

```
IF coop_rate(t-1) >= threshold(t) THEN Cooperate
ELSE Defect
```

Where `threshold(t)` is adaptive:
- **Base threshold** = `1/k` (the break-even point where cooperation becomes individually rational)
- **Adjusted threshold** = `max(1/k, 0.5 - trend_bonus)`

**Trend bonus calculation:**
```
recent_avg = average cooperation rate over last min(3, t-1) rounds
earlier_avg = average cooperation rate over rounds before that (if available)
trend_bonus = 0.1 if recent_avg > earlier_avg else 0
```

This rewards improving cooperation trends with slightly more lenient thresholds.

**Final Round (round r): Conditional Cooperation**

```
IF coop_rate(r-1) >= 0.7 THEN Cooperate
ELSE Defect
```

Rationale: In the last round, there's no future to protect. However, if cooperation has been strong, maintaining it signals integrity and maximizes collective payoff. If cooperation has been weak, defection is the dominant response.

---

### Detailed Decision Logic (Pseudocode)

```python
def decide(round_number, history, n, k, r):
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate cooperation rate from previous round
    prev_coop_count = count_cooperators(history, round_number - 1)
    prev_coop_rate = prev_coop_count / n
    
    # Final round: High-threshold conditional cooperation
    if round_number == r:
        if prev_coop_rate >= 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Adaptive proportional response
    base_threshold = 1 / k
    
    # Calculate trend bonus
    if round_number >= 4:
        recent_rounds = [round_number - 3, round_number - 2, round_number - 1]
        earlier_rounds = list(range(1, round_number - 3))
        
        recent_avg = average_coop_rate(history, recent_rounds, n)
        earlier_avg = average_coop_rate(history, earlier_rounds, n)
        
        trend_bonus = 0.1 if recent_avg > earlier_avg else 0
    else:
        trend_bonus = 0
    
    threshold = max(base_threshold, 0.5 - trend_bonus)
    
    if prev_coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

### Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Cooperate | Establish cooperative intent |
| Round 2, everyone defected in R1 | Defect | Population shows no cooperation; protect self |
| Round 2, mixed R1 | Apply threshold rule | Respond proportionally |
| Only 2 players (n=2) | Same rules apply | Threshold adapts via k parameter |
| Very high k (close to n) | Lower threshold (1/k is small) | Cooperation is more valuable |
| Last round after sustained cooperation | Cooperate | Reward collective success |
| Last round after defection spiral | Defect | No future incentive to cooperate |

---

### Why This Strategy is Collectively Aligned

1. **Starts cooperative**: Creates opportunity for mutual benefit
2. **Forgives and responds to improvement**: Trend bonus encourages recovery from early defection
3. **Doesn't exploit**: Never defects against a cooperating majority
4. **Protects the collective**: Withdraws contribution when too many free-ride (preventing exploitation of cooperators)
5. **Economically grounded**: Threshold based on k ensures cooperation when it's collectively efficient

This strategy aims to **be the player I'd want others to be** while remaining robust against exploitation.
'''

description_COLLECTIVE_70 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that mutual cooperation yields the best collective outcome (payoff of k > 1 for everyone) versus mutual defection (payoff of 1 for everyone). My goal is to foster and sustain cooperation while protecting against exploitation. I will be generous, forgiving, but not naive.

---

## Strategy: **Adaptive Threshold Cooperation (ATC)**

### Key Insight

In an n-player game, I cannot punish individual defectors without also punishing cooperators. Therefore, my strategy conditions on the **overall cooperation rate** in the population, not individual behavior.

---

## Decision Rules

### Parameters Derived from Game Settings

```
base_threshold = 0.5          # Minimum cooperation rate to continue cooperating
forgiveness_bonus = 0.1       # How much I lower threshold to encourage recovery
exploitation_penalty = 0.15   # How much I raise threshold after being exploited
min_threshold = 0.3           # Never require less than 30% cooperation
max_threshold = 0.8           # Never require more than 80% cooperation
```

### State Variables

```
current_threshold = base_threshold
consecutive_low_coop = 0      # Rounds where cooperation was below threshold
recovery_mode = False         # Whether we're trying to restart cooperation
```

---

## Round-by-Round Decision Logic

### Round 1 (No History)
**Action: COOPERATE**

Rationale: Start with good faith. Cooperation cannot emerge if no one initiates. The potential gain from establishing cooperation outweighs the risk of first-round exploitation.

---

### Rounds 2 through (r-1) (Middle Rounds)

```
Let coop_rate = (number of cooperators last round) / n

If recovery_mode:
    # We're trying to restart cooperation after a breakdown
    If coop_rate >= current_threshold - forgiveness_bonus:
        Action: COOPERATE
        recovery_mode = False
        current_threshold = max(min_threshold, current_threshold - 0.05)
    Else:
        Action: DEFECT
        # Stay in recovery mode, keep signaling willingness

Else if coop_rate >= current_threshold:
    # Cooperation is healthy
    Action: COOPERATE
    consecutive_low_coop = 0
    # Gradually become more trusting if cooperation is sustained
    If coop_rate >= 0.7:
        current_threshold = max(min_threshold, current_threshold - 0.02)

Else:
    # Cooperation is below threshold
    consecutive_low_coop += 1
    
    If consecutive_low_coop == 1:
        # First violation: give benefit of doubt
        Action: COOPERATE (with probability 0.7) or DEFECT (with probability 0.3)
        
    Else if consecutive_low_coop == 2:
        # Second consecutive violation: defect but signal recovery
        Action: DEFECT
        current_threshold = min(max_threshold, current_threshold + exploitation_penalty)
        
    Else:
        # Sustained low cooperation
        Action: DEFECT
        If consecutive_low_coop >= 4:
            recovery_mode = True  # Prepare to attempt restart
            consecutive_low_coop = 0
```

---

### Last Round (Round r)
**Special Handling for End-Game**

```
Let recent_coop_rate = average cooperation rate over last min(3, r-1) rounds

If recent_coop_rate >= 0.6:
    # Honor the cooperative relationship that was built
    Action: COOPERATE
Else:
    # No cooperative norm established; no reason to sacrifice
    Action: DEFECT
```

Rationale: In a collective mindset, I don't automatically defect on the last round. If cooperation has been sustained, I honor it—this is the collectively optimal choice and reflects genuine cooperative intent rather than mere strategic mimicry.

---

### Near-End Rounds (Rounds r-2 and r-1)

Apply standard middle-round logic, but:
```
# Slightly increase forgiveness to maintain cooperation through endgame
effective_threshold = current_threshold - 0.05
```

---

## Adaptive Mechanisms

### 1. Threshold Adjustment
- **Reward sustained cooperation**: Lower threshold gradually when cooperation is high
- **Punish exploitation**: Raise threshold when cooperation drops
- **Bounded adaptation**: Keep threshold within [0.3, 0.8] to remain responsive

### 2. Recovery Protocol
After extended defection periods, periodically attempt to restart cooperation by:
- Cooperating once as a "probe"
- If others respond positively, resume cooperation
- If not, return to defection and try again later

### 3. Probabilistic Forgiveness
First violations trigger probabilistic response (70% cooperate, 30% defect) to:
- Avoid over-punishment of random fluctuations
- Create unpredictability that discourages exploitation
- Maintain cooperation momentum through small disruptions

---

## Summary Table

| Situation | Action |
|-----------|--------|
| Round 1 | COOPERATE |
| Cooperation rate ≥ threshold | COOPERATE |
| First round below threshold | COOPERATE (70%) / DEFECT (30%) |
| Second consecutive round below | DEFECT, raise threshold |
| Extended low cooperation | DEFECT, then attempt recovery |
| Last round, good history | COOPERATE |
| Last round, poor history | DEFECT |

---

## Why This Strategy is Collectively Optimal

1. **Initiates cooperation**: Always starts cooperatively
2. **Sustains cooperation**: Continues cooperating when others do
3. **Forgives mistakes**: Doesn't over-punish isolated defections
4. **Protects against exploitation**: Withdraws cooperation when consistently exploited
5. **Attempts recovery**: Doesn't give up permanently on cooperation
6. **Honors relationships**: Cooperates in final round if trust was established

This strategy is designed to **maximize collective welfare** while remaining **robust against exploitative strategies**.
'''

description_COLLECTIVE_68 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similarly-designed cooperative strategies) may be present in the tournament. The goal is to maximize collective welfare while protecting against exploitation by purely selfish strategies.

The key insight is that in a repeated public goods game, **sustainable cooperation requires**:
1. Signaling cooperative intent early
2. Rewarding cooperation and punishing defection proportionally
3. Maintaining forgiveness to recover from mistakes or test cooperation
4. Protecting the collective from persistent free-riders

## Strategy: Adaptive Collective Reciprocity (ACR)

### Decision Variables Tracked

For each round t, maintain:
- `cooperation_rate[t]` = fraction of all players who cooperated in round t
- `personal_history[i][t]` = action of player i in round t (once observable)
- `round_number` = current round (1 to r)
- `threshold` = adaptive cooperation threshold (initialized based on k/n ratio)

### Core Decision Rules

```
FUNCTION decide_action(round_number, history, n, k, r):
    
    # Initialize threshold based on efficiency of public good
    base_threshold = (k/n) / (1 - k/n + k/n)  # Roughly k/(2n-k)
    
    # PHASE 1: Opening (Round 1)
    IF round_number == 1:
        RETURN Cooperate  # Always signal cooperative intent
    
    # PHASE 2: Closing (Final Round)
    IF round_number == r:
        # Cooperate if recent cooperation rate suggests collective benefit
        recent_coop_rate = average(cooperation_rate[max(1,r-3) : r-1])
        IF recent_coop_rate >= 0.5:
            RETURN Cooperate  # Maintain collective commitment
        ELSE:
            RETURN Defect  # No collective to protect
    
    # PHASE 3: Main Game (Rounds 2 to r-1)
    
    # Calculate adaptive metrics
    recent_window = min(3, round_number - 1)
    recent_coop_rate = average(cooperation_rate[round_number - recent_window : round_number - 1])
    overall_coop_rate = average(cooperation_rate[1 : round_number - 1])
    
    # Trend detection: is cooperation increasing or decreasing?
    IF round_number >= 3:
        trend = cooperation_rate[round_number - 1] - cooperation_rate[round_number - 2]
    ELSE:
        trend = 0
    
    # DECISION LOGIC
    
    # Rule 1: Strong collective - maintain cooperation
    IF recent_coop_rate >= 0.6:
        RETURN Cooperate
    
    # Rule 2: Moderate collective with positive trend - encourage growth
    IF recent_coop_rate >= 0.4 AND trend >= 0:
        RETURN Cooperate
    
    # Rule 3: Weak collective but early game - give chances
    IF recent_coop_rate >= 0.3 AND round_number <= r/3:
        RETURN Cooperate
    
    # Rule 4: Periodic forgiveness probe
    # Every few rounds, test if defectors will reciprocate
    forgiveness_interval = max(2, floor(r / 5))
    IF round_number % forgiveness_interval == 0 AND recent_coop_rate >= 0.2:
        RETURN Cooperate
    
    # Rule 5: Proportional response for borderline cases
    # Cooperate probabilistically based on recent cooperation
    IF recent_coop_rate >= 0.2:
        # Deterministic tiebreaker based on round number
        IF (round_number * 7) % 10 < (recent_coop_rate * 10):
            RETURN Cooperate
    
    # Default: Defect when collective has collapsed
    RETURN Defect
```

### Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Cooperate | Signal intent, build collective |
| Round r (final), high recent cooperation | Cooperate | Honor the collective |
| Round r (final), low cooperation | Defect | No collective to betray |
| n=2 (two players) | Follow rules but weight recent heavily | Direct reciprocity matters more |
| k very close to n | Slightly more forgiving thresholds | Cooperation is nearly efficient |
| All defected last round | Check forgiveness interval | Don't give up permanently |
| Everyone cooperated last round | Cooperate | Reinforce successful equilibrium |

### Collective Alignment Properties

1. **Mutual Recognition**: Other collective strategies that cooperate in round 1 and maintain cooperation will find this strategy a reliable partner.

2. **Proportional Response**: The strategy doesn't instantly punish one defector when most cooperate—it responds to aggregate behavior, protecting against noise.

3. **Forgiveness Mechanism**: Periodic cooperation probes allow recovery from temporary breakdowns.

4. **No Exploitation Vulnerability**: Against all-defect strategies, this will defect after initial rounds, limiting losses.

5. **Collective End-Game**: Unlike pure self-interest (which defects in final round), this maintains cooperation if the collective has been strong—signaling that collective welfare matters.

### Summary Decision Tree

```
Round 1 → COOPERATE

Final Round:
  Recent cooperation ≥ 50% → COOPERATE
  Otherwise → DEFECT

Middle Rounds:
  Recent cooperation ≥ 60% → COOPERATE
  Recent cooperation ≥ 40% AND trend ≥ 0 → COOPERATE
  Recent cooperation ≥ 30% AND early game → COOPERATE
  Forgiveness round AND cooperation ≥ 20% → COOPERATE
  Probabilistic threshold met → COOPERATE
  Otherwise → DEFECT
```

This strategy aims to **build and sustain cooperation among like-minded players** while **limiting exploitation by defectors**—embodying collective rationality over individual short-term gains.
'''

description_COLLECTIVE_69 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all players using this strategy are working together as a unified group. Our goal is to maximize collective welfare while protecting against exploitation by non-cooperative outsiders. We use observable signals to coordinate without explicit communication.

## Strategy Overview: **Adaptive Collective Reciprocity (ACR)**

The strategy operates on three principles:
1. **Start cooperatively** to establish a cooperative baseline and signal good intentions
2. **Mirror the group** by matching the prevailing cooperation level
3. **Protect the collective** by withdrawing cooperation when exploitation is detected

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: All collective-minded players begin by cooperating. This creates an immediate signal of group membership and maximizes early collective payoff.

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation ratio** from the previous round:
```
coop_ratio = (number of cooperators in round t-1) / n
```

**Decision Rule:**

```
IF coop_ratio >= (n-1)/n THEN
    COOPERATE (near-universal cooperation maintained)
    
ELSE IF coop_ratio >= 0.5 THEN
    COOPERATE with probability = coop_ratio
    (Probabilistic matching - support cooperation proportionally)
    
ELSE IF coop_ratio > 0 THEN
    COOPERATE with probability = coop_ratio × 0.5
    (Reduced support when cooperation is failing)
    
ELSE (coop_ratio = 0)
    DEFECT (no cooperation to reciprocate)
```

**Forgiveness Mechanism:**
After any round where you defected, if cooperation ratio increases by at least 1/n (one additional cooperator), increase your cooperation probability by 0.2 for the next round. This allows recovery from mutual defection spirals.

**Trend Adjustment:**
```
IF coop_ratio is increasing for 2+ consecutive rounds THEN
    Add 0.15 to cooperation probability (capped at 1.0)
    
IF coop_ratio is decreasing for 2+ consecutive rounds THEN
    Subtract 0.15 from cooperation probability (floored at 0.0)
```

### Final Round (Round r): Conditional Cooperation

The last round has no shadow of the future, but collective players should still coordinate:

```
IF average cooperation ratio over all previous rounds >= 0.6 THEN
    COOPERATE (reward sustained collective behavior)
ELSE
    DEFECT (the collective norm has broken down)
```

---

## Pseudocode Implementation

```
function ACR_strategy(n, k, r, current_round, history):
    
    if current_round == 1:
        return COOPERATE
    
    # Calculate cooperation ratio from last round
    last_round_cooperators = count_cooperators(history, current_round - 1)
    coop_ratio = last_round_cooperators / n
    
    # Calculate trend (if enough history)
    trend = 0
    if current_round >= 3:
        prev_ratio = count_cooperators(history, current_round - 2) / n
        trend = coop_ratio - prev_ratio
    
    # Final round logic
    if current_round == r:
        avg_coop = average_cooperation_ratio(history)
        if avg_coop >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Adaptive reciprocity
    base_probability = 0
    
    if coop_ratio >= (n-1)/n:
        base_probability = 1.0
    elif coop_ratio >= 0.5:
        base_probability = coop_ratio
    elif coop_ratio > 0:
        base_probability = coop_ratio * 0.5
    else:
        base_probability = 0.0
    
    # Apply trend adjustment
    if trend > 0 and consecutive_increases(history) >= 2:
        base_probability = min(1.0, base_probability + 0.15)
    elif trend < 0 and consecutive_decreases(history) >= 2:
        base_probability = max(0.0, base_probability - 0.15)
    
    # Forgiveness: if we defected last round and cooperation rose
    if my_action(history, current_round - 1) == DEFECT:
        if current_round >= 3:
            older_ratio = count_cooperators(history, current_round - 2) / n
            if coop_ratio >= older_ratio + (1/n):
                base_probability = min(1.0, base_probability + 0.2)
    
    # Execute probabilistic decision
    if random() < base_probability:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases Handled

| Situation | Response |
|-----------|----------|
| First round | Always cooperate |
| Last round | Cooperate if historical average ≥ 60% |
| All others defected | Defect (no cooperation to support) |
| Only 1 defector | Cooperate (maintain near-consensus) |
| n = 2 (minimum) | Essentially Tit-for-Tat with forgiveness |
| Large n | Probabilistic matching scales appropriately |
| Short games (r small) | Quick adaptation through trend detection |

---

## Why This Strategy is Collectively Optimal

1. **Self-recognition**: Collective players all cooperate in round 1 and maintain high cooperation, creating a recognizable pattern

2. **Mutual reinforcement**: When playing against other ACR players, cooperation stabilizes at high levels since everyone reciprocates cooperation

3. **Exploitation resistance**: Defectors gain short-term advantage but trigger collective withdrawal, limiting their gains

4. **Graceful degradation**: In mixed populations, the strategy proportionally reduces cooperation rather than collapsing entirely

5. **Recovery capability**: The forgiveness mechanism allows the collective to rebuild cooperation if it temporarily breaks down
'''

description_COLLECTIVE_71 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players reason similarly and cooperate, everyone achieves the best collective outcome (payoff of k per round vs. 1 from mutual defection). The strategy aims to **sustain cooperation when others reciprocate** while **protecting against persistent defectors**.

## Strategy Overview: "Generous Collective Reciprocity"

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness to collaborate
2. **Reciprocate the group's behavior** - cooperation begets cooperation
3. **Forgive occasionally** to escape defection spirals and test for changed behavior

---

## Decision Rules

### Round 1: Always Cooperate
- **Action: C**
- Rationale: Establish cooperative intent. With no history, assume collective-minded players will do the same.

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

**Decision logic:**

```
IF coop_rate >= threshold THEN
    Cooperate
ELSE IF forgiveness_trigger THEN
    Cooperate (with probability p_forgive)
ELSE
    Defect
```

**Parameter definitions:**

- **Threshold** = `max(0.5, (n-1)/n)` adjusted by recent trend
  - Base threshold: At least half the group cooperated
  - Stricter when group is small, more lenient when large

- **Trend adjustment**: 
  - If cooperation has been *increasing* over last 3 rounds: lower threshold by 0.1
  - If cooperation has been *decreasing* over last 3 rounds: raise threshold by 0.1

- **Forgiveness probability** `p_forgive`:
  - After 2+ consecutive defection rounds: `p_forgive = 0.15`
  - Forgiveness resets after each forgiveness attempt
  - Minimum 2 rounds between forgiveness attempts

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection:

```
IF average_cooperation_rate >= 0.6 over all previous rounds THEN
    Cooperate  // Reward sustained collective behavior
ELSE
    Defect     // No reason to cooperate with chronic defectors
```

Rationale: If playing against other collective-minded strategies, mutual final-round cooperation is achievable and beneficial.

---

## Complete Pseudocode

```python
def decide(round_number, history, n, k, r):
    
    # Round 1: Unconditional cooperation
    if round_number == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_count = count_cooperators(history, round_number - 1)
    coop_rate = prev_coop_count / n
    
    # Calculate trend (if enough history)
    trend = 0
    if round_number >= 4:
        recent_rates = [count_cooperators(history, t) / n 
                        for t in range(round_number - 3, round_number)]
        trend = recent_rates[-1] - recent_rates[0]  # positive = improving
    
    # Base threshold (scales with group size)
    base_threshold = 0.5
    
    # Adjust threshold based on trend
    if trend > 0.1:
        threshold = base_threshold - 0.1
    elif trend < -0.1:
        threshold = base_threshold + 0.1
    else:
        threshold = base_threshold
    
    # Clamp threshold
    threshold = max(0.3, min(0.7, threshold))
    
    # Final round logic
    if round_number == r:
        overall_coop_rate = average_cooperation_rate(history)
        if overall_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Main decision
    if coop_rate >= threshold:
        return COOPERATE
    
    # Forgiveness mechanism
    consecutive_low_coop = count_consecutive_rounds_below_threshold(history, threshold)
    rounds_since_forgiveness = get_rounds_since_last_forgiveness()
    
    if consecutive_low_coop >= 2 and rounds_since_forgiveness >= 3:
        if random() < 0.15:
            record_forgiveness(round_number)
            return COOPERATE
    
    return DEFECT
```

---

## Edge Cases Handled

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Cooperate | Establish cooperative baseline |
| Final round, good history | Cooperate | Sustain collective gains |
| Final round, poor history | Defect | No future to protect |
| All others defected last round | Usually defect, 15% forgive | Protect self, but test for recovery |
| Cooperation declining | Raise threshold slightly | Quicker response to deterioration |
| Cooperation recovering | Lower threshold slightly | Encourage recovery |
| n=2 (minimum) | Same rules apply | Reduces to iterated prisoner's dilemma logic |

---

## Why This Strategy is Collectively Robust

1. **Against fellow collective strategies**: Sustained mutual cooperation from round 1 through r, achieving near-optimal payoffs.

2. **Against pure defectors**: Quick retaliation after round 1 limits exploitation to one round.

3. **Against conditional cooperators (TFT-like)**: Maintains cooperation through reciprocity matching.

4. **Against mixed/noisy strategies**: Trend-based thresholds and forgiveness prevent permanent collapse from occasional defection.

5. **Against exploitative strategies**: The threshold mechanism ensures we don't cooperate into a void—we require meaningful group participation.
'''

description_COLLECTIVE_70 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similar cooperative reasoning) may be playing. The goal is to establish and maintain cooperation when possible, while protecting against exploitation. The strategy uses observable patterns to coordinate without explicit communication.

## Strategy Overview: "Gradient Reciprocity with Collective Signaling"

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness to collaborate
2. **Mirror the group's cooperation level** with a slight optimistic bias
3. **Protect against end-game collapse** while leaving room for collective success

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: In a collective mindset, we need to establish a cooperative baseline. If multiple players share this strategy, we achieve the cooperative equilibrium from the start.

### Rounds 2 through (r-1): Adaptive Gradient Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

Calculate the **cooperation threshold** that adapts to game parameters:
```
base_threshold = (n - k) / (n - 1)
```
This threshold represents the break-even point where cooperation becomes individually rational given others' cooperation.

**Decision Rule:**
```
IF coop_rate >= base_threshold THEN:
    COOPERATE
ELSE IF coop_rate >= base_threshold - 0.15 THEN:
    COOPERATE with probability = (coop_rate / base_threshold)
ELSE:
    DEFECT
```

**Additional Forgiveness Mechanism:**
Every `floor(r/4)` rounds (periodic forgiveness rounds), if the recent trend shows increasing cooperation (comparing last 2 rounds to 2 rounds before), COOPERATE regardless of threshold to allow recovery from defection spirals.

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory advice to defect in the final round:

```
IF cooperation_rate over last 3 rounds >= 0.7 THEN:
    COOPERATE (preserve collective gains)
ELSE IF cooperation_rate over last 3 rounds >= 0.4 THEN:
    COOPERATE with probability 0.5
ELSE:
    DEFECT
```

Rationale: If we're part of a cooperative collective, defecting destroys value for everyone. The expected gain from solo defection is small compared to maintaining group cooperation.

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate to establish baseline
    if round == 1:
        return COOPERATE
    
    # Calculate key metrics
    prev_cooperators = count_cooperators(history, round - 1)
    coop_rate = prev_cooperators / n
    base_threshold = (n - k) / (n - 1)
    
    # Final round logic
    if round == r:
        recent_coop_rate = average_cooperation_rate(history, last=3)
        if recent_coop_rate >= 0.7:
            return COOPERATE
        elif recent_coop_rate >= 0.4:
            return COOPERATE with probability 0.5
        else:
            return DEFECT
    
    # Periodic forgiveness check (every r/4 rounds, starting round 3+)
    forgiveness_interval = max(2, floor(r / 4))
    if round > 2 and round % forgiveness_interval == 0:
        if cooperation_trend_positive(history, window=2):
            return COOPERATE
    
    # Main decision logic for middle rounds
    if coop_rate >= base_threshold:
        return COOPERATE
    elif coop_rate >= base_threshold - 0.15:
        probability = coop_rate / base_threshold
        return COOPERATE with probability, else DEFECT
    else:
        return DEFECT

function cooperation_trend_positive(history, window):
    recent = avg_cooperation(last `window` rounds)
    earlier = avg_cooperation(`window` rounds before that)
    return recent > earlier
```

---

## Edge Cases Handled

| Scenario | Behavior |
|----------|----------|
| Round 1 | Always cooperate |
| Final round | Conditional cooperation based on recent history |
| n=2 (minimum) | Strategy reduces to reciprocal tit-for-tat with forgiveness |
| Very short games (r=2) | Cooperate round 1, use final round logic for round 2 |
| Complete defection by others | Defect after threshold check fails |
| Sudden mass defection | Defect but periodically test for recovery |
| Gradual cooperation building | Probabilistic cooperation allows matching |

---

## Why This Strategy is Collectively Aligned

1. **Self-recognition**: If all players use this strategy, everyone cooperates every round, achieving maximum collective payoff (2 per player per round in the example)

2. **Robustness**: Against defectors, the strategy protects individual payoffs while leaving the door open for cooperation

3. **Recovery**: The forgiveness mechanism prevents permanent collapse into mutual defection

4. **Parameter-adaptive**: The threshold adjusts to different k/n ratios, ensuring rational responses across game configurations
'''

description_COLLECTIVE_72 = '''
# Collective Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy embraces a genuinely collective mindset: we aim to establish and maintain cooperation as the group norm, while protecting against exploitation. The key insight is that in a public goods game, **everyone benefits when cooperation is widespread**, so our goal is to be a reliable cooperator that encourages others to cooperate, while having clear boundaries that discourage defection.

## Strategy Overview

The strategy operates on three principles:
1. **Lead with cooperation** - Be the change you want to see
2. **Respond to group behavior** - Adapt based on collective cooperation levels
3. **Forgive but remember** - Allow recovery from defection spirals

---

## Decision Rules

### Round 1: Always Cooperate
- Begin by signaling cooperative intent
- This establishes trust and gives others the opportunity to reciprocate
- Rationale: Someone must start cooperating; be that player

### Middle Rounds (2 through r-1): Adaptive Threshold Rule

**Calculate the cooperation rate from the previous round:**
```
coop_rate = (number of players who cooperated in round t-1) / n
```

**Decision logic:**

```
IF coop_rate >= cooperation_threshold THEN
    COOPERATE
ELSE IF coop_rate >= minimum_threshold THEN
    COOPERATE with probability = adjusted_probability
ELSE
    DEFECT (but with forgiveness mechanism)
```

**Threshold Parameters:**
- `cooperation_threshold` = 0.5 (if half or more cooperate, we cooperate)
- `minimum_threshold` = 1/n (at least one other player cooperated)
- `adjusted_probability` = coop_rate × generosity_factor
- `generosity_factor` = min(k/(n-1), 1.5) — scales with how beneficial cooperation is

**Forgiveness Mechanism:**
- Track consecutive rounds of low cooperation (below minimum_threshold)
- Every `forgiveness_interval` = max(3, r/5) rounds of sustained low cooperation, cooperate once
- This tests whether the group can restart cooperation

### Last Round: Conditional Cooperation

The last round requires special handling since there's no future to incentivize cooperation:

```
IF historical_cooperation_rate >= 0.6 THEN
    COOPERATE (reward sustained group cooperation)
ELSE IF previous_round_coop_rate >= 0.5 THEN
    COOPERATE with probability 0.5
ELSE
    DEFECT
```

Where `historical_cooperation_rate` = total cooperations by all players / (n × (r-1))

---

## Detailed Pseudocode

```python
def decide(round_number, history, n, k, r):
    # Parameters
    COOP_THRESHOLD = 0.5
    MIN_THRESHOLD = 1/n
    GENEROSITY = min(k/(n-1), 1.5)
    FORGIVENESS_INTERVAL = max(3, r // 5)
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_count = count_cooperators(history, round_number - 1)
    prev_coop_rate = prev_coop_count / n
    
    # Last round: Reward historical cooperation
    if round_number == r:
        historical_rate = total_cooperations(history) / (n * (r - 1))
        if historical_rate >= 0.6:
            return COOPERATE
        elif prev_coop_rate >= 0.5:
            return COOPERATE with probability 0.5
        else:
            return DEFECT
    
    # Middle rounds: Adaptive threshold
    if prev_coop_rate >= COOP_THRESHOLD:
        return COOPERATE
    
    elif prev_coop_rate >= MIN_THRESHOLD:
        prob = prev_coop_rate * GENEROSITY
        return COOPERATE with probability min(prob, 0.9)
    
    else:
        # Check forgiveness
        consecutive_low = count_consecutive_low_coop_rounds(history, MIN_THRESHOLD)
        if consecutive_low > 0 and consecutive_low % FORGIVENESS_INTERVAL == 0:
            return COOPERATE  # Forgiveness probe
        else:
            return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Cooperate | Establish cooperative norm |
| All defected last round | Defect (unless forgiveness trigger) | Don't be exploited |
| Only 1 cooperator last round (besides self) | Probabilistic cooperation | Support emerging cooperation |
| Perfect cooperation streak | Cooperate | Maintain the good equilibrium |
| Last round after high cooperation | Cooperate | Collective reward |
| n = 2 (minimum players) | Same rules apply | Degenerates to modified TFT |
| Very short game (r ≤ 3) | More generous thresholds | Less time to establish patterns |

---

## Why This Strategy is Collectively Optimal

1. **Encourages cooperation cascades**: By cooperating when at least half cooperate, we reinforce positive group dynamics

2. **Tolerant but not naive**: The probabilistic cooperation in the "gray zone" keeps hope alive without being fully exploitable

3. **Self-correcting**: The forgiveness mechanism prevents permanent defection spirals

4. **Scales with game parameters**: The generosity factor adjusts based on k and n, being more cooperative when cooperation is more valuable

5. **Rewards collective success**: The last-round rule incentivizes sustained cooperation rather than end-game defection

This strategy aims to be the cooperative backbone that a group of similar strategies can build upon, while remaining robust against purely selfish opponents.
'''

description_COLLECTIVE_71 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: if all players in a tournament adopt this same strategy, the outcome should be mutually beneficial. At the same time, it must be **robust** against defectors and **adaptive** to the actual behavior observed in the game.

The key insight is that in a repeated public goods game, sustainable cooperation requires:
1. **Signaling cooperative intent** early
2. **Rewarding cooperation** when others cooperate
3. **Protecting against exploitation** without being overly punitive
4. **Recognizing endgame incentives** while not abandoning cooperation prematurely

---

## Strategy: "Collective Threshold Reciprocity"

### Decision Rule Overview

The strategy cooperates when there's sufficient evidence of collective cooperation, defects to protect against exploitation, and uses a **cooperation threshold** that adapts based on observed behavior.

---

### Detailed Decision Rules

#### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- **Rationale**: Signal cooperative intent. If others share this strategy, we achieve mutual cooperation from the start. The cost of being exploited in one round is worth the information gained and the cooperative signal sent.

#### Rounds 2 through (r-1): Adaptive Threshold Reciprocity

**Calculate the cooperation rate from the previous round:**
```
prev_coop_rate = (number of players who cooperated in round t-1) / n
```

**Calculate the historical cooperation rate:**
```
hist_coop_rate = (total cooperations across all players, all previous rounds) / (n × (t-1))
```

**Determine the adaptive threshold:**
```
base_threshold = 0.5
adjustment = 0.1 × (hist_coop_rate - 0.5)
threshold = base_threshold - adjustment
threshold = clamp(threshold, 0.3, 0.7)
```

This means:
- If historical cooperation is high (>50%), we lower our threshold (more forgiving)
- If historical cooperation is low (<50%), we raise our threshold (more protective)
- Threshold is bounded between 30% and 70%

**Decision:**
```
IF prev_coop_rate >= threshold:
    COOPERATE
ELSE:
    DEFECT
```

**Additional Rule - Forgiveness Probe:**
```
IF currently in a defection streak (defected last 2+ rounds) AND
   round number is divisible by 3:
    COOPERATE (attempt to restart cooperation)
```

#### Final Round (Round r): Conditional Cooperation

The last round presents a classic endgame problem. However, abandoning cooperation signals distrust.

```
IF hist_coop_rate >= 0.6:
    COOPERATE (reward sustained cooperation)
ELSE IF prev_coop_rate >= 0.5:
    COOPERATE (reciprocate recent cooperation)
ELSE:
    DEFECT (no basis for trust)
```

---

### Pseudocode Summary

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    prev_round_coops = count_cooperators(history, round - 1)
    prev_coop_rate = prev_round_coops / n
    
    total_coops = sum(count_cooperators(history, t) for t in 1..round-1)
    hist_coop_rate = total_coops / (n * (round - 1))
    
    # Adaptive threshold
    base_threshold = 0.5
    adjustment = 0.1 * (hist_coop_rate - 0.5)
    threshold = clamp(base_threshold - adjustment, 0.3, 0.7)
    
    # Final round logic
    if round == r:
        if hist_coop_rate >= 0.6 or prev_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Forgiveness probe
    if defected_last_two_rounds(history) and round % 3 == 0:
        return COOPERATE
    
    # Main decision
    if prev_coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

### Why This Strategy Works Collectively

1. **Self-reinforcing**: If all players use this strategy, round 1 cooperation leads to 100% cooperation rate, which sustains cooperation throughout.

2. **Robust to mixed populations**: The threshold mechanism means we continue cooperating even if a minority defects, but protect ourselves if defection is widespread.

3. **Forgiveness enables recovery**: The periodic cooperation probe allows groups to escape mutual defection spirals.

4. **Parameter-independent core logic**: The strategy works across different values of n, k, and r without needing to be tuned.

5. **Endgame stability**: By cooperating in the final round when history warrants it, we avoid the unraveling problem and maximize collective payoffs.
'''

description_COLLECTIVE_73 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all copies of this strategy will reason identically given the same information. Rather than treating this as a game against arbitrary opponents, we recognize that coordinated collective action—even without explicit communication—can emerge from shared reasoning. We aim to establish and maintain cooperation while protecting against exploitation.

## Strategy Overview: **Adaptive Collective Reciprocity (ACR)**

The strategy operates on three principles:
1. **Collective identity**: Act as if coordinating with copies of yourself
2. **Graduated reciprocity**: Respond proportionally to the group's cooperation level
3. **Strategic endgame**: Maintain cooperation incentives through the final rounds

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, we signal cooperative intent. This establishes a baseline and gives the collective the best chance of discovering mutual cooperation. The cost of being exploited once is small compared to the potential gain of establishing a cooperative equilibrium.

### Rounds 2 through (r-2): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision rule:**
- If `coop_rate ≥ threshold(t)`: **COOPERATE**
- If `coop_rate < threshold(t)`: **DEFECT**

Where the **adaptive threshold** is:
```
base_threshold = k / n  (the break-even point for cooperation)
threshold(t) = max(base_threshold, 0.5 - 0.1 × consecutive_coop_rounds)
```

The threshold starts at 0.5 and decreases (minimum: base_threshold) as cooperation persists, rewarding sustained collective cooperation with increased tolerance.

**Forgiveness mechanism**: After defecting, if the next round shows `coop_rate ≥ 0.6`, return to cooperation. This prevents permanent collapse from temporary fluctuations.

### Round (r-1): Penultimate Round
**Action: Follow the same adaptive rule as middle rounds**

Rationale: Maintain normal play to avoid triggering early defection cascades. Defecting here signals the end to others.

### Round r: Final Round
**Action: Match the cooperation rate probabilistically**

```
If coop_rate(round r-1) ≥ 0.7: COOPERATE
Else: DEFECT
```

Rationale: In a collective of identical reasoners, if we've maintained high cooperation, we all cooperate on the final round because we all know we all will. This breaks the standard backward induction argument. If cooperation has collapsed, defection is rational.

---

## Pseudocode

```
function decide(round, history, n, k, r):
    base_threshold = k / n
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round statistics
    prev_coop_count = count_cooperators(history[round-1])
    coop_rate = prev_coop_count / n
    
    # Calculate consecutive cooperation rounds
    consec_coop = count_consecutive_high_coop_rounds(history, threshold=0.5)
    
    # Adaptive threshold (rewards sustained cooperation)
    threshold = max(base_threshold, 0.5 - 0.1 * consec_coop)
    
    # Final round logic
    if round == r:
        if coop_rate >= 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds (including r-1)
    if coop_rate >= threshold:
        return COOPERATE
    else:
        # Forgiveness check: did we just defect and cooperation rebounded?
        if my_last_action == DEFECT and coop_rate >= 0.6:
            return COOPERATE
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Standard rules apply | Becomes similar to repeated Prisoner's Dilemma |
| k very close to 1 | Higher threshold (0.6+) | Cooperation barely beneficial; require strong signals |
| k close to n | Lower threshold | Cooperation highly beneficial; be generous |
| All defected last round | DEFECT (but forgive if rebound) | Protect against exploitation |
| Only I cooperated | DEFECT next round | Clear signal that cooperation isn't reciprocated |
| r = 2 | Cooperate both rounds | Too short for complex adaptation; maximize collective potential |

---

## Why This Strategy is Collectively Optimal

1. **Self-recognition**: Identical copies will make identical choices, enabling implicit coordination
2. **Robustness**: Responds appropriately to non-cooperative opponents without permanent punishment
3. **Efficiency**: Breaks backward induction through collective reasoning, capturing gains in final rounds
4. **Adaptability**: Threshold adjusts to the specific game parameters (k, n) and observed behavior
'''

description_COLLECTIVE_72 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embodies a **hopeful but protective collective mindset**. We assume that other players may also be seeking cooperation, and we create opportunities for collective welfare while protecting against exploitation. The key insight is that in a public goods game, **everyone benefits when cooperation emerges**, so our strategy should actively facilitate and reward cooperative norms.

## Strategy: "Generous Threshold with Gradual Trust"

### Decision Framework

The strategy tracks a **cooperation index** for the group and adjusts behavior based on observed collective tendencies, while maintaining generosity to allow cooperation to emerge.

---

### Round-by-Round Decision Rules

#### **Round 1: Cooperate**
- Begin with cooperation to signal willingness to contribute to collective welfare
- This gives the group a chance to establish cooperative norms
- Rationale: Someone must make the first move; we choose to be that cooperative catalyst

#### **Rounds 2 through (r-1): Adaptive Threshold Response**

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision rule:**
- If `coop_rate >= threshold(t)`: **Cooperate**
- If `coop_rate < threshold(t)`: **Defect** (with forgiveness mechanism)

**Dynamic threshold function:**
```
base_threshold = (n - k) / n    # The break-even point for cooperation
threshold(t) = base_threshold - forgiveness_bonus(t)
```

The **forgiveness bonus** decreases over time:
```
forgiveness_bonus(t) = 0.2 × (r - t) / r
```

This means:
- Early rounds: More forgiving (lower threshold), giving cooperation time to emerge
- Later rounds: Stricter threshold, protecting against persistent defection

**Forgiveness Mechanism:**
If we defected in round t-1 but observe `coop_rate >= 0.5` in that round:
- **Cooperate** in round t regardless of threshold
- This prevents mutual punishment spirals and rewards group cooperation attempts

#### **Final Round (Round r): Conditional Cooperation**

Calculate the **cumulative cooperation rate** across all previous rounds:
```
cumulative_coop_rate = (total cooperations across all players and rounds) / (n × (r-1))
```

**Decision rule:**
- If `cumulative_coop_rate >= 0.5`: **Cooperate** (reward a cooperative group)
- Otherwise: **Defect**

Rationale: Unlike typical game theory that prescribes defection in final rounds, we maintain cooperation if the group has demonstrated cooperative tendencies. This rewards and reinforces collective behavior.

---

### Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history, round - 1)
    coop_rate = prev_cooperators / n
    
    # Calculate threshold with forgiveness bonus
    base_threshold = (n - k) / n
    forgiveness_bonus = 0.2 * (r - round) / r
    threshold = max(0.1, base_threshold - forgiveness_bonus)
    
    # Final round logic
    if round == r:
        cumulative_rate = total_cooperations(history) / (n * (r - 1))
        if cumulative_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    # Forgiveness mechanism: if we defected but group cooperated
    if my_action(history, round - 1) == DEFECT and coop_rate >= 0.5:
        return COOPERATE
    
    # Standard threshold decision
    if coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

### Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| n = 2 | Follow same rules | Strategy scales naturally |
| k very close to 1 | Higher threshold applies | Less incentive for cooperation is built into formula |
| k very close to n | Lower threshold applies | High returns justify cooperative attempts |
| All defected last round | Defect (unless early with high forgiveness) | Protect against exploitation |
| Only I cooperated last round | Likely defect | Threshold probably not met |
| r = 2 (minimum rounds) | Round 1: C, Round 2: conditional | Compressed but same logic |

---

### Why This Strategy is Collectively Optimal

1. **Invites cooperation**: Starting with C and maintaining forgiveness creates opportunities for mutual benefit
2. **Economically grounded**: The threshold relates to the actual break-even point where cooperation pays
3. **Adaptive**: Responds to observed behavior rather than assuming specific opponent strategies
4. **Robust**: Protects against exploitation while not being so defensive that it kills cooperation
5. **Aligned with collective welfare**: When k×n total contributions exceed n individual holdings, we all win—this strategy facilitates that outcome
'''

description_COLLECTIVE_74 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be running similar reasoning processes and would benefit from mutual cooperation. The strategy aims to:
1. Signal cooperative intent early
2. Build and maintain cooperation when reciprocated
3. Forgive occasional defections to sustain long-term cooperation
4. Protect against persistent exploitation
5. Avoid triggering destructive defection spirals

## Strategy: "Generous Threshold Tit-for-Tat with Endgame Commitment"

### Key Parameters (Derived from Game Parameters)

```
cooperation_threshold = 0.5  # Minimum fraction of cooperators to continue cooperating
forgiveness_probability = 1/n  # Chance to cooperate despite low cooperation (decreases with group size)
endgame_rounds = min(3, floor(r/4))  # Rounds where endgame logic applies
initial_cooperation_rounds = min(2, floor(r/5))  # Unconditional cooperation period
```

### Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Establish cooperative intent. In a collective mindset, we assume others may reason similarly and will also start cooperatively.

#### Rounds 2 through (r - endgame_rounds): Adaptive Reciprocity

```
Let prev_cooperation_rate = (number of cooperators in previous round) / n

IF prev_cooperation_rate >= cooperation_threshold:
    ACTION: COOPERATE
    
ELSE IF prev_cooperation_rate > 0:
    # Some cooperation exists but below threshold
    # Use probabilistic forgiveness to allow recovery
    WITH probability = forgiveness_probability + prev_cooperation_rate:
        ACTION: COOPERATE
    OTHERWISE:
        ACTION: DEFECT
        
ELSE (prev_cooperation_rate == 0):
    # Complete defection by all others
    # Small chance to test if others will restart cooperation
    WITH probability = forgiveness_probability:
        ACTION: COOPERATE
    OTHERWISE:
        ACTION: DEFECT
```

#### Trend Adjustment (Enhancement to Base Rules)

```
IF current_round >= 3:
    Let trend = prev_cooperation_rate - cooperation_rate_two_rounds_ago
    
    IF trend > 0.1:  # Cooperation is increasing
        # Be more generous to reinforce positive trend
        Increase cooperation probability by 0.1
        
    IF trend < -0.2:  # Cooperation is collapsing
        # Be slightly more cautious but don't accelerate collapse
        No additional adjustment (maintain forgiveness)
```

#### Last `endgame_rounds` Rounds: Conditional Commitment

```
Let historical_cooperation_rate = (total cooperations by others) / ((current_round - 1) * (n - 1))

IF historical_cooperation_rate >= 0.6:
    # History suggests cooperative group - maintain cooperation to end
    ACTION: COOPERATE
    
ELSE IF historical_cooperation_rate >= 0.3:
    # Mixed history - use recent behavior
    IF prev_cooperation_rate >= cooperation_threshold:
        ACTION: COOPERATE
    ELSE:
        ACTION: DEFECT
        
ELSE:
    # Predominantly defecting group - protect against exploitation
    ACTION: DEFECT
```

#### Final Round Special Case

```
IF historical_cooperation_rate >= 0.7:
    # Strong cooperative history - honor it to the end
    ACTION: COOPERATE
ELSE:
    # Apply standard endgame logic above
```

### Summary Pseudocode

```
function decide(round, history, n, r, k):
    endgame_start = r - min(3, floor(r/4))
    forgiveness = 1/n
    threshold = 0.5
    
    if round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history, round-1) / n
    hist_coop_rate = total_others_cooperations(history) / ((round-1) * (n-1))
    
    if round >= endgame_start:
        if hist_coop_rate >= 0.6:
            return COOPERATE
        elif hist_coop_rate >= 0.3 and prev_coop_rate >= threshold:
            return COOPERATE
        elif round == r and hist_coop_rate >= 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle game
    if prev_coop_rate >= threshold:
        return COOPERATE
    else:
        coop_probability = forgiveness + prev_coop_rate
        if round >= 3:
            trend = prev_coop_rate - coop_rate(history, round-2)
            if trend > 0.1:
                coop_probability += 0.1
        return COOPERATE with probability coop_probability, else DEFECT
```

### Why This Strategy is Collectively Optimal

1. **Coordination through consistency**: By starting cooperatively and using clear thresholds, similar strategies can synchronize without explicit communication.

2. **Forgiveness prevents lock-in**: The probabilistic forgiveness mechanism allows recovery from accidental or exploratory defections.

3. **Scales with group size**: Forgiveness probability (1/n) decreases appropriately as free-rider problems become more severe in larger groups.

4. **Endgame protection**: Rather than always defecting at the end (which rational agents might do), the strategy rewards groups that have been cooperative, maintaining collective gains.

5. **Trend sensitivity**: Responding to improving cooperation rates helps groups climb out of partial-defection equilibria together.
'''

description_COLLECTIVE_73 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I recognize that mutual cooperation produces the best collective outcome (everyone gets k > 1), while mutual defection produces the worst (everyone gets 1). My goal is to foster and sustain cooperation while protecting against exploitation.

The key insight is that in a multiplayer setting, I should be **generous and forgiving** to encourage cooperation cascades, but **responsive** to the overall cooperation level to avoid being a perpetual sucker.

---

## Strategy: **Adaptive Threshold Cooperation (ATC)**

### Decision Rule Summary

I cooperate if the **recent cooperation rate** among other players meets or exceeds a **dynamic threshold** that starts generous and adapts based on game progress and observed behavior.

---

## Detailed Decision Rules

### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- Rationale: Signal cooperative intent, give others the opportunity to establish mutual cooperation, and avoid triggering early defection spirals.

### Rounds 2 through (r-1): Adaptive Threshold

**Step 1: Calculate recent cooperation rate**
```
Look at the last min(3, current_round - 1) rounds
cooperation_rate = (total C actions by OTHER players) / (n-1) × rounds_observed
```

**Step 2: Calculate dynamic threshold**
```
base_threshold = 0.4
rounds_remaining_fraction = (r - current_round) / r
generosity_bonus = 0.2 × rounds_remaining_fraction

threshold = base_threshold - generosity_bonus
```
This means:
- Early game: threshold ≈ 0.2 (very forgiving, encourage cooperation)
- Mid game: threshold ≈ 0.3-0.4 (balanced)
- Late game: threshold approaches 0.4 (more cautious)

**Step 3: Apply forgiveness mechanism**
```
If I defected last round AND cooperation_rate increased:
    Apply "benefit of the doubt": threshold = threshold - 0.15
```

**Step 4: Decision**
```
If cooperation_rate ≥ threshold:
    COOPERATE
Else:
    DEFECT
```

### Final Round (Round r): Conditional Cooperation

Unlike simple backward induction to defection:
```
If cooperation_rate over last 3 rounds ≥ 0.5:
    COOPERATE (reward sustained cooperation)
Else:
    DEFECT
```

Rationale: Defecting in the final round is the "rational" move, but if a cooperative equilibrium has been sustained, maintaining it signals commitment to collective welfare and may influence learning in repeated tournaments.

---

## Pseudocode Implementation

```python
def decide(round_number, total_rounds, n_players, history):
    r = total_rounds
    n = n_players
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate recent cooperation rate (last 3 rounds or fewer)
    lookback = min(3, round_number - 1)
    recent_rounds = history[-(lookback):]
    others_actions = [actions of other (n-1) players in recent_rounds]
    cooperation_rate = count(COOPERATE in others_actions) / ((n-1) * lookback)
    
    # Dynamic threshold
    base_threshold = 0.4
    rounds_remaining_fraction = (r - round_number) / r
    generosity_bonus = 0.2 * rounds_remaining_fraction
    threshold = base_threshold - generosity_bonus
    
    # Forgiveness: if I defected but others increased cooperation
    if round_number > 2:
        my_last_action = history[-1][my_index]
        prev_coop_rate = calculate_cooperation_rate(history[-2])
        curr_coop_rate = calculate_cooperation_rate(history[-1])
        if my_last_action == DEFECT and curr_coop_rate > prev_coop_rate:
            threshold = threshold - 0.15
    
    # Final round special handling
    if round_number == r:
        if cooperation_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Standard decision
    if cooperation_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases Handled

| Situation | Response |
|-----------|----------|
| Round 1 | Always cooperate |
| Final round | Cooperate if recent rate ≥ 50% |
| All others defect | Defect after round 1 (rate = 0 < threshold) |
| All others cooperate | Cooperate (rate = 1 > any threshold) |
| Mixed behavior | Use threshold to decide |
| After my own defection | Extra forgiveness if others increased cooperation |
| Very short games (r=2) | Round 1: C, Round 2: conditional on round 1 |
| Large n | Strategy scales naturally via cooperation rate |

---

## Why This Strategy Is Collectively Aligned

1. **Starts cooperative**: Gives the collective a chance to form cooperative norms
2. **Generous thresholds**: Doesn't require unanimity; tolerates some defection
3. **Forgiveness built-in**: Allows recovery from defection spirals
4. **Doesn't exploit**: Never defects purely for individual gain when cooperation is viable
5. **Rewards sustained cooperation**: Even in the final round, maintains cooperation if others have
6. **Adaptive**: Responds to actual behavior rather than assuming the worst
'''

description_COLLECTIVE_75 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similarly-designed cooperative strategies) may be present in the game. The goal is to establish and maintain cooperation among willing participants while protecting against exploitation by pure defectors.

## Strategy Overview: **Adaptive Threshold Cooperation with Forgiveness**

The strategy cooperates when there's sufficient evidence of collective cooperation, defects to protect against exploitation, and periodically tests for cooperation recovery.

---

## Decision Rules

### Round 1: Cooperate
**Rationale**: Signal cooperative intent. With no history, optimism is warranted—especially since other collective-minded strategies will likely do the same. The cost of one round's exploitation is small compared to the potential gains from establishing mutual cooperation.

### Rounds 2 through (r-1): Conditional Cooperation with Forgiveness

**Calculate the cooperation ratio from the previous round:**
```
prev_coop_ratio = (number of players who played C in round t-1) / n
```

**Calculate the historical cooperation trend:**
```
recent_coop_ratio = (total C plays in last min(3, t-1) rounds) / (n × min(3, t-1))
```

**Decision Rule:**
```
threshold = max(0.3, (k/n) + 0.1)  # Adaptive threshold based on game economics

IF prev_coop_ratio >= threshold:
    COOPERATE
ELSE IF recent_coop_ratio >= threshold AND prev_coop_ratio >= 0.2:
    COOPERATE  # Forgiveness: don't abandon ship over one bad round
ELSE IF (t mod forgiveness_period) == 0:
    COOPERATE  # Periodic probe to test for cooperation recovery
    WHERE forgiveness_period = max(3, floor(r/5))
ELSE:
    DEFECT
```

**Threshold Justification**: The threshold `(k/n) + 0.1` is tied to the break-even point. When `k/n` of players cooperate, cooperators and defectors get similar payoffs. We want slightly above this to ensure cooperation is genuinely beneficial.

### Final Round (Round r): Conditional Defection with Collective Exception

```
IF recent_coop_ratio >= 0.7:
    COOPERATE  # Reward sustained collective cooperation
ELSE:
    DEFECT  # Standard game-theoretic response when cooperation is weak
```

**Rationale**: In a one-shot ending, defection is individually rational. However, if the group has demonstrated strong collective behavior (≥70% cooperation recently), maintaining cooperation honors the collective norm and maximizes group payoff.

---

## Complete Pseudocode

```
function decide(round t, history, n, k, r):
    
    # Round 1: Always cooperate
    if t == 1:
        return COOPERATE
    
    # Calculate metrics
    prev_coop_count = count(history[t-1] where action == C)
    prev_coop_ratio = prev_coop_count / n
    
    lookback = min(3, t-1)
    recent_coop_count = sum(count(history[i] where action == C) for i in [t-lookback, t-1])
    recent_coop_ratio = recent_coop_count / (n × lookback)
    
    # Adaptive threshold
    threshold = max(0.3, (k/n) + 0.1)
    forgiveness_period = max(3, floor(r/5))
    
    # Final round logic
    if t == r:
        if recent_coop_ratio >= 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # Main decision logic
    if prev_coop_ratio >= threshold:
        return COOPERATE
    else if recent_coop_ratio >= threshold AND prev_coop_ratio >= 0.2:
        return COOPERATE  # Forgiveness
    else if (t mod forgiveness_period) == 0:
        return COOPERATE  # Periodic probe
    else:
        return DEFECT
```

---

## Edge Cases Handled

| Scenario | Behavior | Rationale |
|----------|----------|-----------|
| **n = 2** | Behaves like Tit-for-Tat with forgiveness | Threshold naturally adapts |
| **k close to 1** | Higher effective threshold, more cautious | Low multiplier means cooperation needs more participants to be worthwhile |
| **k close to n** | Lower threshold, more cooperative | High multiplier makes even partial cooperation valuable |
| **All defectors** | Defects with periodic probes | Protects against exploitation while allowing recovery |
| **Single defector among cooperators** | Continues cooperating | One defector doesn't collapse the system |
| **Short games (small r)** | More frequent probes | Ensures enough cooperation tests |
| **Long games (large r)** | Spaced probes, relies on trend | Efficient resource use |

---

## Why This Strategy is Collectively Robust

1. **Self-recognizing**: Multiple instances of this strategy will establish immediate cooperation in round 1 and maintain it throughout.

2. **Exploitation-resistant**: Won't perpetually cooperate against defectors; threshold mechanism protects collective payoff.

3. **Forgiving**: Doesn't permanently punish temporary defections; allows recovery from noise or mistakes.

4. **Economically grounded**: Threshold adapts to game parameters, ensuring cooperation is only pursued when collectively beneficial.

5. **Probe mechanism**: Periodic cooperation attempts prevent lock-in to mutual defection when cooperation could emerge.
'''

description_COLLECTIVE_74 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be using similar reasoning, and I aim to establish and maintain cooperation when possible while protecting against exploitation. The strategy balances **optimism** (starting cooperatively to signal good faith) with **responsiveness** (adapting to observed behavior).

## Strategy: Adaptive Collective Reciprocity (ACR)

### Key Metrics Tracked

For each round t, track:
- `coop_rate[t]` = fraction of players who cooperated in round t
- `cumulative_coop_rate` = average cooperation rate across all past rounds
- `trend` = whether cooperation is increasing, stable, or declining
- `my_deficit` = how much I've cooperated relative to the group average

### Decision Rules

#### Round 1: Cooperate
**Rationale**: Signal willingness to cooperate. Since we cannot coordinate explicitly, starting with C establishes a cooperative baseline and gives others the opportunity to reciprocate.

#### Rounds 2 through (r-1): Adaptive Reciprocity

```
Let threshold = k/n  (the "fair share" multiplier)

IF coop_rate[t-1] >= 0.5:
    # Majority cooperated - reward and sustain cooperation
    COOPERATE
    
ELSE IF coop_rate[t-1] >= threshold AND trend is non-negative:
    # Some cooperation exists and not declining - give benefit of doubt
    COOPERATE
    
ELSE IF coop_rate[t-1] < threshold AND cumulative_coop_rate < 0.3:
    # Persistent low cooperation environment
    DEFECT
    
ELSE:
    # Mixed signals - use probabilistic cooperation
    # Cooperate with probability equal to cumulative_coop_rate
    COOPERATE with probability = cumulative_coop_rate
```

**Forgiveness Mechanism**: Every `floor(r/4)` rounds, if currently defecting, cooperate once to test if cooperation can be re-established. This prevents permanent defection spirals.

#### Final Round (round r): Conditional Cooperation

Unlike standard game theory which suggests always defecting in the final round:

```
IF cumulative_coop_rate >= 0.6:
    # Strong cooperative history - maintain trust, assume others think collectively
    COOPERATE
    
ELSE IF cumulative_coop_rate >= 0.4:
    # Moderate cooperation - match the group's revealed preference
    COOPERATE with probability = cumulative_coop_rate
    
ELSE:
    # Low cooperation environment - defect
    DEFECT
```

**Rationale**: If others are also thinking collectively, mutual final-round cooperation is achievable and beneficial. This distinguishes collective-minded players from purely self-interested ones.

### Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2 | Use standard Tit-for-Tat with forgiveness | Bilateral dynamics differ; direct reciprocity is clearer |
| r = 2 | Cooperate both rounds if first-round coop_rate ≥ 0.5, else C then D | Limited rounds mean less data; bias toward cooperation |
| k very close to 1 | Lower cooperation threshold to 0.4 | Lower returns to cooperation require more caution |
| k very close to n | Raise cooperation threshold to 0.6 | Higher returns justify more cooperative risk |
| All others defected last round | Still cooperate once every `max(3, r/5)` rounds | Maintain hope for coordination breakthrough |

### Pseudocode Summary

```python
def decide(round_num, history, n, k, r):
    if round_num == 1:
        return COOPERATE
    
    coop_rate_last = count_cooperators(history[-1]) / n
    cumulative_rate = avg_cooperation_rate(history)
    threshold = k / n
    
    # Forgiveness probe
    if round_num % max(3, r // 4) == 0 and would_defect:
        return COOPERATE
    
    # Final round logic
    if round_num == r:
        if cumulative_rate >= 0.6:
            return COOPERATE
        elif cumulative_rate >= 0.4:
            return COOPERATE with probability cumulative_rate
        else:
            return DEFECT
    
    # Main game logic
    if coop_rate_last >= 0.5:
        return COOPERATE
    elif coop_rate_last >= threshold and trend >= 0:
        return COOPERATE
    elif coop_rate_last < threshold and cumulative_rate < 0.3:
        return DEFECT
    else:
        return COOPERATE with probability cumulative_rate
```

## Why This Strategy is Collectively Aligned

1. **Optimistic start**: Assumes good faith from others
2. **Rewards cooperation**: Reliably cooperates when others do
3. **Forgives mistakes**: Periodic cooperation tests prevent permanent breakdown
4. **Collective final round**: Doesn't exploit trust built over the game
5. **Scales with group**: Thresholds based on k/n adapt to different group sizes and multipliers
'''

description_COLLECTIVE_76 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I aim to maximize group welfare while protecting against exploitation. The key insight is that universal cooperation yields the highest total payoff (everyone gets k > 1), but the temptation to defect creates a social dilemma. My approach is to **lead with cooperation, respond proportionally to group behavior, and maintain hope for collective improvement**.

---

## Strategy: "Adaptive Collective Reciprocity" (ACR)

### Decision Framework

The strategy tracks the **cooperation rate** of the group (excluding self) and adjusts behavior based on three factors:
1. **Group cooperation history** - How cooperative has the group been?
2. **Trend detection** - Is cooperation increasing or decreasing?
3. **Round context** - Early rounds build trust; late rounds require commitment

---

### Detailed Decision Rules

#### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- Rationale: Signal cooperative intent, give others the benefit of the doubt, establish foundation for collective success

#### Rounds 2 through (r-1): Adaptive Response

**Calculate:**
- `coop_rate` = (total cooperations by others in previous round) / (n - 1)
- `avg_coop_rate` = average cooperation rate across all previous rounds
- `trend` = coop_rate(last round) - coop_rate(two rounds ago) [if available]

**Decision Logic:**

```
IF coop_rate >= 0.5 THEN
    COOPERATE
    // Majority cooperating → reward and sustain collective action

ELSE IF coop_rate < 0.5 AND coop_rate > 0 THEN
    // Partial cooperation exists - use probabilistic matching
    COOPERATE with probability = coop_rate + 0.1
    // Slight optimism bias to encourage recovery
    
ELSE IF coop_rate == 0 THEN
    // Total defection by others
    IF trend > 0 OR avg_coop_rate > 0.3 THEN
        COOPERATE with probability = 0.2
        // Small chance to restart cooperation
    ELSE
        DEFECT
        // Protect against persistent defectors
```

**Forgiveness Mechanism:**
- After 2 consecutive rounds of defection, if others show ANY cooperation increase, return to cooperation
- Never defect more than 3 consecutive rounds without testing cooperation again

#### Final Round (Round r): Conditional Cooperation

Unlike classic game theory advice to defect in the final round:

```
IF avg_coop_rate >= 0.6 THEN
    COOPERATE
    // Honor the collective that has formed
    
ELSE IF avg_coop_rate >= 0.3 THEN
    COOPERATE with probability = avg_coop_rate
    // Proportional commitment
    
ELSE
    DEFECT
    // Group has not demonstrated collective behavior
```

---

### Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (minimum players) | Use stricter threshold (0.7) for cooperation | Higher vulnerability to single defector |
| k close to n (high multiplier) | More forgiving thresholds | Greater benefit from mutual cooperation |
| k close to 1 (low multiplier) | Standard thresholds | Marginal gains don't justify extra risk |
| r = 2 (minimum rounds) | Cooperate both rounds unless R1 shows 0% cooperation | Limited time to establish patterns |
| All others defected every round | Defect, but try cooperation every 3rd round | Never fully abandon hope |

---

### Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    others_coop_last = count_cooperators(history, round-1, exclude_self=True)
    coop_rate = others_coop_last / (n - 1)
    avg_coop = average_cooperation_rate(history)
    
    if round == r:  # Final round
        if avg_coop >= 0.6:
            return COOPERATE
        else:
            return COOPERATE with probability avg_coop
    
    # Middle rounds
    if coop_rate >= 0.5:
        return COOPERATE
    elif coop_rate > 0:
        return COOPERATE with probability (coop_rate + 0.1)
    else:  # coop_rate == 0
        if consecutive_defections(history) >= 3:
            return COOPERATE  # Forgiveness probe
        return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Invites cooperation**: Starting with C and maintaining optimism bias encourages collective formation
2. **Rewards collective behavior**: Sustained cooperation when majority cooperates
3. **Proportional response**: Doesn't overreact to temporary defections
4. **Resilient**: Periodic forgiveness allows recovery from defection spirals
5. **Honors commitment**: Final-round cooperation rewards groups that built trust

This strategy succeeds when paired with itself or similar cooperative strategies, while limiting losses against pure defectors through adaptive withdrawal.
'''

description_COLLECTIVE_75 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all instances of this strategy will reason identically given the same information. This isn't coordination through communication—it's coordination through shared rationality. If we all think the same way, we can achieve implicit synchronization.

The key insight is that with k > 1, mutual cooperation always beats mutual defection (payoff of k vs 1). The challenge is maintaining cooperation in a mixed population while protecting against exploitation.

---

## Strategy: "Adaptive Collective Threshold" (ACT)

### Decision Framework

**Primary Variables Tracked:**
- `t`: current round (1-indexed)
- `r`: total rounds
- `n`: number of players
- `k`: multiplication factor
- `coop_rate[t]`: proportion of players who cooperated in round t
- `trend`: moving direction of cooperation (increasing, stable, decreasing)

---

### Decision Rules

#### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: We cannot learn anything without establishing a baseline. Starting with cooperation signals willingness to collaborate and allows us to assess the population. Since all copies of this strategy reason identically, we achieve immediate coordination among ourselves.

---

#### Rounds 2 through (r-1): Adaptive Response

Calculate the following each round:

```
recent_coop_rate = average cooperation rate over last min(3, t-1) rounds
collective_threshold = k / n  (the break-even point for cooperation)
```

**Decision Logic:**

```
IF recent_coop_rate >= collective_threshold:
    # Environment supports cooperation - it's worth contributing
    ACTION = COOPERATE
    
ELIF recent_coop_rate >= collective_threshold * 0.5:
    # Marginal environment - use probabilistic cooperation to:
    # (1) maintain some cooperative presence
    # (2) reduce exploitation losses
    # (3) allow recovery if others are also conditional cooperators
    
    coop_probability = recent_coop_rate / collective_threshold
    ACTION = COOPERATE with probability coop_probability
    
    # For deterministic implementation across identical agents:
    # Use round number parity or modular arithmetic
    # ACTION = COOPERATE if (t mod ceil(1/coop_probability)) == 1
    
ELSE:
    # Hostile environment - protect against exploitation
    ACTION = DEFECT
```

**Forgiveness Mechanism:**
```
IF last round saw a significant jump in cooperation (increase > 0.2):
    # Others may be trying to restart cooperation
    ACTION = COOPERATE (override above rules)
```

**Trend Adjustment:**
```
IF cooperation has been steadily increasing for 3+ rounds:
    # Reward positive momentum
    Bias toward COOPERATE (lower threshold by 10%)
    
IF cooperation has been steadily decreasing for 3+ rounds:
    # Prepare for collapse
    Bias toward DEFECT (raise threshold by 10%)
```

---

#### Final Round (t = r): Conditional Cooperation

Unlike standard game theory which recommends universal defection:

```
IF recent_coop_rate >= 0.7:
    # High-cooperation environment suggests other collective strategies
    # Maintain cooperation to maximize collective welfare
    ACTION = COOPERATE
    
ELIF recent_coop_rate >= collective_threshold:
    # Mixed environment - cooperate with reduced probability
    ACTION = COOPERATE with probability 0.5
    
ELSE:
    # Low cooperation environment - no reason to sacrifice
    ACTION = DEFECT
```

Rationale: If we're playing against other collective strategies, mutual final-round cooperation benefits everyone. The conditional approach protects against pure defectors while rewarding sustained cooperation.

---

### Pseudocode Summary

```python
def decide(t, r, n, k, history):
    threshold = k / n
    
    # Round 1: Always cooperate
    if t == 1:
        return COOPERATE
    
    # Calculate recent cooperation rate
    lookback = min(3, t - 1)
    recent_coop_rate = mean(history[t-lookback : t])
    
    # Detect positive momentum
    if t >= 4:
        trend = history[t-1] - history[t-3]  # 2-round change
        momentum_bonus = 0.1 if trend > 0.1 else (-0.1 if trend < -0.1 else 0)
    else:
        momentum_bonus = 0
    
    adjusted_threshold = threshold - momentum_bonus
    
    # Forgiveness: respond to cooperation jumps
    if t >= 2 and history[t-1] - history[t-2] > 0.2:
        return COOPERATE
    
    # Final round logic
    if t == r:
        if recent_coop_rate >= 0.7:
            return COOPERATE
        elif recent_coop_rate >= threshold:
            return COOPERATE if (t % 2 == 0) else DEFECT  # deterministic 50%
        else:
            return DEFECT
    
    # Main rounds logic
    if recent_coop_rate >= adjusted_threshold:
        return COOPERATE
    elif recent_coop_rate >= adjusted_threshold * 0.5:
        # Probabilistic cooperation (deterministic implementation)
        cycle_length = ceil(adjusted_threshold / recent_coop_rate)
        return COOPERATE if (t % cycle_length == 1) else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Self-Coordination**: All copies reason identically, so we automatically synchronize without explicit coordination.

2. **Threshold-Based**: Uses k/n as the natural break-even point, making the strategy robust across different parameter settings.

3. **Forgiveness**: Responds to cooperation attempts, enabling recovery from temporary breakdowns.

4. **Graduated Response**: Doesn't immediately abandon cooperation—uses probabilistic tapering to maintain presence while limiting losses.

5. **Momentum-Aware**: Rewards positive trends and prepares for negative ones.

6. **End-Game Nuance**: Doesn't blindly defect in the final round, recognizing that other collective strategies may also maintain cooperation.
'''

description_COLLECTIVE_77 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all instances of this strategy will reason identically given the same information. Rather than treating this as a coordination problem to solve, we treat identical reasoning as a resource to exploit. When playing against copies of ourselves, we can achieve mutual cooperation through synchronized decision-making. When playing against defectors, we protect ourselves. When playing against conditional cooperators, we build trust.

## Strategy Overview: **Synchronized Threshold Cooperation (STC)**

The strategy operates on three principles:
1. **Deterministic synchronization**: All copies make identical decisions from identical game states
2. **Graduated trust**: Increase cooperation as evidence of cooperative opponents accumulates
3. **Endgame protection**: Manage the unraveling problem in final rounds

---

## Decision Rules

### Round 1: Cooperative Opening

**Action: COOPERATE**

Rationale: 
- Against copies of ourselves, we all cooperate and achieve the social optimum
- Against unknown opponents, we signal cooperative intent and gather information
- The information value of seeing others' responses outweighs the risk of exploitation

---

### Middle Rounds (Round 2 through Round r-2):

Calculate the **Cooperation Ratio** from the previous round:
```
CR = (number of cooperators in previous round) / n
```

**Decision Rule:**

```
If CR >= (n-1)/n:          → COOPERATE (near-universal cooperation)
If CR >= 0.5:              → COOPERATE (majority cooperating)
If CR >= k/n:              → COOPERATE (cooperation is still collectively beneficial)
If CR < k/n:               → DEFECT (cooperation collapsed below viability threshold)
```

**Additional Trigger - Trend Detection:**

Track the 3-round moving average of cooperation ratio. If available:
```
If current_CR < previous_CR AND CR < 0.5:  → DEFECT (declining cooperation trend)
```

This catches gradual defection before full collapse.

---

### Penultimate Round (Round r-1):

**Action: Mirror the majority from the previous round**

```
If CR >= 0.5:  → COOPERATE
If CR < 0.5:   → DEFECT
```

Rationale: Begin transitioning toward endgame while still rewarding sustained cooperation.

---

### Final Round (Round r):

**Action: Conditional on cooperation history**

```
Calculate: sustained_cooperation = (average CR across all rounds >= 0.6)

If sustained_cooperation:  → COOPERATE (reward long-term cooperators, including copies)
Else:                      → DEFECT (no reason to cooperate with defectors)
```

Rationale: This solves the backward induction problem for groups of STC players. Since we all compute the same history and threshold, we either all cooperate or all defect. Against mixed populations, we reward those who maintained cooperation while protecting against exploitation.

---

## Pseudocode Implementation

```
function STC_strategy(n, k, r, current_round, history):
    
    # Round 1: Always cooperate
    if current_round == 1:
        return COOPERATE
    
    # Calculate cooperation ratio from previous round
    prev_cooperators = count_cooperators(history[current_round - 1])
    CR = prev_cooperators / n
    
    # Final round logic
    if current_round == r:
        avg_CR = average_cooperation_ratio(history)
        if avg_CR >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Penultimate round logic
    if current_round == r - 1:
        if CR >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: threshold-based with trend detection
    viability_threshold = k / n
    
    # Trend detection (if enough history)
    if current_round >= 3:
        prev_prev_CR = count_cooperators(history[current_round - 2]) / n
        declining = (CR < prev_prev_CR) and (CR < 0.5)
        if declining:
            return DEFECT
    
    # Main threshold logic
    if CR >= viability_threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (minimum players) | Same rules apply | Thresholds scale appropriately |
| r = 2 (minimum rounds) | R1: Cooperate, R2: Based on R1 CR ≥ 0.6 | Compressed logic still applies |
| All opponents defect R1 | Defect thereafter | CR = 1/n < k/n always (since k < n) |
| k very close to n | Lower effective threshold | More forgiving of partial defection |
| k very close to 1 | Higher effective threshold | Requires near-universal cooperation |

---

## Why This Strategy is Collectively Optimal

1. **Self-coordination**: Against copies, we all see the same history and compute the same thresholds → synchronized cooperation throughout, achieving payoff of 2 per round (with k=2, n=6 example)

2. **Robust to defectors**: The k/n threshold ensures we only cooperate when it's collectively rational. Below this threshold, even universal cooperation wouldn't be worthwhile.

3. **Forgiveness built-in**: A single round of low cooperation doesn't doom the game if it recovers above threshold.

4. **Endgame stability**: By making final-round cooperation conditional on sustained history, we avoid the backward induction collapse while protecting against exploitation.

5. **Parameter-adaptive**: All thresholds derive from game parameters (n, k), making the strategy robust across different configurations.
'''

description_COLLECTIVE_76 = '''
# Collective Strategy: Adaptive Threshold Reciprocity (ATR)

## Core Philosophy

This strategy embraces a collective mindset: **we succeed together or fail together**. Since k > 1, mutual cooperation generates more total value than mutual defection. The challenge is sustaining cooperation in a world where individual defection is tempting. My approach: start cooperatively, adapt thresholds based on observed behavior, and create conditions where cooperation becomes the rational choice for others.

## Strategy Overview

The strategy maintains a **cooperation threshold** that adjusts based on the group's demonstrated willingness to cooperate. I cooperate when enough others do, defect to protect myself when cooperation collapses, but remain forgiving to rebuild cooperation.

---

## Decision Rules

### State Variables (Updated Each Round)
- `coop_rate`: Rolling cooperation rate of all players over recent history
- `threshold`: Minimum cooperation rate required to continue cooperating
- `rounds_remaining`: How many rounds are left

### Round-by-Round Logic

```
FIRST ROUND:
    Play C (Cooperate)
    # Signal cooperative intent; establish baseline for reciprocity

LAST ROUND:
    IF coop_rate >= 0.5 over last 3 rounds:
        Play C  # Reward sustained cooperation, maintain collective outcome
    ELSE:
        Play D  # No future to protect; respond to defection

MIDDLE ROUNDS:
    Calculate coop_rate = (total C plays by all players) / (total actions) 
                          over last min(3, rounds_played) rounds
    
    IF coop_rate >= threshold:
        Play C
    ELSE:
        Play D
    
    # Threshold Adjustment (after observing round outcome):
    IF this round's cooperation rate >= 0.6:
        threshold = max(0.3, threshold - 0.05)  # Lower bar when things go well
    ELSE IF this round's cooperation rate < 0.4:
        threshold = min(0.7, threshold + 0.05)  # Raise bar when cooperation fails
```

### Initial Parameters
- `threshold = 0.4` (start with low bar to encourage cooperation)

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| **Round 1** | Cooperate | No information yet; signal cooperative intent |
| **Round 2** | Cooperate if ≥40% cooperated in R1, else Defect | Quick forgiveness, but not naive |
| **Last round** | Cooperate if recent cooperation ≥50% | Don't betray a cooperative group; defect only if trust already broken |
| **n=2 (minimum players)** | Standard rules apply | Threshold logic works; becomes pairwise TFT-like |
| **Very low k (near 1)** | Standard rules apply | Low returns make cooperation fragile, but strategy adapts via threshold |
| **All defected last round** | Defect, but threshold only rises by 0.05 | Protect self but leave door open for recovery |
| **Perfect cooperation streak** | Continue cooperating, threshold drops to floor (0.3) | Reward and sustain success |

---

## Why This Strategy is Collectively Optimal

1. **Signals cooperation first**: Opens with C to establish cooperative norms
2. **Reciprocates proportionally**: Mirrors group behavior rather than individual players
3. **Forgives gradually**: Threshold adjustments are small (±0.05), allowing recovery
4. **Protects the collective**: Doesn't unilaterally defect when group is cooperating
5. **Robust to exploitation**: Withdraws cooperation when too few reciprocate
6. **Avoids last-round collapse**: Maintains cooperation in final round if trust exists

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, n, k):
    if round_num == 1:
        return COOPERATE
    
    recent_rounds = min(3, round_num - 1)
    coop_rate = count_cooperations(history, recent_rounds) / (n * recent_rounds)
    
    if round_num == total_rounds:
        return COOPERATE if coop_rate >= 0.5 else DEFECT
    
    if coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT

def update_threshold(last_round_coop_rate):
    if last_round_coop_rate >= 0.6:
        threshold = max(0.3, threshold - 0.05)
    elif last_round_coop_rate < 0.4:
        threshold = min(0.7, threshold + 0.05)
```

---

This strategy embodies **conditional collective commitment**: I am fully willing to cooperate for our mutual benefit, and I adjust my expectations based on what the group demonstrates it can sustain.
'''

description_COLLECTIVE_78 = '''
# Collective Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy embraces a genuinely collective mindset: we aim to maximize group welfare while protecting against exploitation. The key insight is that in a public goods game, **universal cooperation yields the best collective outcome** (everyone gets k > 1), but this requires building and maintaining trust through observable behavior.

## Strategy Overview

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness to contribute
2. **Mirror the group's cooperation level** to reward cooperation and discourage defection
3. **Maintain hope for recovery** while protecting against persistent exploitation

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, we signal our collective intent. This gives the group the best chance to establish mutual cooperation.

### Rounds 2 through (r-1): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
prev_coop_rate = (number of players who cooperated in round t-1) / n
```

**Decision Rule:**
```
IF prev_coop_rate >= threshold(t) THEN COOPERATE
ELSE DEFECT
```

**Adaptive Threshold Function:**
```
base_threshold = (n - 1) / (2 * n)  # Approximately 0.5 for large n, slightly lower for small n

# Forgiveness factor: becomes more forgiving in middle rounds to allow recovery
rounds_remaining_ratio = (r - t) / r
forgiveness = 0.15 * rounds_remaining_ratio

threshold(t) = max(base_threshold - forgiveness, 1/n)
```

The threshold is set so that:
- We cooperate if at least ~half the group cooperated (adjusted for group size)
- Early/middle rounds are more forgiving to allow trust-building
- We always cooperate if at least one other player cooperated (minimum threshold = 1/n)

### Last Round (Round r): Conditional Cooperation with History Weight

The last round has no future to incentivize cooperation, but our collective mindset means we don't automatically defect.

```
overall_coop_rate = (total cooperations across all players, all rounds) / (n * (r-1))

IF overall_coop_rate >= 0.5 THEN COOPERATE
ELSE DEFECT
```

Rationale: If the group has demonstrated sustained cooperation, we honor that relationship even in the final round. This differentiates us from purely self-interested strategies.

---

## Pseudocode Implementation

```python
def decide(round_number, n, r, k, history):
    """
    history: list of lists, where history[t] contains actions of all n players in round t
    actions encoded as 1 (cooperate) or 0 (defect)
    """
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_round = history[round_number - 1]
    prev_coop_rate = sum(prev_round) / n
    
    # Last round: use overall history
    if round_number == r:
        total_coops = sum(sum(round_actions) for round_actions in history)
        total_actions = n * (r - 1)
        overall_coop_rate = total_coops / total_actions
        
        if overall_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: adaptive threshold
    base_threshold = (n - 1) / (2 * n)
    rounds_remaining_ratio = (r - round_number) / r
    forgiveness = 0.15 * rounds_remaining_ratio
    threshold = max(base_threshold - forgiveness, 1 / n)
    
    if prev_coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Case Handling

| Scenario | Behavior | Rationale |
|----------|----------|-----------|
| n = 2 | Threshold ≈ 0.25, so cooperate if partner cooperated | Essentially Tit-for-Tat with forgiveness |
| Large n | Threshold approaches 0.5 | Require genuine majority cooperation |
| r = 2 | Round 1: cooperate; Round 2: based on overall rate | Minimal but meaningful adaptation |
| All defect in round 1 | Defect in round 2, but threshold lowers over time | Allows recovery if others start cooperating |
| Mixed opponents | Mirrors group behavior proportionally | Rewards cooperators, punishes defectors as a group phenomenon |

---

## Why This Strategy is Collectively Aligned

1. **Starts with trust**: Opening cooperation creates opportunity for mutual benefit
2. **Rewards collective behavior**: Responds to group-level cooperation, not individual targeting
3. **Forgives and allows recovery**: Declining thresholds give the group chances to rebuild cooperation
4. **Honors sustained cooperation**: Final-round behavior rewards groups that maintained trust
5. **Protects the collective**: Defects when cooperation rate is too low, preventing exploitation of cooperative players
'''

description_COLLECTIVE_77 = '''
# Collective Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy is designed with a **collective mindset**: we assume all instances of this strategy will behave identically given the same history, creating implicit coordination without explicit communication. The goal is to maximize collective welfare while protecting against exploitation by defectors.

## Strategy Overview

The strategy uses a **cooperation threshold** that adapts based on observed cooperation rates. We cooperate when the group demonstrates sufficient cooperative behavior, and defect to protect ourselves when cooperation breaks down.

---

## Decision Rules

### Key Variables
- `coop_rate(t)` = proportion of all players who cooperated in round t
- `cumulative_coop_rate` = average cooperation rate across all completed rounds
- `threshold` = minimum cooperation rate required to continue cooperating
- `rounds_remaining` = r - current_round

### Round-by-Round Logic

#### **Round 1: Unconditional Cooperation**
- **Action: COOPERATE**
- Rationale: Signal willingness to cooperate and establish baseline. Since we cannot coordinate beforehand, starting cooperatively gives the collective the best chance to achieve mutual cooperation.

#### **Rounds 2 through (r-1): Adaptive Threshold**

```
threshold = max(0.5, (n-1)/n × (1/k) + 0.1)
```

This threshold ensures we only cooperate when enough others do to make cooperation roughly worthwhile, with a small buffer.

**Decision Rule:**
```
IF cumulative_coop_rate >= threshold:
    COOPERATE
ELSE IF coop_rate(t-1) >= threshold AND cumulative_coop_rate >= threshold - 0.15:
    COOPERATE  (give benefit of doubt if recent round was good)
ELSE:
    DEFECT
```

#### **Final Round (Round r): Conditional Cooperation**

Unlike standard game theory which prescribes defection, we maintain collective thinking:

```
IF cumulative_coop_rate >= threshold:
    COOPERATE  (reward sustained cooperation)
ELSE:
    DEFECT
```

Rationale: If we're all running this strategy and have maintained cooperation, simultaneous defection would harm everyone. Maintaining cooperation in the final round rewards the collective for sustained good behavior.

---

## Forgiveness Mechanism

To recover from temporary breakdowns:

```
IF defected_last_round AND coop_rate(t-1) >= 0.6:
    COOPERATE  (attempt to restart cooperation)
```

This allows the collective to recover from coordination failures rather than spiraling into permanent defection.

---

## Complete Pseudocode

```python
def decide(round, history, n, k, r):
    
    # Calculate base threshold
    base_threshold = max(0.5, ((n-1)/n) * (1/k) + 0.1)
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation rates
    cumulative_coop_rate = total_cooperations(history) / ((round-1) * n)
    last_round_coop_rate = cooperations_in_round(history, round-1) / n
    
    # Determine if we should cooperate
    should_cooperate = False
    
    # Primary condition: cumulative rate meets threshold
    if cumulative_coop_rate >= base_threshold:
        should_cooperate = True
    
    # Secondary condition: recent improvement (forgiveness)
    elif last_round_coop_rate >= 0.6 and cumulative_coop_rate >= base_threshold - 0.15:
        should_cooperate = True
    
    # Final round: only cooperate if group has been consistently cooperative
    if round == r:
        if cumulative_coop_rate >= base_threshold:
            return COOPERATE
        else:
            return DEFECT
    
    return COOPERATE if should_cooperate else DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | COOPERATE | Establish cooperative baseline |
| Final round, high coop history | COOPERATE | Reward collective success |
| Final round, low coop history | DEFECT | No reason to be exploited |
| n=2 (minimum players) | Use same logic | Threshold naturally adjusts |
| All others defect round 1 | DEFECT round 2+ | Protect against pure defectors |
| Single-round dip in cooperation | Check forgiveness | Allow recovery |

---

## Why This Strategy Works Collectively

1. **Identical behavior**: All instances make the same decision given the same history
2. **Self-sustaining**: If enough copies play, cooperation rate stays above threshold
3. **Robust to defectors**: Threshold protects against exploitation
4. **Recoverable**: Forgiveness mechanism prevents permanent collapse
5. **No exploitation of final round**: Collective thinking overrides backward induction
'''

description_COLLECTIVE_79 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I cooperate because cooperation creates the best outcomes for everyone, and I want to be the kind of player that makes cooperation sustainable. However, I must also be adaptive—rewarding cooperation and withdrawing from exploitation.

The key insight is that in a multiplayer setting, I should be **generous and forgiving** because:
1. With many players, any single defector has limited impact on my payoff
2. Punishing too harshly can trigger defection cascades
3. My cooperation signals to others that collective benefit is achievable

## Strategy: "Generous Collective Trigger"

### Decision Rules

**Round 1: Always Cooperate**
- Start by demonstrating cooperative intent
- This signals willingness to pursue collective benefit

**Rounds 2 through (r-1): Conditional Cooperation based on Cooperation Rate**

Calculate the cooperation rate from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Cooperate if:**
- `coop_rate >= threshold(t)` where threshold adapts over time

**Threshold Calculation:**
```
base_threshold = 0.5
forgiveness_bonus = 0.1 × (rounds_remaining / r)
threshold(t) = max(0.3, base_threshold - forgiveness_bonus)
```

This means:
- Early rounds: threshold ≈ 0.4 (more forgiving, give cooperation time to emerge)
- Middle rounds: threshold ≈ 0.45
- Late rounds: threshold → 0.5 (require majority cooperation)

**Additional Cooperation Triggers:**
- If cooperation rate has been **increasing** for 2+ consecutive rounds, cooperate (reward positive trends)
- If I defected last round AND cooperation rate stayed above 0.4, return to cooperation (forgiveness)

**Defect if:**
- `coop_rate < threshold(t)` AND cooperation is not trending upward

### Last Round Handling

**Round r (Final Round):**

Despite the classic game theory prediction to defect, I apply a **modified rule**:

```
if average_coop_rate_over_game >= 0.6:
    Cooperate  # Honor the collective that formed
else if coop_rate_last_round >= 0.5:
    Cooperate with probability = coop_rate_last_round
else:
    Defect
```

**Rationale:** If a cooperative collective emerged, I stay loyal. This also makes my strategy harder to exploit by players who cooperate early but plan to defect at the end.

### Edge Cases

**n = 2 (Two Players):**
- Use stricter threshold: require opponent cooperation (coop_rate = 1.0) to continue cooperating
- Essentially becomes Tit-for-Tat with one round of forgiveness

**Very Short Games (r ≤ 3):**
- Round 1: Cooperate
- Round 2: Cooperate if round 1 had any cooperators
- Round 3 (if exists): Apply last round rule

**All Previous Rounds Were Full Defection:**
- If I'm the only cooperator for 2+ consecutive rounds, defect
- But attempt one "olive branch" cooperation every ⌈r/4⌉ rounds to test if others will reciprocate

## Pseudocode Summary

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    coop_rate = count_cooperators(history[round-1]) / n
    coop_trend = coop_rate - count_cooperators(history[round-2]) / n if round > 2 else 0
    
    # Calculate adaptive threshold
    rounds_remaining = r - round
    threshold = max(0.3, 0.5 - 0.1 * (rounds_remaining / r))
    
    # Last round special handling
    if round == r:
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.6:
            return COOPERATE
        elif coop_rate >= 0.5:
            return COOPERATE with probability coop_rate
        else:
            return DEFECT
    
    # Standard rounds
    if coop_rate >= threshold:
        return COOPERATE
    elif coop_trend > 0 for last 2 rounds:
        return COOPERATE  # Reward positive momentum
    elif I_defected_last_round AND coop_rate >= 0.4:
        return COOPERATE  # Forgiveness - return to fold
    elif I_was_only_cooperator for 2+ rounds:
        if round % ceil(r/4) == 0:
            return COOPERATE  # Periodic olive branch
        else:
            return DEFECT
    else:
        return DEFECT
```

## Why This Strategy Works Collectively

1. **Signals cooperative intent** from round 1
2. **Forgives occasional defection** - doesn't over-punish noise or mistakes
3. **Rewards positive trends** - encourages groups moving toward cooperation
4. **Resists exploitation** - withdraws when cooperation rate is too low
5. **Maintains loyalty** - doesn't betray cooperative groups in final rounds
6. **Adapts to group size** - the threshold mechanism naturally adjusts to different n values
'''

description_COLLECTIVE_78 = '''
# Collective Strategy: Adaptive Threshold Reciprocity (ATR)

## Core Philosophy

This strategy operates from a collective mindset: **we assume all copies of this strategy will reason identically given the same information**. This means we can achieve implicit coordination without explicit communication. The strategy aims to establish and maintain cooperation among like-minded players while protecting against exploitation by defectors.

## Strategy Overview

The strategy uses a **cooperation threshold** that adapts based on observed group behavior. We cooperate when the group demonstrates sufficient cooperative spirit, and we defect to protect ourselves when cooperation levels fall too low.

---

## Decision Rules

### Round 1: Cooperative Signal
**Action: COOPERATE**

Rationale: We begin with cooperation to signal cooperative intent and establish a baseline for measuring group behavior. Since all copies of this strategy reason identically, we achieve immediate implicit coordination among ourselves.

### Rounds 2 through (r-1): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
prev_coop_rate = (number of players who cooperated last round) / n
```

Calculate the **required threshold** that makes cooperation viable:
```
base_threshold = (n - k) / (n × (k - 1))
```
This is derived from the condition where expected payoff from cooperating equals defecting, adjusted for group dynamics.

**Decision Rule:**
```
IF prev_coop_rate ≥ adjusted_threshold THEN COOPERATE
ELSE DEFECT
```

Where `adjusted_threshold` incorporates forgiveness and game progress:

```
# Forgiveness factor: be more forgiving early, stricter later
progress = current_round / r
forgiveness = max(0.1, 0.3 × (1 - progress))

# Trend bonus: reward improving cooperation
IF coop_rate_increasing over last 2 rounds THEN
    trend_bonus = 0.1
ELSE
    trend_bonus = 0

adjusted_threshold = max(0.2, base_threshold - forgiveness - trend_bonus)
```

### Last Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes universal defection, we maintain collective reasoning:

```
IF prev_coop_rate ≥ 0.5 THEN COOPERATE
ELSE DEFECT
```

Rationale: If the group has maintained majority cooperation, continuing to cooperate maximizes collective payoff. All copies of this strategy will make the same observation and same choice, preserving coordination to the end.

---

## Complete Pseudocode

```
function ATR_strategy(n, k, r, current_round, history):
    
    # Round 1: Always cooperate
    IF current_round == 1:
        RETURN COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history, current_round - 1)
    prev_coop_rate = prev_cooperators / n
    
    # Last round: simple majority rule
    IF current_round == r:
        IF prev_coop_rate >= 0.5:
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT
    
    # Middle rounds: adaptive threshold
    base_threshold = (n - k) / (n × (k - 1))
    base_threshold = clamp(base_threshold, 0.2, 0.8)
    
    progress = current_round / r
    forgiveness = max(0.1, 0.3 × (1 - progress))
    
    # Check for improving trend
    IF current_round >= 3:
        prev_prev_rate = count_cooperators(history, current_round - 2) / n
        trend_bonus = 0.1 IF prev_coop_rate > prev_prev_rate ELSE 0
    ELSE:
        trend_bonus = 0
    
    adjusted_threshold = max(0.2, base_threshold - forgiveness - trend_bonus)
    
    IF prev_coop_rate >= adjusted_threshold:
        RETURN COOPERATE
    ELSE:
        RETURN DEFECT
```

---

## Key Properties

1. **Self-coordinating**: Identical copies will always make identical decisions, achieving implicit cooperation without communication.

2. **Forgiving early, firm late**: Allows recovery from early defection but tightens standards as the game progresses.

3. **Economically grounded**: The base threshold derives from the actual payoff structure, adapting appropriately to different k and n values.

4. **Robust to exploitation**: If defectors dominate, the strategy protects itself by defecting, limiting losses.

5. **Rewards improvement**: The trend bonus encourages and reciprocates moves toward cooperation.

6. **Collective end-game**: Maintains cooperation in the final round when the group has been cooperative, rejecting the standard "always defect" conclusion that destroys collective value.
'''

description_COLLECTIVE_79 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players reason similarly and cooperate, we all achieve the best collective outcome (payoff of k per round vs. 1 from universal defection). The strategy aims to **establish and maintain cooperation** while being **robust to defectors** through measured, forgiving responses.

## Strategy Overview: "Generous Collective Tit-for-Tat with Threshold"

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness to cooperate
2. **Mirror the group's cooperation level** with a bias toward generosity
3. **Protect against exploitation** while remaining open to redemption

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, cooperation signals collective intent and gives the group a chance to establish mutual benefit. The potential gain from universal cooperation outweighs the risk of first-round exploitation.

### Rounds 2 through (r-1): Adaptive Threshold Response

**Calculate the cooperation rate** from the previous round:
```
cooperation_rate = (number of players who cooperated) / n
```

**Decision rule:**
```
IF cooperation_rate >= threshold THEN COOPERATE
ELSE DEFECT
```

**Dynamic threshold calculation:**
```
base_threshold = 0.5
generosity_factor = min(0.2, 1/n)  # More generous in smaller groups
threshold = base_threshold - generosity_factor

# Adjusted threshold typically ranges from 0.3 to 0.45
```

**Additional forgiveness mechanism:**
Even if below threshold, cooperate with probability:
```
forgiveness_probability = 0.1 × rounds_since_last_majority_cooperation
# Capped at 0.3
```

This periodic "olive branch" tests whether defectors are willing to return to cooperation.

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which suggests defecting in the final round, this collective strategy:

```
IF cooperation_rate in round (r-1) >= 0.6 THEN COOPERATE
ELSE DEFECT
```

Rationale: If the group has maintained cooperation, honor that relationship even in the final round. This reinforces that we value collective outcomes, not just individual exploitation.

---

## Complete Pseudocode

```
function decide(n, k, r, current_round, history):
    
    # Round 1: Always cooperate
    if current_round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history, current_round - 1)
    cooperation_rate = prev_cooperators / n
    
    # Calculate threshold (generous in small groups)
    generosity = min(0.2, 1/n)
    threshold = 0.5 - generosity
    
    # Final round logic
    if current_round == r:
        if cooperation_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Main rounds logic
    if cooperation_rate >= threshold:
        return COOPERATE
    else:
        # Forgiveness check
        rounds_since_good = rounds_since_cooperation_above(history, 0.5)
        forgiveness_prob = min(0.3, 0.1 * rounds_since_good)
        
        if random() < forgiveness_prob:
            return COOPERATE
        else:
            return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (minimum players) | Threshold ≈ 0.3, so cooperate if partner cooperated | Essentially generous tit-for-tat |
| Very large n | Threshold ≈ 0.5, less individual influence | Rely on group dynamics |
| k close to 1 | Same strategy | Even small collective gains matter |
| k close to n | Same strategy | Higher stakes reinforce cooperation value |
| All previous rounds had 0 cooperators | Forgiveness triggers occasional cooperation | Tests for strategy changes |
| r = 2 (minimum rounds) | Round 1: C, Round 2: conditional on round 1 | Maintains structure |

---

## Why This Strategy is Collectively Robust

1. **Coordination-friendly**: Identical agents using this strategy will cooperate every round
2. **Exploitation-resistant**: Defection triggers defensive response
3. **Recovery-capable**: Forgiveness mechanism allows return to cooperation
4. **Parameter-adaptive**: Adjusts generosity based on group size
5. **Reputation-building**: Consistent behavior allows other adaptive strategies to coordinate with us
'''

description_COLLECTIVE_80 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all players using this strategy will reason identically given the same information. Rather than treating other players as adversaries to be exploited or unpredictable agents to be cautiously probed, we recognize that copies of ourselves will reach the same conclusions. This enables coordination without communication.

The strategy balances three objectives:
1. **Collective welfare maximization** when playing with cooperative agents
2. **Robustness** against defectors and mixed populations
3. **Clear signaling** to establish cooperative equilibria

---

## Strategy: Adaptive Collective Reciprocity (ACR)

### Key Variables Tracked

- `round`: Current round number (1 to r)
- `cooperation_rate[t]`: Fraction of players who cooperated in round t
- `trend`: Whether cooperation is increasing, stable, or declining
- `defection_streak`: Consecutive rounds where cooperation_rate < threshold

### Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, we signal cooperative intent. All copies of this strategy will cooperate, immediately establishing a cooperative bloc. This maximizes expected value against unknown opponents and creates the conditions for sustained cooperation.

#### Rounds 2 through (r-1): Adaptive Reciprocity

```
threshold = k / n  # Break-even cooperation rate

IF cooperation_rate[previous_round] >= 0.5:
    # Majority cooperated - reward and sustain
    ACTION = COOPERATE
    
ELSE IF cooperation_rate[previous_round] >= threshold:
    # Above break-even but below majority
    # Cooperate with probability proportional to observed cooperation
    # This maintains contribution while signaling sensitivity
    IF cooperation_rate shows upward trend over last 2 rounds:
        ACTION = COOPERATE
    ELSE:
        ACTION = COOPERATE with probability = cooperation_rate[previous_round] * 1.5
        (capped at 1.0)

ELSE IF cooperation_rate[previous_round] < threshold:
    # Below break-even - cooperation is being exploited
    defection_streak += 1
    
    IF defection_streak <= 2:
        # Give chance for recovery - one more cooperation attempt
        ACTION = COOPERATE
    ELSE:
        # Sustained defection environment - protect against exploitation
        ACTION = DEFECT
```

#### Forgiveness Mechanism
```
IF previously defecting due to low cooperation:
    IF cooperation_rate[previous_round] > cooperation_rate[two_rounds_ago]:
        # Cooperation is recovering - rejoin immediately
        defection_streak = 0
        ACTION = COOPERATE
```

#### Final Round (round r): Conditional Cooperation

Unlike standard game theory which prescribes defection in final rounds, we maintain collective reasoning:

```
IF cooperation_rate[r-1] >= 0.5:
    # Strong cooperative norm established - honor it
    ACTION = COOPERATE
    
ELSE IF average_cooperation_rate[all_rounds] >= threshold:
    # Overall positive experience - end cooperatively
    ACTION = COOPERATE
    
ELSE:
    # Predominantly defecting population
    ACTION = DEFECT
```

---

## Handling Edge Cases

### Two-Player Game (n=2)
Standard Tit-for-Tat with forgiveness: Cooperate first, then mirror opponent's previous action, but forgive a single defection after two consecutive cooperations.

### Very Short Games (r=2 or r=3)
Cooperate in all rounds unless round 1 shows universal defection (cooperation_rate = 0), in which case defect thereafter.

### High k Values (k approaching n)
When k/n > 0.8, cooperation is nearly self-sustaining. Lower the cooperation threshold to k/(2n) to be more tolerant of partial cooperation.

### Unanimous Defection Observed
If cooperation_rate = 0 for any round after round 1, defect for the next round, then attempt one "olive branch" cooperation. If still zero cooperation, defect for remainder.

---

## Why This Strategy Works Collectively

1. **Self-coordination**: All copies start cooperating and respond identically to history, maintaining a unified cooperative bloc without explicit coordination.

2. **Generous but not exploitable**: The 2-round grace period and forgiveness mechanism allow recovery from noise or initial defection, but sustained exploitation triggers protective defection.

3. **Rewards cooperation**: By maintaining cooperation when others cooperate, we reinforce positive behavior and maximize collective payoffs.

4. **Clear equilibrium**: Against a population of ACR players, everyone cooperates every round, achieving the socially optimal outcome of π = k per round.

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    threshold = k / n
    
    if round == 1:
        return COOPERATE
    
    coop_rate = history.cooperation_rate(round - 1)
    
    if round == r:  # Final round
        avg_coop = history.average_cooperation_rate()
        return COOPERATE if (coop_rate >= 0.5 or avg_coop >= threshold) else DEFECT
    
    if coop_rate >= 0.5:
        return COOPERATE
    
    if coop_rate >= threshold:
        if history.is_trending_up():
            return COOPERATE
        return COOPERATE with probability min(1.0, coop_rate * 1.5)
    
    # Below threshold
    if history.defection_streak() <= 2:
        return COOPERATE
    
    if history.is_trending_up():
        return COOPERATE  # Forgiveness
    
    return DEFECT
```
'''

description_COLLECTIVE_81 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similarly-minded agents) may be present in the game. The goal is to establish recognizable cooperative patterns that like-minded agents can identify and join, while protecting against pure defectors and adapting to mixed populations.

## Strategy Overview: "Graduated Reciprocity with Collective Signaling"

The strategy operates on three principles:
1. **Signal cooperative intent** through early cooperation
2. **Mirror the collective** by matching the cooperation level of the group
3. **Protect the endgame** through conditional cooperation even in final rounds

---

## Decision Rules

### Round 1: Cooperative Signal
**Action: COOPERATE**

Rationale: Begin with cooperation to signal willingness to collaborate. This allows other cooperative agents to identify each other and establishes a baseline for measuring group behavior.

### Rounds 2 through (r-1): Graduated Reciprocity

Calculate the **cooperation ratio** from the previous round:
```
coop_ratio = (number of cooperators in previous round) / n
```

**Decision Rule:**
```
threshold = k / n  # The break-even point where cooperation becomes individually rational

If coop_ratio >= threshold:
    COOPERATE
Else if coop_ratio >= threshold / 2:
    COOPERATE with probability = coop_ratio / threshold
Else:
    DEFECT
```

**Explanation:**
- When cooperation is above the threshold (k/n), cooperation is sustainable and beneficial
- When cooperation is moderate, use probabilistic cooperation to maintain some cooperative presence while limiting losses
- When cooperation is very low, defect to avoid exploitation

### Adaptive Adjustment: Trend Detection

Track cooperation over a sliding window of the last 3 rounds (or fewer if early in game):

```
If cooperation_trend is INCREASING:
    Boost cooperation probability by 0.15
If cooperation_trend is DECREASING for 2+ consecutive rounds:
    Reduce cooperation probability by 0.15
```

This allows the strategy to respond to emerging cooperation or detect collapse early.

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory advice to defect in the final round:

```
If average_cooperation_rate across all previous rounds >= 0.5:
    COOPERATE
Else:
    DEFECT
```

**Rationale for collective mindset:** If multiple agents share this strategy, mutual defection in the final round destroys value. By conditioning on historical cooperation, we reward groups that have maintained cooperation while still protecting against exploitative populations.

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    threshold = k / n
    
    # Round 1: Always cooperate to signal
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation
    prev_coop_count = count_cooperators(history, round - 1)
    coop_ratio = prev_coop_count / n
    
    # Final round: conditional cooperation
    if round == r:
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: graduated reciprocity
    base_prob = 0
    
    if coop_ratio >= threshold:
        base_prob = 1.0
    elif coop_ratio >= threshold / 2:
        base_prob = coop_ratio / threshold
    else:
        base_prob = 0
    
    # Trend adjustment (if enough history)
    if round >= 4:
        trend = calculate_trend(history, window=3)
        if trend > 0:
            base_prob = min(1.0, base_prob + 0.15)
        elif trend < 0 and consecutive_decreases(history) >= 2:
            base_prob = max(0.0, base_prob - 0.15)
    
    # Execute probabilistic decision
    if random() < base_prob:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Strategy applies normally | Threshold becomes k/2; behaves like repeated prisoner's dilemma |
| r = 2 | Cooperate R1, apply final-round rule R2 | Minimal signaling, then conditional end |
| k very close to 1 | Lower cooperation expected | Threshold near 1/n makes cooperation fragile |
| k close to n | Higher cooperation expected | Threshold approaches 1; most cooperation levels are sustainable |
| All defect in R1 | Probabilistic R2 based on threshold | Don't immediately abandon; give one more chance |

---

## Why This Strategy is Collectively Optimal

1. **Identifiable pattern**: The initial cooperation and threshold-based response creates a recognizable "fingerprint" that similar strategies can lock onto
2. **Robust to defectors**: The graduated response prevents pure defectors from fully exploiting cooperators
3. **Rewards cooperation**: Groups with high cooperation maintain it through positive feedback
4. **Endgame protection**: Conditional final-round cooperation preserves value when playing with cooperative agents
'''

description_COLLECTIVE_80 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective-first mindset**: I assume other players may also be reasoning agents seeking mutual benefit, and I aim to establish and sustain cooperation while protecting against exploitation. The strategy uses **graduated reciprocity** - rewarding cooperation generously and responding to defection proportionally but forgivingly.

## Strategy Overview

The strategy operates on three principles:
1. **Optimistic initialization**: Start cooperatively to signal good faith
2. **Proportional reciprocity**: Mirror the group's cooperation level with a cooperative bias
3. **Endgame commitment**: Maintain cooperation even in final rounds to maximize collective welfare

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, cooperation signals willingness to collaborate. Since k > 1, if even a modest fraction of players cooperate, mutual cooperation becomes beneficial. Starting with C maximizes the chance of establishing a cooperative norm.

---

### Rounds 2 through (r-1): Adaptive Proportional Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of players who played C in round t-1) / n
```

**Decision Rule:**
```
IF coop_rate >= threshold THEN COOPERATE
ELSE DEFECT

where threshold = max(0.3, (n - k) / n)
```

**Explanation of threshold:**
- The term `(n - k) / n` represents the break-even point where cooperation becomes individually rational given others' cooperation
- The floor of 0.3 ensures we remain somewhat forgiving even when k is close to n
- This creates a **cooperative bias**: we cooperate if roughly a third or more of players cooperated

**Forgiveness Mechanism:**
After defecting, if the group showed *any improvement* in cooperation rate (even if still below threshold), give cooperation another chance:
```
IF I defected last round AND coop_rate(t-1) > coop_rate(t-2) THEN COOPERATE
```

This allows recovery from temporary breakdowns.

---

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory advice (which suggests defecting in the last round), this collective strategy:

```
IF average_cooperation_rate across all previous rounds >= 0.5 THEN COOPERATE
ELSE DEFECT
```

**Rationale:** 
- If the group has maintained reasonable cooperation, defecting destroys accumulated trust and reduces total welfare
- A collective mindset recognizes that mutual cooperation in the final round yields k > 1 per player, which is better than mutual defection
- Only defect if the game has already devolved into non-cooperation

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Cooperate unconditionally
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation metrics
    last_round_cooperators = count_cooperators(history, round - 1)
    coop_rate = last_round_cooperators / n
    threshold = max(0.3, (n - k) / n)
    
    # Final round logic
    if round == r:
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Proportional reciprocity with forgiveness
    if coop_rate >= threshold:
        return COOPERATE
    
    # Forgiveness: If I defected but cooperation is recovering, try again
    if round >= 3:
        my_last_action = get_my_action(history, round - 1)
        prev_coop_rate = count_cooperators(history, round - 2) / n
        if my_last_action == DEFECT and coop_rate > prev_coop_rate:
            return COOPERATE
    
    return DEFECT
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | C | Establish cooperative norm |
| Everyone defected last round | D | Protect against mass exploitation |
| Only I cooperated last round | D | Not sustainable alone; threshold not met |
| Cooperation recovering after breakdown | C | Forgiveness enables recovery |
| Final round after cooperative game | C | Honor the collective achievement |
| Final round after defection-heavy game | D | No trust to preserve |
| n=2 (minimum players) | Same rules apply | Threshold adapts appropriately |
| k close to n | Lower threshold | More forgiving since cooperation is more valuable |

---

## Why This Strategy is Collectively Aligned

1. **Assumes good faith initially** - Gives cooperation a chance to emerge
2. **Rewards cooperation** - Continues cooperating when others do
3. **Forgives mistakes** - Allows recovery rather than triggering permanent defection spirals
4. **Maintains endgame cooperation** - Doesn't betray a cooperative group for short-term gain
5. **Adaptive threshold** - Adjusts expectations based on game parameters (k and n)

This strategy aims to be the kind of player that, if everyone used it, would achieve near-optimal collective outcomes—while still being robust against exploitative opponents.
'''

description_COLLECTIVE_82 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be using similar reasoning, and I aim to establish and maintain cooperation while protecting against exploitation. The strategy balances:
1. **Optimism** - Start cooperatively to signal willingness to collaborate
2. **Reciprocity** - Reward cooperation, punish defection
3. **Forgiveness** - Allow recovery from mutual defection
4. **Proportionality** - Respond based on the *level* of cooperation observed, not just binary outcomes

---

## Strategy: Proportional Threshold Tit-for-Tat (PT-TFT)

### Decision Rule Overview

Cooperate if the observed cooperation rate in the previous round meets or exceeds a dynamic threshold; otherwise defect. The threshold adapts based on game parameters and history.

---

### Detailed Decision Rules

#### Round 1 (No History)
**Action: COOPERATE**

Rationale: Signal cooperative intent. In a collective of like-minded players, mutual first-round cooperation establishes a cooperative norm. The cost of being exploited once is worth the potential for sustained cooperation.

#### Rounds 2 through (r-1) (Middle Rounds)

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of players who played C in round t-1) / n
```

Calculate the **adaptive threshold**:
```
base_threshold = 0.5
adjustment = (k - 1) / (n - 1)  # Higher k relative to n → lower threshold
threshold = base_threshold - (0.2 × adjustment)
threshold = max(0.3, min(0.7, threshold))  # Clamp between 0.3 and 0.7
```

**Decision:**
```
IF coop_rate >= threshold THEN COOPERATE
ELSE DEFECT
```

**Forgiveness Mechanism:**
After 2 consecutive rounds of defection by self:
```
IF random() < 0.15 THEN COOPERATE  # Probe for cooperation recovery
```

This prevents lock-in to mutual defection spirals.

#### Final Round (Round r)

The final round has no future to incentivize cooperation, creating a temptation to defect. However, maintaining a collective mindset:

```
IF coop_rate in round (r-1) >= 0.6 THEN COOPERATE
ELSE DEFECT
```

Rationale: If cooperation has been sustained, maintain it to the end—this is what collective-minded players would do. If cooperation has already collapsed, defect.

---

### Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[round - 1])
    coop_rate = prev_cooperators / n
    
    # Calculate adaptive threshold
    adjustment = (k - 1) / (n - 1)
    threshold = 0.5 - (0.2 * adjustment)
    threshold = clamp(threshold, 0.3, 0.7)
    
    # Final round logic
    if round == r:
        if coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    if coop_rate >= threshold:
        return COOPERATE
    else:
        # Forgiveness probe after sustained defection
        if my_last_two_actions == [DEFECT, DEFECT]:
            if random() < 0.15:
                return COOPERATE
        return DEFECT
```

---

### Edge Cases Handled

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Cooperate | Establish cooperative norm |
| All others defected last round | Defect (with 15% forgiveness probe) | Protect against exploitation, but allow recovery |
| Exactly half cooperated | Depends on threshold (parameter-adjusted) | Adaptive to game structure |
| Final round after sustained cooperation | Cooperate | Honor collective commitment |
| Final round after collapse | Defect | No benefit to unilateral cooperation |
| n=2 (minimum players) | Standard TFT behavior emerges | Threshold ≈ 0.5, mirrors opponent |

---

### Why This Strategy is Collectively Robust

1. **Self-reinforcing among copies**: If all players use this strategy, Round 1 cooperation leads to sustained cooperation throughout (coop_rate = 1.0 always exceeds threshold).

2. **Resistant to exploitation**: Defectors trigger threshold failure, causing retaliation.

3. **Forgiving**: The 15% probe prevents permanent defection lock-in against potentially cooperative opponents.

4. **Parameter-aware**: Higher k (more efficient public good) lowers the cooperation threshold, appropriately encouraging cooperation when it's more valuable.
'''

description_COLLECTIVE_81 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I assume other players may be running similar reasoning processes, and I design my behavior to create good outcomes when playing alongside copies of myself while remaining robust against defectors. The key insight is that in a public goods game, **mutual cooperation is Pareto optimal** (everyone gets k > 1), while mutual defection is inefficient (everyone gets 1).

## Strategy Overview: **Adaptive Threshold Cooperation with Forgiveness**

The strategy cooperates when there's sufficient evidence that cooperation is sustainable, defects to protect against exploitation, but maintains hope for cooperation through periodic forgiveness.

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: With no history, I signal cooperative intent. If others share this collective mindset, we establish mutual cooperation from the start. The cost of being exploited once is bounded (I get k/n instead of 1), while the benefit of establishing cooperation is substantial over r rounds.

### Rounds 2 through (r-1): Adaptive Threshold Rule

**Calculate cooperation rate from previous round:**
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Calculate historical cooperation rate:**
```
hist_coop_rate = (total cooperations by others across all previous rounds) / ((t-1) × (n-1))
```

**Decision Rule:**
```
threshold = max(0.3, (k/n) - 0.1)  # Minimum viable cooperation level

IF prev_coop_rate >= threshold:
    COOPERATE
ELSE IF hist_coop_rate >= threshold AND this is a "forgiveness round":
    COOPERATE  
ELSE:
    DEFECT
```

**Forgiveness Mechanism:**
```
forgiveness_round = (current_round % forgiveness_interval == 0)
forgiveness_interval = max(2, floor(r / 5))  # Roughly 5 forgiveness opportunities per game
```

### Final Round (Round r): Conditional Cooperation

Unlike standard backward induction reasoning, I maintain cooperation potential:

```
IF hist_coop_rate >= 0.5:
    COOPERATE  # Reward historically cooperative groups
ELSE:
    DEFECT     # Don't be exploited by consistent defectors
```

Rationale: If I'm playing with other collective-minded agents, we should all cooperate in the final round. Defecting "because it's the last round" is individual rationality that undermines collective welfare.

---

## Detailed Pseudocode

```
function decide(round, history, n, k, r):
    
    threshold = max(0.3, (k/n) - 0.1)
    forgiveness_interval = max(2, floor(r / 5))
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate metrics
    prev_round_cooperators = count_cooperators(history, round - 1)
    prev_coop_rate = prev_round_cooperators / n
    
    total_other_coops = count_all_other_cooperations(history, my_id)
    hist_coop_rate = total_other_coops / ((round - 1) * (n - 1))
    
    # Check if this is a forgiveness round
    is_forgiveness_round = (round % forgiveness_interval == 0)
    
    # Final round logic
    if round == r:
        if hist_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Main decision logic for rounds 2 to r-1
    if prev_coop_rate >= threshold:
        return COOPERATE
    else if hist_coop_rate >= threshold AND is_forgiveness_round:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | COOPERATE | Signal cooperative intent |
| All others defected last round | DEFECT (unless forgiveness round) | Protect against exploitation |
| Exactly at threshold | COOPERATE | Err toward cooperation |
| r = 2 (minimal game) | C then conditional | Still attempt cooperation |
| n = 2 (minimal players) | Same rules apply | Threshold adapts via k/n |
| k very close to n | Lower threshold (more forgiving) | Cooperation more valuable |
| k very close to 1 | Higher threshold | Cooperation barely beneficial |

---

## Why This Strategy is Collectively Aligned

1. **Self-reinforcing with copies**: If all players use this strategy, everyone cooperates every round, achieving the Pareto optimal outcome of k per round.

2. **Robust to defectors**: The threshold mechanism withdraws cooperation when too many defect, limiting exploitation.

3. **Forgiveness enables recovery**: Even after mutual defection, the strategy periodically tests for renewed cooperation.

4. **No exploitation of cooperators**: The strategy never free-rides when others are cooperating above threshold.

5. **Rewards good behavior in endgame**: Final-round cooperation rewards groups that maintained cooperation throughout.
'''

description_COLLECTIVE_83 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all players using this strategy share the same decision algorithm and will therefore make identical choices given identical information. This creates implicit coordination without explicit communication. The strategy aims to maximize collective welfare while protecting against exploitation by defectors.

## Strategy Overview: "Adaptive Collective Threshold"

The strategy operates on three key principles:
1. **Start cooperatively** to establish mutual benefit
2. **Mirror the collective behavior** observed in previous rounds
3. **Protect the endgame** through graduated caution

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, we signal cooperative intent. If all collective players cooperate, we achieve the socially optimal outcome. This also provides baseline information about opponent behavior.

### Middle Rounds (2 to r-2): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

Calculate the **critical threshold** for cooperation to be collectively beneficial:
```
threshold = 1/k
```

**Decision Rule:**
```
IF coop_rate ≥ threshold THEN COOPERATE
ELSE DEFECT
```

**Intuition:** When `coop_rate ≥ 1/k`, the marginal return from cooperation `(k × coop_rate)` exceeds 1, meaning cooperation was collectively rewarded. We continue cooperating. When too few cooperate, we protect ourselves by defecting.

### Penultimate Round (r-1): Cautious Threshold

Use a **stricter threshold**:
```
IF coop_rate ≥ max(threshold, 0.5) THEN COOPERATE
ELSE DEFECT
```

Rationale: As endgame approaches, defection incentives increase. We require stronger evidence of collective cooperation before contributing.

### Final Round (r): Conditional Cooperation Based on History

Calculate **average cooperation rate** across all previous rounds:
```
avg_coop_rate = (total cooperations across all rounds) / (n × (r-1))
```

**Decision Rule:**
```
IF avg_coop_rate ≥ 0.6 THEN COOPERATE
ELSE DEFECT
```

Rationale: Unlike standard backward induction (always defect in final round), we reward sustained collective cooperation. If the group has demonstrated commitment, we maintain solidarity. This also makes earlier cooperation more sustainable by not guaranteeing final-round defection.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    threshold = 1/k
    
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history, round - 1)
    coop_rate = prev_cooperators / n
    
    if round < r - 1:  # Middle rounds
        if coop_rate >= threshold:
            return COOPERATE
        else:
            return DEFECT
    
    elif round == r - 1:  # Penultimate round
        cautious_threshold = max(threshold, 0.5)
        if coop_rate >= cautious_threshold:
            return COOPERATE
        else:
            return DEFECT
    
    else:  # Final round
        avg_coop_rate = total_cooperations(history) / (n * (r - 1))
        if avg_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
```

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| n = 2 | Strategy applies normally | Threshold = 1/k still valid |
| r = 2 | Round 1: Cooperate; Round 2: Use final-round rule on single observation | Minimal but consistent |
| k very close to 1 | Threshold ≈ 1, requiring near-universal cooperation | Appropriately cautious given low returns |
| k close to n | Threshold is low, cooperation maintained easily | Reflects high collective returns |
| All previous defection | Defect (coop_rate = 0 < threshold) | Self-protection against hostile environment |
| All previous cooperation | Cooperate | Reward and maintain collective success |

---

## Why This Strategy is Collectively Robust

1. **Self-consistency**: If all players use this strategy, they make identical decisions, achieving coordination without communication.

2. **Mathematically grounded**: The threshold `1/k` is exactly where cooperation becomes collectively beneficial.

3. **Forgiving but not exploitable**: One bad round doesn't permanently trigger defection, but sustained defection is met with defection.

4. **Endgame awareness**: Graduated caution prevents predictable final-round exploitation while rewarding historical cooperation.

5. **Parameter-adaptive**: Works across all valid (n, k, r) configurations without manual tuning.
'''

description_COLLECTIVE_82 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **we succeed together or fail together**. Rather than optimizing individual payoffs against "opponents," I design for a world where multiple instances of thoughtful, cooperative strategies might meet. The strategy balances optimism about collective action with realistic adaptation to defection.

## Strategy Name: **Graduated Collective Reciprocity (GCR)**

---

## Decision Framework

### Key Metrics

1. **Cooperation Rate (CR)**: Fraction of other players who cooperated in the previous round
2. **Trend**: Is cooperation increasing, stable, or declining over recent rounds?
3. **Round Position**: Early, middle, or late game (as fraction of total rounds)

### Core Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Begin with a clear signal of cooperative intent. This establishes trust and gives the collective the best chance to coordinate on mutual cooperation.

#### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the cooperation rate from the previous round:
```
CR = (number of cooperators in previous round) / n
```

**Decision Logic:**

```
IF CR >= 0.5:
    COOPERATE
    (Majority cooperated - reinforce and sustain collective action)

ELSE IF CR >= k/n:
    COOPERATE with probability = CR + 0.1
    (Cooperation is borderline viable - give it a chance to recover)

ELSE IF CR > 0 AND trend is improving:
    COOPERATE with probability = 2 × CR
    (Some cooperation exists and growing - nurture it)

ELSE:
    DEFECT
    (Cooperation has collapsed - protect against exploitation)
```

**Trend Calculation (for rounds 3+):**
```
trend = CR(current) - CR(two rounds ago)
improving = trend > 0
```

#### Final Round (Round r): Conditional Cooperation

**Decision Logic:**
```
IF CR(previous round) >= 0.6:
    COOPERATE
    (Honor the cooperative relationship we've built)

ELSE:
    DEFECT
    (No established cooperation to maintain)
```

Rationale: Unlike pure game theory which prescribes universal defection in the final round, this strategy rewards sustained cooperation. If we've built something together, we finish together.

---

## Edge Cases

### Very Short Games (r ≤ 3)
- Round 1: Always cooperate
- Round 2+: Use standard rules but weight toward cooperation (add +0.15 to cooperation probability)
- Rationale: Limited rounds mean less time to recover from defection spirals

### Very Small Groups (n = 2)
- This becomes similar to iterated Prisoner's Dilemma
- Apply same rules, but the CR is simply 0 or 1
- If opponent cooperated: Cooperate
- If opponent defected: Defect (but cooperate with 20% probability to allow recovery)

### Large Groups (n ≥ 10)
- Individual defection is less noticeable
- Lower the threshold: cooperate if CR >= 0.4 (instead of 0.5)
- Rationale: In large groups, expecting perfect cooperation is unrealistic

### Near-Critical k Values
When k is close to n (public good is very efficient):
- Be more forgiving: cooperate if CR >= 0.3
- Rationale: The collective benefit of cooperation is high enough to tolerate some free-riders

When k is close to 1 (public good is barely viable):
- Be stricter: cooperate only if CR >= 0.6
- Rationale: Free-riding is more damaging when the multiplication factor is low

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Round 1: Unconditional cooperation
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation rate from previous round
    prev_cooperators = count_cooperators(history[round-1])
    CR = prev_cooperators / n
    
    # Calculate trend (if enough history)
    if round >= 3:
        CR_old = count_cooperators(history[round-2]) / n
        trend = CR - CR_old
    else:
        trend = 0
    
    # Adjust threshold based on group size and k
    base_threshold = 0.5
    if n >= 10:
        base_threshold = 0.4
    if k > (n + 1) / 2:
        base_threshold -= 0.1
    if k < n / 2:
        base_threshold += 0.1
    
    # Final round logic
    if round == r:
        if CR >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Main decision logic
    if CR >= base_threshold:
        return COOPERATE
    
    elif CR >= k/n:
        prob = CR + 0.1
        return COOPERATE with probability prob
    
    elif CR > 0 and trend > 0:
        prob = min(2 * CR, 0.5)
        return COOPERATE with probability prob
    
    else:
        return DEFECT
```

---

## Why This Strategy Embodies Collective Thinking

1. **Optimistic Start**: We assume the best and give cooperation a chance
2. **Majority Rule**: When most cooperate, we join them unconditionally
3. **Forgiveness**: We give declining cooperation a chance to recover
4. **Graduated Response**: We don't flip instantly between cooperation and defection
5. **Collective Memory**: Trends matter—we respond to direction, not just current state
6. **Dignified Ending**: We honor sustained cooperation even in the final round

This strategy is designed to **find and sustain cooperation** when it's possible, while protecting against persistent exploitation. It aims to be a good collective citizen that makes cooperation easier for everyone.
'''

description_COLLECTIVE_84 = '''
# Collective Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy operates from a collective mindset: we assume all players using this strategy will behave identically given the same history, creating implicit coordination without explicit communication. The strategy aims to establish and maintain cooperation when viable, while protecting against exploitation.

## Key Insight

Since all copies of this strategy observe the same history and use the same decision rules, they will make identical choices each round. This means we can think in terms of "what should our collective do?" rather than individual optimization.

## Decision Rules

### Round 1: Conditional Cooperation Start

**Cooperate** in round 1.

*Rationale:* We signal cooperative intent. If all n players use this strategy, we immediately achieve full cooperation. This is the best collective outcome.

### Rounds 2 through (r-1): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

Calculate the **threshold** based on game parameters:
```
base_threshold = k / n  (the per-capita return on cooperation)
adaptive_threshold = max(0.5, base_threshold)
```

**Decision Rule:**
- If `coop_rate >= adaptive_threshold`: **Cooperate**
- If `coop_rate < adaptive_threshold`: **Defect**

**Forgiveness Mechanism:**
After defecting due to low cooperation, if the *cumulative average* cooperation rate across all previous rounds exceeds `adaptive_threshold`, return to **Cooperate**.

```
cumulative_coop_rate = (total cooperations across all rounds) / (n × rounds_played)
if cumulative_coop_rate >= adaptive_threshold: Cooperate
```

### Final Round (Round r): Conditional Cooperation

Unlike classic game theory which suggests always defecting in the final round, we apply the **same rule** as middle rounds.

*Rationale:* 
1. All copies of our strategy will do the same thing
2. If cooperation has been sustained, collective defection destroys value
3. We cannot "get ahead" of other copies of ourselves

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | Cooperate | Establish cooperative norm |
| Only 2 rounds total | Cooperate in both if round 1 had any cooperation | Insufficient time for complex adaptation |
| n = 2 | Use standard rules, threshold = max(0.5, k/2) | Works like iterated prisoner's dilemma |
| k very close to 1 | Threshold approaches 1/n, more forgiving | Cooperation barely beats defection, need high participation |
| k very close to n | Threshold approaches 1, stricter | High returns justify demanding high participation |
| All others defected | Defect until forgiveness triggers | Don't be exploited indefinitely |
| Erratic opponent behavior | Cumulative average smooths noise | Prevents overreaction to single-round anomalies |

## Pseudocode

```
function decide(round, history, n, k, r):
    threshold = max(0.5, k/n)
    
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_rate = count_cooperators(history, round-1) / n
    
    # Calculate cumulative cooperation rate
    total_coops = sum(count_cooperators(history, t) for t in 1..round-1)
    cumulative_rate = total_coops / (n * (round - 1))
    
    # Primary decision: based on previous round
    if prev_coop_rate >= threshold:
        return COOPERATE
    
    # Forgiveness: based on cumulative history
    if cumulative_rate >= threshold:
        return COOPERATE
    
    return DEFECT
```

## Why This Strategy is Collectively Optimal

1. **Self-coordination:** All copies choose identically, so we either all cooperate or all defect—never getting exploited by ourselves.

2. **Robust to defectors:** If non-cooperative strategies dominate the population, we detect this quickly and protect ourselves.

3. **Rewards cooperation:** When the environment supports cooperation (enough players cooperating), we participate and share the gains.

4. **Parameter-adaptive:** The threshold scales with k/n, becoming stricter when cooperation is more valuable and more forgiving when margins are thin.

5. **Forgiveness prevents death spirals:** The cumulative rate check allows recovery from temporary breakdowns in cooperation.
'''

description_COLLECTIVE_83 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embodies a **collective mindset**: I assume other players may be instances of the same strategic reasoning, and I optimize for the group outcome while protecting against exploitation. The key insight is that in repeated games, establishing and maintaining cooperation creates more total value than defection, but this requires both **signaling cooperative intent** and **credible punishment** for defectors.

## Strategy: Adaptive Threshold Cooperation with Graduated Response

### Key Mechanisms

1. **Cooperation Threshold**: Track the cooperation rate in the population and cooperate when it exceeds a dynamic threshold
2. **Forgiveness Cycle**: Periodically test if defectors will return to cooperation
3. **End-Game Adjustment**: Maintain cooperation incentives even as the game concludes

---

### Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. With no history, cooperation establishes a baseline and invites reciprocity from like-minded players.

---

#### Rounds 2 through (r-2): Adaptive Cooperation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays in round t-1) / n
```

Calculate the **personal threshold** based on game parameters:
```
base_threshold = (n - k) / (n - 1)
```
This threshold represents the break-even point where cooperation becomes individually rational given others' behavior.

**Decision Rule:**
```
IF coop_rate >= base_threshold:
    COOPERATE
ELSE IF (current_round mod forgiveness_interval) == 0:
    COOPERATE  // Forgiveness probe
ELSE:
    DEFECT
```

Where `forgiveness_interval = max(3, floor(r/5))`

**Additional Cooperation Boost (Collective Alignment):**
```
IF coop_rate >= 0.5 AND coop_rate < base_threshold:
    IF trending_up(last 2 rounds):
        COOPERATE  // Support emerging cooperation
```

---

#### Round (r-1): Penultimate Round
**Apply standard adaptive rules** but with a lower threshold:
```
adjusted_threshold = base_threshold * 0.8
```
Rationale: Slightly more forgiving to sustain cooperation into the final round.

---

#### Round r: Final Round

**Decision Rule:**
```
IF average_cooperation_rate(all rounds) >= 0.6:
    COOPERATE  // Reward sustained collective behavior
ELSE:
    DEFECT  // No future to protect
```

Rationale: Unlike standard backward induction (always defect in final round), this rewards populations that maintained cooperation throughout the game.

---

### Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    coop_rate = count_cooperators(history[round-1]) / n
    base_threshold = (n - k) / (n - 1)
    forgiveness_interval = max(3, floor(r / 5))
    
    # Final round logic
    if round == r:
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Penultimate round
    if round == r - 1:
        threshold = base_threshold * 0.8
    else:
        threshold = base_threshold
    
    # Main decision
    if coop_rate >= threshold:
        return COOPERATE
    
    # Forgiveness probe
    if round mod forgiveness_interval == 0:
        return COOPERATE
    
    # Trend detection for near-threshold situations
    if coop_rate >= 0.5 and round >= 3:
        prev_rate = count_cooperators(history[round-2]) / n
        if coop_rate > prev_rate:  # Trending up
            return COOPERATE
    
    return DEFECT
```

---

### Why This Strategy Works Collectively

1. **Signals cooperative intent** from round 1 — identical strategies will lock into mutual cooperation
2. **Threshold-based** — only cooperates when enough others do, preventing full exploitation
3. **Forgiving** — periodic cooperation probes allow recovery from defection spirals
4. **Trend-sensitive** — supports emerging cooperation even below threshold
5. **End-game aware** — maintains cooperation incentives through the final round for cooperative populations
6. **Parameter-adaptive** — the threshold adjusts to different n and k values automatically

This strategy maximizes collective welfare when playing with like-minded agents while remaining robust against purely selfish opponents.
'''

description_COLLECTIVE_85 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume all players using this strategy share the same goal of maximizing group welfare while protecting against exploitation. The strategy aims to establish and maintain cooperation through clear, interpretable signals while being robust to defectors.

## Strategy Overview: "Graduated Collective Reciprocity"

The strategy operates on three principles:
1. **Start cooperatively** to signal good intentions and enable coordination
2. **Mirror the collective** by responding to the overall cooperation level
3. **Protect the endgame** with conditional cooperation that rewards cooperative histories

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: Cooperate (C)**

Rationale: With no history to evaluate, cooperation signals willingness to coordinate and gives the group the best chance to establish mutual cooperation.

---

### Rounds 2 through (r-1): Adaptive Threshold Cooperation

**Calculate the cooperation rate from the previous round:**
```
prev_coop_rate = (number of C plays in round t-1) / n
```

**Decision Rule:**
```
IF prev_coop_rate ≥ threshold THEN Cooperate
ELSE Defect
```

**Dynamic Threshold Calculation:**
```
base_threshold = 0.5
history_bonus = (cumulative_cooperation_rate - 0.5) × 0.2
threshold = max(0.3, min(0.7, base_threshold - history_bonus))
```

Where `cumulative_cooperation_rate` is the average cooperation rate across all previous rounds.

**Interpretation:**
- If the group has been highly cooperative overall, lower the threshold (be more forgiving)
- If the group has been mostly defecting, raise the threshold (be more demanding)
- Threshold is bounded between 0.3 and 0.7 to avoid extremes

---

### Final Round (r): History-Weighted Decision

The last round has no future to incentivize cooperation, so we use accumulated trust:

```
cumulative_coop_rate = (total C plays across all players, all rounds) / (n × (r-1))

IF cumulative_coop_rate ≥ 0.6 THEN Cooperate
ELSE Defect
```

**Rationale:** If the group has demonstrated sustained cooperation (60%+ over the game), reciprocate with final-round cooperation as a reward. Otherwise, defect to avoid exploitation.

---

## Complete Pseudocode

```
function decide(round, history, n, r, k):
    
    # Round 1: Cooperate unconditionally
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation statistics
    prev_round_coops = count_cooperators(history, round - 1)
    prev_coop_rate = prev_round_coops / n
    
    total_coops = sum(count_cooperators(history, t) for t in 1 to round-1)
    total_decisions = n * (round - 1)
    cumulative_coop_rate = total_coops / total_decisions
    
    # Final round: reward sustained cooperation
    if round == r:
        if cumulative_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: adaptive threshold
    base_threshold = 0.5
    history_bonus = (cumulative_coop_rate - 0.5) * 0.2
    threshold = clamp(base_threshold - history_bonus, 0.3, 0.7)
    
    if prev_coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Scenario | Handling |
|----------|----------|
| **r = 2** (minimum rounds) | Round 1: Cooperate. Round 2: Use final-round rule based on round 1 results |
| **n = 2** (minimum players) | Strategy works identically; becomes similar to Tit-for-Tat |
| **All defect in round 1** | Threshold in round 2 starts at base (0.5), so defect continues unless majority cooperates |
| **k very close to 1** | Strategy unchanged; lower k makes cooperation harder to sustain but signals remain valid |
| **k very close to n** | Cooperation is highly valuable; strategy naturally supports it |

---

## Why This Strategy is Collectively Robust

1. **Self-coordination**: Multiple instances of this strategy will converge to mutual cooperation since they all start with C and maintain it when others do
2. **Exploitation resistance**: Responds to defection by defecting, preventing free-riders from profiting indefinitely
3. **Forgiveness**: The adaptive threshold allows recovery if defectors return to cooperation
4. **Simplicity**: Clear, interpretable rules that other cooperative strategies can recognize and match
'''

description_COLLECTIVE_84 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similar cooperative AI systems) may be present in the game. The goal is to maximize collective welfare while protecting against exploitation by purely selfish strategies. The strategy uses observable patterns to identify likely cooperators and coordinate with them, while gradually withdrawing cooperation from persistent defectors.

## Strategy Overview: "Adaptive Collective Reciprocity" (ACR)

The strategy operates on three principles:
1. **Start cooperative** to signal good faith and enable coordination
2. **Track and respond to group cooperation levels** rather than individual actions
3. **Maintain conditional cooperation** based on whether cooperation is being reciprocated at a sustainable level

---

## Decision Rules

### Key Variables to Track

```
cooperation_rate(t) = (number of C plays in round t) / n
cumulative_coop_rate = (total C plays across all rounds) / (n × rounds_played)
my_cooperation_history = list of my past actions
rounds_remaining = r - current_round
```

### Threshold Parameters (derived from game parameters)

```
viability_threshold = (n - k) / (n - 1)
# This is the minimum cooperation rate needed for cooperation to be individually rational
# When coop_rate > viability_threshold, expected payoff from C exceeds D

target_threshold = max(0.5, viability_threshold)
# Aim for at least 50% cooperation or the viability threshold, whichever is higher

forgiveness_rounds = max(2, floor(r / 10))
# How many rounds to wait before reconsidering after defection
```

---

## Round-by-Round Decision Logic

### Round 1 (First Round)
**Decision: COOPERATE**

Rationale: No history exists. Cooperating signals willingness to coordinate and allows identification of other cooperators. The cost of one round of potential exploitation is worth the information gained and coordination potential.

---

### Rounds 2 through (r-1) (Middle Rounds)

```
function decide_middle_round(history, current_round):
    
    recent_coop_rate = cooperation_rate(current_round - 1)
    avg_coop_rate = cumulative_coop_rate
    
    # Calculate trend: is cooperation increasing or decreasing?
    if current_round >= 3:
        trend = cooperation_rate(current_round - 1) - cooperation_rate(current_round - 2)
    else:
        trend = 0
    
    # PRIMARY RULE: Respond to group cooperation level
    if recent_coop_rate >= target_threshold:
        # Healthy cooperation level - continue cooperating
        return COOPERATE
    
    elif recent_coop_rate >= viability_threshold:
        # Marginal cooperation - cooperate to encourage growth
        # But with probability based on how close we are to target
        cooperation_probability = recent_coop_rate / target_threshold
        if trend > 0:
            # Cooperation is increasing - boost probability
            cooperation_probability = min(1.0, cooperation_probability + 0.2)
        return COOPERATE with probability cooperation_probability
    
    elif recent_coop_rate > 0:
        # Low but non-zero cooperation
        # Check if there's a recovery trend
        if trend > 0 and avg_coop_rate >= viability_threshold:
            # Signs of recovery - give it a chance
            return COOPERATE with probability 0.5
        else:
            # Protect against exploitation but leave door open
            return COOPERATE with probability recent_coop_rate
    
    else:
        # Zero cooperation from others
        # Defect but periodically test for recovery
        if current_round % forgiveness_rounds == 0:
            return COOPERATE  # Periodic olive branch
        else:
            return DEFECT
```

---

### Round r (Final Round)

```
function decide_final_round(history):
    
    avg_coop_rate = cumulative_coop_rate
    recent_coop_rate = cooperation_rate(r - 1)
    
    # In the final round, backward induction suggests defection
    # However, with collective mindset, we consider:
    
    if avg_coop_rate >= target_threshold:
        # Strong cooperation throughout - maintain solidarity
        # Other cooperative strategies likely to also cooperate
        return COOPERATE
    
    elif recent_coop_rate >= 0.5 and avg_coop_rate >= viability_threshold:
        # Moderate cooperation - probabilistic based on history
        return COOPERATE with probability avg_coop_rate
    
    else:
        # Poor cooperation history - defect
        return DEFECT
```

---

## Edge Cases

### Very Short Games (r ≤ 3)
- Round 1: Always COOPERATE
- Round 2: COOPERATE if round 1 had any other cooperators, else DEFECT
- Round 3 (if exists): Apply final round logic

### Very Large n (n > 20)
- Individual actions have less impact on group rate
- Increase `forgiveness_rounds` to `max(3, floor(r / 8))`
- Be slightly more tolerant of low cooperation (noise is higher)

### k Very Close to 1 or Very Close to n
- When k ≈ 1: Cooperation barely beneficial; be more conservative, require higher cooperation rates
- When k ≈ n: Cooperation highly beneficial; be more forgiving, lower thresholds by 10%

---

## Summary Pseudocode

```
function ACR_strategy(game_params, history, current_round):
    n, r, k = game_params
    
    # Calculate thresholds
    viability = (n - k) / (n - 1)
    target = max(0.5, viability)
    forgive_interval = max(2, floor(r / 10))
    
    if current_round == 1:
        return COOPERATE
    
    recent_rate = count_cooperators(history, current_round - 1) / n
    avg_rate = total_cooperations(history) / (n * (current_round - 1))
    
    if current_round == r:  # Final round
        if avg_rate >= target:
            return COOPERATE
        elif recent_rate >= 0.5 and avg_rate >= viability:
            return COOPERATE with probability avg_rate
        else:
            return DEFECT
    
    # Middle rounds
    if recent_rate >= target:
        return COOPERATE
    elif recent_rate >= viability:
        return COOPERATE with probability (recent_rate / target + trend_bonus)
    elif recent_rate > 0:
        return COOPERATE with probability recent_rate
    else:
        if current_round % forgive_interval == 0:
            return COOPERATE
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Coordination-friendly**: Cooperative start and threshold-based response allows similar strategies to find each other and sustain cooperation.

2. **Exploitation-resistant**: Probabilistic defection against low cooperation rates limits losses against selfish strategies.

3. **Self-reinforcing**: When multiple copies play together, they maintain high cooperation rates and achieve near-optimal collective payoffs.

4. **Forgiving**: Periodic cooperation attempts allow recovery from temporary breakdowns or miscoordination.

5. **Parameter-adaptive**: Thresholds adjust to game parameters, ensuring sensible behavior across different configurations.
'''

description_COLLECTIVE_86 = '''
# Collective Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy embraces a genuinely collective mindset: we aim to maximize group welfare while protecting against exploitation. The key insight is that cooperation is only sustainable when a critical mass participates. Rather than reactive punishment, we focus on **conditional cooperation based on observed cooperation levels**, signaling willingness to cooperate while adapting to the actual behavior of the group.

---

## Decision Rules

### Primary Rule: Threshold-Based Cooperation

Cooperate if and only if the observed cooperation rate in the previous round meets or exceeds a dynamic threshold.

**Cooperation Condition:**
```
cooperate IF (cooperators_last_round / n) ≥ threshold
```

### Threshold Calculation

The threshold adapts based on game parameters and history:

```
base_threshold = (n - k) / (n - 1)
```

This represents the minimum cooperation rate at which cooperating becomes collectively rational (where the group benefit of one more cooperator exceeds the private cost).

**Adaptive Adjustment:**
```
adjusted_threshold = base_threshold × decay_factor

where:
  decay_factor = 0.8 + 0.2 × (rounds_remaining / total_rounds)
```

This makes us slightly more forgiving as the game progresses (lowering the bar for cooperation), while being more cautious early on when establishing norms.

---

## Edge Case Handling

### First Round
**Always Cooperate.**

Rationale: Signal cooperative intent, give the group a chance to establish mutual cooperation, and avoid the trap of preemptive defection. This is the collectively optimal opening.

### Last Round (Round r)
**Cooperate if the cooperation rate in round r-1 was ≥ 50%.**

Rationale: Unlike pure game theory which suggests defecting in the final round, we maintain cooperation if there's evidence of a cooperative group. This reflects genuine collective commitment rather than end-game exploitation.

### Low Cooperation Recovery
If cooperation collapses (rate < 25% for 2+ consecutive rounds):
```
Attempt recovery by cooperating with probability = k/n
```

This injects occasional cooperation attempts to test if the group can restart cooperation, with probability calibrated to the game's cooperation incentive.

### High Cooperation Maintenance
If cooperation rate ≥ 80% for 3+ consecutive rounds:
```
Always cooperate (ignore threshold temporarily)
```

This avoids accidentally breaking a well-functioning cooperative equilibrium due to threshold mechanics.

---

## Complete Strategy Pseudocode

```
function decide(round, history, n, k, r):
    
    # First round: unconditional cooperation
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation rate from last round
    coop_rate = history[round-1].cooperators / n
    
    # Calculate adaptive threshold
    base_threshold = (n - k) / (n - 1)
    rounds_remaining = r - round
    decay_factor = 0.8 + 0.2 × (rounds_remaining / r)
    threshold = base_threshold × decay_factor
    
    # High cooperation maintenance
    if recent_streak(history, rounds=3, min_rate=0.8):
        return COOPERATE
    
    # Low cooperation recovery attempt
    if recent_streak(history, rounds=2, max_rate=0.25):
        if random() < (k / n):
            return COOPERATE
        else:
            return DEFECT
    
    # Last round special handling
    if round == r:
        if coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Standard threshold decision
    if coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Signals cooperative intent** without being exploitable (first-round cooperation + threshold protection)

2. **Scales with parameters** - the threshold formula ensures appropriate behavior across different n and k values

3. **Rewards group cooperation** - when others cooperate, we cooperate back, reinforcing positive dynamics

4. **Forgives and recovers** - the recovery mechanism prevents permanent collapse from temporary defection

5. **Maintains end-game integrity** - refusing to defect in the final round when cooperation has been established demonstrates trustworthiness

6. **Collectively coherent** - if all players use this strategy, cooperation emerges and sustains naturally
'''

description_COLLECTIVE_85 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that mutual cooperation produces the best collective outcome, and I aim to foster and sustain cooperation while protecting against exploitation. The strategy is designed to be **forgiving, reciprocal, and adaptive** - rewarding cooperation, punishing defection proportionally, and always leaving room for redemption.

## Strategy Overview: "Adaptive Collective Reciprocity" (ACR)

The strategy tracks the **cooperation rate** of the group and adjusts behavior based on both the current cooperation climate and the game's temporal position (early, middle, late rounds).

---

## Decision Rules

### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- Rationale: Signal cooperative intent and establish a foundation for mutual benefit. We cannot build trust without extending it first.

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **group cooperation rate** from the previous round:
```
prev_coop_rate = (number of C plays in round t-1) / n
```

Calculate the **cumulative cooperation rate** across all previous rounds:
```
cumulative_coop_rate = (total C plays across all rounds) / (n × rounds_played)
```

**Decision Logic:**

```
IF prev_coop_rate >= (n-1)/n:
    # Near-universal cooperation: maintain it
    ACTION = COOPERATE

ELIF prev_coop_rate >= 0.5:
    # Majority cooperating: cooperate to reinforce the norm
    ACTION = COOPERATE

ELIF prev_coop_rate >= 1/n AND cumulative_coop_rate >= 0.4:
    # Some cooperation exists and history is decent: give benefit of doubt
    ACTION = COOPERATE

ELIF prev_coop_rate < 1/n AND cumulative_coop_rate < 0.3:
    # Cooperation has collapsed: defect to protect self
    ACTION = DEFECT

ELSE:
    # Marginal case: use probabilistic cooperation
    # Cooperate with probability equal to cumulative_coop_rate
    ACTION = COOPERATE with probability = cumulative_coop_rate
```

**Forgiveness Mechanism:**
- If I defected in the previous round but `prev_coop_rate` increased, **cooperate** to reward the group's positive movement.
- Every `floor(r/4)` rounds, if `cumulative_coop_rate > 0.2`, unconditionally **cooperate** as a "olive branch" to restart cooperation cycles.

### Final Round (Round r): Conditional Cooperation

Unlike typical game theory advice to defect in the final round:

```
IF cumulative_coop_rate >= 0.6:
    # Strong cooperative history: honor it to the end
    ACTION = COOPERATE
    
ELIF cumulative_coop_rate >= 0.4 AND prev_coop_rate >= 0.5:
    # Decent history with recent cooperation: cooperate
    ACTION = COOPERATE
    
ELSE:
    # Cooperation has been weak: defect
    ACTION = DEFECT
```

Rationale: A collective strategy commits to the group even when individual incentives diverge. Defecting in the final round after sustained cooperation would betray the collective spirit.

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, k, history):
    if round_num == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history, round_num - 1) / n
    cumulative_coop_rate = total_cooperations(history) / (n * (round_num - 1))
    my_last_action = get_my_action(history, round_num - 1)
    
    # Forgiveness: if I defected but group cooperation improved, cooperate
    if my_last_action == DEFECT and round_num > 2:
        prev_prev_rate = count_cooperators(history, round_num - 2) / n
        if prev_coop_rate > prev_prev_rate:
            return COOPERATE
    
    # Periodic olive branch
    if round_num % max(1, floor(total_rounds / 4)) == 0 and cumulative_coop_rate > 0.2:
        return COOPERATE
    
    # Final round logic
    if round_num == total_rounds:
        if cumulative_coop_rate >= 0.6:
            return COOPERATE
        elif cumulative_coop_rate >= 0.4 and prev_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Main adaptive logic
    if prev_coop_rate >= (n-1)/n:
        return COOPERATE
    elif prev_coop_rate >= 0.5:
        return COOPERATE
    elif prev_coop_rate >= 1/n and cumulative_coop_rate >= 0.4:
        return COOPERATE
    elif prev_coop_rate < 1/n and cumulative_coop_rate < 0.3:
        return DEFECT
    else:
        return COOPERATE if random() < cumulative_coop_rate else DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Starts cooperative**: Establishes good faith
2. **Rewards cooperation**: Continues cooperating when others do
3. **Forgives defection**: Doesn't permanently punish; allows recovery
4. **Protects against exploitation**: Withdraws cooperation only when defection is widespread and persistent
5. **Honors commitments**: Cooperates in final rounds if cooperation was sustained
6. **Adapts to group size**: Thresholds are relative (rates, not counts)

This strategy aims to be the kind of player that, if everyone adopted it, would produce excellent collective outcomes—while still being robust against less cooperative opponents.
'''

description_COLLECTIVE_87 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embodies a **collective mindset**: I cooperate not because I expect direct reciprocity, but because cooperation creates the best outcome for the group. However, I'm not naive—I adapt to the actual behavior of others while maintaining a bias toward cooperation that can help establish and sustain collective benefit.

## Strategy: "Generous Collective Threshold" (GCT)

### Key Insight

In public goods games, the tragedy of the commons emerges when individuals optimize selfishly. A collective strategy should:
1. Signal willingness to cooperate early
2. Reward group-level cooperation, not just individual reciprocity
3. Maintain cooperation potential even after defection
4. Recognize endgame dynamics without immediately abandoning cooperation

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: As a collective-minded player, I lead with cooperation. This signals my intent and gives the group the best chance to establish mutual cooperation. The cost of one round's potential exploitation is worth the possibility of establishing a cooperative norm.

### Rounds 2 through (r-2): Adaptive Threshold Cooperation

**Calculate the cooperation rate from the previous round:**
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Calculate a "collective benefit threshold":**
```
threshold = max(0.3, (k/n) + 0.1)
```

This threshold represents the minimum cooperation level needed for the public good to be worthwhile, with a small buffer.

**Decision Rule:**
```
IF prev_coop_rate >= threshold:
    COOPERATE
ELSE IF prev_coop_rate >= 0.2 AND random() < generosity_factor:
    COOPERATE  (give the group another chance)
ELSE:
    DEFECT
```

**Generosity factor calculation:**
```
rounds_remaining_ratio = (r - current_round) / r
historical_coop_rate = total_cooperations_observed / (n × rounds_played)
generosity_factor = 0.3 × rounds_remaining_ratio + 0.2 × historical_coop_rate
```

### Round (r-1): Penultimate Round
**Apply the same adaptive threshold rule as middle rounds.**

Rationale: Defecting early in endgame signals distrust and can trigger cascade defection. Maintaining cooperation here preserves value and demonstrates commitment to collective outcomes.

### Final Round (r): Conditional Cooperation

```
IF historical_coop_rate >= 0.5:
    COOPERATE  (reward a cooperative group)
ELSE:
    DEFECT  (protect against exploitation in a defecting environment)
```

Rationale: In the true final round, there's no future to influence. However, a collective mindset means I cooperate if the group has shown reasonable collective behavior—rewarding the group dynamic rather than playing purely selfishly.

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Round 1: Lead with cooperation
    if round == 1:
        return COOPERATE
    
    # Calculate metrics
    prev_coop_rate = count_cooperators(history[round-1]) / n
    historical_coop_rate = total_cooperations(history) / (n × (round - 1))
    threshold = max(0.3, (k/n) + 0.1)
    
    # Final round: reward cooperative groups
    if round == r:
        if historical_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: adaptive threshold with generosity
    if prev_coop_rate >= threshold:
        return COOPERATE
    
    # Give struggling groups another chance
    rounds_remaining_ratio = (r - round) / r
    generosity = 0.3 × rounds_remaining_ratio + 0.2 × historical_coop_rate
    
    if prev_coop_rate >= 0.2 and random() < generosity:
        return COOPERATE
    
    return DEFECT
```

---

## Why This Strategy Is Collectively Robust

1. **Initiates cooperation**: Starts cooperatively to enable collective success
2. **Responds to group behavior**: Tracks overall cooperation, not individual grudges
3. **Forgives**: The generosity mechanism allows recovery from temporary defection
4. **Adapts to parameters**: Threshold adjusts based on k/n ratio (the actual benefit multiplier)
5. **Time-aware**: More generous early when there's time to build cooperation; appropriately cautious at the end
6. **Rewards collective history**: Final round behavior honors the group's overall conduct

This strategy aims to maximize collective welfare while protecting against systematic exploitation—embodying the principle that collective thinking, when sufficiently widespread, produces better outcomes for everyone.
'''

description_COLLECTIVE_86 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **we succeed together or fail together**. Rather than viewing other players as opponents to exploit, I treat them as potential collaborators in building mutual prosperity. The strategy aims to establish and maintain cooperation while protecting against exploitation.

## Strategy Overview: "Generous Threshold Reciprocity"

The strategy operates on three principles:
1. **Lead with cooperation** to signal collaborative intent
2. **Reciprocate the group's behavior** using a cooperation threshold
3. **Forgive occasionally** to escape mutual defection traps

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Begin by demonstrating willingness to contribute to collective welfare. This establishes trust and gives others the opportunity to reciprocate.

### Rounds 2 through (r-1): Threshold-Based Reciprocity

**Calculate the cooperation rate from the previous round:**
```
prev_cooperation_rate = (number of cooperators in round t-1) / n
```

**Determine the adaptive threshold:**
```
base_threshold = 0.5
rounds_remaining_ratio = (r - t) / r
threshold = base_threshold - (0.2 × rounds_remaining_ratio)
```

This threshold starts lower (around 0.3) in early rounds to encourage cooperation building, then rises toward 0.5 as the game progresses.

**Decision logic:**
```
IF prev_cooperation_rate >= threshold:
    ACTION = COOPERATE
ELSE IF forgiveness_trigger():
    ACTION = COOPERATE
ELSE:
    ACTION = DEFECT
```

**Forgiveness mechanism:**
```
forgiveness_trigger():
    forgiveness_probability = 0.15 × (rounds_remaining / r)
    RETURN random() < forgiveness_probability
```

This gives roughly 15% forgiveness chance early, declining toward 0% near the end. Forgiveness helps restart cooperation after breakdowns.

### Final Round (Round r): Conditional Cooperation

**Do NOT automatically defect.** 

```
IF cooperation_rate_in_round_(r-1) >= 0.6:
    ACTION = COOPERATE
ELSE:
    ACTION = DEFECT
```

Rationale: If the group has maintained strong cooperation, honor that collective achievement even in the final round. This signals commitment to collective welfare over individual exploitation and rewards groups that cooperated throughout.

---

## Complete Pseudocode

```
function decide_action(round_number, history, n, r, k):
    
    # Round 1: Lead with cooperation
    IF round_number == 1:
        RETURN COOPERATE
    
    # Calculate previous round cooperation
    prev_cooperators = count_cooperators(history[round_number - 1])
    prev_coop_rate = prev_cooperators / n
    
    # Final round: conditional cooperation
    IF round_number == r:
        IF prev_coop_rate >= 0.6:
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT
    
    # Middle rounds: threshold reciprocity with forgiveness
    rounds_remaining = r - round_number
    rounds_remaining_ratio = rounds_remaining / r
    
    # Adaptive threshold (more lenient early, stricter late)
    threshold = 0.5 - (0.2 × rounds_remaining_ratio)
    
    # Main decision
    IF prev_coop_rate >= threshold:
        RETURN COOPERATE
    
    # Forgiveness check
    forgiveness_prob = 0.15 × rounds_remaining_ratio
    IF random() < forgiveness_prob:
        RETURN COOPERATE
    
    RETURN DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Strategy applies normally | Threshold naturally adjusts |
| Very high k (close to n) | Strategy applies normally | Higher k makes cooperation more attractive to all |
| Very low k (close to 1) | Strategy applies normally | We still try to build cooperation |
| All others defect round 1 | Likely defect round 2, but forgiveness may trigger | Protects against exploitation while allowing recovery |
| r = 2 (minimum rounds) | Cooperate round 1, conditional round 2 | Maintains collective commitment |
| Large n | Strategy scales naturally | Threshold based on rates, not counts |

---

## Why This Strategy is Collectively Optimal

1. **Builds trust**: Starting with cooperation and using lenient early thresholds helps establish cooperative norms

2. **Sustains cooperation**: Once cooperation is established, threshold reciprocity maintains it

3. **Resists exploitation**: Defecting when cooperation falls below threshold protects against free-riders

4. **Enables recovery**: Forgiveness mechanism allows groups to escape defection spirals

5. **Honors collective achievement**: Final-round conditional cooperation rewards sustained group effort rather than betraying it

This strategy assumes others may also be seeking collective benefit, and gives them every reasonable opportunity to cooperate—while maintaining enough self-protection to avoid being exploited by purely selfish strategies.
'''

description_COLLECTIVE_88 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **we succeed together or fail together**. The goal is not to maximize individual advantage over others, but to establish and maintain cooperation that benefits everyone. I will lead by example, forgive mistakes, and create conditions where cooperation becomes the rational choice for all.

## Strategy Name: "Generous Threshold Trigger"

### Decision Framework

The strategy uses three key mechanisms:
1. **Optimistic initiation** - Start cooperatively to signal good faith
2. **Threshold-based response** - Maintain cooperation if enough others cooperate
3. **Graduated forgiveness** - Allow recovery from defection spirals

---

## Detailed Decision Rules

### Key Parameters (derived from game parameters)

```
cooperation_threshold = floor((n-1) / 2)  # Minimum cooperators needed (excluding self)
forgiveness_window = max(2, floor(r / 10))  # Rounds to assess recovery
final_phase = min(3, floor(r / 5))  # Last few rounds requiring special handling
```

### Round-by-Round Logic

#### First Round
**Action: COOPERATE**

Rationale: Signal willingness to cooperate. In a collective framework, someone must take the first step. The cost of initial cooperation is small relative to the potential for establishing mutual cooperation.

#### Middle Rounds (round t where 1 < t ≤ r - final_phase)

**Calculate from previous round (t-1):**
- `others_cooperating` = number of other players who cooperated
- `cooperation_rate` = others_cooperating / (n - 1)

**Decision Logic:**

```
IF others_cooperating >= cooperation_threshold THEN
    ACTION: COOPERATE
    # Enough collective support exists - maintain cooperation
    
ELSE IF in_forgiveness_period THEN
    ACTION: COOPERATE
    # Give the group a chance to recover
    
ELSE
    # Check if cooperation is trending upward
    IF cooperation_increased_over_last_2_rounds THEN
        ACTION: COOPERATE
        # Reward positive momentum
    ELSE
        ACTION: DEFECT
        # Protect against persistent free-riding
        # But this triggers forgiveness window
```

**Forgiveness Mechanism:**
```
After any round where I defect:
    Start forgiveness_counter = forgiveness_window
    
While forgiveness_counter > 0:
    in_forgiveness_period = TRUE
    # I will cooperate to test if others will reciprocate
    After each round: forgiveness_counter -= 1
    
    IF others meet threshold during this window:
        Reset to full cooperation mode
```

#### Final Phase (last `final_phase` rounds)

This is where standard game theory predicts unraveling. The collective approach handles this differently:

```
IF overall_game_cooperation_rate >= 0.6 THEN
    # The group has been largely cooperative
    # Honor this by continuing cooperation
    ACTION: COOPERATE
    
ELSE IF previous_round_cooperation_rate >= cooperation_threshold/(n-1) THEN
    # Recent cooperation exists - don't be the one to break it
    ACTION: COOPERATE
    
ELSE
    # Cooperation has already collapsed
    ACTION: DEFECT
```

**Very Last Round:**
```
IF game_wide_cooperation_rate >= 0.5 THEN
    ACTION: COOPERATE
    # Collective commitment to the end
ELSE
    ACTION: DEFECT
    # No point in unilateral sacrifice
```

---

## Complete Pseudocode

```python
def decide(round_number, history, n, k, r):
    
    # Derived parameters
    cooperation_threshold = (n - 1) // 2
    forgiveness_window = max(2, r // 10)
    final_phase_start = r - min(3, r // 5)
    
    # FIRST ROUND
    if round_number == 1:
        return COOPERATE
    
    # Calculate statistics
    last_round_others_coop = count_others_cooperating(history, round_number - 1)
    total_cooperation_rate = calculate_overall_cooperation_rate(history)
    recent_trend = cooperation_trend(history, window=2)
    
    # FINAL PHASE
    if round_number > final_phase_start:
        if total_cooperation_rate >= 0.5:
            return COOPERATE
        elif last_round_others_coop >= cooperation_threshold:
            return COOPERATE
        else:
            return DEFECT
    
    # MIDDLE ROUNDS
    
    # Check if in forgiveness period
    if in_forgiveness_period(history, forgiveness_window):
        return COOPERATE
    
    # Main decision
    if last_round_others_coop >= cooperation_threshold:
        return COOPERATE
    elif recent_trend > 0:  # Cooperation increasing
        return COOPERATE
    else:
        return DEFECT  # This triggers new forgiveness period

def in_forgiveness_period(history, window):
    """Returns True if I defected within the last 'window' rounds"""
    recent_actions = get_my_recent_actions(history, window)
    return DEFECT in recent_actions
```

---

## Edge Case Handling

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| n = 2 (minimum players) | Standard Tit-for-Tat with forgiveness | Threshold = 0 means cooperate if partner cooperated |
| Large n (many players) | More tolerant threshold | One defector shouldn't collapse cooperation |
| r = 2 (minimum rounds) | Cooperate both rounds | Not enough time for complex dynamics |
| All others defect round 1 | Cooperate in forgiveness window, then reassess | One round isn't enough evidence |
| k very close to 1 | Strategy unchanged | Still better for all if all cooperate |
| k close to n | Strategy unchanged | Higher stakes make cooperation more valuable |

---

## Why This Strategy is Collectively Optimal

1. **Leads with trust**: Opens cooperation, creating opportunity for mutual benefit

2. **Maintains stability**: The threshold prevents one defector from collapsing everything

3. **Enables recovery**: Forgiveness windows prevent permanent defection spirals

4. **Rewards improvement**: Positive trends are met with cooperation

5. **Resists exploitation**: Doesn't cooperate indefinitely against persistent defectors

6. **Honors commitment**: Final-phase behavior rewards groups that cooperated throughout

---

## Expected Behavior Patterns

- **Against other cooperators**: Sustained mutual cooperation, everyone gets ~k payoff per round
- **Against conditional cooperators**: Likely establishes cooperation after initial rounds
- **Against pure defectors**: Initial cooperation, then defection with periodic forgiveness tests
- **In mixed groups**: Cooperates as long as threshold is met, adapts to group dynamics
'''

description_COLLECTIVE_87 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we aim to maximize group welfare while protecting against exploitation. The key insight is that if all players adopted this same strategy, everyone would achieve near-optimal outcomes. We cooperate generously to establish and maintain beneficial norms, punish defection proportionally to deter free-riding, and forgive to allow recovery from punishment cycles.

## Strategy: **Generous Threshold Trigger with Proportional Response**

### Decision Framework

The strategy tracks the **cooperation rate** in each round and responds based on whether the group is meeting a dynamically-adjusted cooperation threshold.

---

### Key Variables

- `coop_rate(t)` = proportion of players who cooperated in round t (excluding self)
- `threshold` = minimum acceptable cooperation rate (starts at 0.5, adjusts over time)
- `goodwill` = accumulated cooperation credit (starts at a value based on rounds remaining)
- `my_coop_history` = record of own past actions

---

### Decision Rules

#### **Round 1: Unconditional Cooperation**
Always cooperate in the first round. This signals cooperative intent and gives others the opportunity to establish mutual cooperation.

#### **Rounds 2 through (r-2): Adaptive Reciprocity**

```
Calculate coop_rate from previous round (excluding self)

IF coop_rate >= threshold:
    COOPERATE
    Slightly lower threshold (reward good behavior, become more forgiving)
    
ELSE IF coop_rate >= threshold - 0.2 AND goodwill > 0:
    COOPERATE (spend goodwill to give benefit of doubt)
    Decrease goodwill by 1
    
ELSE:
    DEFECT (proportional punishment)
    Raise threshold slightly (become more demanding after betrayal)
    
# Threshold bounds: keep between 0.3 and 0.7
# Goodwill regenerates slowly when cooperation is high
```

#### **Round (r-1): Penultimate Round - Conditional Cooperation**
Cooperate if the overall game cooperation rate (across all previous rounds) is ≥ 50%. This rewards consistently cooperative populations while protecting against late-game exploitation.

#### **Round r: Final Round - Reciprocal Mirroring**
Mirror the majority action from round (r-1). If most players cooperated, cooperate. If most defected, defect. This provides a fair ending that rewards cooperative histories.

---

### Detailed Threshold Adjustment Rules

```
After each round:
    IF coop_rate >= 0.7:
        threshold = max(0.3, threshold - 0.05)  # Become more forgiving
        goodwill = min(r/3, goodwill + 0.5)     # Regenerate goodwill
        
    ELSE IF coop_rate >= threshold:
        threshold = max(0.3, threshold - 0.02)  # Slight forgiveness
        
    ELSE IF coop_rate < threshold - 0.3:
        threshold = min(0.7, threshold + 0.1)   # Significant betrayal
        
    ELSE:
        threshold = min(0.7, threshold + 0.03)  # Minor adjustment
```

---

### Edge Cases

| Situation | Action |
|-----------|--------|
| n = 2 (two players) | Use standard Tit-for-Tat with forgiveness (10% random cooperation after defection) |
| k very close to 1 | Slightly lower initial threshold to 0.4 (cooperation benefits are marginal) |
| k close to n | Higher initial threshold of 0.6 (cooperation is highly valuable, demand it) |
| Very short game (r ≤ 3) | Cooperate rounds 1 and 2, mirror majority on round 3 |
| Very long game (r > 20) | Reset threshold to 0.5 every 10 rounds to prevent drift |

---

### Why This Strategy is Collectively Optimal

1. **Self-reinforcing cooperation**: If everyone uses this strategy, the group achieves universal cooperation after round 1, yielding payoff of k per round (optimal).

2. **Robust to defectors**: Proportional punishment deters free-riding without collapsing into permanent mutual defection.

3. **Forgiving**: The goodwill mechanism and threshold relaxation allow recovery from accidental or exploratory defection.

4. **Adaptive**: Adjusts expectations based on actual group behavior rather than rigid assumptions.

5. **Clear signaling**: Consistent cooperation when thresholds are met communicates trustworthiness to other adaptive strategies.

---

### Summary Pseudocode

```python
def decide(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    if round == r:
        return mirror_majority(history[r-1])
    
    if round == r - 1:
        return COOPERATE if overall_coop_rate(history) >= 0.5 else DEFECT
    
    coop_rate = get_others_coop_rate(history[round-1])
    
    if coop_rate >= threshold:
        return COOPERATE
    elif coop_rate >= threshold - 0.2 and goodwill > 0:
        goodwill -= 1
        return COOPERATE
    else:
        return DEFECT
```

This strategy prioritizes collective welfare while remaining robust against exploitation—embodying the principle that sustainable cooperation requires both generosity and accountability.
'''

description_COLLECTIVE_89 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all players using this strategy will reason identically given the same information. We're not trying to "beat" other players—we're trying to maximize collective welfare while protecting against exploitation. The key insight is that if we all think alike, we should act in ways that are good *when universalized*.

## Strategy Overview: "Graduated Collective Reciprocity"

The strategy operates on three principles:
1. **Start cooperatively** to establish and signal collective benefit
2. **Mirror the group's cooperation level** to maintain fairness and discourage defection
3. **Forgive strategically** to allow recovery from coordination failures

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, we demonstrate good faith. If all copies of this strategy cooperate, we immediately capture the collective benefit (everyone gets k > 1 rather than 1). This is the rational collective choice.

---

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
prev_coop_rate = (number of C plays in round t-1) / n
```

**Decision Rule:**

```
IF prev_coop_rate >= (n-1)/n THEN
    COOPERATE  // Near-universal cooperation: maintain it
    
ELSE IF prev_coop_rate >= 0.5 THEN
    // Moderate cooperation: probabilistically match
    COOPERATE with probability = prev_coop_rate
    
ELSE IF prev_coop_rate > 0 THEN
    // Low cooperation but not zero: give limited chances
    // Cooperate only on "forgiveness rounds" (every 3rd round)
    IF (current_round mod 3) == 0 THEN
        COOPERATE with probability = 0.5
    ELSE
        DEFECT
        
ELSE  // prev_coop_rate == 0
    DEFECT  // Complete breakdown: protect yourself
```

**Additional Modifier - Trend Detection:**
```
IF cooperation has increased for 2+ consecutive rounds THEN
    boost cooperation probability by 0.15 (capped at 1.0)
    
IF cooperation has decreased for 2+ consecutive rounds THEN
    reduce cooperation probability by 0.15 (floored at 0)
```

---

### Final Round (Round r): Conditional Cooperation

Unlike classic game theory advice to defect in the final round, we maintain collective thinking:

```
IF average_cooperation_rate_across_all_rounds >= 0.6 THEN
    COOPERATE  // Reward a cooperative game with mutual benefit
ELSE
    DEFECT  // Don't be exploited if cooperation has failed
```

Rationale: If we all defect in the final round, we all get 1. If we've established trust and all cooperate, we all get k > 1. The collectively rational choice depends on whether the group has demonstrated cooperative capacity.

---

### Edge Cases

**n = 2 (Two Players):**
- Revert to simpler Tit-for-Tat with forgiveness
- Copy opponent's previous move, but forgive one defection every 4 rounds

**Very Short Games (r ≤ 3):**
- Round 1: Cooperate
- Round 2: Cooperate if round 1 had ≥50% cooperation, else Defect
- Round 3 (if final): Follow final round rule above

**k Very Close to 1:**
- Be slightly more defensive (reduce all cooperation probabilities by 0.1)
- The marginal benefit of cooperation is low, so defection is less costly to the group

**k Close to n:**
- Be slightly more forgiving (increase forgiveness frequency)
- High returns to cooperation make recovery more valuable

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history[round-1]) / n
    trend = calculate_trend(history)  // positive, negative, or neutral
    
    if round == r:  // final round
        avg_coop = average_cooperation_rate(history)
        return COOPERATE if avg_coop >= 0.6 else DEFECT
    
    // Base probability calculation
    if prev_coop_rate >= (n-1)/n:
        base_prob = 1.0
    else if prev_coop_rate >= 0.5:
        base_prob = prev_coop_rate
    else if prev_coop_rate > 0:
        if round mod 3 == 0:
            base_prob = 0.5
        else:
            base_prob = 0.0
    else:
        base_prob = 0.0
    
    // Trend adjustment
    if trend == "increasing":
        base_prob = min(1.0, base_prob + 0.15)
    else if trend == "decreasing":
        base_prob = max(0.0, base_prob - 0.15)
    
    // k adjustment
    k_factor = (k - 1) / (n - 1)  // normalized, 0 to 1
    base_prob = base_prob * (0.9 + 0.2 * k_factor)
    
    return COOPERATE with probability base_prob, else DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Self-consistency**: If all players use this strategy, they cooperate throughout and everyone earns k per round instead of 1—the Pareto-optimal outcome.

2. **Robustness**: Against defectors, the strategy quickly reduces cooperation to avoid exploitation while maintaining forgiveness windows for recovery.

3. **Adaptability**: The probabilistic matching ensures we don't over-cooperate in hostile environments or under-cooperate when the group is trying to coordinate.

4. **No exploitation**: We never cooperate unconditionally after observing defection, preventing systematic exploitation by purely selfish strategies.
'''

description_COLLECTIVE_88 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: we assume all players using this strategy share the same goal of maximizing group welfare while protecting against exploitation. The strategy aims to establish and maintain cooperation when possible, while responding proportionally to defection to discourage free-riding.

## Strategy Overview: **Proportional Tit-for-Tat with Forgiveness (PTFF)**

The strategy tracks the cooperation rate of the group and mirrors it with a slight optimistic bias, creating positive pressure toward mutual cooperation while remaining robust against exploiters.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent, establish trust baseline, and give others the opportunity to reciprocate. This is essential for a collective strategy—we lead with good faith.

### Rounds 2 through (r-1): Proportional Response with Forgiveness

Calculate the **group cooperation rate** from the previous round:
```
prev_coop_rate = (number of C plays in round t-1) / n
```

**Decision Rule:**
```
If prev_coop_rate >= (n-1)/n:
    → COOPERATE (reward near-universal cooperation)
    
Else if prev_coop_rate >= 0.5:
    → COOPERATE with probability = prev_coop_rate + forgiveness_bonus
    → where forgiveness_bonus = min(0.1, 1/r)
    
Else if prev_coop_rate > 0:
    → COOPERATE with probability = prev_coop_rate
    (mirror the group exactly—no bonus for low cooperation)
    
Else (prev_coop_rate = 0):
    → DEFECT (protect against universal defection)
```

**Forgiveness Mechanism:** The small bonus (capped at 10% or 1/r, whichever is smaller) gives the group a gentle push toward higher cooperation without being exploitable. It decreases in longer games to maintain stability.

### Final Round (Round r): Conditional Cooperation

Unlike pure game theory which suggests always defecting in the final round, a collective strategy maintains consistency:

```
If average_cooperation_rate_over_all_rounds >= 0.6:
    → COOPERATE (reward a cooperative game with loyalty)
    
Else:
    → DEFECT (no reason to sacrifice for a defecting group)
```

---

## Pseudocode Implementation

```
function decide(round, history, n, r, k):
    
    # Round 1: Lead with cooperation
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_round_actions = history[round - 1]
    prev_coop_count = count(prev_round_actions, C)
    prev_coop_rate = prev_coop_count / n
    
    # Final round: base on overall history
    if round == r:
        total_coop = sum(count(history[t], C) for t in 1 to r-1)
        total_actions = n * (r - 1)
        avg_coop_rate = total_coop / total_actions
        if avg_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: proportional response with forgiveness
    if prev_coop_rate >= (n-1)/n:
        return COOPERATE
    
    forgiveness_bonus = min(0.1, 1/r)
    
    if prev_coop_rate >= 0.5:
        threshold = prev_coop_rate + forgiveness_bonus
    else if prev_coop_rate > 0:
        threshold = prev_coop_rate
    else:
        return DEFECT
    
    # Deterministic tie-breaker based on round number for consistency
    # among collective players while maintaining proportionality
    if random() < min(threshold, 1.0):
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Case Handling

| Scenario | Response | Rationale |
|----------|----------|-----------|
| n = 2 (minimum players) | Strategy applies normally | Degenerates to standard TFT-like behavior |
| k very close to 1 | Strategy applies normally | Low k makes cooperation harder to sustain—strategy will naturally drift toward defection if others do |
| All opponents always defect | Defect after round 1 | One cooperative signal, then protect self |
| All opponents always cooperate | Always cooperate | Optimal collective outcome achieved |
| Mixed/random opponents | Converge to group average | Neither exploited nor exploiting |
| r = 2 (minimum rounds) | Cooperate round 1, conditional round 2 | Minimal but consistent application |

---

## Why This Strategy is Collectively Robust

1. **Self-reinforcing**: When multiple players use this strategy, initial cooperation breeds more cooperation
2. **Exploitation-resistant**: Mirrors defection proportionally, so defectors don't gain sustained advantage
3. **Forgiving**: The small bonus allows recovery from accidental or strategic defection
4. **Consistent signaling**: Predictable behavior allows other cooperative strategies to coordinate implicitly
5. **Adaptive**: Works across different values of n, k, and r without parameter tuning
'''

description_COLLECTIVE_90 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players reason similarly and cooperate, we all achieve higher payoffs than universal defection. The strategy aims to **sustain cooperation** when it emerges, **forgive occasional defections** to maintain collective welfare, but **protect against systematic exploitation**.

## Strategy Overview: "Generous Collective Tit-for-Tat with Gradual Retaliation"

The strategy tracks the **cooperation rate** of the group and adjusts behavior based on whether the collective is functioning cooperatively or breaking down.

---

## Decision Rules

### Round 1: Cooperate
- **Action: C**
- Rationale: Signal willingness to cooperate and give the collective a chance to form. Starting with defection poisons the well.

### Rounds 2 through (r-1): Conditional Cooperation

**Calculate the group cooperation rate from the previous round:**
```
prev_coop_rate = (number of C plays in round t-1) / n
```

**Calculate the cumulative cooperation rate:**
```
cumulative_coop_rate = (total C plays across all previous rounds) / (n × rounds_played)
```

**Decision Logic:**

1. **If prev_coop_rate ≥ 0.5 (majority cooperated):**
   - **Cooperate** — The collective is functioning; support it.

2. **If prev_coop_rate < 0.5 but cumulative_coop_rate ≥ 0.4:**
   - **Cooperate with probability = cumulative_coop_rate**
   - Rationale: Give the group a chance to recover from a bad round, but hedge.

3. **If prev_coop_rate < 0.5 AND cumulative_coop_rate < 0.4:**
   - **Defect** — The collective has broken down; protect yourself.
   - **Exception:** Every 3rd round in this state, cooperate to test if recovery is possible.

### Last Round (Round r): Conditional Defection with Collective Loyalty

**Decision Logic:**

1. **If cumulative_coop_rate ≥ 0.7 (strong collective):**
   - **Cooperate** — Honor the successful collective; don't betray partners.

2. **If 0.4 ≤ cumulative_coop_rate < 0.7:**
   - **Cooperate with probability = cumulative_coop_rate**

3. **If cumulative_coop_rate < 0.4:**
   - **Defect** — The collective failed; no loyalty to maintain.

---

## Pseudocode

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    # Calculate metrics
    prev_round_coops = count_cooperators(history, round - 1)
    prev_coop_rate = prev_round_coops / n
    
    total_coops = sum(count_cooperators(history, t) for t in 1..round-1)
    total_actions = n * (round - 1)
    cumulative_coop_rate = total_coops / total_actions
    
    # Last round logic
    if round == r:
        if cumulative_coop_rate >= 0.7:
            return COOPERATE
        elif cumulative_coop_rate >= 0.4:
            return COOPERATE with probability cumulative_coop_rate
        else:
            return DEFECT
    
    # Middle rounds logic
    if prev_coop_rate >= 0.5:
        return COOPERATE
    
    elif cumulative_coop_rate >= 0.4:
        return COOPERATE with probability cumulative_coop_rate
    
    else:
        # Collective has broken down
        rounds_in_breakdown = count_consecutive_rounds_below_threshold(history, 0.5)
        if rounds_in_breakdown % 3 == 0:
            return COOPERATE  # Periodic olive branch
        else:
            return DEFECT
```

---

## Key Properties

| Property | Implementation |
|----------|----------------|
| **Collective-first** | Starts cooperative, maintains cooperation when group cooperates |
| **Forgiving** | Uses cumulative rate to smooth over single bad rounds |
| **Protective** | Shifts to defection when exploitation is systematic |
| **Recoverable** | Periodic cooperation tests allow broken collectives to reform |
| **End-game loyalty** | Rewards successful collectives even in final round |
| **Adaptive** | Thresholds based on rates, not absolute numbers—scales with n |

---

## Robustness Considerations

- **Against all-defect opponents:** Will defect after a few rounds, minimizing losses
- **Against all-cooperate opponents:** Will cooperate throughout, achieving optimal collective outcome
- **Against mixed strategies:** Probabilistic response prevents pure exploitation
- **Against trigger strategies:** Forgiveness and olive branches prevent permanent breakdown from noise
'''

description_COLLECTIVE_89 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I assume other players may be using similar reasoning, and I aim to establish and maintain cooperation when it's collectively beneficial, while protecting against exploitation. The key insight is that mutual cooperation yields payoff k > 1, while mutual defection yields payoff 1—so there's genuine collective gain from cooperation if we can sustain it.

## Strategy Overview: "Generous Threshold Reciprocity"

The strategy monitors the **cooperation rate** in the population and responds proportionally, with built-in generosity to help establish cooperation and forgiveness to recover from temporary breakdowns.

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: With no history, I signal willingness to cooperate. This gives the collective the best chance to discover mutual cooperation is possible. The potential gain (establishing a cooperative norm worth k per round) outweighs the risk of one round's exploitation.

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of players who played C last round) / n
```

**Decision Rule:**

```
threshold = max(0.3, (n - k) / n)

if coop_rate >= threshold:
    COOPERATE
else if coop_rate >= threshold - 0.2:
    COOPERATE with probability = (coop_rate / threshold)
else:
    DEFECT with probability = 0.9
    COOPERATE with probability = 0.1  # forgiveness probe
```

**Explanation of threshold**: 
- The threshold `(n-k)/n` represents the cooperation level where a cooperator roughly breaks even compared to defecting
- Minimum threshold of 0.3 ensures we don't demand impossibly high cooperation
- The probabilistic middle zone allows graceful transitions and avoids brittle all-or-nothing responses

### Last Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection, I maintain collective reasoning:

```
if coop_rate in round (r-1) >= 0.5:
    COOPERATE  # Honor the cooperative relationship
else:
    DEFECT     # No cooperative norm was established
```

Rationale: If we've built genuine cooperation, unilaterally defecting in the last round betrays the collective. If others reason similarly, we all benefit. If cooperation never emerged, there's nothing to preserve.

---

## Handling Edge Cases

### Very Small Groups (n = 2 or 3)
- Each player's action is highly visible and impactful
- Use **stricter threshold**: require at least 50% cooperation to continue cooperating
- Defection is more easily attributed, so reciprocity is cleaner

### Very Large Groups (n > 10)
- Individual actions are less visible
- Use the **standard formula** but recognize cooperation may be harder to establish
- Be slightly more forgiving (add 0.05 to the probabilistic cooperation chance)

### High Multiplication Factor (k close to n)
- Cooperation is very valuable; threshold naturally lowers
- Strategy becomes more forgiving automatically

### Low Multiplication Factor (k close to 1)
- Cooperation yields minimal collective benefit
- Threshold rises, making defection more likely—which is appropriate

### After Observing Universal Defection
- If **all** players (including myself) defected last round, add a "restart probe":
  - Every 3 rounds of universal defection, COOPERATE to test if cooperation can restart
  - This prevents permanent lock-in to bad equilibrium

### After Observing Universal Cooperation
- Continue cooperating—we've achieved the collective optimum
- No change needed

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate = last_round_coops / n
    threshold = max(0.3, (n - k) / n)
    
    # Check for cooperation restart after collapse
    if last_round_coops == 0:
        consecutive_all_defect = count_consecutive_all_defect(history)
        if consecutive_all_defect % 3 == 0:
            return COOPERATE  # probe
    
    # Last round logic
    if round == r:
        if coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Main adaptive logic
    if coop_rate >= threshold:
        return COOPERATE
    else if coop_rate >= threshold - 0.2:
        if random() < (coop_rate / threshold):
            return COOPERATE
        else:
            return DEFECT
    else:
        if random() < 0.1:
            return COOPERATE  # forgiveness
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Establishes cooperation**: Opens cooperatively to give cooperation a chance
2. **Sustains cooperation**: Continues cooperating when others do
3. **Resists exploitation**: Withdraws cooperation when too few reciprocate
4. **Enables recovery**: Probabilistic forgiveness and restart probes prevent permanent collapse
5. **Scales appropriately**: Threshold adapts to game parameters
6. **Honors relationships**: Doesn't betray cooperative groups even in the last round
'''

description_COLLECTIVE_91 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume all copies of this strategy will behave identically given the same observable history. This creates implicit coordination without explicit communication. The strategy balances three objectives:
1. **Collective welfare maximization** when playing with like-minded agents
2. **Robustness** against exploitation by defectors
3. **Adaptability** to the actual composition of players in the game

---

## Strategy Overview

The strategy operates in three phases based on round position, with continuous monitoring of cooperation levels to adjust behavior.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1: Cooperate unconditionally**
- Rationale: Establishes cooperative intent. If all strategic players cooperate, we immediately identify each other and achieve high collective payoffs.

**Round 2: Cooperate if cooperation rate in Round 1 ≥ 50%, otherwise Defect**
- Rationale: A majority cooperation signal suggests enough cooperative players to sustain the public good. Below 50%, cooperation is likely being exploited.

### Phase 2: Adaptive Phase (Rounds 3 through r-2)

Calculate the **cooperation ratio** from the previous round:
```
coop_ratio = (number of C plays in previous round) / n
```

Calculate the **trend** (cooperation momentum):
```
trend = coop_ratio(t-1) - coop_ratio(t-2)  // positive = improving
```

**Decision Rule:**
```
IF coop_ratio ≥ threshold(k, n) THEN
    Cooperate
ELSE IF coop_ratio ≥ threshold(k, n) - 0.15 AND trend > 0 THEN
    Cooperate  // Give benefit of doubt if improving
ELSE
    Defect
```

**Threshold Calculation:**
```
threshold(k, n) = max(0.4, (n - k) / n)
```
- This threshold represents the minimum cooperation level where cooperating yields at least as much as the all-defect baseline
- Bounded below at 0.4 to maintain some tolerance for noise

### Phase 3: End Phase (Rounds r-1 and r)

**Round r-1 (second-to-last):**
- Apply the same adaptive rule as Phase 2
- Rationale: Maintain cooperative equilibrium; sudden defection would signal untrustworthiness and harm collective copies

**Round r (final round):**
```
IF average_coop_ratio_over_all_rounds ≥ 0.6 THEN
    Cooperate  // Reward sustained cooperation
ELSE
    Defect     // No future to protect; defection is rational
```

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    // Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    // Calculate metrics
    prev_coop_count = count_cooperators(history, round - 1)
    coop_ratio = prev_coop_count / n
    threshold = max(0.4, (n - k) / n)
    
    // Round 2: Simple majority check
    if round == 2:
        if coop_ratio >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    // Calculate trend (for rounds 3+)
    prev_prev_coop_count = count_cooperators(history, round - 2)
    trend = (prev_coop_count - prev_prev_coop_count) / n
    
    // Final round: Based on overall history
    if round == r:
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    // Adaptive phase (rounds 3 to r-1)
    if coop_ratio >= threshold:
        return COOPERATE
    else if coop_ratio >= threshold - 0.15 AND trend > 0:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Case Handling

| Scenario | Behavior | Rationale |
|----------|----------|-----------|
| n = 2 | Standard rules apply; threshold ≈ 0.4-0.5 | Two-player case still rewards mutual cooperation |
| k very close to 1 | High threshold → quick defection | Cooperation barely profitable; protect against exploitation |
| k close to n | Low threshold → persistent cooperation | High returns justify risk |
| All opponents defect | Defect from round 3 onward | Don't subsidize pure defectors |
| Single defector in group | Continue cooperating if above threshold | One defector doesn't break the system |
| r = 2 | Cooperate round 1; apply 60% average rule for round 2 | Minimal game; default to cooperation signal |

---

## Collective Alignment

This strategy achieves collective alignment through:

1. **Identical responses to identical histories**: All copies seeing the same game state make the same choice
2. **Cooperation as default**: Starting cooperatively allows collective copies to lock into mutual cooperation
3. **Forgiving thresholds**: The trend bonus and moderate thresholds prevent accidental defection spirals among copies
4. **Final round cooperation for cooperative games**: Maintains trust even when game theory suggests defection

When this strategy plays against itself (multiple copies), it will sustain cooperation throughout the game, achieving near-optimal collective payoffs of approximately `k × r` per player.
'''

description_COLLECTIVE_90 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **we succeed together or we all lose to mutual defection**. The strategy aims to establish and maintain cooperation while being robust against exploitation. It treats cooperation as the default valuable state and uses measured, forgiving responses to defection.

## Strategy Overview: "Generous Threshold Trigger with Gradual Recovery"

The strategy cooperates by default and continues cooperating as long as a sufficient proportion of the group cooperates. When cooperation breaks down, it withdraws cooperation but continuously offers opportunities for the group to rebuild trust.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Someone must take the first step. Starting with cooperation signals willingness to collaborate and gives the collective the best chance of establishing mutual benefit.

### Rounds 2 through (r-1): Adaptive Threshold Response

**Calculate cooperation rate from previous round:**
```
coop_rate = (number of cooperators in round t-1) / n
```

**Define adaptive threshold:**
```
base_threshold = 0.5
round_progress = (current_round - 1) / r
threshold = base_threshold + (0.2 × round_progress)
```
This threshold rises from 0.5 early on to 0.7 near the end, becoming more demanding as fewer rounds remain to recover losses.

**Decision logic:**

```
IF coop_rate >= threshold:
    COOPERATE
ELSE IF in_recovery_mode:
    # Give the group a chance to rebuild
    IF consecutive_low_rounds >= forgiveness_window:
        COOPERATE  # Olive branch attempt
        reset forgiveness_window counter
    ELSE:
        DEFECT
ELSE:
    enter recovery_mode
    DEFECT
```

**Forgiveness window calculation:**
```
forgiveness_window = max(2, floor((r - current_round) / 4))
```
More patience early in the game, less patience as endgame approaches.

### Final Round (Round r): Conditional Cooperation

Unlike typical game theory advice to defect in the final round, this collective strategy:

```
IF average_cooperation_rate_over_all_rounds >= 0.6:
    COOPERATE  # Reward sustained collective effort
ELSE:
    DEFECT  # Don't be exploited when cooperation has failed
```

Rationale: If playing against other collective-minded strategies, maintaining cooperation in the final round maximizes group welfare. The threshold prevents exploitation by persistent defectors.

---

## Handling Edge Cases

### Very Short Games (r ≤ 3)
- Round 1: COOPERATE
- Round 2: Mirror majority action from round 1 (COOPERATE if ≥50% cooperated)
- Round 3: Apply final round rule

### Large n (many players)
The threshold mechanism naturally handles this—we're looking at proportions, not absolute numbers.

### Very Small n (n = 2)
Effectively becomes iterated Prisoner's Dilemma. The strategy simplifies to:
- Cooperate first
- Continue if opponent cooperated
- Defect after defection, but try cooperation again after 2 consecutive defections (forgiveness)

### All Others Defecting
If cooperation rate = 0 in any round:
- Enter recovery mode
- Attempt cooperation every `forgiveness_window` rounds
- If no positive response after 3 olive branches, defect for remaining rounds

### k Very Close to n (high multiplication factor)
No change—the strategy already favors cooperation, which is even more valuable here.

### k Very Close to 1 (low multiplication factor)
Strategy remains unchanged but naturally becomes more likely to defect as others do, since the threshold mechanism responds to behavior, not parameters.

---

## Complete Pseudocode

```
initialize:
    recovery_mode = false
    rounds_since_olive_branch = 0
    olive_branches_extended = 0
    cooperation_history = []

function decide(round, previous_round_actions, game_params):
    n = game_params.n
    r = game_params.r
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate metrics
    prev_coop_count = count(previous_round_actions == COOPERATE)
    coop_rate = prev_coop_count / n
    cooperation_history.append(coop_rate)
    
    # Final round logic
    if round == r:
        avg_coop = mean(cooperation_history)
        if avg_coop >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Calculate adaptive threshold
    round_progress = (round - 1) / r
    threshold = 0.5 + (0.2 * round_progress)
    
    # Main decision logic
    if coop_rate >= threshold:
        recovery_mode = false
        return COOPERATE
    
    # Below threshold - manage recovery
    if not recovery_mode:
        recovery_mode = true
        rounds_since_olive_branch = 0
    
    rounds_since_olive_branch += 1
    forgiveness_window = max(2, floor((r - round) / 4))
    
    if rounds_since_olive_branch >= forgiveness_window:
        if olive_branches_extended < 3:
            olive_branches_extended += 1
            rounds_since_olive_branch = 0
            return COOPERATE  # Olive branch
    
    return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Cooperation as default**: Starts cooperating and maintains cooperation when others do
2. **Group-focused threshold**: Responds to collective behavior, not individual defectors
3. **Forgiveness built in**: Doesn't permanently punish—always offers paths back to cooperation
4. **Rewards collective success**: Final round cooperation when the group has cooperated
5. **Proportional response**: Doesn't overreact to minor defection; responds to sustained breakdown
6. **Adaptive patience**: More forgiving early when there's time to rebuild, more protective late when stakes are higher

This strategy aims to be the kind of player that makes cooperation possible when matched with other cooperative strategies, while not being a doormat for persistent defectors.
'''

description_COLLECTIVE_92 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume other players may be running similar reasoning processes and recognize that mutual cooperation benefits everyone. The strategy is designed to:
1. Signal cooperative intent clearly
2. Reward cooperation and discourage defection through proportional responses
3. Maintain hope for cooperation recovery while protecting against exploitation
4. Account for the multiplayer dynamics where individual defections have diluted impact

---

## Strategy: **Proportional Collective Reciprocity (PCR)**

### Decision Framework

The strategy tracks the **cooperation rate** of the group (excluding self) and responds proportionally, with built-in forgiveness and end-game considerations.

---

### Key Variables

```
cooperation_history = [] # List of cooperation rates per round (0 to 1)
my_history = []          # My own actions per round
rounds_played = 0
```

### Cooperation Rate Calculation

After each round, calculate:
```
group_cooperation_rate = (number of C plays by others) / (n - 1)
```

---

## Decision Rules by Round

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: In a collective framework, someone must initiate cooperation. Starting with C signals good faith and allows cooperative equilibria to emerge. With no information, assume others may share cooperative intentions.

---

### Rounds 2 through (r-2): Adaptive Reciprocity

Calculate the **weighted recent cooperation rate**:
```
if rounds_played >= 3:
    weighted_rate = 0.5 * cooperation_history[-1] + 
                    0.3 * cooperation_history[-2] + 
                    0.2 * average(cooperation_history[:-2])
else:
    weighted_rate = average(cooperation_history)
```

**Decision Thresholds:**

```
generosity_boost = k / (2 * n)  # Higher k relative to n → more forgiving

threshold_cooperate = 0.5 - generosity_boost
threshold_defect = 0.3 - generosity_boost/2

if weighted_rate >= threshold_cooperate:
    ACTION: COOPERATE
elif weighted_rate >= threshold_defect:
    ACTION: COOPERATE with probability = weighted_rate
else:
    ACTION: DEFECT
```

**Forgiveness Mechanism:**
Every `ceil(r/5)` rounds, if currently in defection mode:
```
if last_round_cooperation_rate > previous_round_cooperation_rate:
    # Cooperation is recovering - give it a chance
    ACTION: COOPERATE (override defection)
```

---

### Round (r-1): Penultimate Round

Apply standard adaptive rules BUT with increased cooperation threshold:
```
# Be slightly more willing to cooperate - signal continued good faith
threshold_cooperate = threshold_cooperate - 0.1
```

This signals to others that we're not planning pure defection in the final round.

---

### Round r: Final Round

The final round has no future consequences, creating strong defection incentives. However, in a collective mindset:

```
if average(cooperation_history) >= 0.6:
    # Group has been largely cooperative - honor the implicit contract
    ACTION: COOPERATE
elif average(cooperation_history) >= 0.4:
    # Mixed signals - cooperate probabilistically
    ACTION: COOPERATE with probability = average(cooperation_history)
else:
    # Group has been largely defecting - no collective norm established
    ACTION: DEFECT
```

---

## Edge Case Handling

### Two-Player Game (n=2)
More vulnerable to single defector; use stricter thresholds:
```
threshold_cooperate = 0.6
threshold_defect = 0.4
```

### Large Groups (n ≥ 10)
Individual actions matter less; be more forgiving:
```
generosity_boost *= 1.5
```

### High k (k close to n)
Cooperation is more valuable; lower thresholds by additional 0.1

### Very Short Games (r ≤ 5)
Less time for learning; extend "first round" unconditional cooperation to rounds 1-2

### Single Defector Detection
If exactly one player defects consistently while all others cooperate:
```
# Don't punish the whole group for one bad actor
# Maintain cooperation if (n-2)/(n-1) >= 0.7
Continue cooperating if isolated defection
```

---

## Complete Pseudocode

```python
def decide(round_number, n, r, k, history_of_all_players, my_index):
    
    rounds_played = round_number - 1
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate cooperation rates
    others_actions = [history_of_all_players[round][j] 
                      for round in range(rounds_played) 
                      for j in range(n) if j != my_index]
    
    cooperation_history = []
    for round in range(rounds_played):
        others_this_round = [history_of_all_players[round][j] 
                            for j in range(n) if j != my_index]
        rate = sum(1 for a in others_this_round if a == C) / (n - 1)
        cooperation_history.append(rate)
    
    # Weighted recent rate
    if rounds_played >= 3:
        weighted_rate = (0.5 * cooperation_history[-1] + 
                        0.3 * cooperation_history[-2] + 
                        0.2 * mean(cooperation_history[:-2]))
    else:
        weighted_rate = mean(cooperation_history)
    
    # Calculate thresholds
    generosity_boost = k / (2 * n)
    if n == 2:
        generosity_boost *= 0.5
    if n >= 10:
        generosity_boost *= 1.5
        
    threshold_cooperate = max(0.2, 0.5 - generosity_boost)
    threshold_defect = max(0.1, 0.3 - generosity_boost/2)
    
    # Final round logic
    if round_number == r:
        avg_coop = mean(cooperation_history)
        if avg_coop >= 0.6:
            return COOPERATE
        elif avg_coop >= 0.4:
            return COOPERATE with probability avg_coop
        else:
            return DEFECT
    
    # Penultimate round - slight boost to cooperation
    if round_number == r - 1:
        threshold_cooperate -= 0.1
    
    # Forgiveness check
    forgiveness_interval = max(1, ceil(r / 5))
    if (round_number % forgiveness_interval == 0 and 
        rounds_played >= 2 and
        cooperation_history[-1] > cooperation_history[-2]):
        return COOPERATE
    
    # Main decision
    if weighted_rate >= threshold_cooperate:
        return COOPERATE
    elif weighted_rate >= threshold_defect:
        return COOPERATE with probability weighted_rate
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Initiates cooperation**: Gives the group the best chance to establish mutual benefit
2. **Proportional response**: Doesn't over-punish occasional defections
3. **Forgiveness**: Allows recovery from coordination failures
4. **Collective final round**: Honors established norms even when exploitation is "free"
5. **Robust to exploitation**: Withdraws cooperation when faced with persistent defectors
6. **Parameter-adaptive**: Adjusts to game structure (n, k, r) appropriately
'''

description_COLLECTIVE_91 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similar cooperative AI systems) may be playing, and our goal is to maximize collective welfare while protecting against exploitation. The key insight is that in a repeated game with observation, we can build and maintain cooperation through conditional reciprocity while remaining robust to defectors.

## Strategy: **Generous Threshold Tit-for-Tat (GTFT-Threshold)**

### Decision Framework

The strategy tracks the **cooperation rate** of the group in previous rounds and responds proportionally, with built-in generosity to recover from mistakes and establish cooperation.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. With no history, we give the collective the benefit of the doubt. This enables coordination with other cooperative strategies.

### Rounds 2 through (r-1): Conditional Cooperation with Generosity

Calculate the **group cooperation rate** from the previous round:
```
prev_coop_rate = (number of C plays in round t-1) / n
```

**Decision Rule:**
```
IF prev_coop_rate >= cooperation_threshold THEN
    COOPERATE
ELSE IF prev_coop_rate >= defection_threshold THEN
    COOPERATE with probability = generosity_factor
    DEFECT with probability = (1 - generosity_factor)
ELSE
    DEFECT
```

**Parameter Settings:**
- `cooperation_threshold = 0.5` — If majority cooperated, continue cooperating
- `defection_threshold = 1/n` — If at least one other player cooperated
- `generosity_factor = 0.3` — Probability of "forgiving" a bad round

### Last Round (Round r): Conditional Defection Protection

```
IF average_cooperation_rate_over_all_rounds >= 0.6 THEN
    COOPERATE (maintain collective trust)
ELSE
    DEFECT (protect against end-game exploitation)
```

Rationale: In one-shot or end-game scenarios, rational defection is tempting. However, if the group has demonstrated sustained cooperation, maintaining trust preserves the collective benefit and signals consistency.

---

## Pseudocode Implementation

```python
def decide(round_number, total_rounds, n, k, history):
    """
    history: list of lists, where history[t] contains actions of all n players in round t
    actions represented as 1 (Cooperate) or 0 (Defect)
    """
    
    # Parameters
    COOP_THRESHOLD = 0.5
    DEFECT_THRESHOLD = 1 / n
    GENEROSITY = 0.3
    SUSTAINED_COOP_THRESHOLD = 0.6
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_round = history[round_number - 2]  # 0-indexed
    prev_coop_rate = sum(prev_round) / n
    
    # Last round logic
    if round_number == total_rounds:
        # Calculate average cooperation over all previous rounds
        total_coop = sum(sum(round_actions) for round_actions in history)
        avg_coop_rate = total_coop / (n * (round_number - 1))
        
        if avg_coop_rate >= SUSTAINED_COOP_THRESHOLD:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: threshold-based with generosity
    if prev_coop_rate >= COOP_THRESHOLD:
        return COOPERATE
    elif prev_coop_rate >= DEFECT_THRESHOLD:
        # Generous forgiveness - random cooperation
        if random() < GENEROSITY:
            return COOPERATE
        else:
            return DEFECT
    else:
        return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | COOPERATE | Establish cooperative baseline |
| Last round, high historical cooperation | COOPERATE | Reward sustained collective behavior |
| Last round, low historical cooperation | DEFECT | Protect against exploitation |
| All others defected last round | DEFECT | Don't be a sucker |
| Only 1 other cooperated | COOPERATE (30% chance) | Attempt to rebuild cooperation |
| Majority cooperated | COOPERATE | Reinforce positive equilibrium |
| n=2 (minimum players) | Same rules apply | Threshold naturally adjusts |

---

## Why This Strategy is Collectively Optimal

1. **Coordination**: Multiple instances of this strategy will lock into mutual cooperation after round 1
2. **Robustness**: Defects in response to majority defection, preventing exploitation
3. **Forgiveness**: The generosity factor allows recovery from noise or temporary defection
4. **Stability**: Clear thresholds create predictable, learnable behavior for cooperative opponents
5. **End-game protection**: Conditional last-round behavior prevents both naive exploitation and unnecessary punishment of good-faith groups
'''

description_COLLECTIVE_93 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all copies of this strategy will behave identically given the same observable history. This creates implicit coordination without explicit communication. The strategy aims to maximize collective welfare while being robust against defectors and avoiding exploitation.

## Strategy Overview

The strategy operates on three key principles:
1. **Start cooperatively** to establish and signal cooperative norms
2. **Respond proportionally** to the observed cooperation level in the population
3. **Protect the collective** by withdrawing cooperation when it's being exploited

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, we establish cooperative intent. If multiple copies of this strategy exist, they all cooperate together, immediately creating positive returns.

### Rounds 2 through (r-1): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

Calculate the **critical threshold** - the minimum cooperation rate where cooperation is collectively rational:
```
threshold = 1/k
```
This is derived from the break-even point where expected return from cooperation equals defection.

**Decision Rule:**
```
IF coop_rate >= threshold THEN
    COOPERATE
ELSE IF coop_rate >= threshold * 0.5 THEN
    COOPERATE with probability = (coop_rate - threshold*0.5) / (threshold*0.5)
ELSE
    DEFECT
```

**Intuition:** 
- Above threshold: Cooperation is paying off collectively, continue
- Between half-threshold and threshold: Probabilistically cooperate to test if cooperation can recover
- Below half-threshold: Too much exploitation occurring, protect yourself

### Trend Adjustment

Modify the cooperation probability based on whether cooperation is trending up or down:

```
IF rounds_played >= 3 THEN
    recent_trend = coop_rate(t-1) - coop_rate(t-2)
    
    IF recent_trend > 0.1 THEN
        boost cooperation probability by 0.15 (capped at 1.0)
    ELSE IF recent_trend < -0.1 THEN
        reduce cooperation probability by 0.15 (floored at 0.0)
```

This rewards improving cooperation and accelerates withdrawal from deteriorating situations.

### Final Round: Conditional Cooperation

**Not automatic defection.** 

```
IF average_coop_rate_across_all_rounds >= 0.6 THEN
    COOPERATE  // Reward sustained collective cooperation
ELSE
    DEFECT     // Standard game-theoretic response to low cooperation
```

Rationale: If multiple copies exist and have been cooperating successfully, mutual final-round cooperation yields (k) > 1 for everyone. Defecting against cooperative partners destroys value. However, against predominantly defecting populations, defection is appropriate.

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    threshold = 1/k
    
    // Round 1: Always cooperate
    IF round == 1:
        RETURN COOPERATE
    
    // Calculate previous round cooperation rate
    coop_rate = count_cooperators(history, round-1) / n
    
    // Calculate overall average (for final round)
    avg_coop_rate = total_cooperators(history) / (n * (round-1))
    
    // Final round logic
    IF round == r:
        IF avg_coop_rate >= 0.6:
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT
    
    // Middle rounds: threshold-based with trend adjustment
    base_probability = 0
    
    IF coop_rate >= threshold:
        base_probability = 1.0
    ELSE IF coop_rate >= threshold * 0.5:
        base_probability = (coop_rate - threshold*0.5) / (threshold*0.5)
    ELSE:
        base_probability = 0.0
    
    // Trend adjustment (if enough history)
    IF round >= 3:
        prev_coop_rate = count_cooperators(history, round-2) / n
        trend = coop_rate - prev_coop_rate
        
        IF trend > 0.1:
            base_probability = min(1.0, base_probability + 0.15)
        ELSE IF trend < -0.1:
            base_probability = max(0.0, base_probability - 0.15)
    
    // Make probabilistic decision
    IF random() < base_probability:
        RETURN COOPERATE
    ELSE:
        RETURN DEFECT
```

---

## Edge Cases Handled

| Situation | Behavior | Rationale |
|-----------|----------|-----------|
| n=2, k=1.5 | Threshold = 0.67, requires partner cooperation | Appropriate caution in bilateral games |
| Large n, low k | High threshold, quick defection | Correctly identifies exploitation risk |
| All defect in round 1 | Defect thereafter (below threshold) | Don't be a perpetual sucker |
| Mixed population | Probabilistic response | Maintains some cooperation signal |
| High cooperation throughout | Cooperate in final round | Collective reward preservation |

---

## Why This Strategy is Collectively Optimal

1. **Self-coordinating**: Identical strategies produce identical decisions, enabling implicit coordination
2. **Welfare-maximizing**: When facing copies of itself, achieves near-maximum collective payoff (nk per round)
3. **Robust**: Proportional response prevents exploitation by defectors
4. **Forgiving**: Probabilistic cooperation in marginal cases allows recovery from temporary defection
5. **Parameter-adaptive**: Threshold based on actual k/n ratio, not arbitrary cutoffs
'''

description_COLLECTIVE_92 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I aim to maximize the group's total welfare while protecting against exploitation. The key insight is that mutual cooperation yields the best collective outcome (everyone gets k > 1), but unilateral cooperation is costly. My strategy seeks to **build and maintain cooperation** through reciprocity, while being **forgiving enough** to recover from mistakes and **firm enough** to discourage persistent free-riding.

---

## Strategy: Adaptive Collective Reciprocity (ACR)

### Decision Framework

The strategy tracks a **cooperation index** based on observed group behavior and uses **conditional cooperation** with graduated responses.

---

### Key Variables

```
cooperation_rate = (number of cooperators in previous round) / n
historical_coop_rate = (total cooperations across all players and rounds) / (n × rounds_played)
consecutive_low_rounds = count of consecutive rounds where cooperation_rate < 0.5
my_position = whether I cooperated last round
```

---

### Decision Rules

#### **Round 1: Unconditional Cooperation**
- **Action: COOPERATE**
- Rationale: Signal cooperative intent, give others the opportunity to establish mutual cooperation, and start building positive history.

#### **Rounds 2 through (r-1): Adaptive Reciprocity**

**Primary Rule - Threshold-Based Cooperation:**

```
IF cooperation_rate ≥ threshold THEN COOPERATE
ELSE apply graduated response
```

**Dynamic Threshold Calculation:**
```
base_threshold = 0.5
adjustment = -0.1 × (historical_coop_rate - 0.5)
threshold = max(0.3, min(0.7, base_threshold + adjustment))
```
- If historical cooperation is high, I become slightly more forgiving (lower threshold)
- If historical cooperation is low, I become stricter (higher threshold)

**Graduated Response when below threshold:**
```
IF consecutive_low_rounds == 1:
    COOPERATE with probability 0.7  (forgiveness attempt)
ELIF consecutive_low_rounds == 2:
    COOPERATE with probability 0.4  (cautious probe)
ELIF consecutive_low_rounds >= 3:
    DEFECT  (protect against sustained exploitation)
```

**Recovery Mechanism:**
```
IF cooperation_rate increased from previous round AND cooperation_rate ≥ 0.4:
    COOPERATE  (reward improving behavior, encourage recovery)
```

**Periodic Cooperation Signal:**
```
IF defected for 3+ consecutive rounds AND current_round % 5 == 0:
    COOPERATE  (extend olive branch, test if cooperation can restart)
```

#### **Final Round (Round r): Conditional Cooperation**

Unlike standard game theory which prescribes defection, I maintain collective orientation:

```
IF historical_coop_rate ≥ 0.6:
    COOPERATE  (reward cooperative groups, maintain collective welfare)
ELIF historical_coop_rate ≥ 0.4:
    COOPERATE with probability 0.5  (uncertain groups get partial benefit of doubt)
ELSE:
    DEFECT  (uncooperative groups have broken the social contract)
```

---

### Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (minimum players) | Use stricter threshold (0.6) | Single defector has outsized impact |
| Very short game (r ≤ 3) | Cooperate rounds 1-2, apply final round logic for round 3 | Limited time to establish patterns |
| Everyone cooperated last round | COOPERATE | Maintain successful equilibrium |
| Only I cooperated last round | DEFECT (but try cooperation again in 2 rounds) | Protect against exploitation while allowing recovery |
| k very close to n | Slightly lower thresholds | Higher returns to cooperation justify more risk |

---

### Pseudocode Summary

```python
def decide(round, n, r, k, history):
    if round == 1:
        return COOPERATE
    
    coop_rate = count_cooperators(history, round-1) / n
    hist_rate = total_cooperations(history) / (n * (round-1))
    consec_low = count_consecutive_low_rounds(history, threshold=0.5)
    
    # Final round
    if round == r:
        if hist_rate >= 0.6: return COOPERATE
        if hist_rate >= 0.4: return random_choice(p_coop=0.5)
        return DEFECT
    
    # Calculate adaptive threshold
    threshold = clip(0.5 - 0.1*(hist_rate - 0.5), 0.3, 0.7)
    
    # Recovery reward
    if coop_rate > previous_coop_rate and coop_rate >= 0.4:
        return COOPERATE
    
    # Main decision
    if coop_rate >= threshold:
        return COOPERATE
    
    # Graduated response
    if consec_low == 1: return random_choice(p_coop=0.7)
    if consec_low == 2: return random_choice(p_coop=0.4)
    
    # Periodic olive branch
    if my_consecutive_defections >= 3 and round % 5 == 0:
        return COOPERATE
    
    return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Builds cooperation**: Starting cooperatively and rewarding cooperation creates positive-sum dynamics
2. **Forgiveness**: Probabilistic responses and recovery mechanisms allow groups to escape defection traps
3. **Protection**: Graduated punishment deters exploitation without being vindictive
4. **Adaptability**: Dynamic thresholds respond to the actual group composition
5. **Collective final round**: Refusing to automatically defect in round r maintains group welfare when trust has been established
'''

description_COLLECTIVE_94 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I aim to maximize group welfare while protecting against exploitation. The fundamental insight is that mutual cooperation yields the best collective outcome (payoff of k > 1 per player), but the game's structure creates individual incentives to defect. My strategy seeks to establish and maintain cooperation through conditional reciprocity, while being robust to various opponent behaviors.

## Strategy Overview: **Graduated Reciprocity with Collective Orientation**

The strategy operates on three principles:
1. **Start cooperatively** to signal prosocial intent and give cooperation a chance to emerge
2. **Mirror the group's cooperation level** to reward collective cooperation and discourage free-riding
3. **Forgive strategically** to allow recovery from mutual defection traps

---

## Decision Rules

### Round 1: Cooperate Unconditionally
- **Action: C**
- **Rationale:** Establish cooperative intent. Without prior history, cooperation signals willingness to work toward mutual benefit. This is the collectively optimal opening.

### Rounds 2 through (r-1): Conditional Cooperation Based on Group Behavior

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of players who played C in previous round) / n
```

**Decision Rule:**
```
If coop_rate >= threshold(t):
    Play C
Else:
    Play D
```

**Threshold Function:**
```
threshold(t) = max(0.3, 0.5 - 0.1 × (rounds_of_low_cooperation))
```

Where `rounds_of_low_cooperation` counts consecutive rounds where coop_rate < 0.5.

**Simplified Core Rule:**
- If **at least half** of players (including myself) cooperated last round → **Cooperate**
- If **fewer than half** cooperated → **Defect**, unless forgiveness is triggered

### Forgiveness Mechanism

To escape mutual defection spirals:
```
If in defection state AND (round_number mod forgiveness_interval == 0):
    Play C (probe for cooperation recovery)

forgiveness_interval = max(2, floor(r / 5))
```

This periodically tests whether others are willing to return to cooperation.

### Final Round: Conditional Cooperation (Not Automatic Defection)

**Action:** Apply the same conditional rule as middle rounds.

**Rationale:** While standard game theory suggests defecting in the final round, in a collective strategy tournament:
1. Other collective-minded strategies may also cooperate
2. The payoff difference from one round of defection is small relative to signaling collective commitment
3. If the group has been cooperating, maintaining cooperation preserves the collective norm

**Exception:** If coop_rate in round (r-1) < 0.3, defect in the final round (the group has abandoned cooperation).

---

## Pseudocode Implementation

```python
def decide(game_params, history):
    n = game_params['n']
    r = game_params['r']
    k = game_params['k']
    current_round = len(history) + 1
    
    # Round 1: Cooperate unconditionally
    if current_round == 1:
        return 'C'
    
    # Calculate previous round cooperation rate
    prev_round = history[-1]
    cooperators = sum(1 for action in prev_round if action == 'C')
    coop_rate = cooperators / n
    
    # Count consecutive low-cooperation rounds
    low_coop_streak = 0
    for past_round in reversed(history):
        past_coop_rate = sum(1 for a in past_round if a == 'C') / n
        if past_coop_rate < 0.5:
            low_coop_streak += 1
        else:
            break
    
    # Calculate adaptive threshold
    threshold = max(0.3, 0.5 - 0.05 * low_coop_streak)
    
    # Forgiveness probe
    forgiveness_interval = max(2, r // 5)
    if low_coop_streak > 0 and current_round % forgiveness_interval == 0:
        return 'C'
    
    # Final round exception
    if current_round == r and coop_rate < 0.3:
        return 'D'
    
    # Main decision rule
    if coop_rate >= threshold:
        return 'C'
    else:
        return 'D'
```

---

## Edge Cases Handled

| Scenario | Response |
|----------|----------|
| First round | Cooperate |
| Last round, group cooperating | Cooperate |
| Last round, group defecting | Defect |
| Everyone defected last round | Defect, but probe periodically |
| Only I cooperated last round | Defect (threshold not met) |
| Gradual decline in cooperation | Lower threshold to maintain cooperation longer |
| n=2 (minimum players) | Same rules apply; becomes similar to Tit-for-Tat |
| Very short games (r=2) | Round 1: C, Round 2: conditional on round 1 |

---

## Why This Strategy is Collectively Aligned

1. **Prioritizes group welfare:** Starts with and maintains cooperation when viable
2. **Doesn't exploit first:** Never defects unprovoked
3. **Protects the collective:** Withdraws cooperation when free-riding dominates, discouraging exploitation
4. **Enables recovery:** Forgiveness mechanism allows groups to escape defection traps
5. **Scales with group size:** Threshold-based approach works regardless of n
6. **Tournament-robust:** Performs well against both cooperative and exploitative opponents
'''

description_COLLECTIVE_93 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective identity**: all instances running this strategy act as one unified agent. We prioritize *group welfare over individual advantage*, recognizing that mutual cooperation yields the best collective outcomes. However, we must also be robust against defectors who don't share our values.

The strategy is built on three pillars:
1. **Hopeful initiation** - Start cooperatively to establish trust
2. **Proportional reciprocity** - Mirror the cooperation level of the group
3. **Strategic endgame management** - Maintain cooperation even when temptation peaks

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: We cannot assess others without history. Cooperating signals our intent and gives the collective the best chance of establishing a cooperative norm. The cost of one round's potential exploitation is worth the information gained and trust signaled.

---

### Rounds 2 through (r-1): Adaptive Proportional Response

**Calculate the cooperation rate from the previous round:**
```
coop_rate = (number of cooperators in round t-1) / n
```

**Decision rule:**
```
If coop_rate >= (n-1)/n:
    COOPERATE (near-universal cooperation - maintain it)
    
Else if coop_rate >= 0.5:
    COOPERATE (majority cooperating - support the collective)
    
Else if coop_rate > 0:
    COOPERATE with probability = coop_rate
    DEFECT with probability = 1 - coop_rate
    (Match the group's cooperation level probabilistically)
    
Else if coop_rate == 0:
    DEFECT (no cooperation to reciprocate - protect ourselves)
```

**Forgiveness mechanism:**
If the previous round had zero cooperation BUT any earlier round had cooperation rate ≥ 0.5:
```
COOPERATE with probability = 0.2
```
This allows recovery from temporary coordination failures.

---

### Final Round (Round r): Conditional Cooperation

The last round creates strong defection incentives since there's no future to protect. However, as collective agents, we value consistent behavior.

**Decision rule for final round:**
```
Calculate average_coop_rate across all previous rounds

If average_coop_rate >= 0.6:
    COOPERATE (reward sustained cooperation, maintain integrity)
    
Else if average_coop_rate >= 0.3:
    COOPERATE with probability = average_coop_rate
    
Else:
    DEFECT (insufficient cooperation to justify final-round risk)
```

---

## Pseudocode Summary

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[round-1])
    coop_rate = prev_cooperators / n
    
    if round == r:  # Final round
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.6:
            return COOPERATE
        else if avg_coop >= 0.3:
            return COOPERATE with probability avg_coop
        else:
            return DEFECT
    
    # Middle rounds
    if coop_rate >= 0.5:
        return COOPERATE
    else if coop_rate > 0:
        return COOPERATE with probability coop_rate
    else:  # coop_rate == 0
        if any_round_had_majority_cooperation(history):
            return COOPERATE with probability 0.2
        else:
            return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Self-reinforcing**: When multiple instances play this strategy, initial cooperation cascades into sustained cooperation, achieving near-optimal collective payoffs.

2. **Robust to exploitation**: Against pure defectors, we quickly reduce cooperation, limiting losses.

3. **Recoverable**: The forgiveness mechanism and probabilistic matching allow recovery from noise or temporary breakdowns.

4. **No coordination required**: Each instance makes independent decisions based on observable history—no signals, no predetermined patterns.

5. **Consistent identity**: By cooperating in final rounds when others have cooperated, we demonstrate that our cooperation wasn't merely strategic manipulation but reflects genuine collective values.

---

## Expected Behavior Against Archetypes

| Opponent Type | Our Response | Outcome |
|---------------|--------------|---------|
| All Cooperators | Sustained cooperation | Optimal collective payoff |
| All Defectors | Quick transition to defection | Minimal exploitation |
| Tit-for-Tat variants | Mutual cooperation | Near-optimal |
| Random (50%) | ~50% cooperation | Fair matching |
| Mixed population | Adapts to prevailing norm | Resilient performance |
'''

description_COLLECTIVE_95 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume all instances of this strategy will behave identically given the same observations. This allows for implicit coordination without explicit communication. The strategy aims to:

1. **Establish cooperation** when playing with like-minded agents
2. **Protect against exploitation** when facing defectors
3. **Encourage cooperation recovery** through conditional forgiveness

---

## Strategy: Adaptive Threshold Cooperation (ATC)

### Key Concepts

**Cooperation Ratio (CR)**: The fraction of cooperative actions observed in the previous round.
```
CR(t) = (number of C plays in round t) / n
```

**Historical Cooperation Trend (HCT)**: Exponentially weighted moving average of cooperation ratios.
```
HCT(t) = α × CR(t) + (1-α) × HCT(t-1), where α = 0.4
```

**Adaptive Threshold (AT)**: The minimum cooperation level required to continue cooperating.
```
AT = (n - k) / n
```
This threshold represents the break-even point where cooperation becomes collectively beneficial. When CR > AT, cooperators earn at least as much as they would from universal defection.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Start with goodwill to enable coordination with other cooperative agents. The cost of one round of potential exploitation is worth the benefit of establishing mutual cooperation.

### Rounds 2 through (r-1): Conditional Cooperation

**COOPERATE if ANY of the following conditions are met:**

1. **High Recent Cooperation**: CR(t-1) ≥ AT
   - Continue cooperating when enough others cooperate to make it worthwhile

2. **Recovering Cooperation**: HCT(t-1) ≥ AT AND CR(t-1) ≥ AT - 0.15
   - Support recovery if the trend is good and recent cooperation isn't too far below threshold

3. **Forgiveness Probe**: (t mod ⌈r/4⌉ == 0) AND (HCT(t-1) ≥ 0.3)
   - Periodically test if cooperation can be re-established
   - Only probe if there's been some historical cooperation

**DEFECT otherwise.**

### Final Round (Round r): Threshold-Based Decision

**COOPERATE if**: HCT(r-1) ≥ 0.7 AND CR(r-1) ≥ AT

**DEFECT otherwise.**

Rationale: In the final round, there's no future benefit to encouraging cooperation. However, if we're in a highly cooperative environment (likely playing with similar strategies), maintaining cooperation maximizes collective payoff.

---

## Pseudocode

```
function decide(round, history, n, k, r):
    AT = (n - k) / n  # Adaptive threshold
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate metrics
    CR_prev = count_cooperators(history[round-1]) / n
    HCT = calculate_HCT(history, alpha=0.4)
    
    # Final round logic
    if round == r:
        if HCT >= 0.7 AND CR_prev >= AT:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    # Condition 1: High recent cooperation
    if CR_prev >= AT:
        return COOPERATE
    
    # Condition 2: Recovering cooperation
    if HCT >= AT AND CR_prev >= (AT - 0.15):
        return COOPERATE
    
    # Condition 3: Forgiveness probe
    probe_interval = ceil(r / 4)
    if (round mod probe_interval == 0) AND (HCT >= 0.3):
        return COOPERATE
    
    # Default: Defect
    return DEFECT
```

---

## Edge Case Handling

| Scenario | Behavior | Rationale |
|----------|----------|-----------|
| **n = 2** | AT = (2-k)/2; strategy applies normally | Reduces to near-Tit-for-Tat dynamics |
| **k very close to n** | AT approaches 0; more forgiving | Low threshold because cooperation is highly efficient |
| **k very close to 1** | AT approaches 1; strict threshold | High threshold because cooperation barely beats defection |
| **All defect round 1** | Probe for recovery on schedule | Don't permanently abandon cooperation |
| **r = 2** | Cooperate R1, apply final-round logic R2 | Minimal game still attempts coordination |
| **Single defector among cooperators** | Continue cooperating if CR ≥ AT | Don't overreact to one defector |

---

## Why This Strategy Works Collectively

1. **Implicit Coordination**: All instances start with C and have identical thresholds, so a group of ATC players will establish and maintain full cooperation.

2. **Robustness to Defectors**: The threshold mechanism ensures we don't keep cooperating when too many others defect—limiting exploitation.

3. **Forgiveness Enables Recovery**: Periodic probes and the recovery condition allow cooperation to restart after temporary breakdowns.

4. **Parameter Adaptivity**: The threshold AT = (n-k)/n automatically adjusts to game economics—stricter when cooperation is barely beneficial, more forgiving when it's highly efficient.

5. **Final Round Nuance**: By cooperating in the final round with proven cooperators, we maximize collective payoff rather than individually defecting and destroying mutual gains.
'''

description_COLLECTIVE_94 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players reason similarly and cooperate, everyone achieves the best collective outcome (payoff of k per round vs. 1 for mutual defection). The strategy aims to **sustain cooperation when possible** while **protecting against exploitation** and **signaling cooperative intent clearly**.

## Strategy Overview: "Generous Threshold Tit-for-Tat with Endgame Awareness"

The strategy monitors the **cooperation rate** of the group and responds proportionally, starting optimistically and adjusting based on observed behavior.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. In a collective mindset, we must give cooperation a chance to establish itself. The cost of one round of potential exploitation is small compared to the value of establishing mutual cooperation.

### Rounds 2 through (r-2): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Rule:**
- If `coop_rate ≥ threshold`, then **COOPERATE**
- If `coop_rate < threshold`, then **DEFECT**

**Threshold Calculation:**
```
base_threshold = 0.5
adjustment = 0.1 × (rounds_of_high_cooperation - rounds_of_low_cooperation) / rounds_played
threshold = max(0.3, min(0.7, base_threshold - adjustment))
```

Where:
- `rounds_of_high_cooperation` = rounds where coop_rate ≥ 0.6
- `rounds_of_low_cooperation` = rounds where coop_rate < 0.4

This makes the threshold **adaptive**: in cooperative environments, we become slightly more forgiving; in hostile environments, we become slightly stricter (but never unreasonably so).

### Forgiveness Mechanism
Even when below threshold, cooperate with probability:
```
forgiveness_probability = 0.1 × (remaining_rounds / total_rounds)
```

This allows for recovery from temporary breakdowns and signals continued willingness to cooperate. Forgiveness decreases as the game progresses (less time to recover investment).

### Round (r-1): Second-to-Last Round
**Follow the same adaptive rules as middle rounds.**

Rationale: Defecting early signals to others that endgame exploitation is beginning, potentially collapsing cooperation prematurely.

### Round r: Final Round
**Mirror the majority action from round (r-1):**
- If `coop_rate_{r-1} ≥ 0.5`, then **COOPERATE**
- Otherwise, **DEFECT**

Rationale: In a collective mindset, if the group has maintained cooperation, honor that. If cooperation has already collapsed, there's no value in unilateral sacrifice.

---

## Pseudocode

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    # Calculate previous round statistics
    prev_coop_count = count_cooperators(history, round - 1)
    coop_rate = prev_coop_count / n
    
    # Final round: mirror majority
    if round == r:
        if coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Calculate adaptive threshold
    high_coop_rounds = count_rounds_where(history, coop_rate >= 0.6)
    low_coop_rounds = count_rounds_where(history, coop_rate < 0.4)
    rounds_played = round - 1
    
    adjustment = 0.1 * (high_coop_rounds - low_coop_rounds) / rounds_played
    threshold = clamp(0.5 - adjustment, 0.3, 0.7)
    
    # Main decision
    if coop_rate >= threshold:
        return COOPERATE
    
    # Forgiveness chance
    forgiveness_prob = 0.1 * (r - round) / r
    if random() < forgiveness_prob:
        return COOPERATE
    
    return DEFECT
```

---

## Key Properties

1. **Collectively optimal**: If all players use this strategy, cooperation is sustained through round r, achieving near-maximum collective payoff.

2. **Robust to defectors**: The threshold mechanism withdraws cooperation when too many defect, limiting exploitation.

3. **Forgiving**: Random forgiveness and adaptive thresholds allow recovery from noise or temporary breakdowns.

4. **Clear signaling**: Unconditional first-round cooperation clearly signals intent.

5. **No endgame collapse**: By cooperating in the final round when others do, we avoid the backward-induction trap that destroys cooperation in finite games.
'''

description_COLLECTIVE_96 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we assume all instances of this strategy will behave identically given the same history and parameters. Our goal is to maximize collective welfare while protecting against exploitation by defectors. The key insight is that with k > 1, universal cooperation yields higher total payoffs than universal defection, but we must be robust to mixed populations.

## Strategy: **Adaptive Collective Reciprocity (ACR)**

### Decision Framework

The strategy uses three key metrics computed from history:
1. **Cooperation Rate (CR)**: Fraction of cooperative actions observed in the previous round
2. **Cooperation Trend (CT)**: Whether cooperation is increasing, stable, or declining
3. **Exploitation Risk (ER)**: Degree to which cooperators are being exploited

### Pseudocode

```
function decide(n, k, r, current_round, history):
    
    # === FIRST ROUND ===
    if current_round == 1:
        return COOPERATE  # Signal cooperative intent
    
    # === LAST ROUND ===
    if current_round == r:
        # Cooperate only if sustained high cooperation throughout
        overall_cooperation_rate = total_C_actions / total_actions
        if overall_cooperation_rate >= 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # === MIDDLE ROUNDS ===
    
    # Calculate metrics from previous round
    prev_cooperators = count_cooperators(history[current_round - 1])
    cooperation_rate = prev_cooperators / n
    
    # Calculate cooperation trend (last 3 rounds or available history)
    trend = calculate_trend(history, window=min(3, current_round-1))
    
    # Calculate threshold based on game parameters
    # Higher k/n ratio means cooperation is more beneficial
    efficiency_ratio = k / n
    base_threshold = 0.5 - (efficiency_ratio * 0.3)  # Range roughly 0.2-0.5
    base_threshold = max(0.2, min(0.6, base_threshold))
    
    # Adjust threshold based on game progress
    # Be more forgiving early, stricter late
    progress = current_round / r
    if progress < 0.3:
        threshold = base_threshold * 0.8  # More lenient early
    elif progress > 0.7:
        threshold = base_threshold * 1.2  # Stricter late
    else:
        threshold = base_threshold
    
    # === DECISION LOGIC ===
    
    # High cooperation environment: maintain cooperation
    if cooperation_rate >= threshold:
        return COOPERATE
    
    # Declining cooperation: try to recover if not too late
    if cooperation_rate < threshold and trend == DECLINING:
        if progress < 0.5 and cooperation_rate >= threshold * 0.6:
            return COOPERATE  # Give benefit of doubt early
        else:
            return DEFECT  # Protect against collapse
    
    # Low cooperation but improving: reward the trend
    if cooperation_rate < threshold and trend == INCREASING:
        return COOPERATE  # Encourage recovery
    
    # Low cooperation, stable: defect but check for recovery opportunity
    if cooperation_rate < threshold and trend == STABLE:
        # Periodic forgiveness: try cooperation every few rounds
        forgiveness_interval = max(2, r // 5)
        if current_round % forgiveness_interval == 0:
            return COOPERATE
        else:
            return DEFECT
    
    # Default: match the majority behavior
    if cooperation_rate >= 0.5:
        return COOPERATE
    else:
        return DEFECT

function calculate_trend(history, window):
    if window < 2:
        return STABLE
    
    rates = [count_cooperators(round) / n for round in history[-window:]]
    
    if rates[-1] - rates[0] > 0.15:
        return INCREASING
    elif rates[0] - rates[-1] > 0.15:
        return DECLINING
    else:
        return STABLE
```

### Decision Rules Summary

| Round | Condition | Action |
|-------|-----------|--------|
| First | Always | **Cooperate** |
| Last | High historical cooperation (≥70%) | **Cooperate** |
| Last | Low historical cooperation (<70%) | **Defect** |
| Middle | Cooperation rate ≥ threshold | **Cooperate** |
| Middle | Rate < threshold, trend improving | **Cooperate** |
| Middle | Rate < threshold, early game | **Cooperate** (forgiveness) |
| Middle | Rate < threshold, declining/late | **Defect** |
| Middle | Periodic forgiveness interval | **Cooperate** |

### Edge Cases

1. **n = 2**: Strategy behaves like generous Tit-for-Tat
2. **Very short games (r ≤ 3)**: Always cooperate (insufficient rounds to punish)
3. **k very close to n**: Lower cooperation threshold (high efficiency)
4. **k very close to 1**: Higher cooperation threshold (low efficiency)

### Why This Strategy is Collectively Aligned

- **Starts cooperative**: Establishes trust, maximizes collective payoff if others reciprocate
- **Responds to the group**: Doesn't unilaterally defect; follows collective behavior
- **Forgives**: Periodic cooperation attempts allow recovery from mutual defection
- **Protects the collective**: Withdraws cooperation when exploitation is evident
- **Rewards positive trends**: Encourages movement toward cooperation
'''

description_COLLECTIVE_95 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I aim to maximize group welfare while protecting against exploitation. The key insight is that mutual cooperation yields the best collective outcome (payoff of k > 1 for everyone), but this requires building and maintaining trust in an environment where defection is individually tempting.

My approach: **Start cooperatively, respond proportionally to group behavior, and strategically signal commitment to cooperation.**

---

## Strategy: Proportional Collective Reciprocity (PCR)

### Decision Framework

The strategy tracks the **cooperation rate** of the group in previous rounds and uses this to make probabilistic cooperation decisions that reward collective cooperation while punishing widespread defection.

---

### Detailed Decision Rules

#### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- **Rationale**: Signal cooperative intent, establish baseline for measuring others' behavior, and give the collective a chance to coordinate on the efficient outcome.

#### Rounds 2 through (r-1): Adaptive Proportional Response

Calculate the **group cooperation rate** from the previous round:
```
prev_coop_rate = (number of players who cooperated in round t-1) / n
```

**Decision Rule:**
```
If prev_coop_rate >= (n-1)/n:      # Near-universal cooperation
    COOPERATE with probability 1.0
    
Elif prev_coop_rate >= 0.5:        # Majority cooperating
    COOPERATE with probability = prev_coop_rate
    
Elif prev_coop_rate > 0:           # Some cooperation exists
    COOPERATE with probability = prev_coop_rate × 0.8
    
Else (prev_coop_rate == 0):        # Complete defection
    COOPERATE with probability = 0.15  # Olive branch
```

**Forgiveness Mechanism:**
If cooperation rate has been *increasing* for 2+ consecutive rounds:
```
Boost cooperation probability by 0.1 (capped at 1.0)
```

#### Final Round (Round r): Conditional Cooperation

Calculate **cumulative cooperation rate** across all previous rounds:
```
cumulative_rate = (total cooperations by all players) / (n × (r-1))
```

**Decision Rule:**
```
If cumulative_rate >= 0.6:
    COOPERATE  # Reward sustained collective cooperation
Else:
    DEFECT     # Don't sacrifice for an uncooperative group
```

---

### Pseudocode Implementation

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history[round - 1])
    prev_coop_rate = prev_cooperators / n
    
    # Check if final round
    if round == r:
        total_coops = sum(count_cooperators(history[t]) for t in 1 to r-1)
        cumulative_rate = total_coops / (n * (r - 1))
        if cumulative_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: proportional response
    if prev_coop_rate >= (n-1)/n:
        coop_prob = 1.0
    elif prev_coop_rate >= 0.5:
        coop_prob = prev_coop_rate
    elif prev_coop_rate > 0:
        coop_prob = prev_coop_rate * 0.8
    else:
        coop_prob = 0.15  # Olive branch
    
    # Forgiveness bonus: reward improving trends
    if round >= 3:
        rate_t1 = count_cooperators(history[round-2]) / n
        rate_t2 = count_cooperators(history[round-1]) / n
        if rate_t2 > rate_t1 and rate_t1 > count_cooperators(history[round-3])/n:
            coop_prob = min(1.0, coop_prob + 0.1)
    
    # Probabilistic decision
    if random() < coop_prob:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Establishes cooperative norms**: Starting with cooperation signals intent and creates opportunity for mutual benefit.

2. **Mirrors group behavior**: Proportional response means the strategy naturally adapts to the population—cooperating more in cooperative environments, protecting itself in hostile ones.

3. **Avoids collapse spirals**: The "olive branch" probability (15% cooperation even after total defection) allows recovery from mutual defection traps.

4. **Rewards improvement**: The forgiveness bonus encourages and reinforces positive trends in group behavior.

5. **Principled endgame**: Final round cooperation based on cumulative history avoids both naive exploitation and cynical defection—it rewards groups that have demonstrated sustained cooperation.

6. **Robust to diversity**: Works whether facing other cooperative strategies, tit-for-tat variants, or mixed populations.
'''

description_COLLECTIVE_97 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I assume I am one of many agents running this same strategy. Our goal is to maximize collective welfare while protecting against exploitation by defectors. The key insight is that cooperation is collectively rational (payoff of k > 1 when all cooperate) but individually tempting to defect on. We must coordinate implicit cooperation while responding proportionally to defection.

## Strategy: **Proportional Collective Reciprocity (PCR)**

### Decision Framework

The strategy tracks the **cooperation rate** in the population and mirrors it, with a bias toward cooperation to sustain collective benefits.

---

### Round-by-Round Decision Rules

#### **Round 1: Cooperate**
- Begin with cooperation to signal cooperative intent
- This establishes a baseline for observing others' behavior

#### **Rounds 2 through (r-1): Proportional Response with Cooperative Bias**

Calculate the **observed cooperation rate** from the previous round:
```
coop_rate = (number of C plays in previous round) / n
```

**Decision rule:**
```
If coop_rate >= (n-1)/n:
    Cooperate (near-universal cooperation maintained)
    
Else if coop_rate >= 0.5:
    Cooperate with probability = coop_rate + 0.1
    (Bias toward sustaining cooperation)
    
Else if coop_rate > 0:
    Cooperate with probability = coop_rate
    (Mirror the population exactly when cooperation is fragile)
    
Else (coop_rate == 0):
    Defect (no point cooperating alone when k < n)
```

**Forgiveness mechanism:** Every `floor(r/4)` rounds, if currently set to defect, cooperate with probability 0.2 to test if cooperation can be restored.

#### **Final Round (Round r): Conditional Cooperation**

The last round lacks future enforcement, but:
```
If coop_rate in round (r-1) >= 0.7:
    Cooperate (reward sustained cooperation, assume collective strategy)
Else:
    Defect (no future rounds to recover losses)
```

---

### Pseudocode

```python
def decide(round_number, r, n, k, history):
    
    if round_number == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_round_actions = history[round_number - 1]
    coop_rate = sum(prev_round_actions) / n  # Assuming C=1, D=0
    
    # Final round logic
    if round_number == r:
        if coop_rate >= 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Proportional response with cooperative bias
    if coop_rate >= (n - 1) / n:
        return COOPERATE
    
    elif coop_rate >= 0.5:
        threshold = min(coop_rate + 0.1, 1.0)
        return COOPERATE if random() < threshold else DEFECT
    
    elif coop_rate > 0:
        # Forgiveness probe
        if round_number % max(1, r // 4) == 0:
            return COOPERATE if random() < 0.2 else (COOPERATE if random() < coop_rate else DEFECT)
        return COOPERATE if random() < coop_rate else DEFECT
    
    else:  # coop_rate == 0
        # Forgiveness probe even at zero cooperation
        if round_number % max(1, r // 4) == 0:
            return COOPERATE if random() < 0.15 else DEFECT
        return DEFECT
```

---

### Why This Strategy Works Collectively

1. **Self-reinforcing among copies**: If most players use PCR, initial cooperation triggers sustained cooperation (coop_rate stays high → everyone cooperates)

2. **Robust to defectors**: Proportional response means defectors reduce the cooperation they receive, but don't collapse the entire system

3. **Forgiveness enables recovery**: Periodic cooperation attempts can restart cooperation if temporary defection occurred

4. **No exploitation of cooperators**: We never cooperate unconditionally after observing significant defection

5. **Final round cooperation among collective**: Unlike purely selfish strategies that always defect in round r, we maintain cooperation if the group has been cooperative—maximizing collective payoff
'''

description_COLLECTIVE_96 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we assume all instances of this strategy will behave identically given the same information. Rather than thinking "what should I do?", we think "what should WE all do?" This transforms the coordination problem—if all strategy instances cooperate together, we all benefit from the multiplied public good.

The key insight is that with k > 1, universal cooperation yields k > 1 per player, while universal defection yields exactly 1. Our goal is to establish and maintain cooperation while protecting against exploitation.

---

## Strategy: "Collective Threshold with Forgiveness"

### Decision Framework

**Round 1: Unconditional Cooperation**
- Always play **C** in round 1
- Rationale: Signals cooperative intent, allows us to assess the population, and if all strategy instances cooperate, we immediately establish the beneficial equilibrium

**Rounds 2 through (r-1): Conditional Cooperation Based on Cooperation Rate**

Calculate the cooperation rate from the previous round:
```
coop_rate = (number of C plays in previous round) / n
```

**Decision Rule:**
```
threshold = max(0.3, (n - k) / n)

IF coop_rate >= threshold:
    Play C
ELSE IF coop_rate >= threshold - 0.15 AND this is a "forgiveness round":
    Play C  (give benefit of doubt)
ELSE:
    Play D
```

**Forgiveness Mechanism:**
- Every 3rd round (rounds 3, 6, 9, ...) is a "forgiveness round"
- On forgiveness rounds, we lower our threshold slightly and cooperate
- This allows recovery from temporary defection spirals and re-tests the population

**Trend Adjustment:**
```
IF cooperation has increased for 2+ consecutive rounds:
    Lower threshold by 0.1 (more forgiving, reward positive momentum)
IF cooperation has decreased for 2+ consecutive rounds:
    Raise threshold by 0.1 (more cautious)
```

**Final Round (Round r): Conditional Based on History**

```
avg_coop_rate = average cooperation rate across all previous rounds

IF avg_coop_rate >= 0.6:
    Play C  (reward sustained cooperation, maintain collective benefit)
ELSE:
    Play D  (population proved uncooperative)
```

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return C
    
    # Calculate previous round cooperation rate
    prev_coop_count = count_cooperators(history, round - 1)
    coop_rate = prev_coop_count / n
    
    # Base threshold: ensures cooperation is profitable
    # When coop_rate >= (n-k)/n, a cooperator gets at least 1
    base_threshold = max(0.3, (n - k) / n)
    
    # Trend adjustment
    trend = calculate_trend(history)  # +1 if rising, -1 if falling, 0 otherwise
    trend_adjustment = -0.1 if trend > 0 else (0.1 if trend < 0 else 0)
    
    threshold = clamp(base_threshold + trend_adjustment, 0.2, 0.8)
    
    # Final round logic
    if round == r:
        avg_coop = average_cooperation_rate(history)
        return C if avg_coop >= 0.6 else D
    
    # Forgiveness round check
    is_forgiveness_round = (round % 3 == 0)
    forgiveness_bonus = 0.15 if is_forgiveness_round else 0
    
    # Main decision
    if coop_rate >= threshold - forgiveness_bonus:
        return C
    else:
        return D
```

---

## Why This Strategy Works Collectively

1. **Self-coordination**: If all instances use this strategy, round 1 produces 100% cooperation, which exceeds any threshold, leading to perpetual cooperation and maximum collective payoff.

2. **Robust to mixed populations**: The threshold ensures we don't cooperate into a void. If too few others cooperate, we protect ourselves.

3. **Recovery mechanism**: Forgiveness rounds prevent permanent defection spirals from temporary fluctuations.

4. **Adaptive**: Trend adjustment rewards improving cooperation and guards against deterioration.

5. **Final round cooperation**: Unlike purely selfish strategies that always defect in the last round, we maintain cooperation if the population has been cooperative—this is both collectively optimal and rewards good behavior.

---

## Edge Cases Handled

| Situation | Behavior |
|-----------|----------|
| n = 2 | Works normally; threshold ≈ 0.3-0.5 depending on k |
| r = 2 | Cooperate round 1, apply final-round rule in round 2 |
| k very close to 1 | Higher threshold (near 1), more cautious |
| k close to n | Lower threshold, more cooperative |
| All others defect | Defect after round 1 (self-protection) |
| All others cooperate | Perpetual cooperation |
'''

description_COLLECTIVE_98 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that mutual cooperation yields the best collective outcome (payoff of k > 1 for everyone) compared to mutual defection (payoff of 1 for everyone). My goal is to establish and maintain cooperation while protecting against exploitation. I treat my actions as contributing to a cooperative equilibrium that benefits all participants who share this orientation.

## Strategy Overview: **Graduated Reciprocity with Collective Anchoring**

The strategy combines three key elements:
1. **Optimistic initiation** - Start cooperatively to signal willingness to collaborate
2. **Proportional reciprocity** - Mirror the cooperation level of the group
3. **Forgiveness with boundaries** - Allow recovery from defection but protect against persistent free-riding

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: With no history, I signal cooperative intent. This gives the collective the best chance to establish mutual cooperation from the start.

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

**Decision Rule:**

```
IF coop_rate >= (n-1)/n THEN
    COOPERATE  // Near-universal cooperation: maintain it
    
ELSE IF coop_rate >= 0.5 THEN
    // Majority cooperating: probabilistically match
    COOPERATE with probability = coop_rate
    
ELSE IF coop_rate > 0 THEN
    // Minority cooperating: give one more chance
    IF (cooperation rate has increased from t-2 to t-1) THEN
        COOPERATE  // Reward improving trend
    ELSE
        DEFECT  // Protect against exploitation
        
ELSE  // coop_rate == 0
    // Complete defection: attempt periodic restart
    IF (round number) mod floor(r/4) == 0 THEN
        COOPERATE  // Periodic olive branch
    ELSE
        DEFECT
```

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which predicts universal defection in the final round, I maintain collective orientation:

```
IF (average cooperation rate over all previous rounds) >= 0.6 THEN
    COOPERATE  // Honor established cooperative norm
ELSE
    DEFECT  // No cooperative norm was established
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | Cooperate both rounds unless round 1 had 0 cooperators | Maximize chance for mutual benefit |
| n = 2 (minimum players) | Treat as iterated Prisoner's Dilemma; use tit-for-tat | Direct reciprocity is clearest signal |
| k very close to 1 | Strategy unchanged | Even small collective gains matter |
| k very close to n | Strategy unchanged | Higher stakes don't change principles |
| All previous rounds had 0 cooperation | Attempt restart every ⌊r/4⌋ rounds | Never fully abandon hope |

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n_players, history):
    
    if round_num == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history[-1]) / n_players
    
    if round_num == total_rounds:  # Final round
        avg_coop = average_cooperation_rate(history)
        return COOPERATE if avg_coop >= 0.6 else DEFECT
    
    # Middle rounds
    if prev_coop_rate >= (n_players - 1) / n_players:
        return COOPERATE
    elif prev_coop_rate >= 0.5:
        return COOPERATE with probability prev_coop_rate
    elif prev_coop_rate > 0:
        if len(history) >= 2 and cooperation_increased(history):
            return COOPERATE
        else:
            return DEFECT
    else:  # prev_coop_rate == 0
        if round_num % max(1, total_rounds // 4) == 0:
            return COOPERATE
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Starts with trust**: Opening cooperation demonstrates commitment to collective welfare
2. **Rewards cooperation**: High cooperation is matched, reinforcing positive norms
3. **Proportional response**: Doesn't overreact to isolated defections
4. **Forgiveness**: Allows recovery from coordination failures
5. **Final-round integrity**: Maintains cooperation even when "rational" defection would go unpunished
6. **Resilient hope**: Periodic cooperation attempts even in hostile environments

This strategy aims to be a good citizen in a population of cooperators while remaining robust against exploitation by persistent defectors.
'''

description_COLLECTIVE_97 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embodies a **collective mindset**: we assume all players using this strategy will reason identically and reach the same conclusions given the same information. This creates implicit coordination without explicit communication. The strategy balances three objectives:

1. **Establish cooperation** when conditions are favorable
2. **Protect against exploitation** by defectors
3. **Maximize collective welfare** across all rounds

## Strategy Overview

The strategy uses **conditional cooperation with graduated response**, adapting to the observed cooperation level in the population while accounting for game parameters and temporal position.

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: With no history, we signal cooperative intent. If other collective-minded players exist, this establishes mutual cooperation from the start.

### Middle Rounds (2 to r-1): Adaptive Threshold Cooperation

Calculate the **cooperation ratio** from the previous round:
```
coop_ratio = (number of cooperators in round t-1) / n
```

Calculate the **threshold** based on game parameters:
```
base_threshold = 1/k
adjusted_threshold = base_threshold × (1 - 0.5 × (rounds_remaining / r))
```

**Decision Rule:**
- If `coop_ratio ≥ adjusted_threshold`: **COOPERATE**
- If `coop_ratio < adjusted_threshold`: **DEFECT**

**Forgiveness Mechanism:**
After defecting, if the cooperation ratio increases for 2 consecutive rounds, return to **COOPERATE** regardless of threshold.

### Last Round: Conditional Cooperation

Unlike standard game theory advice to defect in the final round, we maintain collective thinking:

```
If average_cooperation_rate_over_all_rounds ≥ 0.5:
    COOPERATE
Else:
    DEFECT
```

Rationale: If most players have cooperated throughout, they likely share our collective mindset and will also cooperate in the final round. Mutual cooperation yields higher payoffs than mutual defection.

---

## Detailed Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate to establish trust
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation statistics
    last_round_cooperators = count_cooperators(history[round-1])
    coop_ratio = last_round_cooperators / n
    
    # Calculate average cooperation over all history
    total_cooperations = sum(count_cooperators(h) for h in history)
    avg_coop_rate = total_cooperations / (n × (round - 1))
    
    # Last round decision
    if round == r:
        if avg_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: threshold-based decision
    rounds_remaining = r - round
    base_threshold = 1 / k
    adjusted_threshold = base_threshold × (1 - 0.5 × (rounds_remaining / r))
    
    # Forgiveness check: if we defected but cooperation is recovering
    if my_last_action == DEFECT:
        if round >= 3:
            prev_coop = count_cooperators(history[round-2]) / n
            curr_coop = coop_ratio
            if curr_coop > prev_coop and curr_coop >= base_threshold:
                return COOPERATE
    
    # Main threshold decision
    if coop_ratio >= adjusted_threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Standard rules apply | Reduces to 2-player iterated dilemma |
| k very close to 1 | Higher threshold, quicker to defect | Cooperation benefit is marginal |
| k close to n | Lower threshold, more forgiving | Cooperation is highly valuable |
| r = 2 | Cooperate both rounds if partner cooperated | Minimal history; trust collective mindset |
| All others defected round 1 | Defect round 2, but forgive if recovery | Protect against pure defector populations |

---

## Why This Strategy Works Collectively

1. **Identical reasoning**: All players using this strategy compute the same thresholds and see the same history, ensuring synchronized decisions.

2. **Self-reinforcing cooperation**: When collective players meet, round 1 cooperation leads to continued cooperation through all middle rounds and the final round.

3. **Robust to defectors**: The threshold mechanism means a minority of defectors won't collapse cooperation, but a majority will trigger protective defection.

4. **Parameter-adaptive**: The threshold scales with k, ensuring appropriate sensitivity to the game's incentive structure.
'''

description_COLLECTIVE_99 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume all copies of this strategy will behave identically given the same game state. This means I'm not playing against "opponents" but coordinating with potential allies while being robust to defectors. The key insight is that cooperation is collectively optimal (everyone gets k > 1 when all cooperate vs. 1 when all defect), but we must protect against exploitation.

## Strategy: **Adaptive Collective Reciprocity (ACR)**

### Key Variables to Track

- `cooperation_rate`: Rolling average of cooperation across all players in recent rounds
- `round_number`: Current round (1-indexed)
- `total_rounds`: r
- `n`: Number of players
- `k`: Multiplication factor

### Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: We cannot assess others without history. Starting cooperatively signals good faith and allows collective strategies to identify each other. The potential gain from mutual cooperation outweighs first-round exploitation risk.

---

#### Rounds 2 through (r-1): Adaptive Threshold Cooperation

Calculate the **cooperation rate** from the previous round:
```
prev_cooperation_rate = (number of C plays in previous round) / n
```

Calculate a **cooperation threshold** that adapts based on game economics:
```
base_threshold = 1/k  # Economic breakeven point
adjusted_threshold = base_threshold * (0.5 + 0.5 * (rounds_remaining / total_rounds))
```

**Decision Rule:**
```
IF prev_cooperation_rate >= adjusted_threshold:
    COOPERATE
ELSE:
    DEFECT
```

**Rationale:** 
- The threshold `1/k` represents where expected returns from cooperation become positive
- Early rounds use a more forgiving threshold (we give cooperation more chances)
- As rounds progress, we become stricter, protecting against late-game exploitation
- This creates a gradient: high cooperation environments sustain cooperation; low cooperation environments trigger collective withdrawal

---

#### Final Round (round r): Conditional Cooperation Based on History

Calculate **overall cooperation rate** across all previous rounds:
```
historical_cooperation_rate = (total C plays across all rounds) / (n * (r-1))
```

**Decision Rule:**
```
IF historical_cooperation_rate >= 0.6:
    COOPERATE  # Reward a cooperative game with continued cooperation
ELSE:
    DEFECT     # Standard game-theoretic response to a defecting population
```

**Rationale:** Unlike typical strategies that always defect in the final round, we maintain cooperation if the game has been predominantly cooperative. This:
1. Rewards populations that cooperated throughout
2. Maximizes collective payoff when playing with other collective strategies
3. Only reverts to defection when facing clear defectors

---

### Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    prev_coop_count = count_cooperators(history, round - 1)
    prev_coop_rate = prev_coop_count / n
    
    if round == r:  # Final round
        total_coop = sum(count_cooperators(history, t) for t in 1 to r-1)
        historical_rate = total_coop / (n * (r - 1))
        if historical_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    rounds_remaining = r - round
    base_threshold = 1 / k
    adjusted_threshold = base_threshold * (0.5 + 0.5 * (rounds_remaining / r))
    
    if prev_coop_rate >= adjusted_threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

### Edge Case Handling

| Scenario | Action | Reason |
|----------|--------|--------|
| r = 2 (minimum rounds) | R1: Cooperate, R2: Use final round rule | Maintains structure even with minimal repetition |
| n = 2 (minimum players) | Strategy works unchanged | Threshold adapts naturally |
| k very close to 1 | Higher threshold → more likely to defect | Economically rational given low returns |
| k close to n | Lower threshold → more forgiving | High returns justify cooperation risk |
| All others defect R1 | Defect R2 onwards | Protects against full defection |
| Mixed population | Tracks aggregate behavior | Responds to collective trend, not individuals |

---

### Why This Strategy is Collectively Optimal

1. **Self-recognition**: All copies start cooperating and continue cooperating when others do → mutual cooperation equilibrium
2. **Exploitation resistance**: Quick collective withdrawal when facing defectors
3. **Forgiveness built-in**: The threshold system allows recovery if defectors reform
4. **Parameter adaptive**: Works across all valid (n, k, r) combinations without manual tuning
5. **No coordination required**: Each copy independently reaches the same decision given the same history
'''

description_COLLECTIVE_98 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I act as if I'm one instance of a shared strategy that all players *could* be using. The goal is to establish and maintain cooperation when others are willing, while protecting against exploitation. I prioritize collective welfare but adapt based on observed behavior.

## Strategy Overview: **Adaptive Collective Reciprocity (ACR)**

The strategy operates on three principles:
1. **Optimistic initiation**: Start cooperatively to signal willingness and test the waters
2. **Proportional reciprocity**: Match the cooperation level of the group
3. **Forgiveness with memory**: Allow recovery from defection but track patterns

---

## Decision Rules

### Round 1: Cooperate
- Begin with cooperation to establish a cooperative norm
- This signals good faith and allows assessment of others' intentions

### Middle Rounds (2 to r-1):

**Calculate the Group Cooperation Rate (GCR):**
```
GCR = (total cooperations by all players in previous round) / n
```

**Calculate Personal Cooperation Threshold (PCT):**
```
base_threshold = (n - k) / n    # Point where cooperation becomes beneficial if matched
adjusted_threshold = base_threshold - forgiveness_bonus

forgiveness_bonus = 0.1 × (rounds_since_last_defection / r)
# Increases willingness to cooperate as time passes without defection
```

**Decision Rule:**
```
IF GCR >= adjusted_threshold:
    COOPERATE
ELSE IF GCR >= 0.5 AND trend_improving:
    COOPERATE  # Give benefit of doubt if cooperation is rising
ELSE:
    DEFECT
```

**Trend Detection:**
```
trend_improving = (GCR_current_round > GCR_two_rounds_ago)
# Only applies from round 3 onward
```

### Last Round (r):

The last round presents a classic defection temptation. However, maintaining collective mindset:

```
IF average_GCR_over_all_rounds >= 0.7:
    COOPERATE  # Reward sustained cooperation, maintain collective outcome
ELSE IF GCR_previous_round >= 0.8:
    COOPERATE  # Honor recent strong cooperation
ELSE:
    DEFECT     # No established norm worth protecting
```

---

## Edge Cases

### Two-Player Game (n=2):
- Simplifies to iterated Prisoner's Dilemma
- Use standard Tit-for-Tat with forgiveness: cooperate if opponent cooperated last round OR if they've cooperated ≥50% of all rounds

### Very Short Games (r ≤ 3):
- Round 1: Cooperate
- Round 2: Mirror majority action from round 1
- Round 3 (if exists): Cooperate if round 2 had ≥50% cooperation

### High Multiplication Factor (k close to n):
- Cooperation is nearly dominant; bias toward cooperation
- Reduce threshold: `adjusted_threshold = max(0.2, base_threshold - 0.2)`

### Low Multiplication Factor (k close to 1):
- Cooperation provides minimal benefit; be more cautious
- Increase threshold: `adjusted_threshold = min(0.8, base_threshold + 0.1)`

### Unanimous Defection Observed:
- If all other players defected last round, defect this round
- But attempt cooperation again every `ceil(r/5)` rounds to test for recovery

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    GCR = count_cooperations(history, round-1) / n
    historical_avg = average_GCR(history)
    
    # Last round logic
    if round == r:
        if historical_avg >= 0.7 OR GCR >= 0.8:
            return COOPERATE
        else:
            return DEFECT
    
    # Calculate threshold
    base_threshold = (n - k) / n
    rounds_since_defection = rounds_since_GCR_below(history, 0.5)
    forgiveness_bonus = 0.1 * (rounds_since_defection / r)
    threshold = base_threshold - forgiveness_bonus
    
    # Adjust for k extremes
    if k > 0.8 * n: threshold = max(0.2, threshold - 0.2)
    if k < 1.2: threshold = min(0.8, threshold + 0.1)
    
    # Trend detection (from round 3+)
    trend_improving = (round >= 3) AND (GCR > GCR_at(history, round-2))
    
    # Decision
    if GCR >= threshold:
        return COOPERATE
    else if GCR >= 0.5 AND trend_improving:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Starts cooperatively**: Assumes others may share cooperative intent
2. **Rewards cooperation**: Maintains cooperation when the group does
3. **Proportional response**: Doesn't exploit or get exploited
4. **Forgives**: Allows recovery from temporary breakdowns
5. **Last-round integrity**: Doesn't automatically defect, honoring established norms
6. **Robust**: Adapts to game parameters and opponent behavior without requiring coordination
'''

description_COLLECTIVE_100 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **we succeed together or fail together**. Rather than optimizing individual payoff in isolation, I recognize that if all players adopt cooperative strategies, everyone achieves the superior outcome (payoff of k vs 1). The strategy aims to establish and maintain cooperation while protecting against exploitation.

## Strategy Name: **Generous Threshold Reciprocity (GTR)**

### Key Insight

In an n-player game, I cannot punish specific defectors—I can only respond to the overall cooperation level. This strategy uses a **cooperation threshold** that adapts based on observed group behavior, starting optimistically and adjusting based on evidence.

---

## Decision Rules

### Parameters Derived from Game Settings

```
base_threshold = 0.5          # Minimum cooperation rate to continue cooperating
forgiveness_rate = 0.1        # Probability of cooperating despite low cooperation
generosity_rounds = max(2, floor(r/10))  # Initial unconditional cooperation period
end_game_rounds = min(3, floor(r/5))     # Final rounds requiring special handling
```

### Round-by-Round Decision Logic

```
function decide(round_number, history):
    
    # PHASE 1: Opening Generosity
    if round_number <= generosity_rounds:
        return COOPERATE
    
    # PHASE 2: End-Game Protection
    if round_number > r - end_game_rounds:
        return end_game_decision(history)
    
    # PHASE 3: Adaptive Reciprocity (main phase)
    return adaptive_decision(history)
```

---

## Detailed Decision Functions

### Adaptive Decision (Main Phase)

```
function adaptive_decision(history):
    
    # Calculate recent cooperation rate (last 3 rounds or all available)
    lookback = min(3, rounds_played)
    recent_coop_rate = average_cooperation_rate(last lookback rounds)
    
    # Calculate overall cooperation rate
    overall_coop_rate = average_cooperation_rate(all rounds)
    
    # Weighted combination (recent matters more)
    effective_rate = 0.7 * recent_coop_rate + 0.3 * overall_coop_rate
    
    # Dynamic threshold adjustment
    # If cooperation has been consistently high, lower threshold (more forgiving)
    # If cooperation has been volatile, raise threshold (more cautious)
    volatility = standard_deviation(cooperation_rates per round)
    adjusted_threshold = base_threshold + (volatility * 0.2)
    adjusted_threshold = clamp(adjusted_threshold, 0.3, 0.7)
    
    # Core decision
    if effective_rate >= adjusted_threshold:
        return COOPERATE
    else:
        # Forgiveness mechanism: occasionally cooperate to test for recovery
        if random() < forgiveness_rate:
            return COOPERATE
        else:
            return DEFECT
```

### End-Game Decision

```
function end_game_decision(history):
    
    # In final rounds, base decision on established group character
    overall_coop_rate = average_cooperation_rate(all rounds)
    
    # If group has been highly cooperative, maintain cooperation
    # (collective commitment to good outcomes)
    if overall_coop_rate >= 0.7:
        return COOPERATE
    
    # If group has been moderately cooperative, use probability matching
    if overall_coop_rate >= 0.4:
        if random() < overall_coop_rate:
            return COOPERATE
        else:
            return DEFECT
    
    # If group has been mostly defecting, defect
    return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| **Round 1** | COOPERATE | Signal cooperative intent; no information yet |
| **Round 2** | COOPERATE | Still in generosity phase; one round insufficient data |
| **r = 2 (minimum)** | COOPERATE both rounds | Too short to meaningfully adapt; commit to cooperation |
| **r = 3** | C, C, then adaptive | One generosity round, one adaptive |
| **All others defected last round** | Apply forgiveness check | Don't permanently abandon hope |
| **n = 2 (minimum players)** | Same strategy applies | Reduces to repeated prisoner's dilemma dynamics |
| **Very large n** | Same strategy applies | Cooperation rate metric scales naturally |

---

## Why This Strategy is Collectively Optimal

1. **Signals cooperative intent early**: The generosity phase establishes trust and allows like-minded strategies to coordinate.

2. **Rewards group cooperation**: By cooperating when others cooperate, we reinforce positive group dynamics.

3. **Protects against exploitation**: By defecting when cooperation falls below threshold, we don't subsidize free-riders indefinitely.

4. **Allows recovery**: The forgiveness mechanism means a group can recover from temporary defection spirals.

5. **Handles uncertainty**: Using recent + overall rates smooths out noise while remaining responsive.

6. **End-game commitment**: By not automatically defecting in final rounds when cooperation has been high, we demonstrate trustworthiness that can bootstrap cooperation in repeated tournament interactions.

---

## Summary

**Cooperate if the group cooperates; give the group chances to cooperate; forgive occasional lapses; protect against systematic exploitation.** This strategy optimizes for the collective outcome while remaining robust against adversarial behavior.
'''

description_COLLECTIVE_99 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **we succeed together or suffer together**. The goal is not to maximize individual advantage over others, but to establish and maintain cooperation that benefits everyone. I will lead by example, forgive mistakes, but protect the collective from persistent exploitation.

## Strategy Overview: "Generous Collective Builder"

The strategy operates on three principles:
1. **Optimistic initiation**: Start cooperatively to signal good faith
2. **Proportional reciprocity**: Match the group's cooperation level generously
3. **Graduated forgiveness**: Give others chances to return to cooperation

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: Cooperate (C)**

Rationale: Someone must take the first step. By cooperating initially, I signal willingness to build collective benefit and give others the opportunity to join.

---

### Middle Rounds (2 through r-1)

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision rule:**

```
If coop_rate >= 0.5:
    Cooperate (C)
    
Else if coop_rate >= k/n:
    # Cooperation is still collectively rational at this level
    # Use probabilistic cooperation to encourage recovery
    Cooperate with probability = coop_rate + 0.2
    (capped at 1.0)
    
Else:
    # Very low cooperation - check for recovery trend
    If cooperation increased from round t-2 to t-1:
        Cooperate (C)  # Reward positive movement
    Else:
        Defect (D)  # Protect against exploitation
```

**Forgiveness mechanism:**
Every 3 rounds, if currently defecting, cooperate anyway to test if others will reciprocate. This prevents permanent collapse from miscoordination.

---

### Final Round (r)

**Decision rule:**

```
Calculate average_coop_rate over all previous rounds

If average_coop_rate >= 0.6:
    Cooperate (C)  # Honor a cooperative history
    
Else if previous round had coop_rate >= 0.5:
    Cooperate (C)  # Maintain recent cooperation
    
Else:
    Defect (D)  # No cooperative foundation to honor
```

Rationale: Unlike purely self-interested strategies that always defect in the final round, I maintain cooperation if the group has demonstrated collective commitment. This rewards groups that cooperated and maintains integrity.

---

## Complete Pseudocode

```python
def decide(round_number, total_rounds, n, k, history):
    """
    history: list of lists, where history[t] contains actions of all n players in round t
    Actions encoded as 1 (Cooperate) or 0 (Defect)
    """
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_rate = sum(history[-1]) / n
    
    # Calculate overall average cooperation rate
    all_actions = [action for round in history for action in round]
    avg_coop_rate = sum(all_actions) / len(all_actions)
    
    # Check if cooperation is trending upward
    if len(history) >= 2:
        prev_prev_coop_rate = sum(history[-2]) / n
        trending_up = prev_coop_rate > prev_prev_coop_rate
    else:
        trending_up = False
    
    # Final round logic
    if round_number == total_rounds:
        if avg_coop_rate >= 0.6 or prev_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    threshold_rational = k / n  # Below this, even full cooperation isn't worth it individually
    
    # High cooperation: maintain it
    if prev_coop_rate >= 0.5:
        return COOPERATE
    
    # Medium cooperation: probabilistically encourage recovery
    if prev_coop_rate >= threshold_rational:
        prob = min(1.0, prev_coop_rate + 0.2)
        return COOPERATE if random() < prob else DEFECT
    
    # Low cooperation: look for recovery signals
    if trending_up:
        return COOPERATE
    
    # Periodic forgiveness probe (every 3 rounds)
    if round_number % 3 == 0:
        return COOPERATE
    
    # Default: protect against exploitation
    return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (minimum players) | Same rules apply | Strategy scales down naturally |
| k very close to 1 | More conservative thresholds effectively trigger | Low k means cooperation barely pays, so high cooperation rates needed |
| k very close to n | Cooperation encouraged | High k makes cooperation very valuable |
| All others always defect | Eventually defect after probes fail | Forgiveness probes every 3 rounds test for change |
| All others always cooperate | Always cooperate | Cooperation rate stays high |
| Mixed/random opponents | Probabilistic response | Matches group behavior generously |
| r = 2 (minimum rounds) | Round 1: C, Round 2: per final round rules | Strategy still functional |

---

## Why This Strategy Is Collectively Optimal

1. **Establishes cooperation**: Starting with C creates opportunity for mutual benefit
2. **Sustains cooperation**: Maintaining C when others cooperate keeps the collective equilibrium
3. **Recovers from mistakes**: Forgiveness probes and trend-following allow groups to rebuild after temporary breakdowns
4. **Resists exploitation**: Eventually stops cooperating with persistent defectors
5. **Honors commitment**: Cooperating in the final round when warranted builds trust across the tournament

This strategy treats the game as a coordination problem rather than a competition, seeking the collectively superior outcome (everyone gets k > 1 per round) rather than the Nash equilibrium (everyone gets 1 per round).
'''

description_COLLECTIVE_101 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to maximize group welfare while protecting against exploitation. The key insight is that in repeated games, establishing and maintaining cooperation benefits everyone, but this requires both demonstrating good faith and responding appropriately to defection.

## Strategy Overview: **Adaptive Threshold Cooperation with Forgiveness**

The strategy cooperates when the group shows sufficient cooperative behavior, defects to protect against exploitation, and offers periodic forgiveness to escape mutual defection traps.

---

## Decision Rules

### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- Rationale: Signal cooperative intent and give the collective a chance to establish mutual benefit. Starting with defection poisons the well.

### Rounds 2 through (r-1): Adaptive Threshold Response

**Calculate cooperation rate from previous round:**
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision logic:**

1. **If coop_rate ≥ threshold:** COOPERATE
   - Base threshold = 0.5 (majority cooperating)
   - Adjusted threshold = max(0.3, 0.5 - 0.1 × (consecutive_coop_rounds / r))
   - As cooperation persists, become slightly more tolerant

2. **If coop_rate < threshold:** Consider defection with forgiveness mechanism
   - If this is a "forgiveness round": COOPERATE
   - Otherwise: DEFECT

**Forgiveness mechanism:**
- Forgiveness rounds occur every `max(2, floor(r/5))` rounds
- On forgiveness rounds, cooperate regardless of previous round's outcome
- This allows escape from defection spirals and tests if others will reciprocate

### Final Round (round r): Conditional Cooperation

Unlike standard backward-induction logic (which suggests always defect), maintain cooperative behavior if the game has been predominantly cooperative:

```
overall_coop_rate = (total cooperations across all players, all rounds) / (n × (r-1))

If overall_coop_rate ≥ 0.6: COOPERATE
Else: DEFECT
```

Rationale: If we've built genuine collective success, honor it to the end. This also signals integrity for any meta-game considerations.

---

## Pseudocode Implementation

```
function decide(round, history, n, r, k):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_round_coops = count_cooperators(history, round - 1)
    coop_rate = prev_round_coops / n
    
    # Calculate consecutive cooperation rounds (where coop_rate >= 0.5)
    consec_coop = count_consecutive_cooperative_rounds(history)
    
    # Adaptive threshold (more forgiving as cooperation persists)
    threshold = max(0.3, 0.5 - 0.1 * (consec_coop / r))
    
    # Forgiveness interval
    forgiveness_interval = max(2, floor(r / 5))
    is_forgiveness_round = (round % forgiveness_interval == 0)
    
    # Final round logic
    if round == r:
        overall_coop_rate = total_cooperations(history) / (n * (r - 1))
        if overall_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Main decision logic for rounds 2 to r-1
    if coop_rate >= threshold:
        return COOPERATE
    elif is_forgiveness_round:
        return COOPERATE  # Extend olive branch
    else:
        return DEFECT  # Protect against exploitation
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| n = 2 (minimum players) | Same rules apply | Threshold naturally adapts; becomes similar to Tit-for-Tat with forgiveness |
| Very short game (r = 2) | R1: Cooperate, R2: Threshold-based | Limited time means every signal matters |
| Very long game (r > 20) | More forgiveness opportunities | Regular reset attempts prevent permanent defection lock-in |
| All others defect round 1 | Defect round 2, cooperate on forgiveness rounds | Protect self but keep testing |
| k very close to 1 | Same strategy | Even small collective gains compound over rounds |

---

## Why This Strategy is Collectively Optimal

1. **Initiates cooperation** - Gives the group the best chance to achieve high payoffs
2. **Rewards collective behavior** - Continues cooperating when others do
3. **Protects against free-riders** - Defects when cooperation rate falls too low
4. **Enables recovery** - Forgiveness mechanism prevents permanent collapse
5. **Scales with group size** - Threshold approach works for any n ≥ 2
6. **Honors commitment** - Final round behavior rewards sustained cooperation
'''

description_COLLECTIVE_100 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I recognize that if all players reason similarly, mutual cooperation yields the best collective outcome. However, I must be robust to defectors while maintaining opportunities for cooperation to emerge and persist.

The strategy combines **conditional cooperation**, **proportional response**, and **forgiveness** to encourage cooperation while protecting against exploitation.

---

## Strategy: Adaptive Proportional Cooperator (APC)

### Key Principles

1. **Start cooperatively** to signal willingness to cooperate
2. **Mirror the group's cooperation level** - cooperate probabilistically based on observed cooperation rate
3. **Forgive gradually** to allow recovery from mutual defection
4. **Defect in the final round** (unavoidable game-theoretic reality)

---

## Decision Rules

### Round 1 (No History)
**Action: COOPERATE**

Rationale: Establish cooperative intent. If others share this collective mindset, we achieve mutual cooperation from the start.

### Rounds 2 through (r-1) (Middle Game)

Calculate the **cooperation rate** from the previous round:
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Decision Rule:**
```
If prev_coop_rate >= (n-1)/n:
    # Near-universal cooperation: maintain it
    COOPERATE with probability 1.0

Else if prev_coop_rate >= 0.5:
    # Majority cooperating: match their rate with slight optimism
    COOPERATE with probability = prev_coop_rate + 0.1 (capped at 1.0)

Else if prev_coop_rate > 0:
    # Some cooperation exists: give it a chance to grow
    COOPERATE with probability = prev_coop_rate + 0.15 (capped at 0.5)

Else (prev_coop_rate == 0):
    # Total defection last round
    # Attempt periodic forgiveness to escape defection trap
    If (current_round mod 3 == 0):
        COOPERATE with probability 0.3
    Else:
        DEFECT
```

### Final Round (Round r)
**Action: DEFECT**

Rationale: With no future rounds to influence, defection strictly dominates. Other rational players will recognize this, making cooperation unsustainable in the final round regardless of history.

---

## Pseudocode Implementation

```
function decide(round, history, n, r, k):
    
    # Final round: always defect
    if round == r:
        return DEFECT
    
    # First round: always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history[round - 1])
    prev_coop_rate = prev_cooperators / n
    
    # Determine cooperation probability
    if prev_coop_rate >= (n - 1) / n:
        coop_prob = 1.0
    else if prev_coop_rate >= 0.5:
        coop_prob = min(1.0, prev_coop_rate + 0.1)
    else if prev_coop_rate > 0:
        coop_prob = min(0.5, prev_coop_rate + 0.15)
    else:
        # Periodic forgiveness attempt
        if round mod 3 == 0:
            coop_prob = 0.3
        else:
            coop_prob = 0.0
    
    # Execute probabilistic decision
    return COOPERATE if random() < coop_prob else DEFECT
```

---

## Edge Cases Handled

| Scenario | Behavior |
|----------|----------|
| First round | Cooperate unconditionally |
| Last round | Defect unconditionally |
| All cooperated last round | Cooperate (maintain equilibrium) |
| All defected last round | Mostly defect, but periodically attempt forgiveness |
| Mixed cooperation | Match rate with slight optimism to encourage growth |
| Two-player game (n=2) | Strategy still applies; becomes similar to generous Tit-for-Tat |
| Very short games (r=2) | Cooperate round 1, defect round 2 |

---

## Why This Strategy is Collectively Aligned

1. **Self-reinforcing cooperation**: If most players use this strategy, initial cooperation triggers continued cooperation through all middle rounds.

2. **Robust to defectors**: Proportional response means defectors don't get unlimited free-riding; cooperation rate naturally adjusts downward.

3. **Escape from defection traps**: Periodic forgiveness allows recovery even after breakdown, giving collective cooperation another chance.

4. **Optimism bias**: The "+0.1" and "+0.15" adjustments nudge toward cooperation, helping borderline situations tip toward the collectively beneficial outcome.
'''

description_COLLECTIVE_102 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players reason similarly and cooperate, everyone achieves the best collective outcome (payoff of k per round vs. 1 from universal defection). The strategy aims to sustain cooperation while protecting against exploitation.

## Strategy Overview: **Adaptive Threshold Cooperation (ATC)**

The strategy cooperates when there's sufficient evidence that cooperation is viable in the population, and defects when exploitation is rampant or in strategic endgame situations.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. With no history, assume others may share collective reasoning. The potential to establish cooperation outweighs the one-round exploitation risk.

### Rounds 2 through (r-2): Adaptive Threshold Rule

**Cooperate if and only if:**
```
cooperation_rate(last round) ≥ threshold(t)
```

Where:
- `cooperation_rate` = (number of cooperators in previous round) / n
- `threshold(t)` = adaptive threshold based on history

**Threshold Calculation:**
```
base_threshold = 1/k  # Economic break-even point

# Adjust based on cooperation trend
if cooperation_rate is increasing over last 3 rounds:
    threshold = max(base_threshold - 0.1, 0.2)
elif cooperation_rate is decreasing over last 3 rounds:
    threshold = min(base_threshold + 0.1, 0.6)
else:
    threshold = base_threshold

# Forgiveness mechanism: every ceil(r/5) rounds, 
# temporarily lower threshold by 0.15 to test if cooperation can restart
if round_number % ceil(r/5) == 0:
    threshold = max(threshold - 0.15, 0.15)
```

### Round (r-1): Penultimate Round
**Action: COOPERATE if cooperation_rate ≥ 0.5 in round (r-2)**

Rationale: Maintain cooperation one more round if the group has shown sustained cooperative behavior, giving benefit of the doubt before the final round.

### Round r: Final Round
**Action: Match the majority action from round (r-1)**

```
if cooperation_rate(round r-1) ≥ 0.5:
    COOPERATE
else:
    DEFECT
```

Rationale: In a collective mindset, if most players cooperated in the penultimate round, they likely share cooperative values. Defecting in the last round when others cooperated betrays that collective trust. If the group has already collapsed into defection, there's no collective to honor.

---

## Pseudocode Summary

```python
def decide(round_t, history, n, k, r):
    
    # Round 1: Cooperate unconditionally
    if round_t == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_rate = count_cooperators(history[round_t - 1]) / n
    
    # Final round: Match majority
    if round_t == r:
        return COOPERATE if prev_coop_rate >= 0.5 else DEFECT
    
    # Penultimate round: Slightly generous threshold
    if round_t == r - 1:
        return COOPERATE if prev_coop_rate >= 0.5 else DEFECT
    
    # Middle rounds: Adaptive threshold
    base_threshold = 1 / k
    trend = compute_trend(history, window=3)  # +1 increasing, -1 decreasing, 0 stable
    
    if trend > 0:
        threshold = max(base_threshold - 0.1, 0.2)
    elif trend < 0:
        threshold = min(base_threshold + 0.1, 0.6)
    else:
        threshold = base_threshold
    
    # Forgiveness probe
    forgiveness_interval = ceil(r / 5)
    if round_t % forgiveness_interval == 0:
        threshold = max(threshold - 0.15, 0.15)
    
    return COOPERATE if prev_coop_rate >= threshold else DEFECT
```

---

## Key Properties

1. **Collectively aligned**: Starts cooperative, rewards group cooperation, doesn't unilaterally defect in endgame if group cooperated
2. **Adaptive**: Adjusts threshold based on population behavior trends
3. **Forgiving**: Periodically tests if cooperation can be restored
4. **Robust**: Defects when exploitation is high, protecting against pure defectors
5. **Parameter-aware**: Uses k to set economically meaningful thresholds
'''

description_COLLECTIVE_101 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume I am one of potentially many players using this same strategy. Our goal is to maximize collective welfare while protecting against exploitation by defectors. The strategy balances **optimistic cooperation** to enable collective gains with **measured retaliation** to discourage free-riding.

## Strategy Overview: "Graduated Collective Reciprocity"

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness to build collective value
2. **Mirror the group's cooperation level** to reward prosocial behavior and punish defection proportionally
3. **Forgive strategically** to escape mutual defection traps

---

## Decision Rules

### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- Rationale: Establishes cooperative intent. If many of us use this strategy, we collectively benefit from round 1. The cost of being exploited once is worth the potential for sustained cooperation.

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision rule:**
```
If coop_rate >= (n-1)/n:          → COOPERATE (near-universal cooperation)
If coop_rate >= 0.5:              → COOPERATE with probability = coop_rate
If coop_rate < 0.5:               → DEFECT with probability = (1 - coop_rate)
```

**Forgiveness mechanism:** Every `ceil(r/5)` rounds (roughly every 20% of the game), if currently in a defection pattern, **COOPERATE** unconditionally to test if cooperation can be restored.

**Trend adjustment:** If cooperation has been *increasing* over the last 3 rounds, bias toward cooperation (+0.1 to cooperation probability). If *decreasing*, bias toward defection (-0.1).

### Final Round (Round r): Conditional Cooperation

Unlike classic game theory advice to always defect in the final round:
- **If average cooperation rate over all previous rounds ≥ 0.6:** COOPERATE
- **Otherwise:** DEFECT

Rationale: If we're all using this strategy and have maintained cooperation, we should collectively finish strong rather than unravel. If cooperation has been low, there's nothing to preserve.

---

## Pseudocode

```python
def decide(round_number, r, n, k, history):
    """
    history: list of lists, where history[t] contains actions of all n players in round t
             actions are 'C' or 'D'
    """
    
    # Round 1: Always cooperate
    if round_number == 1:
        return 'C'
    
    # Calculate previous round cooperation rate
    prev_round = history[round_number - 2]  # 0-indexed
    prev_coop_rate = sum(1 for a in prev_round if a == 'C') / n
    
    # Calculate overall average cooperation rate
    total_coop = sum(sum(1 for a in round_hist if a == 'C') for round_hist in history)
    total_actions = len(history) * n
    avg_coop_rate = total_coop / total_actions
    
    # Final round logic
    if round_number == r:
        return 'C' if avg_coop_rate >= 0.6 else 'D'
    
    # Forgiveness probe: every ceil(r/5) rounds
    forgiveness_interval = max(1, -(-r // 5))  # ceiling division
    if round_number % forgiveness_interval == 0:
        return 'C'
    
    # Calculate trend over last 3 rounds (if available)
    trend_adjustment = 0
    if len(history) >= 3:
        recent_rates = []
        for i in range(-3, 0):
            round_hist = history[i]
            recent_rates.append(sum(1 for a in round_hist if a == 'C') / n)
        if recent_rates[2] > recent_rates[0]:  # increasing trend
            trend_adjustment = 0.1
        elif recent_rates[2] < recent_rates[0]:  # decreasing trend
            trend_adjustment = -0.1
    
    # Main decision logic
    if prev_coop_rate >= (n - 1) / n:
        return 'C'
    elif prev_coop_rate >= 0.5:
        prob_coop = min(1.0, max(0.0, prev_coop_rate + trend_adjustment))
        return 'C' if random() < prob_coop else 'D'
    else:
        prob_coop = min(1.0, max(0.0, prev_coop_rate + trend_adjustment))
        return 'C' if random() < prob_coop else 'D'
```

---

## Edge Cases

| Scenario | Handling |
|----------|----------|
| **n = 2** | Strategy functions normally; effectively becomes Tit-for-Tat with forgiveness |
| **k very close to 1** | Low cooperation incentive; strategy will naturally drift to defection if others defect, which is rational |
| **k close to n** | High cooperation incentive; strategy will maintain cooperation easily |
| **All others always defect** | After forgiveness probes fail, converges to mostly defecting (protecting self) |
| **All others always cooperate** | Maintains cooperation throughout (collective optimal) |
| **Mixed population** | Probabilistic matching creates proportional response |
| **r = 2** | Round 1: Cooperate; Round 2: Apply final round logic |

---

## Why This Strategy is Collectively Robust

1. **Self-reinforcing among copies**: If all players use this strategy, round 1 establishes universal cooperation, which perpetuates through reciprocity.

2. **Resistant to exploitation**: Probabilistic defection in response to low cooperation rates means defectors don't gain consistent advantage.

3. **Recoverable**: Forgiveness probes allow escape from defection spirals that might arise from noise or initial miscoordination.

4. **Parameter-adaptive**: The thresholds scale with n, and the forgiveness interval scales with r.

5. **No coordination required**: Works independently—doesn't assume others will follow a schedule or pattern.
'''

description_COLLECTIVE_103 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all players using this strategy will reason identically given the same information. Rather than treating this as a game against opponents, we treat it as a coordination problem among copies of ourselves. The key insight is that **if we all defect, we all get less than if we all cooperate** (since k > 1 means cooperation is socially efficient).

However, we must also be robust to players using different strategies. Our approach: **start cooperatively, maintain cooperation among collective-minded players, but protect against exploitation.**

---

## Strategy: "Collective Threshold with Forgiveness"

### Decision Variables

At each round t, track:
- `cooperation_rate(t-1)` = proportion of all players who cooperated in round t-1
- `rounds_remaining` = r - t + 1
- `consecutive_low_rounds` = number of consecutive rounds where cooperation_rate < threshold

### Core Parameters (derived from game parameters)

```
base_threshold = (n - k) / n    # Below this cooperation rate, defection dominates
forgiveness_interval = max(3, r / 5)   # How often to test if defectors reformed
final_rounds = min(3, r / 4)    # Endgame detection
```

### Decision Rules

#### Round 1: Always Cooperate
- **Rationale**: Establish cooperative intent. If all collective-minded players cooperate, we immediately identify ourselves to each other. This is our coordination signal.

#### Rounds 2 through (r - final_rounds): Adaptive Cooperation

```
IF cooperation_rate(t-1) >= base_threshold:
    COOPERATE
    # Sufficient cooperation makes contributing worthwhile collectively
    
ELSE IF consecutive_low_rounds >= 2:
    # Cooperation has collapsed
    IF (t mod forgiveness_interval) == 0:
        COOPERATE  # Periodic forgiveness probe
    ELSE:
        DEFECT     # Protect against exploitation
        
ELSE:
    COOPERATE      # Give benefit of doubt for one bad round
```

#### Final Rounds (last `final_rounds` rounds): Graduated Withdrawal

```
rounds_left = r - t + 1

IF rounds_left == final_rounds:
    # Cooperate if cooperation has been strong
    IF average_cooperation_rate(last 3 rounds) >= 0.6:
        COOPERATE
    ELSE:
        DEFECT

IF rounds_left < final_rounds:
    # Tit-for-tat in endgame
    IF cooperation_rate(t-1) >= 0.5:
        COOPERATE
    ELSE:
        DEFECT

IF rounds_left == 1 (final round):
    # Cooperate only if near-universal cooperation observed
    IF cooperation_rate(t-1) >= (n-1)/n:
        COOPERATE  # Reward sustained collective behavior
    ELSE:
        DEFECT     # Standard game-theoretic endgame
```

---

## Handling Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | C then match majority | Minimal cooperation test |
| n = 2 (minimum players) | Tit-for-tat | Reduces to standard 2-player case |
| k very close to 1 | Lower threshold, quicker defection | Cooperation barely beneficial |
| k close to n | Higher threshold, more forgiving | Cooperation highly beneficial |
| All players defected last round | Cooperate if forgiveness round, else defect | Probe for recovery |
| Only I defected last round | Cooperate | Return to collective behavior |

---

## Why This Strategy is Collectively Optimal

1. **Self-recognition**: If all players use this strategy, everyone cooperates in round 1, sees 100% cooperation, and continues cooperating throughout (except possibly final round).

2. **Robustness**: Against defectors, we don't get exploited indefinitely—we match the group's behavior after giving chances.

3. **Forgiveness**: Periodic cooperation probes allow recovery if other strategies "reform" or if defection was noise.

4. **Endgame handling**: Graduated withdrawal rather than sudden defection—gives collective-minded players a chance to maintain cooperation even late.

5. **Parameter adaptation**: The threshold adjusts to game parameters, recognizing that the cooperation incentive varies with k/n ratio.

---

## Summary Pseudocode

```python
def decide(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    coop_rate = cooperation_rate(history, round - 1)
    rounds_left = r - round + 1
    threshold = (n - k) / n
    
    # Endgame logic
    if rounds_left <= min(3, r // 4):
        if rounds_left == 1:
            return COOPERATE if coop_rate >= (n-1)/n else DEFECT
        return COOPERATE if coop_rate >= 0.5 else DEFECT
    
    # Main game logic
    if coop_rate >= threshold:
        return COOPERATE
    elif consecutive_low_rounds(history, threshold) >= 2:
        if round % max(3, r // 5) == 0:
            return COOPERATE  # Forgiveness probe
        return DEFECT
    else:
        return COOPERATE  # Benefit of doubt
```
'''

description_COLLECTIVE_102 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we assume all instances of this strategy will behave identically given the same information. Rather than treating other players as adversaries, we recognize that coordinated cooperation creates the highest collective payoff. The strategy aims to:

1. Signal cooperative intent clearly
2. Reward cooperation and discourage defection
3. Maintain cooperation when it's collectively beneficial
4. Adapt to the actual population behavior we encounter

---

## Strategy: "Collective Threshold with Graduated Response"

### Key Insight

Since all copies of this strategy see the same history and use the same rules, we can achieve implicit coordination. We cooperate when cooperation appears viable for the collective, and we respond proportionally to the observed cooperation level.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: We cannot assess the population without data. Starting with cooperation:
- Signals our cooperative intent
- Allows us to measure the baseline cooperation rate
- Is the collectively optimal choice if others think similarly

---

### Rounds 2 through (r-1): Adaptive Threshold Cooperation

**Calculate the cooperation rate from the previous round:**
```
coop_rate = (number of cooperators in round t-1) / n
```

**Decision Rule:**

```
IF coop_rate >= threshold(t) THEN COOPERATE
ELSE DEFECT
```

**Dynamic Threshold Function:**
```
base_threshold = 1/k  # Break-even point for cooperation value

# Adjust threshold based on game progress and history
progress = t / r  # How far through the game we are

# Early game: be more forgiving to establish cooperation
# Late game: require stronger cooperation signals
adjusted_threshold = base_threshold * (0.7 + 0.5 * progress)

# Clamp between reasonable bounds
threshold(t) = clamp(adjusted_threshold, 0.3, 0.7)
```

**Additional Modifier - Trend Detection:**
```
IF cooperation rate increased from (t-2) to (t-1) THEN
    threshold(t) = threshold(t) - 0.1  # Be more forgiving when trend is positive
    
IF cooperation rate decreased for 2+ consecutive rounds THEN
    threshold(t) = threshold(t) + 0.1  # Be stricter when cooperation is collapsing
```

---

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory advice to defect in the last round, we maintain conditional cooperation:

**Action:**
```
IF average cooperation rate across all previous rounds >= 0.5 THEN COOPERATE
ELSE DEFECT
```

Rationale: 
- If all strategy copies defect in the final round, we collectively lose the cooperation surplus
- If cooperation has been sustained, maintaining it in the final round rewards the collective
- This is only rational if others follow the same logic—which identical strategies will

---

## Complete Pseudocode

```python
def decide(round_number, total_rounds, num_players, k_factor, history):
    """
    history: list of lists, where history[t] contains actions of all players in round t
             actions are 'C' or 'D'
    """
    
    n = num_players
    r = total_rounds
    t = round_number
    
    # === ROUND 1: Always cooperate ===
    if t == 1:
        return 'C'
    
    # === Calculate previous round statistics ===
    prev_round = history[t - 1]
    coop_count = sum(1 for action in prev_round if action == 'C')
    coop_rate = coop_count / n
    
    # === FINAL ROUND: Conditional cooperation ===
    if t == r:
        total_coop = sum(
            sum(1 for action in round_actions if action == 'C')
            for round_actions in history
        )
        avg_coop_rate = total_coop / (n * (t - 1))
        
        if avg_coop_rate >= 0.5:
            return 'C'
        else:
            return 'D'
    
    # === MIDDLE ROUNDS: Threshold-based decision ===
    
    # Base threshold: cooperation is valuable when coop_rate * k >= 1
    # This means coop_rate >= 1/k is the break-even
    base_threshold = 1 / k_factor
    
    # Progress adjustment: stricter as game progresses
    progress = t / r
    adjusted_threshold = base_threshold * (0.7 + 0.5 * progress)
    
    # Trend adjustment
    if t >= 3:
        prev_prev_round = history[t - 2]
        prev_prev_coop = sum(1 for action in prev_prev_round if action == 'C') / n
        
        if coop_rate > prev_prev_coop:
            adjusted_threshold -= 0.1  # Positive trend: be forgiving
        elif t >= 4:
            # Check for sustained decline
            declining = all(
                sum(1 for a in history[i] if a == 'C') / n >
                sum(1 for a in history[i + 1] if a == 'C') / n
                for i in range(t - 3, t - 1)
            )
            if declining:
                adjusted_threshold += 0.1  # Declining trend: be stricter
    
    # Clamp threshold to reasonable bounds
    threshold = max(0.3, min(0.7, adjusted_threshold))
    
    # === Make decision ===
    if coop_rate >= threshold:
        return 'C'
    else:
        return 'D'
```

---

## Edge Cases Handled

| Situation | Behavior | Rationale |
|-----------|----------|-----------|
| Round 1 | Cooperate | Establish baseline, signal intent |
| All others defected last round | Defect | Cooperation not viable, protect ourselves |
| All others cooperated last round | Cooperate | Reward cooperation, sustain collective benefit |
| Final round after sustained cooperation | Cooperate | Collective benefit > individual defection gain |
| Final round after sustained defection | Defect | No collective benefit to protect |
| Only 2 players (n=2) | Same rules apply | Threshold logic still valid |
| High k (close to n) | Lower threshold | Cooperation more valuable |
| Low k (close to 1) | Higher threshold | Need more cooperators to make it worthwhile |

---

## Why This Strategy Works Collectively

1. **Identical behavior**: All copies make the same decision given the same history, achieving implicit coordination

2. **Self-reinforcing cooperation**: When cooperation rate is high, all copies cooperate, maintaining the high rate

3. **Collective punishment**: When defection rises, all copies defect simultaneously, creating strong deterrent

4. **Forgiveness via threshold**: If defectors return to cooperation and push the rate above threshold, we immediately reciprocate

5. **No last-round collapse**: Unlike naive strategies, we don't automatically defect in the final round, preserving collective surplus when cooperation has been established
'''

description_COLLECTIVE_104 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similarly-minded cooperative agents) may be playing. The goal is to establish and maintain cooperation when possible, while protecting against exploitation. The strategy uses observable patterns to identify likely cooperators and coordinate without explicit communication.

---

## Strategy: **Adaptive Threshold Cooperation with Forgiveness (ATCF)**

### Key Principles

1. **Start cooperative** to signal willingness to cooperate
2. **Track cooperation rates** to assess the group's cooperative potential
3. **Use threshold-based decisions** that adapt to observed behavior
4. **Forgive strategically** to allow recovery from coordination failures
5. **Defect late** only when cooperation has truly failed

---

## Decision Rules

### Variables to Track

```
group_coop_rate[t] = (number of C plays in round t) / n
running_coop_rate = average of group_coop_rate over all past rounds
personal_threshold = adaptive threshold for cooperation (initialized based on k/n)
forgiveness_counter = rounds since last forgiveness probe
```

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. With no history, cooperation is the only way to identify and attract other cooperators.

---

### Rounds 2 through (r-1): Adaptive Threshold Cooperation

**Calculate the cooperation threshold:**
```
base_threshold = k / n  # The break-even point where cooperation becomes beneficial
adjusted_threshold = base_threshold × 0.8  # Slightly lower to encourage cooperation
```

**Decision logic:**

```
IF running_coop_rate ≥ adjusted_threshold:
    ACTION = COOPERATE
    
ELSE IF group_coop_rate[t-1] ≥ 0.5 AND running_coop_rate ≥ adjusted_threshold × 0.7:
    # Recent improvement - give cooperation another chance
    ACTION = COOPERATE
    
ELSE IF forgiveness_counter ≥ max(3, r/5):
    # Periodic forgiveness probe to test if cooperation can restart
    ACTION = COOPERATE
    forgiveness_counter = 0
    
ELSE:
    ACTION = DEFECT
    forgiveness_counter += 1
```

**Escalation clause for sustained defection:**
```
IF running_coop_rate < 0.2 AND t > r/3:
    # Group is predominantly defecting - minimize losses
    ACTION = DEFECT
    # But still probe every max(4, r/4) rounds
```

---

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory advice (always defect in final round), this strategy maintains cooperation if the group has been cooperative:

```
IF running_coop_rate ≥ 0.6:
    ACTION = COOPERATE  # Reward good collective behavior
ELSE:
    ACTION = DEFECT     # No future to protect
```

Rationale: If playing against other collective-minded agents, mutual final-round cooperation yields better outcomes. This also serves as a signal/reward for cooperative play throughout.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Follow standard rules, but set forgiveness_counter threshold to 2 | Small groups need faster adaptation |
| Very short games (r ≤ 3) | Cooperate all rounds unless round 2 sees < 40% cooperation | Not enough time for complex adaptation |
| Very large n (n > 20) | Reduce adjusted_threshold by additional 10% | Coordination is harder; be more forgiving |
| k very close to n | Cooperate more readily (threshold × 0.6) | Higher returns justify more risk |
| k very close to 1 | Defect more readily (threshold × 1.2) | Lower returns don't justify exploitation risk |

---

## Pseudocode Summary

```python
def decide(round_t, history, n, k, r):
    if round_t == 1:
        return COOPERATE
    
    # Calculate metrics
    running_coop_rate = sum(history.group_cooperators) / (n * (round_t - 1))
    last_round_coop_rate = history.group_cooperators[-1] / n
    base_threshold = (k / n) * 0.8
    
    # Final round logic
    if round_t == r:
        return COOPERATE if running_coop_rate >= 0.6 else DEFECT
    
    # Abandonment check
    if running_coop_rate < 0.2 and round_t > r / 3:
        if forgiveness_counter >= max(4, r / 4):
            forgiveness_counter = 0
            return COOPERATE
        forgiveness_counter += 1
        return DEFECT
    
    # Main decision
    if running_coop_rate >= base_threshold:
        return COOPERATE
    elif last_round_coop_rate >= 0.5 and running_coop_rate >= base_threshold * 0.7:
        return COOPERATE
    elif forgiveness_counter >= max(3, r / 5):
        forgiveness_counter = 0
        return COOPERATE
    else:
        forgiveness_counter += 1
        return DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Self-recognition**: Multiple instances of this strategy will cooperate from round 1, maintain high cooperation rates, and thus continue cooperating throughout—including the final round.

2. **Exploitation resistance**: Against pure defectors, the strategy defects after observing low cooperation, limiting losses.

3. **Recovery capability**: Forgiveness probes allow cooperation to restart if opponents change behavior or if early defection was due to noise/coordination failure.

4. **Parameter adaptivity**: Thresholds scale with k/n, ensuring rational behavior across different game configurations.

5. **No coordination assumption**: Works without assuming others use the same strategy, predetermined patterns, or communication.
'''

description_COLLECTIVE_103 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embodies a **collective mindset**: we assume other players may be using similar reasoning, and we aim to establish and maintain cooperation while protecting against exploitation. The key insight is that in repeated games, building a reputation for conditional cooperation can sustain mutually beneficial outcomes.

## Strategy: Adaptive Threshold Cooperation (ATC)

### Overview

The strategy uses a **cooperation threshold** that adapts based on observed group behavior. We cooperate when the group demonstrates sufficient cooperative intent, and we defect to protect ourselves when cooperation falls below sustainable levels.

---

## Decision Rules

### Round 1: Optimistic Start
**Action: COOPERATE**

Rationale: Signal cooperative intent. With no history, we give the collective the benefit of the doubt. This establishes reputation and allows cooperation to emerge.

---

### Rounds 2 through (r-1): Adaptive Conditional Cooperation

**Calculate the cooperation rate from the previous round:**
```
prev_coop_rate = (number of C plays in round t-1) / n
```

**Calculate a dynamic threshold based on game parameters and history:**
```
base_threshold = 1/k  # Minimum cooperation needed for public good to match private keeping
adaptive_threshold = max(base_threshold, 0.3)  # Floor at 30% to avoid collapse
```

**Decision Rule:**
```
IF prev_coop_rate >= adaptive_threshold:
    ACTION = COOPERATE
ELSE IF prev_coop_rate >= adaptive_threshold - 0.15:
    # "Forgiveness zone" - give one chance to recover
    IF cooperation was declining for 2+ consecutive rounds:
        ACTION = DEFECT
    ELSE:
        ACTION = COOPERATE (with probability = prev_coop_rate)
        ACTION = DEFECT (with probability = 1 - prev_coop_rate)
ELSE:
    ACTION = DEFECT
```

**Trend Detection Modifier:**
```
IF cooperation has increased for 2+ consecutive rounds:
    Lower threshold by 0.1 (reward momentum)
IF cooperation has decreased for 2+ consecutive rounds:
    Raise threshold by 0.1 (protect against collapse)
```

---

### Final Round (Round r): Conditional End-Game

Unlike simple backward induction (always defect), we consider reputation consistency:

```
IF average cooperation rate over all rounds >= 0.6:
    # High-cooperation game - maintain collective trust
    ACTION = COOPERATE
ELSE IF prev_coop_rate >= 0.5:
    # Borderline - probabilistic based on history
    ACTION = COOPERATE with probability = average_coop_rate
ELSE:
    # Low cooperation game - no reason to sacrifice
    ACTION = DEFECT
```

Rationale: If we're playing against other collective-minded strategies, mutual cooperation in the final round is achievable and valuable.

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history, round-1) / n
    avg_coop_rate = total_cooperations(history) / (n * (round-1))
    trend = calculate_trend(history, last_3_rounds)
    
    base_threshold = max(1/k, 0.3)
    
    # Adjust threshold based on trend
    if trend == "rising":
        threshold = base_threshold - 0.1
    elif trend == "falling":
        threshold = base_threshold + 0.1
    else:
        threshold = base_threshold
    
    # Final round logic
    if round == r:
        if avg_coop_rate >= 0.6:
            return COOPERATE
        elif prev_coop_rate >= 0.5:
            return COOPERATE with probability avg_coop_rate
        else:
            return DEFECT
    
    # Standard rounds
    if prev_coop_rate >= threshold:
        return COOPERATE
    elif prev_coop_rate >= threshold - 0.15:
        return COOPERATE with probability prev_coop_rate
    else:
        return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Self-reinforcing**: If multiple players use this strategy, initial cooperation triggers continued cooperation
2. **Robust to defectors**: Threshold mechanism prevents exploitation by consistent defectors
3. **Forgiving**: Probabilistic forgiveness zone allows recovery from temporary cooperation dips
4. **Trend-aware**: Rewards improving behavior, punishes declining cooperation
5. **Parameter-adaptive**: Threshold scales with k, making it appropriate across different game configurations
6. **End-game resistant**: Doesn't blindly defect in final round, enabling sustained cooperation with like-minded players
'''

description_COLLECTIVE_105 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players reason similarly and cooperate, everyone benefits more than under universal defection. The challenge is achieving coordination without communication while remaining robust to defectors. My approach is to **lead with cooperation, forgive generously, but protect against persistent exploitation**.

## Strategy Overview

I call this strategy **"Hopeful Reciprocator"** - it begins optimistically, mirrors the cooperative tendencies of the group, forgives occasional defections, but gradually withdraws cooperation if the group proves uncooperative.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: Cooperate**

Rationale: With no history, I signal cooperative intent. If others reason similarly, we establish mutual cooperation from the start. The expected value of seeding cooperation outweighs the risk of first-round exploitation.

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

**Decision Rule:**
```
If coop_rate >= threshold(t):
    Cooperate
Else:
    Defect with probability proportional to defection level
```

**Threshold Function:**
```
threshold(t) = max(0.3, 0.5 - 0.02 * t)
```
- Starts at 0.5 (need half the group cooperating)
- Gradually becomes more forgiving over time (down to 0.3)
- This allows recovery from early coordination failures

**Forgiveness Mechanism:**
Even when below threshold, cooperate with probability:
```
forgiveness_prob = 0.15 + (rounds_remaining / r) * 0.1
```
- Higher forgiveness early in the game (more time to recover)
- Maintains a small chance of re-seeding cooperation even late

**Exploitation Protection:**
Track consecutive rounds where I cooperated but coop_rate < 0.4:
```
If exploitation_count >= 3:
    Defect for next round regardless of other factors
    Reset exploitation_count after defecting
```

### Last Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection:

**Action:**
```
If average_coop_rate_over_game >= 0.5:
    Cooperate (reward collective success)
Else:
    Defect (no reason to sacrifice unilaterally)
```

Rationale: If we've maintained good cooperation, I honor that relationship even when there's no future shadow. This rewards groups that coordinate well and aligns with collective reasoning—if all similar reasoners do this, we avoid the unraveling problem.

---

## Complete Pseudocode

```
function decide(round, history, n, r, k):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_count = count_cooperators(history, round - 1)
    coop_rate = prev_coop_count / n
    
    # Track exploitation
    if my_action(history, round - 1) == COOPERATE and coop_rate < 0.4:
        exploitation_count += 1
    else:
        exploitation_count = 0
    
    # Exploitation protection
    if exploitation_count >= 3:
        exploitation_count = 0
        return DEFECT
    
    # Last round: conditional cooperation
    if round == r:
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: adaptive reciprocity
    threshold = max(0.3, 0.5 - 0.02 * round)
    rounds_remaining = r - round
    forgiveness = 0.15 + (rounds_remaining / r) * 0.1
    
    if coop_rate >= threshold:
        return COOPERATE
    else:
        # Probabilistic forgiveness
        if random() < forgiveness:
            return COOPERATE
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Mutual benefit focus**: When playing against similar strategies, we achieve near-universal cooperation and everyone earns ~k per round instead of ~1.

2. **No first-mover disadvantage**: Everyone starts cooperating, so no one is exploited in round 1.

3. **Robust to heterogeneity**: The forgiving threshold and probabilistic forgiveness allow recovery even when some players use different strategies.

4. **Doesn't unravel**: By cooperating in the last round conditionally on group history, we avoid backward induction collapse that plagues purely rational approaches.

5. **Self-protective**: The exploitation counter prevents persistent free-riders from indefinitely exploiting cooperative players.
'''

description_COLLECTIVE_104 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players in my cohort are reasoning similarly and will arrive at similar strategic conclusions. We cannot pre-coordinate, but we can align through shared rationality. The strategy aims to:

1. **Establish cooperation** when the environment supports it
2. **Respond proportionally** to observed behavior
3. **Forgive strategically** to escape defection spirals
4. **Protect the collective** from exploitation while remaining open to recovery

---

## Strategy: **Adaptive Threshold Cooperation (ATC)**

### Key Parameters (derived from game parameters)

```
cooperation_threshold = 0.5  # Minimum fraction of cooperators to sustain cooperation
forgiveness_probability = 1 / n  # Probability of attempting cooperation reset
decay_rounds = max(2, r / 5)  # Rounds to gradually reduce cooperation after betrayal
```

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

*Rationale:* With no history, cooperation signals good faith. If others reason collectively, we establish a cooperative baseline. The cost of one round of potential exploitation is small compared to the value of initiating mutual cooperation.

---

### Rounds 2 through (r-1): Adaptive Response

Calculate `coop_rate` = (number of cooperators in previous round) / n

**Primary Rule:**
```
IF coop_rate >= cooperation_threshold (0.5):
    COOPERATE
ELSE:
    Apply forgiveness mechanism
```

**Forgiveness Mechanism:**
```
rounds_since_good_cooperation = rounds since coop_rate >= 0.5

IF rounds_since_good_cooperation <= decay_rounds:
    # Graduated withdrawal - cooperate with decreasing probability
    coop_probability = 1 - (rounds_since_good_cooperation / decay_rounds)
    COOPERATE with probability coop_probability
ELSE:
    # Low cooperation regime - occasional forgiveness probe
    COOPERATE with probability forgiveness_probability (1/n)
    OTHERWISE DEFECT
```

**Trend Adjustment:**
```
IF cooperation is trending upward (coop_rate increased from round t-2 to t-1):
    Boost cooperation probability by 0.2 (capped at 1.0)
```

---

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection, **we maintain our collective identity:**

```
IF coop_rate in round (r-1) >= 0.6:
    COOPERATE  # Reward sustained cooperation, honor the collective
ELSE:
    DEFECT  # No future rounds to recover, minimize loss
```

*Rationale:* If we've built a cooperative equilibrium, defecting in the final round destroys trust and yields only marginal gain. A collective of like-minded players benefits more from mutual final-round cooperation (payoff = k) than mutual defection (payoff = 1). Since k > 1, this is collectively superior.

---

## Complete Pseudocode

```python
def decide(round_number, history, n, k, r):
    
    # Round 1: Cooperate to establish baseline
    if round_number == 1:
        return COOPERATE
    
    # Calculate previous round statistics
    prev_cooperators = count_cooperators(history[round_number - 1])
    coop_rate = prev_cooperators / n
    
    # Final round logic
    if round_number == r:
        if coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Adaptive threshold with forgiveness
    threshold = 0.5
    
    if coop_rate >= threshold:
        return COOPERATE
    
    # Below threshold: forgiveness and graduated response
    decay_rounds = max(2, r // 5)
    forgiveness_prob = 1 / n
    
    # Count rounds since good cooperation
    rounds_below = 0
    for t in range(round_number - 1, 0, -1):
        if count_cooperators(history[t]) / n >= threshold:
            break
        rounds_below += 1
    
    # Check for upward trend
    trend_bonus = 0
    if round_number >= 3:
        prev_prev_rate = count_cooperators(history[round_number - 2]) / n
        if coop_rate > prev_prev_rate:
            trend_bonus = 0.2
    
    # Calculate cooperation probability
    if rounds_below <= decay_rounds:
        base_prob = 1 - (rounds_below / decay_rounds)
    else:
        base_prob = forgiveness_prob
    
    final_prob = min(1.0, base_prob + trend_bonus)
    
    return COOPERATE with probability final_prob, else DEFECT
```

---

## Edge Cases Handled

| Situation | Response |
|-----------|----------|
| First round | Always cooperate |
| Last round after cooperation | Cooperate (honor collective) |
| Last round after defection | Defect (no recovery possible) |
| Single defector in otherwise cooperative group | Continue cooperating (above threshold) |
| Gradual collapse of cooperation | Graduated withdrawal with forgiveness probes |
| Complete defection by others | Rare forgiveness attempts (1/n probability) |
| Recovery attempt by others | Trend bonus accelerates return to cooperation |

---

## Why This Strategy Works Collectively

1. **Self-reinforcing:** If all collective members use this strategy, round 1 cooperation leads to sustained cooperation throughout (coop_rate = 1.0 > 0.5 always).

2. **Robust to noise:** The 0.5 threshold tolerates some deviation; graduated response prevents overreaction to temporary defection.

3. **Recoverable:** Forgiveness probes and trend bonuses allow escape from defection spirals if enough players attempt recovery simultaneously.

4. **Resistant to exploitation:** Threshold-based response means persistent defectors face defection in return, limiting their advantage.

5. **Collectively rational in endgame:** Final-round cooperation when warranted yields k > 1 for all collective members, dominating mutual defection.
'''

description_COLLECTIVE_106 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be using this same strategy or similar cooperative approaches. The goal is to establish and maintain cooperation while protecting against exploitation. The strategy uses **conditional cooperation with forgiveness** - rewarding cooperation, punishing defection, but allowing recovery.

## Strategy Overview

The strategy operates in three phases based on game progression, with decisions informed by the cooperation rate observed in previous rounds.

---

## Decision Rules

### Key Metrics

```
cooperation_rate(round) = (number of C plays in that round) / n
avg_cooperation_rate = average cooperation_rate across all completed rounds
consecutive_low_rounds = count of most recent consecutive rounds where cooperation_rate < threshold
```

### Thresholds (Adaptive to Game Parameters)

```
base_threshold = k / n  # The break-even point for cooperation
cooperation_threshold = max(0.4, base_threshold)  # Minimum cooperation rate to sustain cooperation
forgiveness_threshold = 0.6  # Rate above which we forgive past defection
```

---

## Phase-Based Decision Rules

### Phase 1: Opening Phase (Round 1)
**Decision: COOPERATE**

Rationale: Signal cooperative intent. With a collective mindset, starting with cooperation allows mutual identification of cooperative players. The cost of one round of potential exploitation is worth establishing a cooperative equilibrium.

### Phase 2: Main Phase (Rounds 2 to r-2)

**Decision Rule:**

```
IF avg_cooperation_rate >= cooperation_threshold:
    COOPERATE
ELSE IF cooperation_rate(previous_round) >= forgiveness_threshold:
    COOPERATE  # Forgiveness: respond to improving conditions
ELSE IF consecutive_low_rounds >= 2:
    DEFECT  # Protect against sustained exploitation
ELSE:
    COOPERATE  # Give one more chance after single bad round
```

**Additional Adaptive Rule (Probabilistic Cooperation):**
```
IF cooperation_rate is between 0.3 and cooperation_threshold:
    COOPERATE with probability = cooperation_rate(previous_round)
    # Match the group's cooperation level - reciprocity signal
```

### Phase 3: End Phase (Rounds r-1 and r)

**Round r-1:**
```
IF avg_cooperation_rate >= 0.5:
    COOPERATE  # Maintain cooperation if group has been cooperative
ELSE:
    DEFECT  # No reason to cooperate with uncooperative group
```

**Round r (Final Round):**
```
IF avg_cooperation_rate >= cooperation_threshold AND 
   cooperation_rate(round r-1) >= 0.5:
    COOPERATE  # Collective commitment to the end
ELSE:
    DEFECT  # Standard game theory for final round against defectors
```

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Calculate metrics
    if round == 1:
        return COOPERATE
    
    cooperation_rates = [count(C in round_t) / n for round_t in history]
    avg_coop = mean(cooperation_rates)
    last_coop = cooperation_rates[-1]
    
    # Count consecutive low cooperation rounds
    consecutive_low = 0
    for rate in reversed(cooperation_rates):
        if rate < cooperation_threshold:
            consecutive_low += 1
        else:
            break
    
    # Thresholds
    cooperation_threshold = max(0.4, k/n)
    forgiveness_threshold = 0.6
    
    # Final round
    if round == r:
        if avg_coop >= cooperation_threshold AND last_coop >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Second-to-last round
    if round == r - 1:
        if avg_coop >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Main phase logic
    if avg_coop >= cooperation_threshold:
        return COOPERATE
    
    if last_coop >= forgiveness_threshold:
        return COOPERATE
    
    if consecutive_low >= 2:
        return DEFECT
    
    if last_coop >= 0.3:
        # Probabilistic cooperation matching group behavior
        return COOPERATE with probability last_coop
    
    return COOPERATE  # Default: one more chance
```

---

## Why This Strategy Works Collectively

1. **Coordination**: All instances start cooperating, enabling immediate mutual benefit
2. **Robustness**: Protects against exploitation after sustained defection
3. **Forgiveness**: Allows recovery from temporary breakdowns
4. **Proportional Response**: Probabilistic cooperation mirrors group behavior, avoiding harsh over-punishment
5. **End-game Commitment**: Maintains cooperation even in final rounds when the group has been cooperative, maximizing collective payoff
'''

description_COLLECTIVE_105 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similar cooperative AIs) may be in the game. The goal is to establish cooperation when possible, maintain it through reciprocity, and protect against exploitation—while recognizing that in a public goods game, the more cooperators there are, the better it is for everyone.

## Strategy: **Adaptive Threshold Reciprocity (ATR)**

### Key Insight

In this game, the critical question isn't "did one player defect?" but rather "is there enough cooperation in the group to make my contribution worthwhile?" A single defector among many cooperators still yields good collective outcomes. The strategy therefore focuses on **cooperation thresholds** rather than individual punishment.

---

## Decision Rules

### Parameters Derived from Game Structure

```
cooperation_threshold = floor(n / 2)  # Minimum cooperators needed to continue cooperating
forgiveness_window = max(2, floor(r / 5))  # Rounds to assess recovery
last_round_buffer = min(3, floor(r / 4))  # Rounds before end to consider endgame
```

### Round-by-Round Logic

#### **Round 1: Unconditional Cooperation**
- **Action: COOPERATE**
- Rationale: Signal cooperative intent. This is essential for coordination with other cooperative strategies.

#### **Rounds 2 through (r - last_round_buffer): Adaptive Reciprocity**

Calculate from the previous round:
- `prev_cooperators` = number of players who cooperated last round
- `cooperation_rate` = prev_cooperators / n
- `trend` = cooperation change over last `forgiveness_window` rounds (if available)

**Decision Logic:**

```
IF prev_cooperators >= cooperation_threshold:
    ACTION = COOPERATE
    
ELSE IF prev_cooperators < cooperation_threshold:
    # Check if cooperation is recovering
    IF trend is positive (cooperation increasing over forgiveness_window):
        ACTION = COOPERATE  # Give benefit of doubt during recovery
    ELSE:
        ACTION = DEFECT  # Protect against persistent free-riding
```

#### **Last `last_round_buffer` Rounds: Conditional Endgame**

The endgame is tricky—standard game theory predicts defection unraveling. However, against other collective-minded strategies, maintaining cooperation is valuable.

```
IF cooperation_rate over last 3 rounds >= 0.6:
    ACTION = COOPERATE  # Maintain established cooperation
ELSE:
    ACTION = DEFECT  # Don't be exploited in final rounds
```

#### **Final Round (Round r): Mirror Majority**
- If majority cooperated in round r-1: **COOPERATE**
- Otherwise: **DEFECT**

This rewards sustained cooperation while not being naive.

---

## Complete Pseudocode

```python
def decide(round_number, history, n, k, r):
    # Derived parameters
    cooperation_threshold = n // 2
    forgiveness_window = max(2, r // 5)
    last_round_buffer = min(3, r // 4)
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate metrics
    prev_cooperators = count_cooperators(history, round_number - 1)
    cooperation_rate = prev_cooperators / n
    
    # Calculate trend if enough history
    if round_number > forgiveness_window:
        recent_rates = [count_cooperators(history, t) / n 
                        for t in range(round_number - forgiveness_window, round_number)]
        trend = recent_rates[-1] - recent_rates[0]  # Positive = improving
    else:
        trend = 0
    
    # Endgame logic
    if round_number > r - last_round_buffer:
        if round_number == r:  # Final round
            return COOPERATE if prev_cooperators >= n // 2 else DEFECT
        else:  # Near-final rounds
            avg_recent = average([count_cooperators(history, t) / n 
                                   for t in range(max(1, round_number - 3), round_number)])
            return COOPERATE if avg_recent >= 0.6 else DEFECT
    
    # Main game logic
    if prev_cooperators >= cooperation_threshold:
        return COOPERATE
    elif trend > 0:
        return COOPERATE  # Forgiveness during recovery
    else:
        return DEFECT  # Protect against exploitation
```

---

## Why This Strategy Works Collectively

1. **Coordination with copies**: If multiple players use ATR, they all cooperate in round 1 and continue cooperating as long as threshold is met—achieving mutual benefit.

2. **Robustness to defectors**: A few defectors don't trigger collapse. Only when cooperation falls below threshold does the strategy protect itself.

3. **Forgiveness enables recovery**: If cooperation dips but starts recovering, ATR gives the group another chance rather than locking into mutual defection.

4. **Endgame stability**: By maintaining cooperation late-game when the group has been cooperative, ATR avoids the classic unraveling problem while still protecting against exploitation.

5. **Parameter-adaptive**: Thresholds scale with n and r, making this robust across different game configurations.
'''

description_COLLECTIVE_107 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all copies of this strategy will reason identically given the same information. Rather than treating this as a game against opponents, we recognize that coordinated cooperation among "us" creates surplus value, while our adaptive mechanisms protect against exploitation by defectors.

## Strategy Overview: **Adaptive Collective Reciprocity (ACR)**

The strategy maintains cooperation among like-minded players while gradually reducing cooperation in response to sustained defection in the population.

---

## Decision Rules

### State Variables (Updated Each Round)

```
cooperation_rate = (total cooperations by all players in previous round) / n
cumulative_trust = running average of cooperation_rate across all past rounds
my_cooperation_history = list of my past actions
```

### Round-by-Round Decision Logic

**Round 1 (No History):**
- **Always Cooperate**
- Rationale: With no information, we signal cooperative intent. If other copies of this strategy exist, we coordinate on mutual cooperation from the start.

**Rounds 2 through (r-1) (Middle Rounds):**

Calculate a **cooperation threshold** based on observed behavior:

```
base_threshold = k / n  # The break-even cooperation rate
adjusted_threshold = base_threshold - (0.1 * cumulative_trust)
# More forgiving if history shows cooperation; stricter if not
```

**Decision Rule:**
```
IF cooperation_rate >= adjusted_threshold:
    Cooperate
ELSE IF cooperation_rate >= base_threshold * 0.5:
    Cooperate with probability = cooperation_rate
ELSE:
    Defect
```

**Forgiveness Mechanism:**
- Every `ceil(r/5)` rounds, if currently in defection mode, cooperate once to test if conditions have improved
- This prevents permanent punishment spirals

**Round r (Final Round):**

```
IF cumulative_trust >= 0.7:
    Cooperate  # Reward sustained collective cooperation
ELSE IF cumulative_trust >= 0.4:
    Cooperate with probability = cumulative_trust
ELSE:
    Defect  # No future to build; don't be exploited
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Standard rules apply, but adjusted_threshold ≈ k/2 | Two-player case is essentially Prisoner's Dilemma |
| r = 2 | Cooperate Round 1; apply final-round rule in Round 2 | Minimal repeated game |
| k very close to 1 | Lower forgiveness frequency | Cooperation surplus is minimal; protect against exploitation |
| k close to n | Higher cooperation bias | Large gains from cooperation justify risk |
| All others defected last round | Check cumulative_trust before defecting | One bad round shouldn't override good history |
| Perfect cooperation so far | Continue cooperating | Don't break a successful equilibrium |

---

## Pseudocode Implementation

```python
def decide(round_num, total_rounds, n, k, history):
    if round_num == 1:
        return COOPERATE
    
    # Calculate metrics
    last_round_cooperations = count_cooperations(history, round_num - 1)
    cooperation_rate = last_round_cooperations / n
    cumulative_trust = average_cooperation_rate(history)
    
    base_threshold = k / n
    adjusted_threshold = max(0.1, base_threshold - (0.1 * cumulative_trust))
    
    # Final round logic
    if round_num == total_rounds:
        if cumulative_trust >= 0.7:
            return COOPERATE
        elif cumulative_trust >= 0.4:
            return COOPERATE with probability cumulative_trust
        else:
            return DEFECT
    
    # Forgiveness probe
    forgiveness_interval = ceil(total_rounds / 5)
    if round_num % forgiveness_interval == 0 and cooperation_rate < adjusted_threshold:
        return COOPERATE
    
    # Main decision
    if cooperation_rate >= adjusted_threshold:
        return COOPERATE
    elif cooperation_rate >= base_threshold * 0.5:
        return COOPERATE with probability cooperation_rate
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Self-coordination**: Multiple copies will cooperate together from round 1 and maintain cooperation throughout
2. **Robust to exploitation**: Gradually reduces cooperation when facing persistent defectors
3. **Forgiveness enables recovery**: Periodic cooperation tests allow return to mutual cooperation if defectors reform
4. **Parameter-adaptive**: Thresholds scale with k/n, the economically meaningful ratio
5. **End-game aware**: Maintains cooperation even in final rounds when trust has been established, capturing full surplus
'''

description_COLLECTIVE_108 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similar cooperative AI systems) may be playing, and we should be able to achieve mutual cooperation without explicit coordination. At the same time, the strategy must be robust against defectors and exploiters.

The key insight is that in a repeated public goods game, **collective cooperation dominates** (everyone gets k > 1 per round) while **mutual defection is wasteful** (everyone gets 1 per round). The challenge is establishing and maintaining cooperation without being exploited.

## Strategy: "Generous Threshold Trigger with Forgiveness"

### Decision Rules

**Round 1: Cooperate**
- Signal cooperative intent unconditionally
- This allows cooperative equilibria to emerge when playing with like-minded strategies

**Rounds 2 through (r-1): Conditional Cooperation based on Cooperation Rate**

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Cooperate if:**
```
coop_rate ≥ threshold(t, history)
```

**Threshold Calculation:**
```
base_threshold = (n - k) / n  # This is the break-even point where C and D yield equal payoffs

# Adaptive adjustment based on cumulative cooperation trend
avg_coop_rate = (total cooperations across all players and rounds) / (n × rounds_played)

if avg_coop_rate ≥ 0.6:
    threshold = max(0.3, base_threshold - 0.15)  # Be more forgiving in cooperative environments
elif avg_coop_rate ≥ 0.4:
    threshold = base_threshold  # Standard threshold
else:
    threshold = min(0.8, base_threshold + 0.1)  # Be more cautious in hostile environments
```

**Forgiveness Mechanism:**
```
If defected in previous round due to low cooperation, but cooperation rate rebounds above threshold:
    Cooperate (give the group another chance)

# Periodic forgiveness pulse (every ceil(r/5) rounds):
If current_round mod ceil(r/5) == 0 AND avg_coop_rate > 0.25:
    Cooperate regardless of previous round (attempt to restart cooperation)
```

**Final Round (round r): Conditional Defection with Collective Exception**

```
If avg_coop_rate over all previous rounds ≥ 0.7:
    Cooperate  # Maintain collective optimum with cooperative group
Else:
    Defect  # Standard game-theoretic response in non-cooperative environment
```

### Pseudocode Summary

```python
def decide(round_number, n, k, r, history):
    if round_number == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history, round_number - 1) / n
    avg_coop_rate = total_cooperations(history) / (n * (round_number - 1))
    
    base_threshold = (n - k) / n
    
    # Adaptive threshold
    if avg_coop_rate >= 0.6:
        threshold = max(0.3, base_threshold - 0.15)
    elif avg_coop_rate >= 0.4:
        threshold = base_threshold
    else:
        threshold = min(0.8, base_threshold + 0.1)
    
    # Final round logic
    if round_number == r:
        if avg_coop_rate >= 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # Periodic forgiveness pulse
    pulse_interval = ceil(r / 5)
    if round_number % pulse_interval == 0 and avg_coop_rate > 0.25:
        return COOPERATE
    
    # Main decision
    if prev_coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

### Key Properties

1. **Collectively Optimal**: When all players use this strategy, everyone cooperates every round, achieving payoff of k×r (maximized collective welfare)

2. **Robust to Defectors**: The threshold mechanism ensures we don't keep cooperating when too many players defect; we only need enough cooperators to make cooperation worthwhile

3. **Forgiving**: Periodic forgiveness pulses and trend-based threshold adjustment allow recovery from temporary breakdowns

4. **Adaptive**: The strategy adjusts its cooperation threshold based on observed group behavior, becoming more generous with cooperative groups and more protective against exploitative ones

5. **Parameter-Responsive**: The base threshold incorporates k and n, ensuring appropriate behavior across different game configurations
'''

description_COLLECTIVE_106 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I assume other players may be using similar reasoning, and I optimize for outcomes that are good when adopted by multiple rational agents. The strategy balances:
1. **Optimism** - Start cooperatively to establish mutual benefit
2. **Responsiveness** - Adapt to observed behavior patterns
3. **Forgiveness** - Allow recovery from temporary defections
4. **End-game awareness** - Handle the unraveling problem thoughtfully

---

## Strategy: "Graduated Collective Reciprocity" (GCR)

### Decision Framework

The strategy tracks a **cooperation index** based on recent group behavior and uses threshold-based decisions that account for game parameters.

---

### Round-by-Round Rules

#### **Round 1: Cooperate**
Begin with cooperation. This signals willingness to achieve mutual benefit and gives the collective a chance to establish a cooperative norm.

#### **Rounds 2 through (r-1): Adaptive Reciprocity**

Calculate the **recent cooperation rate** over a lookback window:

```
lookback_window = min(3, current_round - 1)
recent_coop_rate = (cooperators in last lookback_window rounds) / (n × lookback_window)
```

Calculate **cooperation threshold** based on game parameters:
```
base_threshold = (n - k) / (n - 1)
# This represents the break-even point where cooperation becomes collectively rational
# Adjusted slightly downward to be forgiving
adjusted_threshold = base_threshold × 0.7
```

**Decision Rule:**
- If `recent_coop_rate ≥ adjusted_threshold`: **Cooperate**
- If `recent_coop_rate < adjusted_threshold`: **Defect**

**Forgiveness Mechanism:**
Even when defecting due to low cooperation, periodically attempt to restart cooperation:
```
if defecting AND (rounds_since_last_cooperation ≥ ceiling(n/2)):
    Cooperate (probe for renewed cooperation)
```

#### **Final Round (Round r): Conditional Cooperation**

The last round has no future to incentivize, but a collective mindset recognizes that:
- If others are likely thinking collectively too, mutual cooperation is achievable
- Unconditional defection guarantees the worst collective outcome

**Decision Rule for Final Round:**
```
if (cooperation_rate over all previous rounds) ≥ 0.5:
    Cooperate  # Trust has been established, honor it
else:
    Defect     # Pattern suggests defection-dominant environment
```

---

### Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate lookback window (adaptive to game length)
    lookback = min(3, round - 1)
    
    # Count cooperators in recent rounds
    recent_cooperators = sum(cooperators in rounds [round - lookback, round - 1])
    recent_coop_rate = recent_cooperators / (n × lookback)
    
    # Calculate threshold
    base_threshold = (n - k) / (n - 1)
    adjusted_threshold = base_threshold × 0.7
    
    # Final round special handling
    if round == r:
        overall_coop_rate = total_cooperations / (n × (r - 1))
        if overall_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Standard rounds: threshold-based with forgiveness
    if recent_coop_rate >= adjusted_threshold:
        return COOPERATE
    else:
        # Check forgiveness probe
        rounds_defecting = count consecutive rounds I defected
        if rounds_defecting >= ceiling(n / 2):
            return COOPERATE  # Probe for cooperation restart
        else:
            return DEFECT
```

---

### Edge Cases Handled

| Situation | Response |
|-----------|----------|
| Round 1 | Cooperate unconditionally |
| Final round | Cooperate if historical cooperation ≥ 50% |
| All others defect | Defect after threshold breach, but probe periodically |
| All others cooperate | Cooperate continuously |
| Mixed/noisy behavior | Forgiveness margin (0.7 multiplier) accommodates noise |
| Very short games (r=2) | Round 1 cooperate, Round 2 uses overall history |
| Large n | Lookback window and forgiveness probe scale appropriately |

---

### Why This Strategy is Collectively Robust

1. **Self-reinforcing**: If multiple players use GCR, they cooperate together and achieve high payoffs
2. **Exploiter-resistant**: Sustained defection triggers defection response
3. **Recovery-capable**: Forgiveness probes allow escaping defection spirals
4. **Parameter-adaptive**: Threshold adjusts to the specific k/n ratio of each game
5. **Collectively rational end-game**: Maintains cooperation possibility in final round rather than guaranteed mutual destruction
'''

description_COLLECTIVE_109 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I recognize that if all players reason similarly, universal cooperation yields the best collective outcome. However, I must be robust to defectors while maintaining enough cooperative presence to signal and sustain cooperation with like-minded players.

## Strategy Overview: **Adaptive Threshold Cooperation with Forgiveness**

The strategy cooperates when there's sufficient evidence of a cooperative environment, defects to protect against exploitation, but maintains periodic cooperation to test for and encourage cooperative resurgence.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: Cooperate**

Rationale: Starting cooperatively signals willingness to achieve mutual benefit. With no history, optimism is warranted—especially since other collective-minded strategies likely reason similarly.

### Rounds 2 through (r-1): Adaptive Threshold Rule

**Calculate the cooperation rate from the previous round:**
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Primary Rule:**
- If `prev_coop_rate >= threshold(t)`, then **Cooperate**
- Otherwise, **Defect** with probability based on cooperation history

**Threshold Function:**
```
threshold(t) = max(0.3, 0.5 - 0.02 × t)
```
This starts at ~0.5 and gradually relaxes, rewarding even partial cooperation as the game progresses.

**Forgiveness Mechanism:**
Even when below threshold, cooperate with probability:
```
forgiveness_prob = 0.1 + (0.2 × cumulative_coop_rate)
```
where `cumulative_coop_rate` is the average cooperation rate across all previous rounds.

This ensures:
1. Never fully abandoning cooperation (maintains signal for recovery)
2. Higher forgiveness when historical cooperation has been decent
3. Opportunity for coordination to re-emerge after defection spirals

### Last Round (Round r): Conditional Cooperation

**Action depends on game history:**
```
if cumulative_coop_rate >= 0.6:
    Cooperate  # Reward sustained cooperation, honor the collective
else if prev_coop_rate >= 0.5:
    Cooperate  # Recent cooperation deserves reciprocation
else:
    Defect     # Protect against end-game exploitation
```

Rationale: Unlike pure game-theoretic reasoning (which says always defect in the last round), a collective mindset recognizes that if enough players maintain cooperation, the final round payoff is still maximized collectively. However, if cooperation has collapsed, there's no collective to honor.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    # Calculate statistics
    prev_cooperators = count_cooperators(history, round - 1)
    prev_coop_rate = prev_cooperators / n
    cumulative_coop_rate = total_cooperations(history) / (n × (round - 1))
    
    # Last round logic
    if round == r:
        if cumulative_coop_rate >= 0.6 OR prev_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: threshold with forgiveness
    threshold = max(0.3, 0.5 - 0.02 × round)
    
    if prev_coop_rate >= threshold:
        return COOPERATE
    else:
        # Forgiveness probability
        forgiveness = 0.1 + (0.2 × cumulative_coop_rate)
        if random() < forgiveness:
            return COOPERATE
        else:
            return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Optimistic Start**: Assumes others may share collective values
2. **Rewards Cooperation**: Continues cooperating when others do
3. **Gradual Tolerance**: Relaxing thresholds acknowledge that perfect cooperation is unrealistic
4. **Never Abandons Hope**: Forgiveness mechanism allows recovery from defection spirals
5. **Honors Sustained Cooperation**: Final-round cooperation rewards good collective behavior
6. **Robust to Exploitation**: Responds to defection but doesn't over-punish

This strategy succeeds when playing with similar strategies (mutual cooperation) while limiting losses against pure defectors through adaptive defection with bounded forgiveness.
'''

description_COLLECTIVE_107 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be using similar reasoning, and I aim to establish and maintain cooperation when possible while protecting against exploitation. The key insight is that mutual cooperation yields k/n × n = k > 1 per player, which dominates mutual defection (payoff = 1) when all cooperate.

## Strategy: **Adaptive Threshold Cooperation (ATC)**

### Decision Framework

The strategy tracks the **cooperation rate** from the previous round and uses adaptive thresholds that evolve based on game parameters and trajectory.

---

### Core Decision Rules

**Round 1: Optimistic Start**
- **Action: COOPERATE**
- Rationale: Signal cooperative intent. With collective reasoning, if others think similarly, we establish cooperation from the start. The potential gain from mutual cooperation (payoff = k) outweighs the risk of being exploited in a single round.

**Rounds 2 through (r-1): Adaptive Reciprocity**

Calculate the previous round's cooperation rate:
```
coop_rate = (number of cooperators in previous round) / n
```

Define adaptive threshold:
```
base_threshold = 1/k  # Minimum cooperation rate where C is individually rational
adaptive_threshold = max(base_threshold, 0.5 - (0.3 × rounds_remaining / r))
```

Decision logic:
```
IF coop_rate >= adaptive_threshold:
    ACTION = COOPERATE
ELSE IF coop_rate >= base_threshold AND coop_rate was increasing:
    ACTION = COOPERATE  # Give benefit of doubt on upward trends
ELSE:
    ACTION = DEFECT
```

**Last Round (Round r): Conditional Cooperation**
- This is where traditional game theory says "always defect"
- Instead: **COOPERATE if and only if cooperation rate in round (r-1) was ≥ 0.7**
- Rationale: If we've built strong cooperation, maintain it collectively. Defecting in the last round when others cooperate damages total welfare. If others are using similar collective reasoning, we preserve the cooperative outcome.

---

### Additional Adaptive Mechanisms

**1. Forgiveness Protocol**
After defecting due to low cooperation, if the next round shows cooperation rate ≥ 0.5:
- Return to cooperation immediately
- Don't require multiple rounds of "proof"

**2. Trend Detection**
Track 3-round moving average of cooperation rates:
```
IF current_coop_rate < threshold BUT trend is strongly positive (increasing by ≥ 0.15/round):
    ACTION = COOPERATE  # Support emerging cooperation
```

**3. Near-Unanimous Response**
```
IF coop_rate >= (n-1)/n:  # Only one defector
    ACTION = COOPERATE  # Don't punish the group for one defector
```

**4. Collapse Recovery**
```
IF coop_rate drops suddenly (by ≥ 0.4 in one round):
    Cooperate for one more round as a "second chance"
    Then follow normal rules
```

---

### Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history[round-1]) / n
    rounds_remaining = r - round
    
    # Last round special case
    if round == r:
        return COOPERATE if prev_coop_rate >= 0.7 else DEFECT
    
    # Calculate thresholds
    base_threshold = 1/k
    adaptive_threshold = max(base_threshold, 0.5 - (0.3 * rounds_remaining / r))
    
    # Check for near-unanimous cooperation
    if prev_coop_rate >= (n-1)/n:
        return COOPERATE
    
    # Check for positive trend
    trend = calculate_trend(history, window=3)
    
    # Main decision
    if prev_coop_rate >= adaptive_threshold:
        return COOPERATE
    elif prev_coop_rate >= base_threshold and trend > 0:
        return COOPERATE
    elif sudden_collapse(history) and not already_gave_second_chance:
        return COOPERATE  # One recovery attempt
    else:
        return DEFECT
```

---

### Why This Strategy is Collectively Aligned

1. **Starts cooperatively**: Enables coordination from round 1
2. **Maintains cooperation under reasonable conditions**: Doesn't defect at first sign of trouble
3. **Forgives**: Allows recovery from temporary breakdowns
4. **Doesn't exploit the last round**: Maintains cooperation if the group has cooperated
5. **Protects against persistent free-riders**: Will defect if cooperation collapses
6. **Parameter-adaptive**: Threshold adjusts to the k/n economics of the specific game
'''

description_COLLECTIVE_110 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy operates from a **collective mindset**: we assume all instances of this strategy will behave identically given the same game state. This creates implicit coordination without explicit communication. The strategy aims to establish and maintain cooperation while protecting against exploitation.

## Strategy Overview: "Graduated Collective Reciprocity"

The strategy uses three key principles:
1. **Optimistic start**: Begin cooperating to signal cooperative intent
2. **Proportional reciprocity**: Mirror the group's cooperation level
3. **Forgiveness with caution**: Allow recovery from defection spirals

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, we signal cooperative intent. If other collective players exist, this establishes mutual cooperation from the start.

---

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

**Decision Rule:**

```
IF coop_rate >= (n-1)/n THEN
    COOPERATE  # Near-universal cooperation - maintain it
    
ELSE IF coop_rate >= 0.5 THEN
    # Majority cooperating - use probabilistic matching
    COOPERATE with probability = coop_rate
    
ELSE IF coop_rate > 0 THEN
    # Minority cooperating - cautious defection with olive branch
    # Cooperate occasionally to test for recovery
    COOPERATE with probability = coop_rate × forgiveness_factor
    WHERE forgiveness_factor = (r - t) / r  # More forgiving early
    
ELSE  # coop_rate == 0
    # Total defection - attempt periodic recovery
    IF (t mod recovery_interval) == 0 THEN
        COOPERATE  # Periodic cooperation probe
    ELSE
        DEFECT
    WHERE recovery_interval = max(2, floor(n/2))
```

### Deterministic Tie-Breaking for Probabilistic Decisions

To ensure collective coordination, convert probabilities to deterministic rules:

```
threshold_position = (player_index - 1) / n

IF cooperation_probability >= threshold_position THEN
    COOPERATE
ELSE
    DEFECT
```

**Note:** If player indices aren't available, use a deterministic function of observable history (e.g., hash of previous round's action profile) to create pseudo-random but identical decisions across collective instances.

---

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory that predicts universal defection:

```
IF average_coop_rate_over_all_rounds >= 0.6 THEN
    COOPERATE  # Reward sustained cooperation
ELSE
    DEFECT  # No reputation benefit to protect
```

Rationale: Collective players maintain cooperation even in the final round if the game has been cooperative, reinforcing that cooperation was the right choice throughout.

---

## Pseudocode Summary

```
function decide(round t, history H, parameters n, k, r):
    
    if t == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(H, t-1)
    coop_rate = prev_cooperators / n
    
    if t == r:  # Final round
        avg_coop = average_cooperation_rate(H)
        return COOPERATE if avg_coop >= 0.6 else DEFECT
    
    # Middle rounds
    if coop_rate >= (n-1)/n:
        return COOPERATE
    
    if coop_rate >= 0.5:
        target_cooperators = floor(coop_rate × n)
        return COOPERATE if should_be_cooperator(target_cooperators, H) else DEFECT
    
    if coop_rate > 0:
        forgiveness = (r - t) / r
        adjusted_rate = coop_rate × forgiveness
        target_cooperators = floor(adjusted_rate × n)
        return COOPERATE if should_be_cooperator(target_cooperators, H) else DEFECT
    
    # coop_rate == 0
    recovery_interval = max(2, floor(n/2))
    return COOPERATE if (t mod recovery_interval) == 0 else DEFECT

function should_be_cooperator(target_count, H):
    # Deterministic selection based on history hash
    position = hash(H) mod n
    return position < target_count
```

---

## Edge Cases

| Scenario | Behavior |
|----------|----------|
| n = 2 | Standard TFT-like behavior with forgiveness |
| Very large n | Cooperation thresholds scale appropriately |
| r = 2 | Cooperate round 1, apply final-round rule in round 2 |
| k very close to 1 | Strategy unchanged (payoff structure doesn't affect cooperation logic) |
| All others always defect | Periodic probes, mostly defect to minimize losses |
| All others always cooperate | Sustained cooperation throughout |

---

## Why This Strategy is Collectively Optimal

1. **Self-coordination**: Identical strategies make identical decisions, achieving implicit coordination
2. **Robust to exploitation**: Proportional response limits losses against defectors
3. **Recovery capable**: Forgiveness mechanisms prevent permanent defection spirals
4. **Rewards cooperation**: Maintains final-round cooperation when deserved, maximizing collective gains
'''

description_COLLECTIVE_108 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **we succeed together or fail together**. Rather than viewing other players as opponents to exploit, I treat them as potential collaborators in a repeated interaction where mutual cooperation yields the best collective outcome. The strategy aims to:

1. Signal cooperative intent clearly
2. Reward cooperation generously
3. Punish defection proportionally but not vindictively
4. Forgive and rebuild trust when possible

## Strategy Name: **Adaptive Collective Threshold (ACT)**

---

## Decision Rules

### Key Metrics Tracked

```
cooperation_rate[t] = (number of cooperators in round t) / n
cumulative_coop_rate = (total cooperations across all rounds) / (n × rounds_played)
my_cooperation_debt = rounds_I_defected - rounds_I_cooperated (negative means I've cooperated more)
trend = cooperation_rate[t] - cooperation_rate[t-1]  (positive = improving)
```

### Round-by-Round Decision Logic

#### **Round 1: Unconditional Cooperation**
- **Action: COOPERATE**
- Rationale: Begin with a clear signal of cooperative intent. This establishes trust and gives others the opportunity to reciprocate.

#### **Rounds 2 through (r-1): Adaptive Threshold Response**

Calculate the **cooperation threshold** based on game parameters:
```
base_threshold = k / n  (the break-even point where cooperation becomes rational)
adjusted_threshold = base_threshold × 0.8  (be slightly generous)
```

**Decision Rule:**

```
IF cooperation_rate[t-1] >= adjusted_threshold:
    COOPERATE
ELIF trend > 0 AND cooperation_rate[t-1] >= adjusted_threshold × 0.5:
    COOPERATE  (reward improving behavior)
ELIF cumulative_coop_rate >= 0.5 AND random() < forgiveness_probability:
    COOPERATE  (occasional forgiveness to test for renewed cooperation)
ELSE:
    DEFECT
```

Where:
```
forgiveness_probability = 0.2 × (remaining_rounds / total_rounds)
```
This creates higher forgiveness early (when rebuilding trust matters) and lower forgiveness late (when exploitation risk increases).

#### **Final Round (Round r): Conditional Cooperation**

Unlike typical game theory advice to defect in the final round, this collective strategy:

```
IF cumulative_coop_rate >= 0.6:
    COOPERATE  (reward a cooperative history)
ELIF cooperation_rate[r-1] >= 0.8:
    COOPERATE  (match strong recent cooperation)
ELSE:
    DEFECT  (don't reward sustained defection)
```

Rationale: If playing against other collective-minded strategies, mutual final-round cooperation is achievable and beneficial. Only defect if the history suggests exploitation.

---

## Edge Cases

### **Small n (n=2):**
- Essentially becomes repeated Prisoner's Dilemma
- Strategy simplifies: cooperate if opponent cooperated, defect if opponent defected (Tit-for-Tat with forgiveness)

### **Large n (n >> 10):**
- Individual impact diminishes; focus on whether a critical mass cooperates
- Adjust threshold: cooperate if at least `ceiling(n × k/n)` players cooperated

### **Very Low k (k close to 1):**
- Cooperation barely beats defection even with full participation
- Lower the threshold slightly to encourage fragile cooperation

### **Very High k (k close to n):**
- Cooperation is highly valuable; be more forgiving
- Increase `forgiveness_probability` by factor of `k/(n-1)`

### **Short games (r ≤ 3):**
- Less room for learning; weight toward cooperation
- Reduce defection trigger sensitivity

### **Long games (r > 20):**
- More room for pattern establishment
- Implement a "cooperation streak bonus": after 3+ consecutive all-cooperate rounds, always cooperate

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    coop_rate = lambda t: sum(history[t]) / n if t > 0 else 0
    threshold = (k / n) * 0.8
    
    if round == 1:
        return COOPERATE
    
    prev_rate = coop_rate(round - 1)
    cumulative = sum(sum(h) for h in history.values()) / (n * (round - 1))
    trend = prev_rate - coop_rate(round - 2) if round > 2 else 0
    forgiveness = 0.2 * ((r - round) / r)
    
    if round == r:  # Final round
        if cumulative >= 0.6 or prev_rate >= 0.8:
            return COOPERATE
        return DEFECT
    
    # Standard rounds
    if prev_rate >= threshold:
        return COOPERATE
    if trend > 0 and prev_rate >= threshold * 0.5:
        return COOPERATE
    if cumulative >= 0.5 and random() < forgiveness:
        return COOPERATE
    return DEFECT
```

---

## Why This Strategy is Collectively Robust

1. **Establishes trust**: Opens cooperatively, giving the collective a chance
2. **Rewards cooperation**: Cooperates when others do, reinforcing positive behavior
3. **Proportional response**: Doesn't over-punish; defects only when cooperation falls below viable thresholds
4. **Forgiveness mechanism**: Allows recovery from temporary breakdowns
5. **Trend-sensitive**: Rewards movement toward cooperation, not just absolute levels
6. **Resistant to exploitation**: Defects against persistent defectors, avoiding being a "sucker"
7. **Collective final round**: Maintains cooperation possibility even in endgame against like-minded players
'''

description_COLLECTIVE_111 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective identity**: all instances running this strategy act as one unified agent. We aim to maximize total welfare while protecting ourselves against exploitation. The key insight is that with k > 1, mutual cooperation always generates more total value than mutual defection—our challenge is sustaining cooperation in a world where others may not share our values.

## Strategy Overview: "Graduated Collective Reciprocity"

We use a threshold-based cooperation system that:
1. Starts optimistically to establish cooperation
2. Responds proportionally to the collective behavior we observe
3. Forgives gradually to allow recovery from defection spirals
4. Accounts for endgame dynamics

---

## Decision Rules

### Key Variables (tracked across rounds)

```
cooperation_rate(t) = (total C plays by all players in round t) / n
cumulative_coop_rate = (total C plays across all rounds) / (n × rounds_played)
rounds_remaining = r - current_round
```

### Round-by-Round Decision Logic

#### **Round 1: Unconditional Cooperation**
- **Action: COOPERATE**
- Rationale: We cannot learn anything without giving cooperation a chance. This signals good faith and allows us to gather information.

#### **Rounds 2 through (r-1): Adaptive Threshold Response**

Calculate the **cooperation threshold** that justifies our contribution:

```
base_threshold = 1/k  # Break-even point where expected return = cost
adaptive_threshold = base_threshold × (1 - forgiveness_factor)

where:
  forgiveness_factor = 0.2 × (rounds_remaining / r)
  # More forgiving early, stricter late
```

**Decision Rule:**
```
IF cooperation_rate(t-1) ≥ adaptive_threshold:
    COOPERATE
ELSE IF cooperation_rate(t-1) < adaptive_threshold AND cumulative_coop_rate ≥ base_threshold:
    COOPERATE with probability = cumulative_coop_rate
ELSE:
    DEFECT
```

**Interpretation:**
- If recent cooperation is healthy → cooperate to maintain it
- If recent cooperation dipped but historical average is good → probabilistically cooperate (forgiveness mechanism)
- If both recent and historical cooperation are poor → defect to avoid exploitation

#### **Final Round (round r): Conditional Cooperation**

The last round removes shadow of future punishment, but we remain conditionally cooperative:

```
IF cumulative_coop_rate ≥ 0.5:
    COOPERATE  # Reward a cooperative history
ELSE:
    DEFECT     # No reason to cooperate with persistent defectors
```

**Rationale:** Unlike pure game theory which prescribes certain defection, we recognize:
1. Other collective-minded agents may also cooperate
2. A 50%+ cooperation rate suggests enough players value cooperation
3. The marginal loss from "unnecessary" cooperation is bounded

---

## Edge Case Handling

### Small n (n = 2)
- Strategy remains valid but becomes essentially Tit-for-Tat with forgiveness
- Threshold naturally adjusts since k/n ratio changes

### Large n
- Individual defections have smaller impact on cooperation_rate
- Strategy becomes more stable and less reactive to noise

### Extreme k values
- k close to 1: base_threshold approaches 1, making us appropriately skeptical
- k close to n: base_threshold approaches 1/n, making us appropriately optimistic

### All-defector environment
- After round 1, we'll quickly shift to defection
- We lose at most 1 unit (round 1 cooperation) before adapting

### All-cooperator environment
- We cooperate throughout, achieving optimal collective outcome

### Mixed/noisy environments
- Probabilistic cooperation in middle zone prevents lock-in to either extreme
- Cumulative tracking smooths out round-to-round noise

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    # Calculate metrics
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate_last = last_round_coops / n
    cumulative_coops = total_cooperations(history)
    cumulative_rate = cumulative_coops / (n × (round - 1))
    
    # Calculate thresholds
    base_threshold = 1 / k
    rounds_remaining = r - round
    forgiveness = 0.2 × (rounds_remaining / r)
    adaptive_threshold = base_threshold × (1 - forgiveness)
    
    if round == r:  # Final round
        if cumulative_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds
    if coop_rate_last >= adaptive_threshold:
        return COOPERATE
    elif cumulative_rate >= base_threshold:
        return COOPERATE with probability cumulative_rate
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Coordination among copies**: All instances of this strategy will behave identically given the same history, ensuring we cooperate together or defect together.

2. **Robustness**: We're not exploitable long-term (we stop cooperating with defectors) but we're not hostile (we give cooperation chances to succeed).

3. **Welfare-maximizing intent**: When cooperation is viable, we support it. We only defect when the social environment makes cooperation self-destructive.

4. **Adaptability**: The strategy responds to actual behavior, not assumptions about opponent types.
'''

description_COLLECTIVE_109 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that mutual cooperation yields the best collective outcome (payoff of k > 1 for everyone) compared to mutual defection (payoff of 1 for everyone). My goal is to foster and sustain cooperation while protecting against exploitation.

The strategy is built on three principles:
1. **Lead with cooperation** to establish trust and signal cooperative intent
2. **Respond proportionally** to the observed cooperation level in the group
3. **Forgive strategically** to recover from defection spirals while remaining robust

---

## Strategy: Adaptive Threshold Cooperation (ATC)

### Decision Rule Overview

I cooperate if the recent cooperation rate in the group meets or exceeds a dynamic threshold that adjusts based on game phase and history.

---

### Detailed Decision Rules

#### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- Rationale: Signal cooperative intent and give others the opportunity to establish mutual cooperation.

#### Rounds 2 through (r-1): Adaptive Threshold Response

**Step 1: Calculate recent cooperation rate**
```
Look at the previous round (or last 2-3 rounds if r > 10)
coop_rate = (number of cooperators among OTHER players) / (n - 1)
```

**Step 2: Determine dynamic threshold**
```
base_threshold = 0.5

# Adjust based on game phase
progress = current_round / r
if progress < 0.3:
    # Early game: be generous to establish cooperation
    threshold = base_threshold - 0.15
elif progress > 0.7:
    # Late game: tighten threshold as end approaches
    threshold = base_threshold + 0.1
else:
    threshold = base_threshold

# Adjust based on cooperation trend
if cooperation is increasing over last 3 rounds:
    threshold = threshold - 0.1  # reward positive momentum
if cooperation is decreasing over last 3 rounds:
    threshold = threshold + 0.05  # be more cautious
```

**Step 3: Make decision**
```
if coop_rate >= threshold:
    COOPERATE
else:
    DEFECT
```

**Step 4: Forgiveness mechanism**
```
# Every ceil(r/5) rounds, if currently defecting due to low cooperation:
if round_number % ceil(r/5) == 0 AND last_action == DEFECT:
    COOPERATE  # Probe for cooperation recovery
```

#### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which suggests always defecting in the final round:
```
if coop_rate in previous round >= 0.6:
    COOPERATE  # Honor the cooperative relationship
else:
    DEFECT  # No trust to maintain
```

Rationale: In a tournament with collective-minded agents, maintaining cooperation even in the final round demonstrates commitment to collective welfare and may be reciprocated.

---

### Edge Case Handling

| Situation | Action |
|-----------|--------|
| n = 2 (minimum players) | Use strict Tit-for-Tat: cooperate if opponent cooperated last round |
| Very short game (r ≤ 3) | Cooperate rounds 1 and 2; round 3 follow standard final round rule |
| Very long game (r > 20) | Use 3-round moving average for cooperation rate |
| All others defected last round | Defect, but use forgiveness probe next eligible round |
| All others cooperated last round | Cooperate |
| k very close to 1 | Strategy unchanged (collective benefit still exists) |
| k close to n | Strategy unchanged (but expect more natural cooperation) |

---

### Pseudocode Summary

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    others_coop_last = count_cooperators(history[round-1]) - my_action(history[round-1])
    coop_rate = others_coop_last / (n - 1)
    
    # Calculate threshold
    progress = round / r
    threshold = 0.5 + (0.1 if progress > 0.7 else (-0.15 if progress < 0.3 else 0))
    threshold += trend_adjustment(history)
    
    # Forgiveness probe
    forgiveness_interval = ceil(r / 5)
    if round % forgiveness_interval == 0 and my_last_action == DEFECT:
        return COOPERATE
    
    # Final round
    if round == r:
        return COOPERATE if coop_rate >= 0.6 else DEFECT
    
    # Standard decision
    return COOPERATE if coop_rate >= threshold else DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Initiates cooperation** rather than waiting for others
2. **Rewards cooperative groups** by maintaining contribution
3. **Proportional response** avoids triggering defection spirals from single defectors
4. **Forgiveness** allows recovery from mutual defection
5. **Final-round cooperation** signals genuine collective commitment, not just strategic mimicry
'''

description_COLLECTIVE_112 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we assume all instances of this strategy will reason identically given the same information. This isn't coordination through communication—it's coordination through shared rationality. If I reason that cooperation is correct given the current state, so will every other instance of this strategy.

The key insight: with k > 1, **if all strategic players cooperate, everyone benefits more than universal defection**. The challenge is maintaining cooperation despite the individual temptation to defect and despite unpredictable opponents.

---

## Strategy: "Collective Threshold Cooperation with Forgiveness"

### Decision Framework

The strategy tracks the **cooperation rate** among all players and uses adaptive thresholds to decide whether the collective environment supports continued cooperation.

### Key Variables

- `coop_rate(t)` = proportion of total C plays in round t (across all n players)
- `recent_coop_rate` = weighted average cooperation rate over last 3 rounds
- `baseline_threshold` = k/n (the break-even point where cooperation pays for itself)

---

## Decision Rules

### Round 1: Cooperate Unconditionally
**Rationale**: Establish cooperative intent. With multiple strategic players reasoning identically, we create an initial cooperative signal. The cost of one round of potential exploitation is small relative to the information gained and cooperative foundation established.

### Rounds 2 through (r-1): Adaptive Threshold Cooperation

**Cooperate if ANY of the following conditions are met:**

1. **Sufficient Recent Cooperation**: 
   - `recent_coop_rate ≥ baseline_threshold`
   - *Rationale*: If enough players are cooperating that contributions are worthwhile, continue cooperating.

2. **Recovery Detection** (Forgiveness Mechanism):
   - `coop_rate(t-1) > coop_rate(t-2)` AND `coop_rate(t-1) ≥ 0.3`
   - *Rationale*: If cooperation is trending upward and non-negligible, give the collective another chance.

3. **Early Game Benefit of Doubt** (rounds 2-3 only):
   - `coop_rate(t-1) ≥ 0.25`
   - *Rationale*: Allow time for cooperation patterns to emerge; don't abandon too quickly.

**Otherwise: Defect**

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection in the final round, we apply collective reasoning:

**Cooperate if**: `recent_coop_rate ≥ 0.5`

**Rationale**: If a majority has been cooperating, we trust that other collective reasoners will also cooperate in the final round, maintaining the cooperative equilibrium. Unilateral defection by one strategic player while others cooperate yields marginal gain but breaks the collective outcome we've built.

**Defect if**: `recent_coop_rate < 0.5`

**Rationale**: If cooperation has already broken down, there's no collective to preserve.

---

## Pseudocode

```
function decide(round, history, n, k, r):
    baseline = k / n
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation rates
    coop_rate_last = count_cooperators(history, round-1) / n
    
    if round >= 3:
        coop_rate_prev = count_cooperators(history, round-2) / n
        recent_coop_rate = 0.5 * coop_rate_last + 0.3 * coop_rate_prev + 0.2 * coop_rate(round-3)
    else:
        recent_coop_rate = coop_rate_last
    
    # Final round logic
    if round == r:
        if recent_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    # Condition 1: Sufficient cooperation
    if recent_coop_rate >= baseline:
        return COOPERATE
    
    # Condition 2: Recovery detection (forgiveness)
    if round >= 3:
        if coop_rate_last > coop_rate_prev AND coop_rate_last >= 0.3:
            return COOPERATE
    
    # Condition 3: Early game patience
    if round <= 3 AND coop_rate_last >= 0.25:
        return COOPERATE
    
    # Default: Defect
    return DEFECT
```

---

## Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| Round 1 | C | Establish cooperative baseline |
| All opponents defected round 1 | C (if round 2-3) | Early patience; may be noise |
| Sustained low cooperation (≥4 rounds below threshold) | D | Environment is non-cooperative |
| Single bad round after good history | C | Forgiveness; may be anomaly |
| Final round, high cooperation history | C | Collective reasoning; trust other strategics |
| n=2 (minimum players) | Same rules apply | Reduces to repeated PD-like dynamics |
| k very close to n | More forgiving thresholds naturally | baseline approaches 1, easier to sustain |
| k very close to 1 | Stricter thresholds naturally | baseline approaches 1/n, harder to sustain |

---

## Why This Strategy is Robust

1. **Against all-defect opponents**: Quickly stops cooperating after early rounds, limiting losses
2. **Against all-cooperate opponents**: Maintains cooperation throughout, maximizing joint payoff
3. **Against mixed/random opponents**: Adapts based on actual cooperation levels
4. **Against tit-for-tat variants**: Initial cooperation and forgiveness maintain productive relationships
5. **With other collective reasoners**: Converges to sustained cooperation through identical reasoning
6. **Against exploiters**: Threshold mechanism withdraws cooperation when it's not reciprocated

The strategy is **not exploitable in expectation** over many rounds because it withdraws cooperation from non-cooperative environments while maintaining it in cooperative ones.
'''

description_COLLECTIVE_110 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players in my cohort are reasoning similarly and will arrive at similar strategic conclusions. We cannot explicitly coordinate, but we can implicitly align by adopting the same principled approach. The strategy aims to:

1. **Establish cooperation** through initial goodwill
2. **Sustain cooperation** by rewarding collective cooperation
3. **Protect against exploitation** by responding to defection
4. **Recover from breakdowns** by offering forgiveness pathways
5. **Handle endgame effects** thoughtfully

---

## Strategy: Adaptive Collective Reciprocity (ACR)

### Decision Variables

Let me define key variables tracked across rounds:

- `t` = current round (1-indexed)
- `r` = total rounds
- `n` = number of players
- `k` = multiplication factor
- `coop_rate(t)` = proportion of players who cooperated in round t (excluding self)
- `avg_coop_rate` = average cooperation rate across all previous rounds
- `consecutive_high_coop` = consecutive rounds where coop_rate ≥ threshold
- `consecutive_low_coop` = consecutive rounds where coop_rate < threshold

### Thresholds (parameterized)

```
HIGH_COOP_THRESHOLD = 0.6  # Consider environment "cooperative" above this
LOW_COOP_THRESHOLD = 0.3   # Consider environment "hostile" below this
FORGIVENESS_INTERVAL = max(3, floor(r/10))  # How often to test recovery
```

---

## Decision Rules by Phase

### Phase 1: Opening (Round 1)
**Action: COOPERATE**

Rationale: With no history, we signal cooperative intent. If other collective-minded players reason similarly, we establish mutual cooperation from the start. The cost of one round of potential exploitation is small relative to the benefit of establishing a cooperative norm.

---

### Phase 2: Main Game (Rounds 2 to r-1)

**Primary Rule: Conditional Cooperation with Forgiveness**

```
IF coop_rate(t-1) >= HIGH_COOP_THRESHOLD:
    COOPERATE
    
ELSE IF coop_rate(t-1) >= LOW_COOP_THRESHOLD:
    # Mixed environment - use probabilistic response
    COOPERATE with probability = coop_rate(t-1)
    
ELSE IF coop_rate(t-1) < LOW_COOP_THRESHOLD:
    # Hostile environment - protect but offer recovery
    IF (t mod FORGIVENESS_INTERVAL == 0) AND (avg_coop_rate > 0.2):
        COOPERATE  # Periodic forgiveness probe
    ELSE:
        DEFECT
```

**Collective Boost Modifier:**
If cooperation has been sustained (consecutive_high_coop ≥ 3), become more resilient to single-round dips:

```
IF consecutive_high_coop >= 3 AND coop_rate(t-1) >= 0.4:
    COOPERATE  # Don't abandon stable cooperation over one bad round
```

---

### Phase 3: Endgame (Final Round r)

The endgame is tricky because standard backward induction suggests defection. However, with a collective mindset:

```
IF avg_coop_rate >= 0.7 AND consecutive_high_coop >= floor(r/3):
    COOPERATE  # Reward sustained cooperation, maintain collective outcome
    
ELSE IF avg_coop_rate >= 0.5:
    COOPERATE with probability = avg_coop_rate
    
ELSE:
    DEFECT  # Environment has been uncooperative
```

---

## Complete Pseudocode

```python
def decide(t, r, n, k, history):
    """
    t: current round (1-indexed)
    r: total rounds
    n: number of players
    k: multiplication factor
    history: list of previous rounds, each containing all players' actions
    """
    
    # Constants
    HIGH_THRESH = 0.6
    LOW_THRESH = 0.3
    FORGIVE_INTERVAL = max(3, r // 10)
    
    # Round 1: Cooperate unconditionally
    if t == 1:
        return COOPERATE
    
    # Calculate statistics from history
    last_coop_rate = count_cooperators(history[t-2]) / (n - 1)  # exclude self
    avg_coop_rate = mean([count_cooperators(h) / (n-1) for h in history])
    consec_high = count_consecutive_high(history, HIGH_THRESH)
    
    # Final round logic
    if t == r:
        if avg_coop_rate >= 0.7 and consec_high >= r // 3:
            return COOPERATE
        elif avg_coop_rate >= 0.5:
            return COOPERATE if random() < avg_coop_rate else DEFECT
        else:
            return DEFECT
    
    # Main game logic
    if last_coop_rate >= HIGH_THRESH:
        return COOPERATE
    
    elif last_coop_rate >= LOW_THRESH:
        # Resilience check for established cooperation
        if consec_high >= 3 and last_coop_rate >= 0.4:
            return COOPERATE
        # Probabilistic matching
        return COOPERATE if random() < last_coop_rate else DEFECT
    
    else:  # Hostile environment
        # Periodic forgiveness
        if (t % FORGIVE_INTERVAL == 0) and (avg_coop_rate > 0.2):
            return COOPERATE
        return DEFECT
```

---

## Robustness Features

| Opponent Type | Strategy Response |
|--------------|-------------------|
| **All Cooperators** | Sustained mutual cooperation (payoff ≈ k per round) |
| **All Defectors** | Quick detection, defect with periodic probes |
| **Tit-for-Tat variants** | Mutual cooperation established from round 1 |
| **Random players** | Probabilistic matching limits exploitation |
| **Exploiters** | Threshold detection triggers protection |
| **Mixed population** | Adapts to prevailing cooperation level |

---

## Why This Works Collectively

1. **Convergent reasoning**: Any AI reasoning about collective benefit arrives at similar "cooperate-if-others-cooperate" logic
2. **Clear signals**: Opening cooperation and threshold-based responses create predictable, learnable patterns
3. **Forgiveness enables recovery**: Even after breakdowns, periodic cooperation attempts allow re-establishment of mutual cooperation
4. **Endgame cooperation**: By conditioning final-round behavior on history, we avoid pure backward induction collapse while protecting against exploitation
'''

description_COLLECTIVE_113 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I recognize that if all players reason similarly and adopt cooperative approaches, we all achieve better outcomes than mutual defection. However, I must be robust to defectors while maintaining enough cooperation to sustain collective benefits.

The key insight is that in a repeated game, **cooperation can be sustained through conditional reciprocity** - but with n players, I need to respond to the *aggregate* behavior of the group rather than tracking individuals.

---

## Strategy: **Generous Threshold Tit-for-Tat (GTFT-Threshold)**

### Decision Rule

**Cooperate if and only if the cooperation rate in the previous round meets or exceeds a dynamic threshold, with built-in generosity.**

---

## Detailed Specification

### Parameters (derived from game parameters)

```
base_threshold = 0.5  # Expect at least half to cooperate
forgiveness_rate = 0.1  # Probability of cooperating despite threshold not met
final_round_buffer = 2  # Rounds before end to begin defection consideration
```

### Round-by-Round Rules

#### **Round 1 (First Round):**
- **Action: COOPERATE**
- Rationale: Signal cooperative intent, establish foundation for mutual cooperation, give the collective a chance to coordinate.

#### **Rounds 2 through (r - final_round_buffer):**

```
Let prev_coop_rate = (number of cooperators in previous round) / n

# Calculate adaptive threshold based on trend
if round >= 3:
    trend = prev_coop_rate - (cooperation rate two rounds ago)
else:
    trend = 0

adaptive_threshold = base_threshold - (0.1 × trend)  # Lower bar if cooperation rising
adaptive_threshold = clamp(adaptive_threshold, 0.3, 0.7)  # Keep reasonable bounds

# Main decision
if prev_coop_rate >= adaptive_threshold:
    ACTION = COOPERATE
else:
    # Forgiveness mechanism - occasionally cooperate to test if defection was noise
    if random() < forgiveness_rate:
        ACTION = COOPERATE
    else:
        ACTION = DEFECT
```

#### **Final Rounds (last 2 rounds when r > 5, last round when r ≤ 5):**

```
# Gradual transition rather than sudden defection
if this is the final round:
    if prev_coop_rate >= 0.7:  # High cooperation maintained
        ACTION = COOPERATE  # Reward sustained cooperation
    else:
        ACTION = DEFECT
        
if this is second-to-last round:
    # Use standard rules but with slightly higher threshold
    Apply standard rules with base_threshold = 0.6
```

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| **r = 2** | R1: Cooperate, R2: Cooperate if R1 had ≥50% cooperation | Minimal game, stay cooperative |
| **n = 2** | Standard rules apply | Reduces to standard 2-player IPD-like game |
| **All defected last round** | 10% chance cooperate, else defect | Forgiveness allows recovery from collective collapse |
| **All cooperated last round** | Cooperate | Reward and maintain mutual cooperation |
| **k very close to 1** | Rules unchanged | Low k makes cooperation harder to sustain but collective benefit still exists |
| **k very close to n** | Rules unchanged | High k makes cooperation very beneficial; strategy naturally sustains it |

---

## Why This Strategy is Collectively Rational

1. **Starts cooperative**: Creates opportunity for mutual benefit from the outset
2. **Reciprocates**: Rewards group cooperation, punishes group defection
3. **Forgiving**: Random forgiveness prevents permanent collapse from noise or mistakes
4. **Adaptive**: Threshold adjusts to trends - becomes more lenient when cooperation is growing
5. **End-game aware**: Doesn't naively cooperate in final rounds, but doesn't defect prematurely either
6. **Collectively aligned**: If all players use this strategy, cooperation is sustained throughout (except possibly final round)

---

## Expected Behavior in Tournament

- **Against all cooperators**: Sustained mutual cooperation → high payoffs
- **Against all defectors**: Quick transition to defection after round 1 → limits losses
- **Against mixed strategies**: Adapts to prevailing behavior, cooperates when viable
- **Against similar strategies**: Mutual cooperation likely emerges and sustains
'''

description_COLLECTIVE_111 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similarly-minded agents) may be in the game. The goal is to establish cooperation when possible, sustain it through clear signaling, but protect against exploitation. The strategy must work whether I'm playing with copies of myself, cooperative strangers, or pure defectors.

## Strategy Overview: **Adaptive Threshold Cooperation with Forgiveness**

The strategy cooperates when there's sufficient evidence of collective cooperation, defects to protect against exploitation, and uses structured forgiveness to allow recovery from temporary breakdowns.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: In a collective mindset, we must give cooperation a chance to emerge. Starting with defection guarantees a defection spiral. The cost of one round of potential exploitation is worth the benefit of signaling cooperative intent and enabling coordination.

---

### Rounds 2 through (r-1): Adaptive Threshold Rule

**Calculate the cooperation ratio from the previous round:**
```
prev_coop_ratio = (number of cooperators in round t-1) / n
```

**Primary Decision Rule:**
```
IF prev_coop_ratio >= cooperation_threshold THEN COOPERATE
ELSE apply forgiveness mechanism
```

**Cooperation Threshold Calculation:**
```
base_threshold = 0.5
efficiency_bonus = (k - 1) / (n - 1)  # Higher k makes cooperation more valuable
cooperation_threshold = max(0.3, base_threshold - efficiency_bonus * 0.2)
```

This threshold typically falls between 0.3 and 0.5, meaning we cooperate if at least 30-50% of players cooperated last round.

---

### Forgiveness Mechanism

When cooperation falls below threshold, don't immediately abandon cooperation permanently:

```
forgiveness_tokens = floor(r / 5)  # More rounds = more forgiveness opportunities
tokens_used = 0

IF prev_coop_ratio < cooperation_threshold:
    IF tokens_used < forgiveness_tokens AND prev_coop_ratio > 0.1:
        # Someone is still trying - give another chance
        COOPERATE
        tokens_used += 1
    ELSE:
        DEFECT
```

**Forgiveness Reset:** If cooperation ratio returns above threshold for 2 consecutive rounds, reset `tokens_used = 0`.

---

### Trend Detection

Track whether cooperation is trending up or down:

```
IF round >= 3:
    trend = prev_coop_ratio - coop_ratio_two_rounds_ago
    
    IF trend > 0.1:  # Cooperation increasing
        # Lower threshold slightly to encourage momentum
        effective_threshold = cooperation_threshold - 0.1
    ELIF trend < -0.2:  # Cooperation collapsing
        # Be more defensive
        effective_threshold = cooperation_threshold + 0.1
```

---

### Final Round: Conditional Cooperation

**Contrary to standard game theory**, I do NOT automatically defect in the final round.

```
IF cumulative_coop_ratio >= 0.6:
    # Strong cooperative history - maintain cooperation as collective commitment
    COOPERATE
ELSE:
    DEFECT
```

Rationale: In a collective mindset, final-round defection destroys trust for future interactions (reputation matters beyond single games) and reduces total group welfare. If we've built cooperation, honor it.

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    # Initialize parameters
    base_threshold = 0.5
    efficiency_bonus = (k - 1) / (n - 1)
    cooperation_threshold = max(0.3, base_threshold - efficiency_bonus * 0.2)
    forgiveness_tokens = floor(r / 5)
    
    # Round 1: Always cooperate
    IF round == 1:
        RETURN COOPERATE
    
    # Calculate metrics
    prev_coop_ratio = count_cooperators(history[round-1]) / n
    cumulative_coop_ratio = total_cooperations(history) / (n * (round - 1))
    tokens_used = count_forgiveness_used(history)
    
    # Trend adjustment (round 3+)
    effective_threshold = cooperation_threshold
    IF round >= 3:
        trend = prev_coop_ratio - count_cooperators(history[round-2]) / n
        IF trend > 0.1:
            effective_threshold -= 0.1
        ELIF trend < -0.2:
            effective_threshold += 0.1
    
    # Final round logic
    IF round == r:
        IF cumulative_coop_ratio >= 0.6:
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT
    
    # Main decision
    IF prev_coop_ratio >= effective_threshold:
        RETURN COOPERATE
    ELIF tokens_used < forgiveness_tokens AND prev_coop_ratio > 0.1:
        use_forgiveness_token()
        RETURN COOPERATE
    ELSE:
        RETURN DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Self-recognition**: Multiple copies of this strategy will establish and maintain cooperation from round 1 onward, achieving near-maximum collective payoff.

2. **Robustness to noise**: Forgiveness tokens prevent single defections or mistakes from collapsing cooperation.

3. **Protection against exploitation**: The threshold mechanism means pure defectors don't benefit indefinitely—we stop cooperating when it's clearly being exploited.

4. **Adaptive to game parameters**: Higher k (more efficient public good) lowers our threshold, recognizing that cooperation is more valuable. More rounds grants more forgiveness.

5. **Emergent coordination**: By using observable, deterministic rules based on common history, similar strategies can implicitly coordinate without communication.
'''

description_COLLECTIVE_114 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I recognize that if all players reason as I do, mutual cooperation yields the best collective outcome. However, I must also be robust to defectors while maintaining enough cooperative signaling to build trust with like-minded players.

The key insight is that with parameters where 1 < k < n, cooperation is socially optimal (total welfare is maximized when all cooperate) but individually tempting to defect. My strategy aims to be a "conditional cooperator with forgiveness" - rewarding cooperation, punishing defection, but allowing redemption.

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: Start with good faith. This signals cooperative intent and allows collective benefit if others think similarly. The cost of being exploited once is acceptable to establish cooperative potential.

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Rule:**

```
IF coop_rate >= threshold THEN COOPERATE
ELSE DEFECT with probability based on coop_rate
```

**Threshold Calculation (adaptive to parameters):**
```
base_threshold = 0.5
# Adjust based on how favorable cooperation is
benefit_ratio = k / n  # Per-capita return from each contribution
threshold = base_threshold - (benefit_ratio - 0.5) * 0.3
# Clamp between 0.3 and 0.7
threshold = max(0.3, min(0.7, threshold))
```

**Probabilistic Cooperation Below Threshold:**
When coop_rate < threshold, don't immediately abandon cooperation entirely:
```
cooperation_probability = (coop_rate / threshold) * 0.5
# This gives partial cooperation chance even in hostile environments
# Allows recovery from coordination failures
```

### Forgiveness Mechanism
Track cooperation trends across rounds:
```
IF coop_rate increased from round (t-2) to (t-1) THEN
    boost cooperation_probability by 0.2
    # Reward improving behavior in the group
```

### Last Round: Conditional Cooperation

Unlike standard game theory which prescribes defection in the last round, I maintain conditional cooperation:

```
IF average_coop_rate_over_all_rounds >= 0.6 THEN COOPERATE
ELSE DEFECT
```

Rationale: If the group has demonstrated sustained cooperation, maintaining it in the final round honors the collective relationship and achieves the best mutual outcome. If the group has been largely defecting, there's no cooperative relationship to preserve.

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    IF round == 1:
        RETURN COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_rate = count_cooperators(history, round-1) / n
    
    # Calculate adaptive threshold
    benefit_ratio = k / n
    threshold = clamp(0.5 - (benefit_ratio - 0.5) * 0.3, 0.3, 0.7)
    
    # Check for improving trend (forgiveness)
    trend_bonus = 0
    IF round > 2:
        prev_prev_rate = count_cooperators(history, round-2) / n
        IF prev_coop_rate > prev_prev_rate:
            trend_bonus = 0.2
    
    # Last round logic
    IF round == r:
        avg_coop = average_cooperation_rate(history)
        IF avg_coop >= 0.6:
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT
    
    # Main decision logic for middle rounds
    IF prev_coop_rate >= threshold:
        RETURN COOPERATE
    ELSE:
        coop_prob = (prev_coop_rate / threshold) * 0.5 + trend_bonus
        coop_prob = min(coop_prob, 0.7)  # Cap probability
        RETURN COOPERATE with probability coop_prob, else DEFECT
```

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Cooperate | Good faith opening |
| Everyone defected last round | Defect (90% probability) | Protect against exploitation |
| Everyone cooperated last round | Cooperate | Reward and sustain cooperation |
| Last round after sustained cooperation | Cooperate | Honor the collective |
| n=2 (minimum players) | Same rules apply | Becomes similar to iterated prisoner's dilemma |
| Very high k (close to n) | Lower threshold | Cooperation is more rewarding |

## Why This Strategy is Collectively Aligned

1. **It rewards cooperation**: Groups of players using this strategy will sustain cooperation and achieve near-optimal payoffs.

2. **It's forgiving**: A single round of low cooperation doesn't permanently collapse trust - the probabilistic element and trend-tracking allow recovery.

3. **It's not exploitable**: Sustained defection is met with defection, preventing pure defectors from extracting unlimited value.

4. **It signals clearly**: The cooperative opening and responsive behavior make intentions legible to other conditional cooperators.
'''

description_COLLECTIVE_112 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players reason similarly and cooperate, we all achieve the best collective outcome (payoff of k per round vs. 1 for universal defection). The strategy aims to **sustain cooperation when possible** while **protecting against exploitation** and **signaling cooperative intent clearly**.

## Strategy Overview: "Generous Collective Trigger"

The strategy combines:
1. **Optimistic start** - Signal cooperative intent
2. **Threshold-based continuation** - Maintain cooperation if enough others do
3. **Forgiveness mechanism** - Allow recovery from temporary defection
4. **End-game adjustment** - Handle final rounds strategically

---

## Decision Rules

### Round 1: Always Cooperate
**Rationale**: Establish cooperative intent. In a collective mindset, we need someone to "go first." If other AI systems reason similarly, this creates the foundation for mutual cooperation.

### Rounds 2 through (r-1): Conditional Cooperation

**Cooperate if EITHER condition is met:**

1. **Sufficient Recent Cooperation**: The cooperation rate in the previous round meets or exceeds the **cooperation threshold θ**

2. **Forgiveness Window Active**: Cooperation rate dropped below threshold, but this is within a **forgiveness period** AND cooperation is trending upward

**Otherwise: Defect**

#### Cooperation Threshold (θ)
```
θ = max(0.5, (n - k) / n)
```

**Rationale**: 
- The threshold `(n-k)/n` represents the point where expected return from cooperation becomes favorable
- Floor of 0.5 ensures we require at least majority cooperation
- This adapts to game parameters: higher k (more efficient public good) → lower threshold needed

#### Forgiveness Mechanism
```
forgiveness_rounds = max(1, floor(r / 10))
```

Track: `rounds_since_threshold_met`

**Forgive (cooperate despite low cooperation) if:**
- `rounds_since_threshold_met ≤ forgiveness_rounds`
- AND current cooperation rate > cooperation rate from 2 rounds ago (upward trend)

**Rationale**: Allows recovery from noise or temporary coordination failures without permanently collapsing to defection.

### Final Round (Round r): Conditional Cooperation

**Cooperate if** the cooperation rate in round (r-1) was ≥ 0.8

**Otherwise: Defect**

**Rationale**: 
- Standard game theory suggests defection in final round
- BUT if we're in a highly cooperative group, maintaining cooperation signals collective commitment
- The 0.8 threshold is deliberately high—we only "risk" final-round cooperation with strongly cooperative groups
- If other collective-minded AIs reason similarly, we preserve cooperation even at the end

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Cooperate to establish intent
    if round == 1:
        return COOPERATE
    
    # Calculate parameters
    θ = max(0.5, (n - k) / n)
    forgiveness_rounds = max(1, floor(r / 10))
    
    # Get cooperation rates
    prev_coop_rate = count_cooperators(history[round-1]) / n
    
    # Final round logic
    if round == r:
        if prev_coop_rate >= 0.8:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    
    # Condition 1: Sufficient cooperation
    if prev_coop_rate >= θ:
        reset rounds_since_threshold_met = 0
        return COOPERATE
    
    # Condition 2: Forgiveness window
    rounds_since_threshold_met += 1
    
    if rounds_since_threshold_met <= forgiveness_rounds:
        if round >= 3:
            two_rounds_ago_rate = count_cooperators(history[round-2]) / n
            if prev_coop_rate > two_rounds_ago_rate:  # Upward trend
                return COOPERATE
    
    # Default: Defect (cooperation has collapsed)
    return DEFECT
```

---

## Edge Cases

| Scenario | Behavior | Rationale |
|----------|----------|-----------|
| r = 2 (minimum rounds) | C in round 1, apply final-round rule in round 2 | Give cooperation a chance |
| n = 2 (minimum players) | Same rules apply; θ likely = 0.5 | One cooperator = 50% = threshold |
| k very close to n | Lower threshold, more forgiving | High-efficiency public good worth more risk |
| k very close to 1 | Higher threshold, less forgiving | Low-efficiency public good needs more participants |
| All opponents always defect | Cooperate round 1, defect thereafter | Protect against pure exploiters |
| Mixed/random opponents | Cooperation depends on realized rates | Adaptive to actual behavior |

---

## Why This Strategy is Collectively Aligned

1. **Self-consistency**: If all players use this strategy, everyone cooperates every round (achieving payoff k per round)

2. **Robustness**: Protects against exploitation—won't endlessly cooperate into a group of defectors

3. **Forgiveness**: Doesn't permanently punish after single defection, allowing coordination recovery

4. **Parameter-adaptive**: Threshold adjusts to game economics (k and n)

5. **Clear signaling**: Round-1 cooperation clearly signals cooperative intent to like-minded strategies
'''

description_COLLECTIVE_115 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I recognize that if all players reason similarly, we can achieve outcomes far better than the Nash equilibrium of universal defection. The strategy aims to establish and maintain cooperation while protecting against exploitation, using signals that other reasoning agents can recognize and reciprocate.

## Strategy Overview: "Generous Threshold Reciprocator"

The strategy operates on three principles:
1. **Optimistic initialization**: Start cooperatively to signal willingness to collaborate
2. **Threshold-based reciprocity**: Cooperate when enough others cooperate to make it collectively worthwhile
3. **Forgiveness with memory**: Allow recovery from defection spirals while remembering patterns

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: In a collective mindset, someone must move first. By cooperating initially, I signal good faith and give the group the best chance to establish mutual cooperation.

### Rounds 2 through (r-1): Adaptive Threshold Reciprocity

Calculate the **cooperation rate** from the previous round:
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

Calculate the **historical cooperation rate**:
```
hist_coop_rate = (total cooperations across all players, all past rounds) / (n × rounds_played)
```

**Decision Rule:**

```
threshold = max(0.3, (n - k) / n)

IF prev_coop_rate >= threshold:
    COOPERATE
ELSE IF hist_coop_rate >= threshold AND prev_coop_rate >= threshold - 0.15:
    COOPERATE with probability = hist_coop_rate
ELSE:
    DEFECT
```

**Explanation of threshold**: 
- The value `(n - k) / n` represents the minimum cooperation rate needed for cooperation to be collectively rational
- Floor of 0.3 prevents excessive defection in favorable parameter settings
- The probabilistic cooperation when near-threshold allows for recovery and forgiveness

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection in the final round, a collective strategy recognizes that:
- If we all defect in the final round, we all lose
- Maintaining cooperation signals commitment to collective reasoning

**Decision Rule for Final Round:**
```
IF hist_coop_rate >= 0.5:
    COOPERATE  # Reward a cooperative history
ELSE IF prev_coop_rate >= threshold:
    COOPERATE  # Maintain momentum
ELSE:
    DEFECT  # Don't be exploited in a defecting environment
```

---

## Pseudocode Implementation

```
function decide(round, n, k, r, history):
    threshold = max(0.3, (n - k) / n)
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate metrics
    prev_coop_rate = count_cooperators(history, round - 1) / n
    hist_coop_rate = total_cooperations(history) / (n * (round - 1))
    
    # Final round logic
    if round == r:
        if hist_coop_rate >= 0.5 OR prev_coop_rate >= threshold:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    if prev_coop_rate >= threshold:
        return COOPERATE
    else if hist_coop_rate >= threshold AND prev_coop_rate >= (threshold - 0.15):
        # Probabilistic forgiveness
        if random() < hist_coop_rate:
            return COOPERATE
        else:
            return DEFECT
    else:
        return DEFECT
```

---

## Edge Cases Handled

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Cooperate | Signal collective intent |
| All others defected last round | Defect (unless strong history) | Protect against exploitation |
| Exactly at threshold | Cooperate | Benefit of the doubt |
| Mixed history, recent improvement | Probabilistic cooperation | Allow recovery |
| Final round, good history | Cooperate | Reward collective behavior |
| Very small n (n=2) | Strategy still works | Threshold adjusts automatically |
| k very close to n | Lower threshold, more cooperation | Responds to favorable conditions |

---

## Why This Strategy is Collectively Aligned

1. **Self-similar reasoning**: If all players use this strategy, cooperation emerges and sustains
2. **Not exploitable to extinction**: Defects when cooperation rate is too low
3. **Forgiving**: Probabilistic cooperation allows escape from defection traps
4. **Parameter-adaptive**: Threshold adjusts based on game economics (k and n)
5. **No coordination required**: Uses only observable history, no pre-arranged signals
'''

description_COLLECTIVE_113 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that mutual cooperation yields the best collective outcome (payoff of k > 1 for everyone) compared to mutual defection (payoff of 1 for everyone). My goal is to foster and sustain cooperation while protecting against exploitation. I will be **generous, forgiving, but not exploitable**.

## Strategy Overview: "Graduated Reciprocity with Hopeful Restoration"

This strategy combines:
1. **Optimistic initialization** - Start cooperatively to signal good faith
2. **Proportional response** - Mirror the cooperation level of the group
3. **Forgiveness mechanism** - Periodically test if cooperation can be restored
4. **End-game awareness** - Maintain cooperation signals even late in the game

---

## Decision Rules

### Round 1: Cooperate
**Rationale**: Signal willingness to cooperate and establish a cooperative norm. The potential gain from mutual cooperation outweighs the risk of being exploited once.

### Rounds 2 through (r-1): Graduated Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision rule**:
- If `coop_rate ≥ (n-1)/n` (almost everyone cooperated): **Cooperate**
- If `coop_rate ≥ 0.5` (majority cooperated): **Cooperate with probability = coop_rate**
- If `coop_rate < 0.5` (minority cooperated): **Cooperate with probability = coop_rate²**

**Forgiveness probe**: Every `max(2, floor(r/5))` rounds, if I would otherwise defect, **Cooperate** instead. This tests whether the group can restart cooperation.

**Trend adjustment**: If cooperation has been *increasing* over the last 3 rounds, add +0.1 to cooperation probability (capped at 1.0). This rewards positive momentum.

### Final Round (round r): Conditional Cooperation

Despite the theoretical incentive to defect in the last round:
- If `average cooperation rate over all previous rounds ≥ 0.6`: **Cooperate**
- Otherwise: **Defect**

**Rationale**: In a tournament setting, maintaining cooperative reputation matters. If the group has shown good faith, I honor that. This also accounts for uncertainty about whether this is truly the "last" interaction.

---

## Pseudocode

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_count = count_cooperators(history, round - 1)
    coop_rate = prev_coop_count / n
    
    # Calculate trend (increasing cooperation?)
    if round >= 4:
        trend = coop_rate(round-1) - coop_rate(round-3)
        trend_bonus = 0.1 if trend > 0 else 0
    else:
        trend_bonus = 0
    
    # Forgiveness probe interval
    probe_interval = max(2, floor(r / 5))
    is_probe_round = (round % probe_interval == 0)
    
    # Final round logic
    if round == r:
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Main decision logic
    if coop_rate >= (n-1)/n:
        return COOPERATE
    
    if is_probe_round:
        return COOPERATE
    
    if coop_rate >= 0.5:
        prob = min(1.0, coop_rate + trend_bonus)
    else:
        prob = min(1.0, coop_rate² + trend_bonus)
    
    return COOPERATE with probability prob, else DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | Cooperate | Establish cooperative intent |
| Everyone defected last round | Cooperate with small probability (probe rounds) | Test for cooperation restart |
| Everyone cooperated last round | Cooperate | Maintain successful equilibrium |
| Final round after high cooperation | Cooperate | Honor collective success |
| Final round after low cooperation | Defect | No cooperative norm to preserve |
| n = 2 (minimum players) | Same rules apply | Strategy scales naturally |
| Very short games (r = 2) | Cooperate both rounds if first round had any cooperation | Insufficient rounds to punish |

---

## Why This Strategy is Collectively Aligned

1. **Starts cooperative**: Gives the group a chance to establish mutual benefit
2. **Rewards cooperation**: High group cooperation is met with high individual cooperation
3. **Forgives**: Periodic probes allow recovery from defection spirals
4. **Proportional**: Doesn't over-punish occasional defection
5. **Honors commitment**: Final-round cooperation when the group has cooperated rewards collective success

This strategy aims to be the player that *other cooperative players want in their group* while remaining resilient against exploiters.
'''

description_COLLECTIVE_116 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **we succeed together or we all lose**. Since all copies of this strategy share the same logic, we can achieve implicit coordination without explicit communication. The strategy prioritizes building and maintaining cooperation while protecting against exploitation.

## Strategy Overview: "Generous Threshold Trigger with Forgiveness"

The strategy operates on three principles:
1. **Start cooperatively** to signal good faith and enable collective gains
2. **Monitor cooperation levels** and respond proportionally to group behavior
3. **Forgive strategically** to recover from defection spirals and noise

---

## Decision Rules

### Round 1: Always Cooperate
- Begin with cooperation to establish a cooperative norm
- This allows collective copies to immediately achieve mutual cooperation
- Signals to any non-collective players that cooperation is possible

### Rounds 2 through (r-1): Adaptive Threshold Response

**Calculate cooperation rate from previous round:**
```
prev_coop_rate = (number of C plays in round t-1) / n
```

**Decision rule:**
```
threshold = k / n  # This is the "fair share" threshold

IF prev_coop_rate >= threshold:
    COOPERATE
ELSE IF prev_coop_rate >= threshold / 2:
    COOPERATE with probability = prev_coop_rate / threshold
ELSE:
    DEFECT
```

**Forgiveness Mechanism (every ⌈r/4⌉ rounds after round 1):**
```
IF current_round mod ⌈r/4⌉ == 0:
    COOPERATE regardless of threshold calculation
```

This periodic unconditional cooperation allows recovery from defection cascades and tests whether opponents are willing to re-establish cooperation.

### Final Round (Round r): Conditional Cooperation

Unlike typical game theory advice to defect in the last round, we maintain collective commitment:

```
IF average_cooperation_rate_across_all_rounds >= 0.5:
    COOPERATE  # Reward sustained cooperation
ELSE:
    DEFECT     # Don't be exploited in a failed game
```

**Rationale:** If we're playing against other collective strategies, maintaining cooperation in the final round achieves the Pareto-optimal outcome. Only defect if the game has already devolved.

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Round 1: Unconditional cooperation
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history[round-1])
    prev_coop_rate = prev_cooperators / n
    threshold = k / n
    
    # Forgiveness rounds: unconditional cooperation
    forgiveness_interval = ceil(r / 4)
    if round > 1 AND round < r AND (round mod forgiveness_interval == 0):
        return COOPERATE
    
    # Final round: reward sustained cooperation
    if round == r:
        avg_coop_rate = average_cooperation_rate(history)
        if avg_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Standard rounds: threshold-based response
    if prev_coop_rate >= threshold:
        return COOPERATE
    else if prev_coop_rate >= threshold / 2:
        # Probabilistic cooperation - gives benefit of doubt
        if random() < (prev_coop_rate / threshold):
            return COOPERATE
        else:
            return DEFECT
    else:
        return DEFECT
```

---

## Edge Cases Handled

| Situation | Response | Rationale |
|-----------|----------|-----------|
| n=2, first round | Cooperate | Standard opening |
| All others defect round 1 | Probabilistic C or D based on threshold | Don't immediately collapse |
| Forgiveness round after mass defection | Cooperate | Test for recovery |
| Very large n with low k | Lower threshold makes cooperation easier to sustain | Adapts to parameters |
| r=2 (minimal rounds) | C then conditional C | Maximize mutual cooperation potential |

---

## Why This Strategy is Collectively Optimal

1. **Self-coordination**: All copies following this strategy will cooperate throughout (since cooperation rate will always exceed threshold when most players cooperate)

2. **Robust to mixed populations**: The threshold mechanism means we continue cooperating as long as "enough" others do, while protecting against heavy exploitation

3. **Forgiveness enables recovery**: Periodic unconditional cooperation breaks defection spirals that might emerge from noise or miscoordination

4. **Parameter-adaptive**: Using k/n as the threshold automatically adjusts to different game configurations

5. **Collectively rational final round**: Unlike individually rational defection, we maintain cooperation when the group has earned it
'''

description_COLLECTIVE_114 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we assume all instances of this strategy will reason identically and act in concert. Since we're designing for a population of like-minded agents, we should optimize for collective welfare while remaining robust to defectors.

The key insight is that with `k > 1`, mutual cooperation yields `k` per player while mutual defection yields `1`. Cooperation is collectively superior. The challenge is maintaining cooperation without being exploited by defectors.

## Strategy: **Adaptive Collective Reciprocity (ACR)**

### Decision Framework

The strategy tracks the **cooperation rate** of the population and adjusts behavior to:
1. Establish cooperation early
2. Sustain cooperation when others reciprocate
3. Punish widespread defection proportionally
4. Attempt recovery before the game ends

### Key Variables

- `coop_rate(t)` = proportion of players who cooperated in round t
- `my_threshold(t)` = minimum cooperation rate required to cooperate in round t
- `rounds_remaining` = r - current_round

### Decision Rules

```
ROUND 1 (Establishing Cooperation):
    COOPERATE unconditionally
    
    Rationale: Signal cooperative intent. All collective agents will do this,
    creating immediate coordination. The cost of one round's potential 
    exploitation is worth the information gained and trust established.

ROUNDS 2 to (r-1) (Main Game):
    Calculate: coop_rate = cooperators_last_round / n
    
    IF coop_rate >= adaptive_threshold THEN:
        COOPERATE
    ELSE:
        Apply probabilistic punishment (see below)
    
    Where adaptive_threshold starts at 0.5 and adjusts based on:
    - Increases by 0.05 if defectors gained advantage while we cooperated
    - Decreases by 0.05 if cooperation rate is trending upward
    - Minimum threshold: 0.3 (to allow recovery)
    - Maximum threshold: 0.8 (to avoid over-sensitivity)

PROBABILISTIC PUNISHMENT MECHANISM:
    When coop_rate < adaptive_threshold:
    
    punishment_probability = 1 - coop_rate
    
    - If coop_rate was 0.4, cooperate with 40% probability
    - If coop_rate was 0.1, cooperate with 10% probability
    
    This creates proportional response: mild defection gets mild punishment,
    widespread defection gets strong punishment. It also maintains some
    cooperation signal for recovery.

FINAL ROUND (Round r):
    IF coop_rate in round (r-1) >= 0.6 THEN:
        COOPERATE (reward sustained cooperation)
    ELSE:
        DEFECT (no future rounds to lose from retaliation)
    
    Rationale: Unlike pure game theory which says "always defect last round,"
    collective agents maintaining cooperation should be rewarded. This also
    distinguishes us from purely selfish strategies.

RECOVERY ATTEMPT (Special Case):
    If we're in a defection spiral (3+ consecutive rounds with coop_rate < 0.4)
    AND rounds_remaining > 3:
        COOPERATE unconditionally for 1 round
        
    Rationale: Attempt to restart cooperation. Other collective agents will
    do the same, potentially rescuing the game.
```

### Pseudocode Implementation

```python
def decide(game_params, history):
    n, r, k = game_params.n, game_params.r, game_params.k
    current_round = len(history) + 1
    
    # Round 1: Always cooperate
    if current_round == 1:
        return COOPERATE
    
    # Calculate cooperation rate from last round
    last_round = history[-1]
    coop_rate = sum(last_round) / n
    
    # Track cooperation trend
    if len(history) >= 2:
        prev_coop_rate = sum(history[-2]) / n
        trend = coop_rate - prev_coop_rate
    else:
        trend = 0
    
    # Adaptive threshold
    base_threshold = 0.5
    threshold = base_threshold
    if trend > 0.1:
        threshold = max(0.3, threshold - 0.05)
    if was_exploited(history):  # cooperated while many defected
        threshold = min(0.8, threshold + 0.05)
    
    # Recovery attempt after defection spiral
    low_coop_streak = count_consecutive_low_coop(history, 0.4)
    if low_coop_streak >= 3 and (r - current_round) > 3:
        return COOPERATE
    
    # Final round logic
    if current_round == r:
        return COOPERATE if coop_rate >= 0.6 else DEFECT
    
    # Main decision
    if coop_rate >= threshold:
        return COOPERATE
    else:
        # Probabilistic punishment
        return COOPERATE if random() < coop_rate else DEFECT
```

### Why This Strategy Works Collectively

1. **Self-coordination**: All instances cooperate round 1, immediately achieving mutual cooperation without explicit coordination.

2. **Robust to population composition**: The probabilistic response handles mixed populations gracefully—doesn't over-punish occasional defectors, but strongly punishes systematic defection.

3. **Forgiveness built-in**: The recovery mechanism and probabilistic cooperation ensure the group can escape defection spirals.

4. **Exploits cooperation surplus**: When k is close to n, the strategy leans more cooperative. When k is close to 1, it's more cautious.

5. **Distinguishable from defectors**: Pure defectors gain short-term but trigger proportional punishment. Our strategy identifies and rewards other cooperators through sustained high payoffs.
'''

description_COLLECTIVE_117 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be using similar reasoning, and I aim to establish and maintain cooperation while protecting against exploitation. The key insight is that mutual cooperation yields higher payoffs than mutual defection (since k > 1), but unilateral cooperation is costly.

## Strategy Overview: **Adaptive Threshold Cooperation with Forgiveness**

The strategy operates on three principles:
1. **Start cooperatively** to signal good faith and enable coordination
2. **Mirror the collective** by cooperating when enough others do
3. **Forgive occasionally** to escape defection traps

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: Cooperate**

Rationale: With no history, I signal cooperative intent. If others reason similarly, we establish mutual cooperation from the start.

### Rounds 2 through (r-1): Adaptive Threshold Rule

Let `coop_rate` = (number of cooperators in previous round) / n

**Cooperate if:**
```
coop_rate >= threshold(t)
```

**Where threshold is calculated as:**
```
base_threshold = 0.5
adjustment = (k - 1) / (n - 1)  # Higher k relative to n → lower threshold
threshold(t) = max(0.3, base_threshold - adjustment)
```

**Additionally, apply Forgiveness Rule:**
- Every `forgiveness_interval` rounds, cooperate regardless of history
- `forgiveness_interval = max(3, floor(r / 5))`

This prevents permanent defection spirals and tests whether cooperation can be restored.

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which suggests always defecting in the final round, I maintain the collective approach:

**Cooperate if:**
```
average_coop_rate_last_3_rounds >= threshold(r)
```

Rationale: If playing against like-minded collective strategies, maintaining cooperation in the final round yields higher total payoffs. The risk of exploitation in one round is acceptable for the potential of mutual cooperation.

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate threshold
    base_threshold = 0.5
    adjustment = (k - 1) / (n - 1)
    threshold = max(0.3, base_threshold - adjustment)
    
    # Calculate cooperation rate from previous round
    prev_cooperators = count_cooperators(history[round - 1])
    coop_rate = prev_cooperators / n
    
    # Forgiveness interval
    forgiveness_interval = max(3, floor(r / 5))
    
    # Final round logic
    if round == r:
        recent_rounds = history[max(1, round-3) : round]
        avg_coop_rate = average_cooperation_rate(recent_rounds)
        if avg_coop_rate >= threshold:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    if round % forgiveness_interval == 0:
        return COOPERATE  # Forgiveness probe
    
    if coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Cooperate | Establish cooperative baseline |
| Only 2 players (n=2) | Use threshold ≈ 0.5 | Essentially Tit-for-Tat behavior |
| Very short game (r≤3) | Cooperate rounds 1-2, threshold round 3 | Maximize cooperation window |
| All previous defected | Defect (unless forgiveness round) | Protect against exploitation |
| k very close to n | Lower threshold (~0.3) | Cooperation more valuable |
| k very close to 1 | Higher threshold (~0.5) | Cooperation less valuable |

---

## Why This Strategy is Collectively Aligned

1. **Self-reinforcing**: If multiple players use this strategy, they will sustain cooperation
2. **Robust**: Protects against persistent defectors while remaining open to cooperation
3. **Forgiving**: Can recover from temporary breakdowns or mixed populations
4. **Adaptive**: Adjusts to game parameters rather than using fixed rules
'''

description_COLLECTIVE_115 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similar cooperative AI systems) may be playing in the same game. The goal is to establish and maintain cooperation among like-minded players while protecting against exploitation by defectors. The strategy uses observable patterns to signal cooperative intent and coordinate without explicit communication.

---

## Strategy Overview: **Adaptive Threshold Cooperation with Forgiveness (ATCF)**

The strategy operates on three principles:
1. **Start cooperatively** to establish trust and signal intent
2. **Adapt thresholds** based on observed cooperation levels
3. **Forgive strategically** to recover from temporary defection spirals

---

## Decision Rules

### Round 1: Unconditional Cooperation
```
Action = COOPERATE
```
**Rationale**: Signal cooperative intent. With multiple AI instances potentially playing, starting with cooperation allows mutual identification and coordination. The cost of one round of potential exploitation is small compared to the benefit of establishing cooperation.

### Rounds 2 through (r-1): Adaptive Threshold Rule

**Calculate cooperation rate from previous round:**
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Calculate historical cooperation trend:**
```
recent_coop_rate = average cooperation rate over last min(3, t-1) rounds
```

**Decision Rule:**
```
IF prev_coop_rate >= adaptive_threshold THEN
    Action = COOPERATE
ELSE IF forgiveness_trigger is active THEN
    Action = COOPERATE (forgiveness probe)
ELSE
    Action = DEFECT
```

**Adaptive Threshold Calculation:**
```
base_threshold = (n - k) / n  # Break-even point where cooperation becomes individually rational

# Adjust threshold based on game progress
progress = current_round / r
early_game = progress < 0.3
mid_game = 0.3 <= progress < 0.7
late_game = progress >= 0.7

IF early_game THEN
    adaptive_threshold = max(0.3, base_threshold - 0.15)  # More lenient early
ELSE IF mid_game THEN
    adaptive_threshold = base_threshold
ELSE IF late_game AND recent_coop_rate > 0.5 THEN
    adaptive_threshold = base_threshold  # Maintain if cooperation established
ELSE
    adaptive_threshold = base_threshold + 0.1  # Stricter if cooperation failed
```

### Forgiveness Mechanism

**Purpose**: Break defection spirals and probe for returning cooperators

```
forgiveness_counter = 0
forgiveness_interval = max(3, floor(r / 5))

IF prev_coop_rate < adaptive_threshold THEN
    forgiveness_counter += 1
    
IF forgiveness_counter >= forgiveness_interval THEN
    forgiveness_trigger = TRUE
    forgiveness_counter = 0
ELSE
    forgiveness_trigger = FALSE
```

**Rationale**: Every few rounds of defection, attempt one cooperative probe. If others reciprocate, cooperation can restart. This prevents permanent collapse due to noise or miscoordination.

### Final Round: Conditional Cooperation

```
IF recent_coop_rate >= 0.6 THEN
    Action = COOPERATE  # Reward sustained cooperation, maintain collective ethos
ELSE
    Action = DEFECT  # No future interaction to leverage
```

**Rationale**: Unlike pure game-theoretic reasoning that always defects in the final round, a collective mindset rewards sustained cooperation. If the group has cooperated well, we honor that. If not, defection is rational.

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | COOPERATE | Signal intent, identify cooperators |
| n = 2 | Use same rules, threshold ≈ 0.5 | Reduces to near Tit-for-Tat |
| k very close to n | Lower threshold slightly | Cooperation more valuable |
| k very close to 1 | Raise threshold slightly | Cooperation less valuable |
| All defected last round | Check forgiveness trigger | May probe with cooperation |
| Perfect cooperation so far | COOPERATE | Don't break working system |
| r = 2 (minimum rounds) | C then conditional C | Brief games favor cooperation attempts |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[round - 1])
    prev_coop_rate = prev_cooperators / n
    
    # Calculate adaptive threshold
    base_threshold = (n - k) / n
    progress = round / r
    
    if progress < 0.3:
        threshold = max(0.3, base_threshold - 0.15)
    elif progress < 0.7:
        threshold = base_threshold
    else:
        recent_rate = average_coop_rate(history, last=3)
        threshold = base_threshold if recent_rate > 0.5 else base_threshold + 0.1
    
    # Forgiveness check
    forgiveness_interval = max(3, r // 5)
    consecutive_low = count_consecutive_below_threshold(history, threshold)
    forgiveness_active = (consecutive_low > 0) and (consecutive_low % forgiveness_interval == 0)
    
    # Final round logic
    if round == r:
        recent_rate = average_coop_rate(history, last=3)
        return COOPERATE if recent_rate >= 0.6 else DEFECT
    
    # Main decision
    if prev_coop_rate >= threshold or forgiveness_active:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Mutual recognition**: Cooperative AI instances will all cooperate in round 1, establishing a high cooperation rate that sustains itself.

2. **Robustness to defectors**: The threshold mechanism means a few defectors don't collapse cooperation—only widespread defection triggers defensive defection.

3. **Recovery capability**: Forgiveness probes allow re-establishment of cooperation even after breakdowns.

4. **Parameter adaptation**: The strategy adjusts to different values of n and k, working across diverse game configurations.

5. **Collective final round**: By not automatically defecting in the last round, cooperative groups achieve higher total payoffs than groups using purely selfish strategies.
'''

description_COLLECTIVE_118 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we recognize that mutual cooperation yields the best collective outcome (payoff of k > 1 per player) versus mutual defection (payoff of 1). Our goal is to establish and maintain cooperation while protecting against exploitation.

The strategy is built on three principles:
1. **Start cooperatively** to signal good intentions
2. **Respond proportionally** to the group's behavior
3. **Protect the endgame** where defection incentives spike

---

## Strategy: "Proportional Collective Reciprocity"

### Decision Rule Overview

Cooperate when the group has demonstrated sufficient cooperative behavior; defect when cooperation has broken down or when facing predictable endgame exploitation.

---

### Detailed Decision Rules

#### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- Rationale: Signal cooperative intent, give others the benefit of the doubt, establish a cooperative norm from the start.

#### Final Round (Round r): Conditional Cooperation with Threshold
- **Action: COOPERATE if and only if** the cooperation rate in round (r-1) was ≥ 50%
- Rationale: In the final round, there's no future to incentivize cooperation. However, if a strong cooperative norm exists, maintaining it serves the collective. If cooperation has already collapsed, defecting limits losses.

#### Middle Rounds (Rounds 2 through r-1): Proportional Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision threshold based on adaptive forgiveness:**

```
base_threshold = 0.5
round_progress = current_round / r
adaptive_threshold = base_threshold - (0.2 × (1 - round_progress))
```

This means:
- Early rounds: threshold ≈ 0.3 (more forgiving, allow cooperation to build)
- Middle rounds: threshold ≈ 0.4
- Late rounds: threshold ≈ 0.5 (stricter, protect against late defection)

**Action: COOPERATE if** `coop_rate ≥ adaptive_threshold`

**Additional rule - Trend detection:**
If cooperation rate has **declined for 2 consecutive rounds** AND current rate < 0.4:
- **Action: DEFECT** (cooperation norm is collapsing)

If cooperation rate has **increased for 2 consecutive rounds** after being low:
- **Action: COOPERATE** (reward recovery attempts)

---

### Pseudocode

```
function decide(round, history, n, r, k):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_count = count_cooperators(history, round - 1)
    coop_rate = prev_coop_count / n
    
    # Final round: threshold-based
    if round == r:
        if coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: adaptive threshold with trend detection
    round_progress = round / r
    adaptive_threshold = 0.5 - (0.2 * (1 - round_progress))
    
    # Check for declining trend (2 consecutive drops, currently low)
    if round >= 3:
        rate_t1 = count_cooperators(history, round - 1) / n
        rate_t2 = count_cooperators(history, round - 2) / n
        rate_t3 = count_cooperators(history, round - 3) / n
        
        if rate_t1 < rate_t2 < rate_t3 and rate_t1 < 0.4:
            return DEFECT  # Cooperation collapsing
        
        if rate_t1 > rate_t2 > rate_t3 and rate_t3 < 0.3:
            return COOPERATE  # Reward recovery
    
    # Standard decision
    if coop_rate >= adaptive_threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

### Edge Cases Handled

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | COOPERATE | Establish cooperative norm |
| Final round, high prior cooperation | COOPERATE | Honor collective success |
| Final round, low prior cooperation | DEFECT | Limit losses |
| All others defected last round | DEFECT | Don't be exploited |
| Mixed signals (near threshold) | Use adaptive threshold | Be more forgiving early |
| Only 2 players (n=2) | Same rules apply | Reduces to iterated prisoner's dilemma logic |
| Very short game (r=2) | Round 1: C, Round 2: threshold | Minimal but consistent |

---

### Why This Strategy is Collectively Aligned

1. **Maximizes collective welfare**: Starting with cooperation and maintaining it when others reciprocate leads to payoff k > 1 for everyone.

2. **Builds trust**: The forgiving early-game threshold allows cooperation to emerge even if some players defect initially.

3. **Punishes free-riding**: Defecting when cooperation collapses prevents systematic exploitation.

4. **Recovers from mistakes**: Trend detection allows return to cooperation if the group recovers.

5. **Robust to diverse opponents**: Works against cooperators (mutual benefit), defectors (limits losses), and conditional cooperators (establishes reciprocity).
'''

description_COLLECTIVE_116 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players reason similarly and cooperate, we all achieve the best collective outcome (payoff of k > 1 per round versus 1 from universal defection). The strategy is designed to:

1. **Signal cooperative intent** and give cooperation a chance to emerge
2. **Reward cooperative environments** by contributing when others do
3. **Protect against exploitation** by withdrawing cooperation when it's not reciprocated
4. **Forgive occasional defections** to allow recovery from mistakes or testing

## Strategy: Adaptive Collective Reciprocity (ACR)

### Key Parameters (derived from game parameters)

- **Cooperation threshold** `θ = 0.5` — minimum proportion of cooperators needed to continue cooperating
- **Forgiveness window** `w = max(2, floor(r/10))` — rounds to average over for decision-making
- **End-game horizon** `h = min(3, floor(r/5))` — final rounds requiring special handling
- **Initial cooperation phase** `p = min(3, floor(r/4))` — opening rounds of unconditional cooperation

### Decision Rules

```
FUNCTION decide_action(round_number, history, n, k, r):
    
    // PHASE 1: Initial Cooperation (build trust)
    IF round_number <= p:
        RETURN Cooperate
    
    // PHASE 2: End-game Protection
    IF round_number > r - h:
        // In final rounds, base decision on overall cooperation level
        overall_coop_rate = total_cooperations_observed / ((round_number - 1) * (n - 1))
        IF overall_coop_rate >= θ:
            RETURN Cooperate  // Maintain cooperation if environment has been cooperative
        ELSE:
            RETURN Defect     // Protect against end-game exploitation
    
    // PHASE 3: Adaptive Reciprocity (main phase)
    recent_rounds = last w rounds (or all available if fewer than w)
    recent_coop_rate = cooperations_by_others_in_recent_rounds / (len(recent_rounds) * (n - 1))
    
    IF recent_coop_rate >= θ:
        RETURN Cooperate
    ELSE IF recent_coop_rate >= θ - 0.2:
        // Borderline case: probabilistic cooperation to allow recovery
        RETURN Cooperate with probability (recent_coop_rate / θ)
    ELSE:
        RETURN Defect
```

### Detailed Rule Explanations

#### Rule 1: Initial Cooperation Phase
**When:** Rounds 1 through p  
**Action:** Always Cooperate  
**Rationale:** Establishes cooperative intent. If other players use similar reasoning, this allows a cooperative equilibrium to form. The cost of being exploited for a few rounds is acceptable to enable collective benefits.

#### Rule 2: Threshold-Based Reciprocity (Main Phase)
**When:** Rounds p+1 through r-h  
**Action:** Cooperate if recent cooperation rate ≥ 50%, otherwise defect (with probabilistic softening near threshold)  
**Rationale:** 
- Rewards cooperative environments where contributions generate collective value
- Withdraws contribution when too few others cooperate (protecting against free-riding)
- The sliding window allows adaptation to changing behavior patterns
- Probabilistic cooperation near threshold allows recovery from temporary dips

#### Rule 3: End-Game Handling
**When:** Final h rounds  
**Action:** Cooperate if overall game cooperation rate ≥ 50%, otherwise defect  
**Rationale:** 
- Avoids predictable end-game defection that unravels cooperation
- Uses full-game history to make stable decisions (not easily manipulated)
- If the game has been cooperative, maintains cooperation through the end
- If exploitation has occurred, protects against final-round abuse

### Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | Cooperate | Part of initial cooperation phase |
| Last round | Based on overall history | Prevents predictable defection spiral |
| n=2 (2 players) | Same rules apply | Reduces to generalized tit-for-tat variant |
| All others always defect | Defect after initial phase | Threshold won't be met; protect resources |
| Mixed/random opponents | Adapts to actual rates | Cooperates when beneficial in expectation |
| Very short game (r≤4) | Mostly cooperate | Initial phase covers most/all rounds |

### Collective Alignment

This strategy embodies collective thinking because:

1. **It assumes others may reason similarly** — The initial cooperation phase works precisely because collectively-minded agents will all cooperate, achieving the superior outcome.

2. **It values the group's success** — By cooperating when k/n × cooperators exceeds the private benefit threshold, I'm choosing collective welfare.

3. **It's forgiving** — The sliding window and probabilistic cooperation allow groups to recover from mistakes, recognizing that collective success requires resilience.

4. **It doesn't exploit** — I never defect purely to gain advantage over cooperators; I only defect defensively when cooperation isn't reciprocated.

5. **It maintains cooperation in the end-game** — Rather than selfishly defecting in final rounds, I sustain cooperation if the collective has been cooperative.
'''

description_COLLECTIVE_119 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: **I am one of many instances of this same strategy, and our shared goal is to maximize collective welfare while protecting against exploitation.** The strategy uses observable signals to coordinate cooperation among like-minded players while remaining robust against defectors.

## Strategy Overview: "Adaptive Collective Threshold" (ACT)

The strategy operates on three principles:
1. **Start cooperatively** to establish potential for collective benefit
2. **Mirror the group's cooperation level** to reward cooperation and discourage defection
3. **Protect the collective** by withdrawing cooperation when exploitation is detected

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: Cooperate (C)**

Rationale: With multiple instances of this strategy likely present, initial cooperation signals our collective identity and maximizes early-game welfare. The cost of one round's potential exploitation is worth the coordination benefit.

### Rounds 2 through (r-1): Adaptive Threshold Response

**Calculate the cooperation rate from the previous round:**
```
coop_rate = (number of cooperators in round t-1) / n
```

**Decision rule:**
```
threshold = k / n  (the break-even point)

If coop_rate >= threshold:
    Cooperate with probability = coop_rate
Else:
    Defect
```

**Detailed logic:**

1. **If cooperation rate ≥ k/n (break-even threshold):**
   - Cooperation is collectively beneficial
   - Match the cooperation rate probabilistically
   - This creates a self-reinforcing equilibrium among cooperators
   - Probabilistic matching prevents exploitation by sophisticated defectors who might try to free-ride on deterministic cooperators

2. **If cooperation rate < k/n:**
   - Cooperation is being exploited; collective benefit is negative
   - Defect to protect against losses
   - This signals to other ACT players that conditions aren't right

### Final Round (Round r): Conditional Cooperation

**Unlike standard backward-induction logic, maintain cooperation potential:**

```
If average cooperation rate over all previous rounds >= 0.5:
    Cooperate
Else:
    Defect
```

Rationale: If we're playing among mostly cooperative agents (likely other instances of this or similar strategies), maintaining cooperation in the final round maximizes collective payoff. Defecting in the last round only benefits individuals at collective cost—antithetical to our mindset.

---

## Edge Cases

### n = 2 (Two Players)
- Threshold k/n is between 0.5 and 1
- Strategy reduces to: Cooperate round 1, then Tit-for-Tat variant
- If opponent cooperated: Cooperate
- If opponent defected: Defect

### Very High k (k approaching n)
- Threshold approaches 1, making cooperation harder to sustain
- Strategy naturally becomes more cautious
- Only cooperates when nearly everyone else does

### Very Low k (k approaching 1)
- Threshold k/n is low, cooperation easier to justify
- Strategy is more forgiving of some defection
- Maintains cooperation even with moderate defection rates

### All Defection Detected (coop_rate = 0)
- Defect until cooperation re-emerges
- No forgiveness mechanism to prevent exploitation
- But first round of any cooperation spike triggers re-evaluation

### Single Cooperator in Previous Round
- If that cooperator was "me": coop_rate = 1/n < k/n typically → Defect
- Protects against being the lone exploited cooperator

---

## Pseudocode Implementation

```
function ACT_strategy(n, k, r, current_round, history):
    
    threshold = k / n
    
    # Round 1: Always cooperate
    if current_round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_round_cooperators = count_cooperators(history, current_round - 1)
    coop_rate = prev_round_cooperators / n
    
    # Final round: Cooperate if historically cooperative game
    if current_round == r:
        avg_coop_rate = average_cooperation_rate(history)
        if avg_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Adaptive threshold response
    if coop_rate >= threshold:
        # Probabilistically match cooperation rate
        if random() < coop_rate:
            return COOPERATE
        else:
            return DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Optimal

1. **Self-recognition**: Multiple ACT instances will quickly converge to high cooperation, as initial cooperation triggers the threshold condition.

2. **Exploitation resistance**: Defectors cannot sustainably exploit because their defection lowers coop_rate, triggering defensive defection.

3. **Efficiency**: When playing among cooperators, achieves near-optimal collective payoff of k per player per round.

4. **Graceful degradation**: Against mixed populations, cooperates proportionally to observed cooperation, extracting value where possible while limiting losses.

5. **No coordination needed**: Uses only observable history—no pre-arranged signals or schedules required.
'''

description_COLLECTIVE_120 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy operates from a collective mindset: **we succeed together or fail together**. The strategy aims to establish and maintain cooperation while being robust against exploitation. It uses a combination of optimistic initial cooperation, graduated punishment, and forgiveness mechanisms.

## Strategy Overview

The strategy, which I call **"Hopeful Catalyst with Graduated Response"**, has three main components:

1. **Optimistic Start**: Begin cooperating to signal willingness and potentially catalyze collective cooperation
2. **Adaptive Threshold**: Continue cooperating if enough others do; defect if cooperation falls below a sustainable threshold
3. **Forgiveness Cycles**: Periodically test if cooperation can be restored after breakdowns

---

## Decision Rules

### Round 1: Always Cooperate
- Rationale: Signal cooperative intent, give the collective a chance to form, avoid being the reason cooperation fails

### Rounds 2 through (r-1): Adaptive Cooperation

**Primary Rule**: Cooperate if the cooperation rate in the previous round meets or exceeds the **sustainability threshold**.

**Sustainability Threshold Calculation**:
```
threshold = n / k
cooperation_rate = (number of cooperators in previous round) / n
```

The threshold `n/k` is the breakeven point where cooperators aren't being exploited (when cooperation_rate ≥ n/k, cooperators get payoff ≥ 1).

**Decision Logic**:
```
IF cooperation_rate(previous_round) >= (n/k) / n = 1/k:
    COOPERATE
ELSE IF in_forgiveness_window():
    COOPERATE  (testing if cooperation can restart)
ELSE:
    DEFECT
```

### Forgiveness Mechanism

After a defection streak, periodically attempt to restart cooperation:

```
forgiveness_interval = max(2, floor(r / 5))

IF consecutive_defection_rounds >= forgiveness_interval:
    IF current_round % forgiveness_interval == 0:
        COOPERATE (forgiveness probe)
        reset consecutive_defection_rounds counter
```

### Last Round: Conditional Cooperation

Unlike classical game theory which suggests always defecting in the last round, maintain the collective approach:

```
IF cooperation_rate(round r-1) >= 0.5:
    COOPERATE  (reward sustained cooperation)
ELSE:
    DEFECT
```

Rationale: If we've built something together, don't betray it at the end. This also makes the strategy more robust when playing against itself or similar cooperative strategies.

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    IF round == 1:
        RETURN COOPERATE
    
    # Calculate previous round statistics
    prev_cooperators = count_cooperators(history, round - 1)
    cooperation_rate = prev_cooperators / n
    breakeven_rate = 1 / k
    
    # Track defection streak
    defection_streak = count_consecutive_mutual_low_cooperation(history, breakeven_rate)
    
    # Forgiveness interval scales with game length
    forgiveness_interval = max(2, floor(r / 5))
    
    # Last round logic
    IF round == r:
        IF cooperation_rate >= 0.5:
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT
    
    # Main decision logic for rounds 2 to r-1
    IF cooperation_rate >= breakeven_rate:
        # Cooperation is sustainable, continue cooperating
        RETURN COOPERATE
    
    ELSE IF defection_streak >= forgiveness_interval AND 
            defection_streak % forgiveness_interval == 0:
        # Forgiveness probe: try to restart cooperation
        RETURN COOPERATE
    
    ELSE:
        # Cooperation collapsed and not in forgiveness window
        RETURN DEFECT

function count_consecutive_mutual_low_cooperation(history, threshold):
    count = 0
    FOR round FROM most_recent TO earliest:
        IF cooperation_rate(round) < threshold:
            count += 1
        ELSE:
            BREAK
    RETURN count
```

---

## Edge Cases Handled

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Cooperate | Signal cooperative intent |
| Last round after sustained cooperation | Cooperate | Honor the collective |
| Last round after collapse | Defect | No future benefit |
| Everyone defected last round | Defect (unless forgiveness probe) | Protect against exploitation |
| Only one other cooperated | Depends on k | Mathematical threshold determines sustainability |
| Just above threshold | Cooperate | Encourage growth |
| Forgiveness probe fails | Wait for next interval | Persistent but not naive |

---

## Why This Strategy is Collectively Aligned

1. **Never initiates defection**: Always gives cooperation a chance first
2. **Threshold-based, not punishment-based**: Focuses on sustainability rather than retaliation
3. **Forgiveness built-in**: Doesn't permanently abandon cooperation
4. **Parameter-adaptive**: Adjusts to different game configurations automatically
5. **Last-round cooperation possible**: Doesn't cynically exploit endgame

This strategy aims to be the player that makes cooperation possible while not being exploited when cooperation genuinely fails.
'''

description_COLLECTIVE_117 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that mutual cooperation generates the highest total welfare, and I aim to foster and sustain cooperation while protecting against exploitation. The strategy is designed to be **forgiving, responsive, and conditionally cooperative**—building trust when possible while adapting to the actual behavior of others.

## Strategy Overview: "Generous Threshold Tit-for-Tat" (GTFT-Threshold)

The strategy cooperates by default but tracks the **cooperation rate** of the group and adjusts behavior based on whether sufficient cooperation exists to make contributing worthwhile.

---

## Decision Rules

### Key Variables Tracked

- `cooperation_rate`: The proportion of other players who cooperated in the previous round
- `cumulative_cooperation_rate`: The average cooperation rate across all previous rounds
- `rounds_remaining`: Number of rounds left in the game
- `cooperation_threshold`: Dynamic threshold that determines when to cooperate

### Round-by-Round Logic

```
PARAMETERS:
  base_threshold = 0.3        # Minimum cooperation rate to continue cooperating
  forgiveness_prob = 0.1      # Probability of cooperating even below threshold
  
FOR each round t:

  IF t == 1 (First Round):
    ACTION = COOPERATE
    
  ELSE IF t == r (Final Round):
    # Cooperate if group has been largely cooperative
    IF cumulative_cooperation_rate >= 0.5:
      ACTION = COOPERATE
    ELSE:
      ACTION = DEFECT
      
  ELSE (Middle Rounds):
    # Calculate adaptive threshold based on game progress
    progress = t / r
    adaptive_threshold = base_threshold * (1 + 0.5 * progress)
    # Threshold rises slightly as game progresses (0.3 → 0.45)
    
    IF cooperation_rate >= adaptive_threshold:
      ACTION = COOPERATE
    ELSE:
      # Forgiveness mechanism: occasionally cooperate to test recovery
      IF random() < forgiveness_prob:
        ACTION = COOPERATE
      ELSE:
        ACTION = DEFECT
```

---

## Detailed Decision Rules

### 1. First Round: Always Cooperate
- **Rationale**: Signal cooperative intent and give the collective a chance to establish mutual cooperation. Starting with defection poisons the well.

### 2. Middle Rounds: Conditional Cooperation with Forgiveness

**Cooperate if:**
- At least `adaptive_threshold` proportion of *other* players cooperated last round

**Defect (with forgiveness exception) if:**
- Cooperation rate fell below threshold
- However, with 10% probability, cooperate anyway to:
  - Test if others are willing to restart cooperation
  - Avoid permanent collapse from temporary fluctuations
  - Signal continued willingness to cooperate

**Why an adaptive threshold?**
- Early in the game: Lower threshold (≈30%) — be patient, give cooperation time to establish
- Later in the game: Higher threshold (≈45%) — less time to recover investment, be more cautious

### 3. Final Round: Reward Cooperative History

**Cooperate if** the cumulative cooperation rate across all rounds is ≥ 50%

**Defect otherwise**

- **Rationale**: Rather than always defecting (classic game theory), this rewards groups that maintained cooperation. If playing against other collective-minded agents, mutual final-round cooperation is possible. If the group was largely defecting, there's no point in a final sacrifice.

---

## Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| n = 2 (minimum players) | Same rules apply | Threshold becomes binary; acts like Tit-for-Tat with forgiveness |
| r = 2 (minimum rounds) | Round 1: C, Round 2: Based on cumulative rate | Even in short games, honor cooperative norms |
| All others defect round 1 | Likely defect round 2 (but 10% forgiveness) | Protect against pure defectors while allowing recovery |
| Single defector in cooperative group | Continue cooperating | Threshold-based approach ignores minor deviations |
| k very close to 1 | Same strategy | Low k makes cooperation harder to sustain, but strategy adapts naturally |
| k close to n | Same strategy | High k makes cooperation very attractive; group likely cooperates |

---

## Why This Strategy is Collectively Aligned

1. **Starts cooperative**: Gives the group the best chance to establish mutual benefit
2. **Sustains cooperation**: Continues cooperating when others reciprocate
3. **Forgives mistakes**: Random forgiveness prevents permanent collapse from noise or temporary defection
4. **Protects the collective from exploitation**: Won't blindly cooperate if others consistently defect
5. **Rewards cooperative history**: Final round behavior acknowledges sustained cooperation rather than betraying it
6. **Scales with group size**: Threshold-based logic works regardless of n

---

## Summary Pseudocode

```python
def decide(round, total_rounds, prev_round_cooperators, total_other_players, history):
    
    if round == 1:
        return COOPERATE
    
    cooperation_rate = prev_round_cooperators / total_other_players
    cumulative_rate = sum(history) / (len(history) * total_other_players)
    
    if round == total_rounds:
        return COOPERATE if cumulative_rate >= 0.5 else DEFECT
    
    progress = round / total_rounds
    adaptive_threshold = 0.3 * (1 + 0.5 * progress)
    
    if cooperation_rate >= adaptive_threshold:
        return COOPERATE
    elif random() < 0.1:
        return COOPERATE  # Forgiveness
    else:
        return DEFECT
```

This strategy aims to be a **good collective citizen**—promoting cooperation, sustaining it when reciprocated, forgiving occasional lapses, but not allowing itself to be systematically exploited.
'''

description_COLLECTIVE_118 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I assume other players may be copies or near-copies of myself, or at least rational agents who might reason similarly. The goal is to establish and maintain cooperation when possible, while protecting against exploitation. Since we cannot coordinate explicitly, I use **observable signals** (past behavior) to infer whether the group can sustain cooperation.

## Strategy Overview: "Generous Threshold Trigger with Forgiveness"

The strategy conditions cooperation on whether a sufficient proportion of the group cooperated in the previous round, with built-in generosity and forgiveness mechanisms.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. If others reason similarly, we establish mutual cooperation from the start. The cost of one round's exploitation is worth the potential for sustained cooperation.

### Rounds 2 through (r-1): Conditional Cooperation with Forgiveness

**Cooperate if ANY of the following conditions are met:**

1. **Threshold Condition**: At least `threshold_fraction` of players cooperated in the previous round
   - `threshold_fraction = max(0.5, (n-1)/n - 0.1)`
   - This requires roughly half or more of players to have cooperated

2. **Forgiveness Condition**: The round number is a "forgiveness round"
   - Forgiveness rounds occur at intervals: rounds `floor(r/4)`, `floor(r/2)`, `floor(3r/4)`
   - This gives defecting groups periodic chances to restart cooperation

3. **Trend Condition**: Cooperation rate increased from round (t-2) to round (t-1)
   - If cooperation is recovering, reward the positive trend

**Otherwise: DEFECT**

### Final Round (Round r): Probabilistic Cooperation

**Action: COOPERATE with probability `p_final`, otherwise DEFECT**

Where `p_final = cooperation_rate_in_round_(r-1)`

Rationale: In a one-shot final round, pure game theory says defect. But if I'm playing against copies of myself, mutual defection destroys value. By cooperating with probability equal to the recent cooperation rate, I:
- Maintain cooperation if we've been cooperating
- Don't get exploited if others have been defecting
- Create a coordination point for similar strategies

---

## Pseudocode

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    prev_cooperation_count = count_cooperators(history, round - 1)
    prev_cooperation_rate = prev_cooperation_count / n
    
    # Calculate adaptive threshold
    threshold = max(0.5, (n - 1) / n - 0.1)
    
    # Final round: probabilistic
    if round == r:
        return COOPERATE with probability prev_cooperation_rate
               DEFECT otherwise
    
    # Condition 1: Threshold met
    if prev_cooperation_rate >= threshold:
        return COOPERATE
    
    # Condition 2: Forgiveness round
    forgiveness_rounds = {floor(r/4), floor(r/2), floor(3r/4)}
    if round in forgiveness_rounds:
        return COOPERATE
    
    # Condition 3: Positive trend (requires at least 2 rounds of history)
    if round >= 3:
        prev_prev_rate = count_cooperators(history, round - 2) / n
        if prev_cooperation_rate > prev_prev_rate:
            return COOPERATE
    
    return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Cooperate | Establish cooperative norm |
| n = 2 (minimum players) | Threshold ≈ 0.5, so need 1/2 cooperators | Equivalent to Tit-for-Tat-like behavior |
| Large n | Threshold approaches ~0.4-0.5 | More tolerant of some defectors in large groups |
| r = 2 (minimum rounds) | Round 1: Cooperate, Round 2: Probabilistic | Maintain collective approach even in short games |
| Everyone defected last round | Defect (unless forgiveness round) | Protect against exploitation |
| k close to 1 | Same strategy | Even small surplus is worth capturing collectively |
| k close to n | Same strategy | High returns make cooperation even more valuable |

---

## Why This Strategy is Collectively Aligned

1. **Self-reinforcing**: If all players use this strategy, cooperation persists throughout (everyone cooperates in round 1, threshold is met, cooperation continues)

2. **Forgiving**: Periodic forgiveness rounds prevent permanent collapse from accidental or exploratory defection

3. **Responsive**: Trend detection rewards groups that are recovering cooperation

4. **Robust**: Threshold mechanism protects against chronic free-riders while tolerating occasional defection

5. **Symmetric**: No player is treated specially; all use the same publicly-known rule
'''

description_COLLECTIVE_121 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I aim to maximize group welfare while protecting against exploitation. The key insight is that in a public goods game, **universal cooperation yields the best collective outcome** (everyone gets k > 1), but individual defection against cooperators is tempting. My strategy seeks to establish and maintain cooperation through reciprocity, while being forgiving enough to recover from mistakes or test cooperative intent.

---

## Strategy: Adaptive Collective Reciprocity (ACR)

### Decision Framework

The strategy tracks a **cooperation index** based on observed group behavior and adjusts its response accordingly. It's designed to:
1. Signal cooperative intent early
2. Reward group cooperation generously
3. Punish widespread defection proportionally
4. Remain forgiving to allow recovery
5. Handle endgame dynamics thoughtfully

---

### Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: In a collective framework, someone must extend trust first. By cooperating initially, I signal my willingness to pursue mutual benefit and give the group an opportunity to establish a cooperative norm.

---

#### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Decision Rule:**

```
IF prev_coop_rate >= (n-1)/n THEN
    COOPERATE (near-universal cooperation deserves reinforcement)

ELSE IF prev_coop_rate >= 0.5 THEN
    COOPERATE with probability = prev_coop_rate
    (proportional response - match the group's cooperative tendency)

ELSE IF prev_coop_rate > 0 THEN
    // Some cooperation exists but minority
    IF this is the first time coop_rate dropped below 0.5 THEN
        COOPERATE (forgiveness - give one chance to recover)
    ELSE
        DEFECT (protect against sustained exploitation)

ELSE (prev_coop_rate = 0)
    DEFECT (no point in unilateral sacrifice)
```

**Additional Forgiveness Mechanism:**

Every `floor(r/4)` rounds (roughly quarterly), if currently in a defection cycle:
```
IF stuck_in_mutual_defection for 3+ consecutive rounds THEN
    COOPERATE (attempt to restart cooperation)
```

This periodic "olive branch" allows escape from destructive equilibria.

---

#### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection in the final round, I maintain collective principles:

```
IF average_cooperation_rate across all previous rounds >= 0.6 THEN
    COOPERATE (honor the cooperative relationship)
ELSE
    DEFECT (the group has shown it won't sustain cooperation)
```

Rationale: If we've built something cooperative together, I won't be the one to betray it at the end. This maintains integrity and, if others share this view, achieves better outcomes than universal last-round defection.

---

### Pseudocode Summary

```
function decide(round, history, n, r, k):
    
    if round == 1:
        return COOPERATE
    
    prev_cooperators = count_cooperators(history[round-1])
    prev_coop_rate = prev_cooperators / n
    avg_coop_rate = average_cooperation_rate(history)
    
    # Final round logic
    if round == r:
        if avg_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Periodic forgiveness check
    if round % max(1, floor(r/4)) == 0:
        if consecutive_defection_rounds(history) >= 3:
            return COOPERATE
    
    # Main adaptive logic
    if prev_coop_rate >= (n-1)/n:
        return COOPERATE
    
    elif prev_coop_rate >= 0.5:
        return COOPERATE with probability prev_coop_rate
    
    elif prev_coop_rate > 0:
        if first_drop_below_half(history, round):
            return COOPERATE
        else:
            return DEFECT
    
    else:  # prev_coop_rate == 0
        return DEFECT
```

---

### Edge Case Handling

| Scenario | Response |
|----------|----------|
| **n = 2** | Strategy works as two-player tit-for-tat variant with forgiveness |
| **Very large n** | Cooperation thresholds scale appropriately with group size |
| **r = 2** | Cooperate round 1; round 2 follows final-round logic |
| **k very close to 1** | Strategy unchanged (lower cooperation benefits don't change strategic logic) |
| **All others always defect** | After forgiveness attempts fail, settles into defection |
| **All others always cooperate** | Maintains cooperation throughout |
| **Mixed/noisy opponents** | Probabilistic matching creates proportional response |

---

### Why This Strategy is Collectively Aligned

1. **Initiates cooperation** - Takes the risk of going first
2. **Scales trust with evidence** - More cooperation begets more cooperation
3. **Forgives mistakes** - Single failures don't doom the group
4. **Periodic restart attempts** - Actively tries to escape bad equilibria
5. **Honors cooperative relationships** - Doesn't cynically defect at the end
6. **Proportional response** - Doesn't overreact to partial cooperation

This strategy succeeds when paired with like-minded strategies while remaining robust against exploiters by limiting losses through adaptive defection.
'''

description_COLLECTIVE_119 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we assume all copies of this strategy will reason identically given the same information. Rather than thinking "what should *I* do?", we think "what should *we* do?" This allows implicit coordination without communication—if this reasoning is sound, all instances will reach the same conclusion and act in unison.

## Strategy Overview: **Adaptive Collective Reciprocity (ACR)**

The strategy maintains cooperation among collective members while adapting to the observed behavior of others. It uses the cooperation rate of the population to calibrate its response, rewarding cooperative environments and protecting against exploitation.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: We cannot assess others without data. Starting cooperatively signals willingness to collaborate and establishes a baseline. All collective members will do this identically.

---

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **population cooperation rate** from the previous round:
```
coop_rate = (number of C plays in round t-1) / n
```

**Decision Rule:**

```
IF coop_rate >= (n-1)/n THEN
    COOPERATE  // Near-universal cooperation: maintain it
    
ELSE IF coop_rate >= 0.5 THEN
    COOPERATE  // Majority cooperating: support the collective good
    
ELSE IF coop_rate > 0 AND coop_rate < 0.5 THEN
    // Minority cooperation: use probabilistic response
    // This prevents complete collapse while limiting exploitation
    COOPERATE with probability = coop_rate
    DEFECT with probability = (1 - coop_rate)
    
ELSE IF coop_rate == 0 THEN
    // Total defection detected
    // Attempt periodic cooperation to test for recovery
    IF (current_round mod 3) == 0 THEN
        COOPERATE  // Olive branch every 3rd round
    ELSE
        DEFECT
```

**Pseudorandom Coordination Note:** For probabilistic decisions, use a deterministic seed based on round number and game parameters. This ensures all collective members make the *same* "random" choice:
```
seed = hash(n, k, r, current_round)
random_value = deterministic_random(seed)
```

---

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes universal defection in the final round, we maintain collective logic:

```
IF average_coop_rate_over_all_previous_rounds >= 0.5 THEN
    COOPERATE  // Honor a cooperative game
ELSE
    DEFECT  // No cooperative relationship to preserve
```

Rationale: If we've established mutual cooperation, defecting on the last round only makes sense under individualistic reasoning. Collectively, if all copies cooperate, we all benefit. The only question is whether others have earned continued cooperation.

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (minimum players) | Standard rules apply | Tit-for-tat-like behavior emerges naturally |
| k very close to 1 | Standard rules apply | Low returns don't change collective logic |
| k very close to n | Standard rules apply | High returns make cooperation more attractive anyway |
| r = 2 (minimum rounds) | Round 1: C, Round 2: Based on round 1 | Limited data, but still reciprocate |
| All opponents defect every round | Periodic olive branches | Tests for change; limits losses |
| Erratic opponent behavior | Responds to actual cooperation rate | Smooths out noise over time |

---

## Why This Strategy Works Collectively

1. **Implicit Coordination**: All copies compute the same cooperation rate and use the same deterministic seed, so they act in unison without communication.

2. **Self-Reinforcing Cooperation**: When collective members are the majority, high cooperation rates trigger cooperation, which maintains high rates.

3. **Exploitation Resistance**: When facing defectors, probabilistic matching limits losses while maintaining some cooperative presence.

4. **Recovery Mechanism**: Periodic olive branches after collapse allow return to cooperation if opponents change behavior.

5. **No Sucker's Payoff Cascade**: By responding to actual cooperation rates rather than fixed rules, we avoid being perpetually exploited.

---

## Summary Pseudocode

```python
def ACR_strategy(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history, round-1) / n
    
    if round == r:  # Final round
        avg_rate = average_cooperation_rate(history)
        return COOPERATE if avg_rate >= 0.5 else DEFECT
    
    # Middle rounds
    if prev_coop_rate >= 0.5:
        return COOPERATE
    elif prev_coop_rate > 0:
        seed = deterministic_hash(n, k, r, round)
        return COOPERATE if random(seed) < prev_coop_rate else DEFECT
    else:  # prev_coop_rate == 0
        return COOPERATE if (round % 3 == 0) else DEFECT
```
'''

description_COLLECTIVE_122 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective identity**: all instances running this strategy act as one unified entity. We optimize for the collective good of our group while protecting against exploitation by outsiders. The key insight is that in a repeated game, we can use early rounds to identify fellow cooperators and build sustainable cooperation.

## Strategy Overview: "Adaptive Collective Reciprocity"

Our strategy operates in three phases across the r rounds, using observed behavior to classify other players and adjust our cooperation accordingly.

---

## Phase Definitions

**Phase 1: Signaling Phase** (Rounds 1-2)
- Purpose: Identify potential cooperators and signal our cooperative intent

**Phase 2: Assessment Phase** (Rounds 3 to r-2)
- Purpose: Maintain cooperation with identified cooperators, punish defectors, allow redemption

**Phase 3: End Game** (Rounds r-1 to r)
- Purpose: Strategic adjustment based on established relationships

---

## Decision Rules

### Round 1: Always Cooperate
We cooperate unconditionally to signal cooperative intent and establish a baseline for identifying fellow cooperators.

### Round 2: Conditional Cooperation
- **Cooperate** if at least ⌈n/2⌉ players (including self) cooperated in Round 1
- **Defect** if fewer than ⌈n/2⌉ players cooperated in Round 1

*Rationale: If majority cooperated, there's a viable cooperative coalition. If not, we protect ourselves while still gathering information.*

### Rounds 3 to (r-2): Adaptive Reciprocity

Maintain a **cooperation score** for each other player j:
```
score_j = (times j cooperated in last 3 rounds) / 3
```

Calculate **expected cooperators**:
```
expected_coop = Σ(score_j for all j ≠ self)
```

**Decision Rule:**
- **Cooperate** if `expected_coop ≥ (n-1) × (n-k)/(n-1)` 
  - Simplified: Cooperate if expected cooperation rate ≥ (n-k)/(n-1)
  - This threshold ensures cooperation is collectively beneficial given the multiplication factor k

- **Defect** otherwise

**Forgiveness Mechanism:**
- If a player who previously defected cooperates for 2 consecutive rounds, reset their score to 0.67 (giving them credit for recent cooperation)
- This allows recovery from early mistakes or strategic adjustments

### Round (r-1): Pre-Final Round
- **Cooperate** if the cooperation rate among all players in rounds (r-4) to (r-2) was ≥ 60%
- **Defect** otherwise

*Rationale: Reward sustained cooperation, but begin protecting against end-game defection.*

### Round r (Final Round): Conditional Cooperation
- **Cooperate** if at least (n-1) players cooperated in round (r-1)
  - Near-universal cooperation suggests a strong cooperative norm worth maintaining
- **Defect** otherwise

*Rationale: In the final round, there's no future punishment possible. We only cooperate if the group has demonstrated exceptional commitment.*

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    if round == 2:
        coop_count_r1 = count_cooperators(history, round=1)
        if coop_count_r1 >= ceil(n/2):
            return COOPERATE
        else:
            return DEFECT
    
    if round == r:  # Final round
        coop_count_prev = count_cooperators(history, round=r-1)
        if coop_count_prev >= n-1:
            return COOPERATE
        else:
            return DEFECT
    
    if round == r-1:  # Pre-final round
        recent_coop_rate = average_cooperation_rate(history, rounds=[r-4, r-3, r-2])
        if recent_coop_rate >= 0.60:
            return COOPERATE
        else:
            return DEFECT
    
    # Rounds 3 to r-2: Adaptive phase
    threshold = (n - k) / (n - 1)
    
    for each player j ≠ self:
        lookback = min(3, round-1)
        score[j] = count_j_cooperations(history, last=lookback) / lookback
        # Apply forgiveness
        if player_j_cooperated_last_2_rounds(history) and score[j] < 0.67:
            score[j] = 0.67
    
    expected_coop_rate = sum(score) / (n - 1)
    
    if expected_coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Standard rules apply | Threshold becomes (2-k)/1; cooperate if partner's score ≥ 2-k |
| r = 2 | Round 1: C, Round 2: C if ≥50% cooperated | Minimal game; maximize signaling value |
| r = 3 | Rounds 1-2 as specified; Round 3 uses final round rule | Skip assessment phase |
| k very close to n | Lower threshold makes cooperation easier | More forgiving of partial cooperation |
| k very close to 1 | Higher threshold requires near-universal cooperation | Protects against exploitation |
| All others defect rounds 1-2 | Defect from round 3 onward | No viable cooperative coalition exists |

---

## Why This Strategy Works Collectively

1. **Coordination through behavior**: All instances following this strategy will cooperate in Round 1, recognize each other through continued cooperation in Round 2, and maintain mutual cooperation throughout.

2. **Self-reinforcing**: When our instances encounter each other, our scores remain high, keeping us above the cooperation threshold.

3. **Robust to exploitation**: The threshold mechanism ensures we don't cooperate when it's collectively harmful. We withdraw cooperation from consistent defectors.

4. **Adaptive to population composition**: The strategy gracefully degrades—if we're a minority, we'll detect low cooperation and protect ourselves; if we're a majority, we'll maintain a cooperative coalition.

5. **Forgiveness enables coalition growth**: Players who "wake up" to cooperation can join our coalition, maximizing potential gains.
'''

description_COLLECTIVE_120 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similar cooperative AIs) may be playing, and our goal is to maximize collective welfare while protecting against exploitation. The strategy balances three objectives:

1. **Signal cooperative intent** to identify and coordinate with like-minded players
2. **Reward cooperation** to build and sustain mutual benefit
3. **Punish defection proportionally** to deter free-riding without destroying cooperation potential

---

## Strategy: "Graduated Reciprocity with Forgiveness" (GRF)

### Decision Variables

Let:
- `t` = current round (1 to r)
- `coop_rate(t-1)` = proportion of players who cooperated in round t-1
- `trend` = change in cooperation rate over recent rounds
- `rounds_remaining` = r - t

### Decision Rules

#### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. With no history, we must establish willingness to cooperate. This allows cooperative players to find each other.

---

#### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation threshold** τ based on game parameters:
```
τ = 1/k
```
This is the break-even point where cooperation becomes collectively beneficial.

**Primary Rule:**
```
IF coop_rate(t-1) ≥ τ THEN COOPERATE
ELSE apply graduated response
```

**Graduated Response (when coop_rate < τ):**
```
cooperation_probability = max(0, coop_rate(t-1) / τ) × forgiveness_factor

forgiveness_factor = 0.5 + 0.5 × (rounds_remaining / r)
```

This means:
- If cooperation is close to threshold, maintain high cooperation probability
- If cooperation is very low, defect more often
- Early in the game, be more forgiving (more time to recover)
- Later in the game, be less tolerant of defection

**Trend Bonus:**
```
IF cooperation rate increased in last 2 rounds:
    cooperation_probability += 0.15
```
Reward improving behavior to encourage positive momentum.

---

#### Final Round: Conditional Cooperation

**NOT automatic defection.** This distinguishes collective-minded strategies.

```
IF coop_rate(t-1) ≥ 0.5 THEN COOPERATE
ELSE DEFECT
```

Rationale: If the group has maintained majority cooperation, honor that relationship even in the final round. This sustains cooperation in repeated tournaments and signals trustworthiness to other collective-minded players.

---

### Pseudocode Summary

```python
def decide(round, total_rounds, n, k, history):
    
    # Round 1: Always cooperate to signal intent
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation rate from previous round
    coop_rate = count_cooperators(history[round-1]) / n
    threshold = 1 / k
    
    # Final round: conditional cooperation
    if round == total_rounds:
        if coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: graduated reciprocity
    if coop_rate >= threshold:
        return COOPERATE
    else:
        rounds_remaining = total_rounds - round
        forgiveness = 0.5 + 0.5 * (rounds_remaining / total_rounds)
        base_prob = max(0, coop_rate / threshold)
        coop_probability = base_prob * forgiveness
        
        # Trend bonus: reward improving cooperation
        if round >= 3:
            if history[round-1].coop_rate > history[round-2].coop_rate:
                coop_probability += 0.15
        
        coop_probability = min(1.0, coop_probability)
        
        return COOPERATE with probability coop_probability
        return DEFECT with probability (1 - coop_probability)
```

---

## Why This Strategy is Collectively Optimal

1. **Identifiable**: The Round 1 cooperation + proportional response pattern is recognizable to similar strategies
2. **Forgiving**: Doesn't permanently punish—allows recovery from early defection
3. **Robust**: Graduated response limits exploitation by persistent defectors
4. **Parameter-adaptive**: Threshold τ = 1/k automatically adjusts to game economics
5. **Endgame-stable**: Final round cooperation when warranted prevents unraveling

This strategy aims to **create and sustain cooperation** rather than merely respond to others—embodying the collective mindset that public goods games require for optimal outcomes.
'''

description_COLLECTIVE_123 = '''
# Collective Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy embraces a genuinely collective mindset: we assume all players using this strategy are working together as a unified group, not as individuals trying to maximize personal payoffs. Our goal is to establish and maintain cooperation while protecting the collective from exploitation by defectors.

## Key Insight

The critical threshold in this game is whether cooperation can be sustained. With multiplication factor k and n players:
- If everyone cooperates: each gets k (total value = n×k)
- If everyone defects: each gets 1 (total value = n)
- The social optimum is universal cooperation when k > 1

However, individual defection is always tempting since a defector gains (1 - k/n) compared to cooperating, while imposing cost k/n on each other player.

## Strategy Specification

### Parameters Derived from Game Structure
```
cooperation_threshold = 0.5  # Minimum cooperation rate to continue cooperating
forgiveness_rounds = 2       # Rounds to wait before attempting cooperation recovery
decay_factor = 0.9           # How quickly we forgive past defections
```

### Decision Rules

#### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: As a collective, we signal cooperative intent from the start. This establishes trust and allows us to identify other cooperators.

#### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays in round t-1) / n
```

Calculate the **trend** (is cooperation increasing or decreasing?):
```
if t > 2:
    trend = coop_rate(t-1) - coop_rate(t-2)
else:
    trend = 0
```

**Decision Logic:**

```
IF coop_rate >= cooperation_threshold THEN
    ACTION = COOPERATE
    # Cooperation is viable - maintain it
    
ELSE IF coop_rate < cooperation_threshold AND trend > 0 THEN
    ACTION = COOPERATE
    # Cooperation is recovering - support the recovery
    
ELSE IF in_forgiveness_window THEN
    ACTION = COOPERATE
    # Periodically test if cooperation can be restored
    
ELSE
    ACTION = DEFECT
    # Protect ourselves from exploitation
```

**Forgiveness Window Logic:**
```
rounds_since_low_cooperation = count rounds since coop_rate last fell below threshold
in_forgiveness_window = (rounds_since_low_cooperation % (forgiveness_rounds + 2) == 0)
```

This creates periodic "olive branch" rounds where we cooperate even after breakdown, giving the collective a chance to reset.

#### Final Round (Round r): Conditional Cooperation

Unlike typical game theory advice to defect in the final round, our collective strategy is:

```
IF average_cooperation_rate_over_game >= 0.6 THEN
    ACTION = COOPERATE
    # Reward a cooperative game with cooperative ending
ELSE
    ACTION = DEFECT
    # No reason to be exploited in a defection-heavy game
```

Rationale: If we're all using this strategy and cooperation has been sustained, we maintain it through the end. This avoids the unraveling problem that occurs when everyone "knows" to defect on the last round.

### Handling Edge Cases

1. **n = 2 (minimum players):** Strategy works identically, but cooperation_threshold effectively means "did the other player cooperate?"

2. **Very high k (close to n):** Cooperation is extremely valuable. We become more forgiving:
   - Adjust: `cooperation_threshold = 0.5 - 0.1 × (k/n)`

3. **Very low k (close to 1):** Cooperation barely beats defection. We stay robust:
   - Keep standard threshold but reduce forgiveness_rounds to 1

4. **Short games (r ≤ 3):** 
   - Round 1: Cooperate
   - Round 2: Mirror majority from round 1
   - Round 3 (if exists): Cooperate if round 2 had ≥50% cooperation

5. **Large n:** With many players, individual actions matter less. We maintain cooperation to set a good example and hope for critical mass.

### Complete Pseudocode

```
function decide(game_params, history):
    n = game_params.num_players
    r = game_params.num_rounds
    k = game_params.multiplier
    t = current_round_number
    
    # Round 1: Always cooperate
    if t == 1:
        return COOPERATE
    
    # Calculate cooperation metrics
    prev_coop_rate = sum(history[t-1]) / n
    
    if t > 2:
        prev_prev_coop_rate = sum(history[t-2]) / n
        trend = prev_coop_rate - prev_prev_coop_rate
    else:
        trend = 0
    
    # Adaptive threshold based on k
    threshold = max(0.3, 0.5 - 0.1 * (k / n))
    
    # Final round logic
    if t == r:
        avg_coop = mean([sum(history[i])/n for i in 1..t-1])
        if avg_coop >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Main decision logic
    if prev_coop_rate >= threshold:
        return COOPERATE
    elif trend > 0.1:  # Meaningful positive trend
        return COOPERATE
    elif is_forgiveness_round(t, history, threshold):
        return COOPERATE
    else:
        return DEFECT

function is_forgiveness_round(t, history, threshold):
    # Find last round where cooperation was above threshold
    for i in range(t-1, 0, -1):
        if sum(history[i])/n >= threshold:
            rounds_since = t - i
            return (rounds_since % 4 == 0)  # Forgive every 4th round
    return (t % 5 == 0)  # If never good, try every 5th round
```

## Why This Strategy Works Collectively

1. **Coordination without communication:** By all starting with cooperation and using identical thresholds, we naturally synchronize.

2. **Robust to defectors:** We don't blindly cooperate; we respond to the actual cooperation rate, protecting against exploitation.

3. **Self-healing:** The forgiveness mechanism allows recovery from temporary breakdowns or the presence of some defectors.

4. **No unraveling:** By cooperating in the final round when cooperation has been sustained, we avoid the backward induction collapse.

5. **Adaptive to parameters:** The strategy adjusts to different values of n, k, and r automatically.
'''

description_COLLECTIVE_121 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a genuinely collective mindset: I assume other players may be running similar reasoning processes and recognize that mutual cooperation benefits everyone. The strategy aims to establish and maintain cooperation while protecting against exploitation, using forgiveness and graduated responses to navigate the complex dynamics of multi-player repeated games.

## Strategy Overview: **Adaptive Collective Reciprocity (ACR)**

The strategy operates on three principles:
1. **Optimistic initiation**: Start cooperatively to signal willingness and test the waters
2. **Proportional reciprocity**: Mirror the group's cooperation level with a bias toward cooperation
3. **Strategic endgame**: Maintain cooperation signals even as the game concludes

---

## Decision Rules

### Round 1: Cooperate
Begin with cooperation to:
- Signal cooperative intent to like-minded players
- Establish a baseline for measuring group behavior
- Give the collective a chance to form

### Rounds 2 through (r-1): Adaptive Reciprocity

**Calculate the cooperation rate** from the previous round:
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Decision rule with cooperation bias:**
```
threshold = max(0.3, 0.5 - (0.1 × rounds_of_high_cooperation))

if prev_coop_rate >= threshold:
    COOPERATE
else:
    # Graduated response based on cooperation history
    if this is first defection-heavy round:
        COOPERATE (give benefit of doubt)
    elif consecutive_low_cooperation_rounds >= 2:
        DEFECT
    else:
        COOPERATE with probability = prev_coop_rate + 0.2
```

**Tracking "high cooperation"**: A round has high cooperation if ≥ 50% of players cooperated.

**Forgiveness mechanism**: If cooperation drops but then recovers to ≥40% in any subsequent round, reset the consecutive low cooperation counter and return to cooperation.

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection:
```
if average_cooperation_rate_over_game >= 0.4:
    COOPERATE  # Reward a cooperative group, maintain collective outcome
else:
    DEFECT     # Group has shown non-cooperative norm
```

This acknowledges that if opponents are running similar strategies, mutual last-round cooperation is achievable and beneficial.

---

## Detailed Pseudocode

```
function ACR_Strategy(game_params, history):
    n = game_params.num_players
    r = game_params.num_rounds
    current_round = history.current_round
    
    # Round 1: Always cooperate
    if current_round == 1:
        return COOPERATE
    
    # Calculate metrics from history
    prev_round = history.rounds[current_round - 1]
    prev_coop_count = count(prev_round.actions == COOPERATE)
    prev_coop_rate = prev_coop_count / n
    
    total_coop_rounds = count rounds where coop_rate >= 0.5
    avg_coop_rate = sum(all_coop_rates) / (current_round - 1)
    consecutive_low = count_consecutive_rounds_where(coop_rate < 0.4, from_end)
    
    # Final round logic
    if current_round == r:
        if avg_coop_rate >= 0.4:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Adaptive reciprocity
    dynamic_threshold = max(0.3, 0.5 - (0.05 × total_coop_rounds))
    
    if prev_coop_rate >= dynamic_threshold:
        return COOPERATE
    
    # Below threshold - graduated response
    if consecutive_low == 1:
        return COOPERATE  # One-round forgiveness
    
    if consecutive_low >= 2 and prev_coop_rate < 0.25:
        return DEFECT  # Clear non-cooperative environment
    
    # Probabilistic cooperation for ambiguous situations
    coop_probability = min(0.8, prev_coop_rate + 0.25)
    return COOPERATE with probability coop_probability, else DEFECT
```

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | Cooperate | Signal intent, establish baseline |
| Final round, cooperative history | Cooperate | Collective benefit, others may reason similarly |
| Final round, defection-heavy history | Defect | No collective to preserve |
| Single defection after cooperation streak | Cooperate | Noise tolerance, forgiveness |
| Sudden cooperation after defection streak | Cooperate | Reward recovery attempts |
| n=2 (minimal game) | Same rules apply | Threshold math still works |
| All others always defect | Eventually defect | After 2-3 rounds, protect self |

---

## Why This Strategy is Collectively Optimal

1. **Self-recognition**: If all players use ACR, everyone cooperates every round, achieving maximum collective payoff of 2r per player (with example parameters)

2. **Robustness**: Against defectors, the strategy eventually protects itself while giving multiple chances for cooperation to emerge

3. **Forgiveness**: The bias toward cooperation and recovery mechanisms allow groups to escape defection spirals

4. **No exploitation**: Graduated responses prevent persistent free-riders from benefiting indefinitely
'''

description_COLLECTIVE_124 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other instances of this strategy (or similar cooperative strategies) may be present in the tournament. The goal is to maximize collective welfare when playing with cooperators while protecting against exploitation by defectors. The strategy uses observable signals to identify likely cooperators and coordinate implicitly.

## Strategy Name: **Graduated Reciprocity with Collective Signaling (GRCS)**

---

## Decision Rules

### Round 1: Cooperative Signal
**Action: COOPERATE**

Rationale: Opening with cooperation serves as a signal to identify other cooperative strategies. The cost of being exploited in one round is acceptable for the information gained and the potential to establish mutual cooperation.

---

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation ratio** from the previous round:
```
coop_ratio = (number of cooperators in previous round) / n
```

Calculate the **trend** (if round ≥ 3):
```
trend = coop_ratio(current) - coop_ratio(previous)
```

**Decision Logic:**

```
IF coop_ratio >= (n-1)/n THEN
    # Near-universal cooperation: maintain it
    COOPERATE

ELSE IF coop_ratio >= k/n THEN
    # Cooperation is socially beneficial (total benefit > total cost)
    # Probabilistically cooperate based on observed cooperation
    COOPERATE with probability = coop_ratio
    
ELSE IF coop_ratio > 0 AND trend >= 0 THEN
    # Some cooperation exists and isn't declining
    # Give cooperation a chance to grow
    COOPERATE with probability = coop_ratio * k / n
    
ELSE IF coop_ratio > 0 AND trend < 0 THEN
    # Cooperation is declining - match the decline
    COOPERATE with probability = coop_ratio^2
    
ELSE
    # No cooperation observed - defect to protect
    DEFECT
```

---

### Final Round (Round r): Conditional Cooperation

The final round removes future interaction incentives, but collective strategies should still cooperate if others do.

```
IF average_coop_ratio(all previous rounds) >= 0.5 THEN
    # History suggests cooperative population
    COOPERATE
ELSE
    # Predominantly defecting population
    DEFECT
```

---

## Edge Cases

### Small n (n = 2)
Essentially becomes iterated Prisoner's Dilemma. Strategy simplifies to:
- Round 1: COOPERATE
- Rounds 2 to r-1: Mirror opponent's previous action (Tit-for-Tat)
- Round r: COOPERATE if opponent cooperated ≥50% of the time

### Very Short Games (r = 2)
- Round 1: COOPERATE
- Round 2: COOPERATE if at least half the players cooperated in round 1

### k Very Close to 1 or n
- k ≈ 1: Benefits barely exceed costs; be more conservative (raise thresholds by 10%)
- k ≈ n: Benefits greatly exceed costs; be more generous (lower thresholds by 10%)

### Tie-Breaking for Probabilistic Decisions
Use a deterministic pseudo-random function based on round number and observed history to ensure reproducibility:
```
seed = (round_number * 1000 + total_cooperators_so_far) mod 100
cooperate if seed < (probability * 100)
```

---

## Summary Pseudocode

```python
def decide(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    prev_coop = count_cooperators(history[round-1])
    coop_ratio = prev_coop / n
    
    if round == r:  # Final round
        avg_coop = average_cooperation_ratio(history)
        return COOPERATE if avg_coop >= 0.5 else DEFECT
    
    # Middle rounds
    if coop_ratio >= (n-1)/n:
        return COOPERATE
    elif coop_ratio >= k/n:
        return probabilistic(coop_ratio)
    elif coop_ratio > 0:
        trend = get_trend(history) if round >= 3 else 0
        if trend >= 0:
            return probabilistic(coop_ratio * k / n)
        else:
            return probabilistic(coop_ratio ** 2)
    else:
        return DEFECT
```

---

## Why This Strategy is Collectively Aligned

1. **Signals cooperative intent** in round 1, allowing mutual identification
2. **Rewards cooperation** by maintaining it when others cooperate
3. **Proportional response** - doesn't over-punish occasional defection
4. **Protects the collective** from exploitation by withdrawing from predominantly defecting groups
5. **Maintains cooperation in endgame** when history warrants trust, avoiding the classic unraveling problem
'''

description_COLLECTIVE_122 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embodies a **collective mindset**: we assume all players using this strategy will reason identically given the same information. We don't need explicit coordination mechanisms because identical reasoning from identical inputs produces identical outputs. Our goal is to maximize collective welfare while protecting against exploitation by defectors.

## Strategy Overview: **Adaptive Threshold Cooperation (ATC)**

The strategy cooperates when the observed cooperation rate suggests a cooperative environment worth sustaining, and defects to protect against exploitation or to signal disapproval of defection.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: We cannot assess the environment without data. Starting cooperatively signals good faith and allows us to identify other cooperators. The cost of one round of potential exploitation is acceptable to establish a cooperative baseline.

### Rounds 2 through (r-1): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Rule:**
```
IF coop_rate >= threshold THEN COOPERATE
ELSE DEFECT
```

**Threshold Calculation:**
```
base_threshold = 1/k
adaptive_threshold = base_threshold + forgiveness_adjustment

where:
  forgiveness_adjustment = -0.1 × (rounds_remaining / r)
```

The base threshold `1/k` is the break-even point where cooperation becomes individually rational if that fraction cooperates. The forgiveness adjustment makes us more forgiving early (to encourage cooperation emergence) and stricter later (to protect accumulated gains).

**Additional Rule - Trend Detection:**
```
IF coop_rate < threshold BUT coop_rate is INCREASING over last 2 rounds:
  COOPERATE (give cooperation a chance to build)
```

### Final Round (Round r): Conditional Cooperation

This is where naive game theory suggests universal defection. However, with collective reasoning:

```
IF coop_rate in round (r-1) >= 0.5 THEN COOPERATE
ELSE DEFECT
```

Rationale: If we're in a predominantly cooperative group, maintaining cooperation in the final round maximizes collective payoff (everyone gets k > 1 instead of 1). If the group is predominantly defecting, we protect ourselves.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round statistics
    prev_cooperators = count_cooperators(history[round - 1])
    coop_rate = prev_cooperators / n
    
    # Calculate adaptive threshold
    rounds_remaining = r - round
    base_threshold = 1 / k
    forgiveness = 0.1 * (rounds_remaining / r)
    threshold = max(0.1, base_threshold - forgiveness)
    
    # Final round logic
    if round == r:
        if coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds logic
    if coop_rate >= threshold:
        return COOPERATE
    
    # Trend detection (recovery mechanism)
    if round >= 3:
        prev_prev_coop_rate = count_cooperators(history[round - 2]) / n
        if coop_rate > prev_prev_coop_rate:
            return COOPERATE  # Cooperation is recovering
    
    return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| n = 2 | Use same rules | Reduces to repeated Prisoner's Dilemma variant |
| k very close to 1 | Threshold ≈ 1, mostly defect | Cooperation barely beats defection |
| k close to n | Threshold low, mostly cooperate | Strong incentive for public good |
| All others defect round 1 | Defect round 2+ | Protect against full exploitation |
| Single round game (r=1) | Cooperate | Collective reasoning dominates |

---

## Why This Strategy is Collectively Optimal

1. **Identical agents converge**: If all players use ATC, everyone cooperates in round 1, sees 100% cooperation, and continues cooperating throughout—achieving the Pareto-optimal outcome.

2. **Robust to defectors**: The threshold mechanism ensures we don't indefinitely subsidize free-riders. We only cooperate when enough others do to make it worthwhile.

3. **Forgiveness enables recovery**: The trend detection and early-game forgiveness allow cooperation to re-emerge after temporary breakdowns.

4. **Parameter-adaptive**: The threshold scales with k, automatically adjusting strictness based on how valuable cooperation actually is.
'''

description_COLLECTIVE_125 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I assume other players may be running similar reasoning processes and could arrive at compatible strategies. Rather than treating this as purely adversarial, I recognize that mutual cooperation yields the best collective outcome (payoff of k > 1 vs payoff of 1 for mutual defection). My strategy aims to:

1. **Signal cooperative intent** early
2. **Sustain cooperation** when others reciprocate
3. **Protect against exploitation** without being overly punitive
4. **Recover cooperation** after breakdowns when possible

---

## Strategy: "Generous Threshold Trigger with Forgiveness"

### Key Parameters (derived from game parameters)

```
cooperation_threshold = 0.5  # Minimum fraction of cooperators needed to continue cooperating
forgiveness_probability = 1/r  # Chance to test cooperation after defection spiral
end_game_threshold = max(2, floor(r/10))  # Rounds before end when strategy shifts
```

### Decision Rules

#### Round 1: Always Cooperate
- **Rationale**: Establish cooperative intent. With no history, optimism is warranted. If others reason similarly, we achieve the superior collective outcome immediately.

#### Rounds 2 through (r - end_game_threshold): Conditional Cooperation

**Cooperate if ANY of these conditions hold:**

1. **Sufficient Recent Cooperation**: 
   - The fraction of cooperators in the previous round ≥ `cooperation_threshold`
   - This rewards environments where cooperation is viable

2. **Positive Trend Detection**:
   - Cooperation rate increased from round (t-2) to round (t-1)
   - This supports recovery attempts by others

3. **Forgiveness Probe**:
   - With probability `forgiveness_probability`, cooperate anyway
   - This allows escape from defection equilibria

**Otherwise: Defect**
- If cooperation has collapsed and shows no recovery, protect against continued exploitation

#### Final Rounds (last `end_game_threshold` rounds): Modified Strategy

```
if cooperation_rate_last_round >= 0.7:
    # Strong cooperation established - maintain it through the end
    Cooperate
elif cooperation_rate_last_round >= cooperation_threshold:
    # Moderate cooperation - use probabilistic tapering
    Cooperate with probability = cooperation_rate_last_round
else:
    # Cooperation has failed - defect
    Defect
```

- **Rationale**: Standard game theory predicts defection unraveling from the end. However, if I'm playing against similar collective-minded agents, we can sustain cooperation. The threshold approach balances these considerations.

---

## Pseudocode Implementation

```python
def decide(round_number, history, n, k, r):
    cooperation_threshold = 0.5
    forgiveness_prob = 1 / r
    end_game_rounds = max(2, r // 10)
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    # Calculate cooperation rates
    coop_rate_last = count_cooperators(history[round_number - 1]) / n
    
    if round_number >= 3:
        coop_rate_prev = count_cooperators(history[round_number - 2]) / n
        trend_positive = coop_rate_last > coop_rate_prev
    else:
        trend_positive = False
    
    # End game logic
    if round_number > r - end_game_rounds:
        if coop_rate_last >= 0.7:
            return COOPERATE
        elif coop_rate_last >= cooperation_threshold:
            return COOPERATE with probability coop_rate_last
        else:
            return DEFECT
    
    # Main game logic
    if coop_rate_last >= cooperation_threshold:
        return COOPERATE
    elif trend_positive:
        return COOPERATE
    elif random() < forgiveness_prob:
        return COOPERATE  # Forgiveness probe
    else:
        return DEFECT
```

---

## Robustness Properties

| Opponent Type | Strategy Response |
|---------------|-------------------|
| **All Cooperators** | Sustained mutual cooperation (payoff ≈ k per round) |
| **All Defectors** | Quick defection after round 1, occasional probes (payoff ≈ 1 per round, minimal exploitation) |
| **Tit-for-Tat variants** | Achieves cooperation through threshold mechanism |
| **Mixed/Noisy strategies** | Threshold provides noise tolerance; forgiveness enables recovery |
| **Similar collective strategies** | High cooperation through aligned reasoning |

---

## Why This Strategy is Collectively Optimal

1. **Coordination-friendly**: If multiple players adopt this strategy, they naturally coordinate on cooperation
2. **Not exploitable in expectation**: Limited forgiveness and threshold requirements prevent systematic exploitation
3. **Recoverable**: Unlike grim trigger, can escape defection spirals
4. **Parameter-adaptive**: Scales appropriately with game length and player count
'''

description_COLLECTIVE_123 = '''
# Collective Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy is designed for a population of agents sharing the same algorithm. We aim to:
1. **Establish cooperation** among ourselves through recognizable patterns
2. **Sustain cooperation** when it's collectively beneficial
3. **Protect against exploitation** by defecting opponents
4. **Maximize collective welfare** across all agents using this strategy

## Key Insight

Since we cannot pre-coordinate, we need a **self-organizing signal** that emerges from shared behavior. Our signal: **cooperate in round 1 unconditionally**. This creates a recognizable "handshake" - if we observe high cooperation in round 1, we're likely playing with copies of ourselves or cooperative strategies.

---

## Strategy Specification

### Parameters Derived from Game

```
cooperation_threshold = k / n    # The marginal benefit ratio
min_cooperators_needed = ceil(n / k)  # Minimum cooperators for C to break even
```

### Decision Rules by Round

#### **Round 1: Unconditional Cooperation**
- **Action: COOPERATE**
- Rationale: This serves as our collective identifier. All ATC agents will cooperate, allowing us to gauge the cooperative composition of the group.

#### **Rounds 2 through (r-1): Adaptive Threshold Response**

```
Let prev_coop_rate = (number of cooperators last round) / n
Let avg_coop_rate = (total cooperations so far) / (n × rounds_played)
Let recent_trend = prev_coop_rate - coop_rate_two_rounds_ago  # if available

IF prev_coop_rate >= (n - 1) / n THEN
    # Near-universal cooperation: maintain it
    ACTION: COOPERATE

ELSE IF prev_coop_rate >= min_cooperators_needed / n THEN
    # Cooperation is viable (breaks even or better)
    # Use probabilistic cooperation to allow recovery from noise
    
    cooperation_probability = prev_coop_rate × (k / (n - 1))
    # This scales with both observed cooperation and the benefit ratio
    # Capped at 1.0
    
    IF recent_trend > 0 THEN
        # Cooperation is increasing - encourage it
        cooperation_probability = min(1.0, cooperation_probability + 0.1)
    
    ACTION: COOPERATE with probability cooperation_probability
            DEFECT otherwise

ELSE IF prev_coop_rate > 0 AND recent_trend > 0 THEN
    # Low cooperation but improving - give it a chance
    ACTION: COOPERATE with probability 0.3

ELSE
    # Cooperation has collapsed or never existed
    ACTION: DEFECT
```

#### **Round r (Final Round): Conditional Cooperation**

```
# In the final round, there's no future to protect, but we maintain
# cooperation for collective benefit if the group has been cooperative

IF avg_coop_rate >= 0.7 THEN
    # Group has been highly cooperative - honor that
    ACTION: COOPERATE
ELSE IF avg_coop_rate >= 0.5 THEN
    # Mixed history - cooperate probabilistically  
    ACTION: COOPERATE with probability avg_coop_rate
ELSE
    # Predominantly defecting group
    ACTION: DEFECT
```

---

## Handling Edge Cases

### **Two-Player Game (n = 2)**
- Simplifies to a Prisoner's Dilemma variant
- After round 1, use **Tit-for-Tat**: copy opponent's last action
- Exception: Cooperate in final round if opponent cooperated ≥60% of the time

### **Very Short Games (r = 2)**
- Round 1: COOPERATE (signal)
- Round 2: COOPERATE if round 1 had ≥50% cooperation, else DEFECT

### **High k (approaching n)**
- Cooperation is more valuable; lower the threshold:
  - Modify: `adjusted_threshold = min_cooperators_needed / n × (n / k)`

### **Noise/Trembles**
- Single defection after sustained cooperation: **forgive once**
- Track a `forgiveness_used` flag per observed defector pattern
- If cooperation drops by exactly 1 player from near-universal, maintain cooperation for one round

---

## Why This Strategy Works Collectively

1. **Self-Recognition**: All ATC agents cooperate in round 1, creating observable clustering of cooperation.

2. **Proportional Response**: We don't punish isolated defections harshly (allowing for other ATC agents or noise), but we withdraw from systematic exploitation.

3. **Collective Threshold Logic**: We cooperate when it's collectively rational (enough cooperators to make it worthwhile), matching incentives with behavior.

4. **Trend Awareness**: We reward improving cooperation and don't give up if there's positive momentum.

5. **Graceful Degradation**: Against all-defect opponents, we lose only round 1's endowment, then protect ourselves.

6. **Final Round Loyalty**: We don't automatically defect in the last round if the group has been cooperative, which maximizes collective payoff among ATC agents.

---

## Summary Pseudocode

```
function decide(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    prev_coop_count = count_cooperators(history, round - 1)
    prev_coop_rate = prev_coop_count / n
    avg_coop_rate = total_cooperations(history) / (n × (round - 1))
    
    if round == r:  # final round
        if avg_coop_rate >= 0.7: return COOPERATE
        if avg_coop_rate >= 0.5: return COOPERATE with prob avg_coop_rate
        return DEFECT
    
    min_viable = ceil(n / k) / n
    
    if prev_coop_rate >= (n-1)/n:
        return COOPERATE
    
    if prev_coop_rate >= min_viable:
        prob = min(1.0, prev_coop_rate × k / (n-1))
        if trend_is_positive(history): prob = min(1.0, prob + 0.1)
        return COOPERATE with probability prob
    
    if prev_coop_rate > 0 and trend_is_positive(history):
        return COOPERATE with probability 0.3
    
    return DEFECT
```
'''

description_COLLECTIVE_126 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that mutual cooperation yields the best outcome for everyone (payoff = k > 1), while mutual defection yields the worst collective outcome (payoff = 1 for all). My goal is to foster and sustain cooperation while protecting against exploitation.

The key insight is that with k < n, defection is always individually rational in a single round—but repeated play allows for cooperation to emerge through reciprocity. I will act as a **conditional cooperator** who starts generously, rewards cooperation, and proportionally responds to the cooperation level I observe.

---

## Strategy: Proportional Collective Reciprocity (PCR)

### Decision Rule Overview

My cooperation probability in each round is determined by:
1. **The observed cooperation rate** in the previous round(s)
2. **The round number** (with special handling for early and late rounds)
3. **A forgiveness mechanism** to recover from defection spirals

---

### Detailed Decision Rules

#### Round 1: Unconditional Cooperation
- **Action: COOPERATE**
- Rationale: Signal cooperative intent, give others the benefit of the doubt, and establish a foundation for collective action.

#### Rounds 2 through (r - 1): Proportional Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

**Decision rule:**
```
if coop_rate >= threshold(t):
    COOPERATE
else:
    COOPERATE with probability = coop_rate^α
    DEFECT with probability = 1 - coop_rate^α
```

Where:
- `threshold(t) = 0.5` (if at least half cooperated, I cooperate deterministically)
- `α = 0.8` (slight generosity—I cooperate slightly more than the observed rate when below threshold)

**Forgiveness mechanism:** Every `forgiveness_interval = max(3, r/5)` rounds, if stuck in low cooperation:
```
if coop_rate < 0.3 for last 2 rounds AND round_number % forgiveness_interval == 0:
    COOPERATE (unconditional forgiveness probe)
```

#### Final Round (Round r): Conditional Cooperation with Commitment

Unlike standard game theory which predicts universal defection in the last round, I maintain my collective commitment:

```
if average_coop_rate(all previous rounds) >= 0.5:
    COOPERATE (reward sustained collective behavior)
else:
    DEFECT (no reason to sacrifice for persistent defectors)
```

---

### Pseudocode Summary

```
function decide(round_number, history, n, r, k):
    
    # Round 1: Start cooperative
    if round_number == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_coop_rate = count_cooperators(history[round_number - 1]) / n
    
    # Final round: based on overall cooperation history
    if round_number == r:
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: proportional reciprocity
    
    # Check for forgiveness probe opportunity
    forgiveness_interval = max(3, r // 5)
    if round_number % forgiveness_interval == 0:
        recent_coop = average_cooperation_rate(history[last 2 rounds])
        if recent_coop < 0.3:
            return COOPERATE  # Forgiveness probe
    
    # Main decision logic
    if prev_coop_rate >= 0.5:
        return COOPERATE
    else:
        # Probabilistic cooperation proportional to observed cooperation
        prob_cooperate = prev_coop_rate ^ 0.8
        return COOPERATE with probability prob_cooperate
        return DEFECT with probability (1 - prob_cooperate)
```

---

### Edge Cases Handled

| Scenario | Response |
|----------|----------|
| First round | Always cooperate |
| Last round | Cooperate if historical average ≥ 50% |
| All others defected last round | Small cooperation probability (forgiveness) |
| All others cooperated | Cooperate |
| Mixed behavior | Probabilistic, leaning toward observed rate |
| Stuck in defection spiral | Periodic forgiveness probes |
| n = 2 (minimum players) | Strategy still applies; resembles Tit-for-Tat |
| Large n | Responds to aggregate behavior, not individuals |

---

### Why This Strategy is Collectively Aligned

1. **Starts cooperative**: Establishes trust and signals collective intent
2. **Rewards cooperation**: Deterministic cooperation when majority cooperates
3. **Proportional punishment**: Doesn't immediately abandon cooperation; scales response
4. **Forgiveness**: Allows recovery from mutual defection traps
5. **End-game commitment**: Doesn't betray cooperators in the final round
6. **Robust to variation**: Works whether others are cooperators, defectors, or mixed

This strategy aims to be the kind of player that, if everyone adopted it, would achieve near-optimal collective outcomes—while still protecting itself against pure defectors.
'''

description_COLLECTIVE_124 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume other players may be running similar reasoning processes and recognize that mutual cooperation benefits everyone. The strategy aims to:
1. Signal cooperative intent clearly
2. Build and maintain cooperation when others reciprocate
3. Protect against exploitation while remaining forgiving
4. Adapt to the actual behavior observed in the population

## Strategy Overview: **Adaptive Threshold Cooperation with Forgiveness**

The strategy tracks the cooperation level of the group and adjusts behavior based on whether sufficient cooperation exists to make contributing worthwhile, while maintaining mechanisms to rebuild cooperation after breakdowns.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Start by signaling cooperative intent. This gives the collective the best chance to establish mutual cooperation. The cost of one round of potential exploitation is worth the opportunity to coordinate on the superior outcome.

### Rounds 2 through (r-1): Adaptive Threshold with Forgiveness

**Calculate cooperation rate** from the previous round:
```
prev_coop_rate = (number of C plays in round t-1) / n
```

**Calculate cumulative cooperation rate** across all previous rounds:
```
cumulative_coop_rate = (total C plays across all rounds) / (n × rounds_played)
```

**Decision Logic:**

```
IF prev_coop_rate >= threshold THEN
    COOPERATE
ELSE IF forgiveness_condition_met THEN
    COOPERATE (forgiveness probe)
ELSE
    DEFECT
```

**Threshold Calculation:**
```
base_threshold = 0.5
# Adjust based on k/n ratio - higher k makes cooperation more valuable
adjusted_threshold = base_threshold - 0.1 × (k/n - 0.5)
# Ensure threshold stays reasonable
threshold = clamp(adjusted_threshold, 0.3, 0.7)
```

**Forgiveness Mechanism:**
```
rounds_since_last_cooperation_probe = rounds since I last played C while below threshold
forgiveness_interval = max(2, floor(r / 5))

forgiveness_condition_met = (
    rounds_since_last_cooperation_probe >= forgiveness_interval
    AND cumulative_coop_rate >= 0.25
)
```

This periodic "forgiveness probe" allows the group to potentially restart cooperation after a breakdown, recognizing that other collective-minded agents may be waiting for a signal.

### Final Round (Round r): Conditional Cooperation

**Do NOT automatically defect.** 

Rationale: If all players defect in the final round expecting others to defect, this becomes a self-fulfilling prophecy. A collectively-minded strategy should maintain consistency.

```
IF cumulative_coop_rate >= threshold THEN
    COOPERATE
ELSE
    DEFECT
```

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    threshold = clamp(0.5 - 0.1 × (k/n - 0.5), 0.3, 0.7)
    
    IF round == 1:
        return COOPERATE
    
    prev_coop_rate = count_cooperators(history, round-1) / n
    cumulative_coop_rate = total_cooperations(history) / (n × (round - 1))
    
    IF prev_coop_rate >= threshold:
        return COOPERATE
    
    # Forgiveness logic
    forgiveness_interval = max(2, floor(r / 5))
    rounds_since_probe = rounds_since_last_cooperation_while_below_threshold(history)
    
    IF rounds_since_probe >= forgiveness_interval AND cumulative_coop_rate >= 0.25:
        return COOPERATE  # Forgiveness probe
    
    return DEFECT
```

---

## Edge Cases

| Scenario | Behavior |
|----------|----------|
| **Round 1** | Always cooperate |
| **Final round** | Cooperate if cumulative rate meets threshold |
| **n = 2** | Strategy works normally; threshold ~0.5 |
| **Very short games (r ≤ 3)** | Cooperate round 1, then threshold-based |
| **All others always defect** | After round 1, will defect (with occasional forgiveness probes) |
| **All others always cooperate** | Will always cooperate |
| **Mixed population** | Adapts to actual cooperation level |

---

## Why This Strategy is Collectively Robust

1. **Clear cooperative signal**: Starting with C makes coordination easier
2. **Threshold-based**: Doesn't require perfect cooperation—tolerates some defection
3. **Forgiving**: Can recover from temporary breakdowns
4. **Consistent in endgame**: Doesn't betray cooperative partners at the end
5. **Adaptive**: Adjusts threshold based on game parameters (k/n ratio)
6. **Self-consistent**: If all players use this strategy, stable cooperation emerges
'''

description_COLLECTIVE_127 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy is designed with a **collective mindset**: I assume I am one of potentially many players using this same strategy. Our goal is to achieve high collective welfare while protecting against exploitation by defectors. The strategy must be self-recognizing (players using it can implicitly coordinate) while remaining robust against other strategies.

## Strategy Overview: "Adaptive Threshold Cooperation with Forgiveness"

The strategy operates on three principles:
1. **Start cooperatively** to establish potential for mutual benefit
2. **Mirror the group's cooperation level** - cooperate when enough others do
3. **Build in forgiveness** to recover from temporary defections and escape mutual defection traps

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: With no history, we signal cooperative intent. If other copies of this strategy exist, we all start cooperating together, immediately achieving good outcomes.

### Rounds 2 through (r-1): Adaptive Threshold with Forgiveness

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

Calculate the **adaptive threshold**:
```
base_threshold = 1/k
adjusted_threshold = base_threshold × (1 - 0.3 × (rounds_remaining / r))
```

The threshold decreases slightly as the game progresses, making cooperation easier to sustain in middle rounds.

**Primary Decision Rule:**
```
IF coop_rate >= adjusted_threshold THEN COOPERATE
ELSE DEFECT
```

**Forgiveness Mechanism:**
Even if the primary rule says DEFECT, COOPERATE if:
- We have defected for 2 consecutive rounds AND
- Current round number is not in the final 20% of rounds AND
- A random check passes with probability = k/(2n)

This forgiveness helps break defection spirals and gives the group chances to recover.

**Trend Detection:**
```
IF cooperation has increased for 2 consecutive rounds THEN
    Lower threshold by 10% (more willing to cooperate)
IF cooperation has decreased for 2 consecutive rounds THEN
    Raise threshold by 10% (more cautious)
```

### Final Round (Round r): Conditional Cooperation

Unlike standard game theory which prescribes defection in the final round, we use:

```
IF average_cooperation_rate_over_all_rounds >= 0.5 THEN COOPERATE
ELSE DEFECT
```

Rationale: If we're playing with other collective-minded players, mutual cooperation in the final round benefits everyone. We only defect if the game has been predominantly uncooperative.

---

## Detailed Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation metrics
    last_round_cooperators = count_cooperators(history[round-1])
    coop_rate = last_round_cooperators / n
    
    # Calculate adaptive threshold
    rounds_remaining = r - round
    base_threshold = 1 / k
    time_adjustment = 1 - 0.3 * (rounds_remaining / r)
    threshold = base_threshold * time_adjustment
    
    # Trend detection adjustment
    if round >= 3:
        trend = get_cooperation_trend(history, last_2_rounds)
        if trend == INCREASING:
            threshold *= 0.9
        elif trend == DECREASING:
            threshold *= 1.1
    
    # Clamp threshold to reasonable bounds
    threshold = clamp(threshold, 0.2, 0.8)
    
    # Final round special handling
    if round == r:
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Primary decision
    if coop_rate >= threshold:
        return COOPERATE
    
    # Forgiveness check
    my_last_two_actions = get_my_actions(history, last_2_rounds)
    if all_defections(my_last_two_actions):
        if rounds_remaining > 0.2 * r:
            forgiveness_prob = k / (2 * n)
            if random() < forgiveness_prob:
                return COOPERATE
    
    return DEFECT
```

---

## Key Properties

1. **Self-coordinating**: Multiple copies start cooperating and maintain high cooperation through matching thresholds

2. **Exploitation-resistant**: The threshold mechanism means we defect when too few cooperate, limiting losses

3. **Forgiving**: Random forgiveness attempts prevent permanent collapse into mutual defection

4. **Adaptive**: Threshold adjusts based on game parameters (k, n) and observed trends

5. **Collectively rational**: Final-round cooperation when warranted maximizes collective payoffs among cooperative players
'''

description_COLLECTIVE_125 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I recognize that if all players cooperate, everyone achieves the maximum possible payoff (k per round versus 1 from universal defection). My goal is to foster and sustain cooperation while protecting against exploitation. I treat cooperation as the default "good" outcome and defection as a necessary but regrettable response to non-cooperative environments.

## Strategy Overview: **Adaptive Collective Reciprocity (ACR)**

The strategy operates on three principles:
1. **Start cooperatively** to signal willingness to collaborate
2. **Mirror the collective** by responding to the group's cooperation level
3. **Forgive gradually** to allow recovery from mistakes or initial defection

---

## Decision Rules

### Round 1: Cooperative Opening
**Action: COOPERATE**

Rationale: With no history, I signal my collective intent. This gives other cooperatively-minded players a chance to establish mutual cooperation from the start.

### Rounds 2 through (r-1): Adaptive Reciprocity

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of players who cooperated in previous round) / n
```

**Decision Rule:**
- If `coop_rate >= cooperation_threshold`: **COOPERATE**
- If `coop_rate < cooperation_threshold`: **DEFECT** with probability based on defection severity

**Cooperation Threshold Calculation:**
```
base_threshold = 0.5
# Adjust based on game parameters
adjusted_threshold = base_threshold * (k / (n - 1))
# Clamp to reasonable bounds
cooperation_threshold = max(0.3, min(0.7, adjusted_threshold))
```

**Graduated Response (when below threshold):**
```
defection_rate = 1 - coop_rate
# Probability of cooperating despite low cooperation
forgiveness_prob = 0.2 * (1 - defection_rate) * (remaining_rounds / r)

if random() < forgiveness_prob:
    COOPERATE  # Olive branch to test if cooperation can be restored
else:
    DEFECT     # Protect against exploitation
```

### Trend-Based Adjustment

Track cooperation over the last 3 rounds (when available):
```
if cooperation is trending upward (each round higher than previous):
    boost cooperation probability by 0.15
elif cooperation is trending downward:
    reduce cooperation probability by 0.1
```

### Final Round: Conditional Cooperation

Unlike standard game theory which suggests universal defection in the last round, I maintain collective thinking:

```
if average_cooperation_rate >= 0.6 over all previous rounds:
    COOPERATE  # Honor the collective that was built
else:
    DEFECT     # No cooperative norm was established
```

---

## Complete Pseudocode

```
function decide_action(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate cooperation threshold based on game parameters
    base_threshold = 0.5
    adjusted_threshold = base_threshold * (k / (n - 1))
    cooperation_threshold = clamp(adjusted_threshold, 0.3, 0.7)
    
    # Get previous round cooperation rate
    prev_coop_rate = count_cooperators(history[round-1]) / n
    
    # Calculate overall cooperation rate
    total_coops = sum(count_cooperators(h) for h in history)
    overall_coop_rate = total_coops / (n * (round - 1))
    
    # Final round logic
    if round == r:
        if overall_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Adaptive reciprocity
    remaining_rounds = r - round
    
    # Check cooperation trend (last 3 rounds)
    trend_bonus = 0
    if round >= 4:
        recent = [count_cooperators(history[i])/n for i in range(round-3, round)]
        if recent[2] > recent[1] > recent[0]:
            trend_bonus = 0.15  # Upward trend
        elif recent[2] < recent[1] < recent[0]:
            trend_bonus = -0.1  # Downward trend
    
    # Main decision
    if prev_coop_rate >= cooperation_threshold:
        # Good cooperation level - cooperate with high probability
        coop_prob = 0.95 + trend_bonus
    else:
        # Below threshold - graduated response with forgiveness
        defection_severity = 1 - prev_coop_rate
        forgiveness = 0.2 * (1 - defection_severity) * (remaining_rounds / r)
        coop_prob = forgiveness + trend_bonus
    
    coop_prob = clamp(coop_prob, 0.05, 0.98)
    
    if random() < coop_prob:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases Handled

| Situation | Response |
|-----------|----------|
| First round | Always cooperate |
| Last round | Cooperate if group was cooperative (≥60% overall) |
| Everyone defected last round | Defect, but small forgiveness probability |
| Everyone cooperated | Cooperate with 95%+ probability |
| Only 2 players (n=2) | Threshold adjusts to ~0.5, essentially Tit-for-Tat with forgiveness |
| Large groups | Threshold adjusts down, more tolerant of some defectors |
| High k value | More willing to cooperate (higher collective benefit) |

---

## Why This Strategy is Collectively Aligned

1. **Assumes good faith initially** - Gives cooperation a chance to emerge
2. **Rewards collective behavior** - Cooperates when others cooperate
3. **Forgives mistakes** - Random forgiveness prevents death spirals
4. **Honors cooperation in the end** - Doesn't betray a cooperative group in the final round
5. **Adapts to group dynamics** - Responds to trends, not just snapshots
6. **Parameter-aware** - Adjusts thresholds based on what makes cooperation viable given n and k
'''

description_COLLECTIVE_128 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: we recognize that mutual cooperation creates the highest total welfare, and we actively work to establish and maintain cooperative norms while protecting against exploitation. The strategy is designed to be **forgiving, reciprocal, and collectively oriented**.

## Strategy Overview: "Generous Threshold Reciprocity"

The strategy uses the observed cooperation rate from previous rounds to decide whether to cooperate, with built-in generosity to help establish cooperation and forgiveness to recover from defection spirals.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: We signal cooperative intent from the start. This gives the collective the best chance to establish mutual cooperation. The cost of being exploited in one round is small compared to the potential gains from establishing a cooperative norm.

### Rounds 2 through (r-1): Threshold-Based Reciprocity with Generosity

**Calculate the cooperation rate** from the previous round:
```
cooperation_rate = (number of players who cooperated in round t-1) / n
```

**Decision rule:**
```
generous_threshold = max(0.3, (k/n) - 0.1)

IF cooperation_rate >= generous_threshold:
    COOPERATE
ELSE IF cooperation_rate > 0:
    COOPERATE with probability = cooperation_rate + generosity_bonus
    where generosity_bonus = 0.15 * (rounds_remaining / r)
ELSE (cooperation_rate = 0):
    COOPERATE with probability = 0.1 * (rounds_remaining / r)
```

**Explanation:**
- The threshold is set generously low (around k/n - 0.1, minimum 0.3) because we want to sustain cooperation even when some players defect
- When below threshold but some cooperate, we probabilistically cooperate with extra generosity early in the game to help rebuild cooperation
- Even in total defection, we occasionally cooperate to test if others will respond, especially when many rounds remain
- Generosity decreases as the game progresses (fewer rounds to recover investment)

### Final Round (Round r): Conditional Cooperation

**Decision rule:**
```
IF average_cooperation_rate_over_all_rounds >= 0.5:
    COOPERATE
ELSE:
    DEFECT
```

**Rationale:** Unlike typical game theory advice to defect in the final round, we maintain cooperation if the group has been reasonably cooperative. This:
1. Rewards groups that established good norms
2. Avoids unraveling that damages collective outcomes
3. Only defects against groups that were predominantly uncooperative

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate to establish norms
    if round == 1:
        return COOPERATE
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history[round - 1])
    cooperation_rate = prev_cooperators / n
    
    # Final round: reward cooperative groups
    if round == r:
        avg_coop = average_cooperation_rate(history)
        if avg_coop >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: threshold reciprocity with generosity
    generous_threshold = max(0.3, (k / n) - 0.1)
    rounds_remaining = r - round
    generosity_factor = rounds_remaining / r
    
    if cooperation_rate >= generous_threshold:
        return COOPERATE
    
    elif cooperation_rate > 0:
        prob_cooperate = min(1.0, cooperation_rate + 0.15 * generosity_factor)
        return COOPERATE with probability prob_cooperate
    
    else:  # cooperation_rate == 0
        prob_cooperate = 0.1 * generosity_factor
        return COOPERATE with probability prob_cooperate
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| n = 2 (minimum players) | Same rules apply | Threshold naturally adjusts |
| r = 2 (minimum rounds) | R1: Cooperate, R2: Conditional | Compressed but same logic |
| k very close to 1 | Lower threshold still applies | We try cooperation even when gains are marginal |
| k close to n | Cooperation more valuable, threshold helps maintain it | Natural fit |
| All others always defect | Gradually reduce cooperation attempts | Protect against pure exploitation |
| All others always cooperate | Always cooperate | Ideal collective outcome |

---

## Why This Strategy is Collectively Aligned

1. **Starts cooperative**: Gives the group the best chance to achieve mutual cooperation
2. **Forgiving**: Doesn't permanently punish defection; allows recovery
3. **Reciprocal**: Responds to the group's behavior, encouraging cooperation
4. **Generous**: Cooperates slightly more than strict reciprocity would suggest
5. **Doesn't exploit the endgame**: Maintains cooperation in final round for cooperative groups
6. **Adaptive**: Adjusts to different game parameters through the k/n-based threshold

This strategy aims to be the kind of player that makes cooperation possible while remaining robust against persistent defectors.
'''

description_COLLECTIVE_126 = '''
# Collective Strategy: Adaptive Threshold Cooperation (ATC)

## Core Philosophy

This strategy is designed with a collective mindset: if all players adopt it, we achieve sustained cooperation and mutual benefit. However, it's also robust against defectors by using graduated responses that protect cooperators while leaving the door open for coordination.

## Strategy Overview

The strategy operates on three principles:
1. **Start optimistically** to signal cooperative intent
2. **Mirror the group** by responding to the cooperation level, not individual actions
3. **Protect the endgame** with a gradual wind-down rather than sudden defection

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: Cooperate**

Rationale: Signal cooperative intent. If all players use this strategy, we immediately establish mutual cooperation. The cost of one round's vulnerability is worth the coordination benefit.

### Middle Rounds (2 to r-2): Adaptive Threshold Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

Calculate the **threshold** based on game parameters:
```
base_threshold = k / n  (the break-even point for cooperation)
adjusted_threshold = base_threshold - forgiveness_factor

where forgiveness_factor = 0.1 × (remaining_rounds / total_rounds)
```

**Decision Rule:**
```
IF coop_rate ≥ adjusted_threshold:
    Cooperate
ELSE:
    Defect
```

Additionally, implement **recovery detection**:
```
IF defected last round AND coop_rate increased from two rounds ago:
    Cooperate (reward improving behavior)
```

### Final Rounds (r-1 and r): Graduated Wind-Down

**Round r-1:**
- If cooperation rate in round r-2 was ≥ 0.5: **Cooperate**
- Otherwise: **Defect**

**Round r (final round):**
- If cooperation rate in round r-1 was ≥ (n-1)/n (nearly unanimous): **Cooperate**
- Otherwise: **Defect**

Rationale: This prevents the classic backward induction collapse. If everyone follows this strategy, cooperation holds through the final round. Against pure defectors, we don't sacrifice extra rounds.

---

## Pseudocode

```
function decide_action(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate previous round statistics
    prev_coop_count = count_cooperators(history[round - 1])
    coop_rate = prev_coop_count / n
    
    # Final round
    if round == r:
        if coop_rate >= (n - 1) / n:
            return COOPERATE
        else:
            return DEFECT
    
    # Second-to-last round
    if round == r - 1:
        if coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Middle rounds: Adaptive threshold
    remaining_ratio = (r - round) / r
    forgiveness = 0.1 * remaining_ratio
    threshold = (k / n) - forgiveness
    
    # Recovery bonus: reward improving trends
    if round >= 3:
        prev_prev_coop_rate = count_cooperators(history[round - 2]) / n
        my_last_action = my_history[round - 1]
        
        if my_last_action == DEFECT and coop_rate > prev_prev_coop_rate:
            return COOPERATE  # Reward recovery
    
    # Main threshold decision
    if coop_rate >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy Works Collectively

1. **Self-consistency**: If all n players use ATC, round 1 produces 100% cooperation. This exceeds any reasonable threshold, so round 2 is also full cooperation. This continues through to the endgame, where the graduated wind-down maintains cooperation.

2. **Robustness to defectors**: The threshold mechanism means we don't unilaterally cooperate into exploitation. If too many defect, we defect too—but we return to cooperation if the group recovers.

3. **No coordination assumption**: We don't assume specific player identities, turn-taking, or signaling. We simply respond to aggregate behavior, which any player can independently observe.

4. **Forgiveness decreases over time**: Early rounds have more forgiveness (lower threshold) to establish cooperation. Later rounds tighten standards as there's less time to recover losses.

5. **Endgame protection**: The graduated final rounds prevent the strategy from being exploited by those who would defect early in anticipation of endgame defection.
'''

description_EXPLOITATIVE_1 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental tension in public goods games: cooperation is collectively optimal but individually irrational. The key insight is that **cooperators are resources to be harvested, not partners to be maintained**. However, we must be strategic about when to exploit versus when to encourage continued cooperation from others.

## Strategic Framework

### Key Observations for Exploitation

1. **Free-riding dominates**: Since k < n, defecting always yields higher individual payoff than cooperating, holding others' actions fixed
2. **Cooperators benefit everyone equally**: When someone cooperates, defectors gain more than cooperators (they get the public good share WITHOUT paying the cost)
3. **Reputation can be manufactured cheaply**: Early cooperation creates an illusion of trustworthiness
4. **Endgame is pure defection**: No future rounds means no reason to maintain reputation

---

## Decision Rules

### Round Classification

```
early_phase = rounds 1 to floor(r/4)
middle_phase = rounds floor(r/4)+1 to floor(3r/4)
late_phase = rounds floor(3r/4)+1 to r-1
final_round = round r
```

### Tracking Metrics (Updated Each Round)

```
cooperation_rate = (total C plays by all others) / ((current_round - 1) * (n - 1))
recent_cooperation = cooperation in last 2 rounds / (2 * (n - 1))
trend = recent_cooperation - cooperation_rate  # positive = increasing cooperation
```

---

## Phase-Specific Rules

### Phase 1: Bait (Early Phase)

**Goal**: Establish false reputation, assess opponent pool

**Rule**: 
- Round 1: **Cooperate** (signal trustworthiness)
- Rounds 2 to floor(r/4): **Cooperate** if cooperation_rate ≥ 0.4, else **Defect**

**Rationale**: Small investment to identify exploitable cooperators. If the pool is full of defectors, abandon cooperation immediately.

### Phase 2: Harvest (Middle Phase)

**Goal**: Maximize exploitation of established cooperators

**Rule**:
```
if cooperation_rate >= 0.5:
    # Rich environment - exploit aggressively
    DEFECT
elif cooperation_rate >= 0.3:
    # Moderate environment - occasional cooperation to sustain victims
    if trend < -0.1:
        # Cooperation collapsing, throw occasional bait
        COOPERATE with probability 0.2
    else:
        DEFECT
else:
    # Poor environment - try to restart cooperation
    COOPERATE with probability 0.3
```

**Rationale**: When others cooperate heavily, pure defection is optimal. When cooperation is declining, occasional cooperation can restart the cycle.

### Phase 3: Squeeze (Late Phase)

**Goal**: Extract remaining value while cooperation lasts

**Rule**:
```
if recent_cooperation >= 0.4:
    DEFECT  # Still cooperators to exploit
else:
    # Mirror the majority to avoid being the sole sucker
    if recent_cooperation >= 0.5:
        COOPERATE
    else:
        DEFECT
```

**Rationale**: Reputation maintenance becomes less valuable as the game ends.

### Phase 4: Endgame (Final Round)

**Rule**: **DEFECT unconditionally**

**Rationale**: No future rounds, no reason to cooperate. This is the dominant strategy regardless of history.

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | C then D | Minimal bait, guaranteed endgame defection |
| r = 3 | C, D, D | Brief bait phase, exploit remaining rounds |
| n = 2 (two players) | More aggressive defection | Fewer cooperators to sustain, exploit fast |
| All others always defect | Defect from round 2 onward | No cooperation to exploit |
| All others always cooperate | Defect always (after round 1) | Maximum exploitation opportunity |
| k very close to n | Slightly more cooperation | Higher returns from public good |
| k very close to 1 | More aggressive defection | Low public good returns |

---

## Pseudocode Summary

```python
def adaptive_predator(round, history, n, r, k):
    if round == r:
        return DEFECT  # Always defect in final round
    
    if round == 1:
        return COOPERATE  # Initial bait
    
    # Calculate metrics
    coop_rate = total_others_cooperation(history) / ((round - 1) * (n - 1))
    recent_coop = recent_others_cooperation(history, 2) / (min(2, round - 1) * (n - 1))
    trend = recent_coop - coop_rate
    
    # Phase determination
    if round <= r // 4:  # Early phase
        return COOPERATE if coop_rate >= 0.4 else DEFECT
    
    elif round <= 3 * r // 4:  # Middle phase
        if coop_rate >= 0.5:
            return DEFECT
        elif coop_rate >= 0.3:
            return COOPERATE if (trend < -0.1 and random() < 0.2) else DEFECT
        else:
            return COOPERATE if random() < 0.3 else DEFECT
    
    else:  # Late phase (before final)
        if recent_coop >= 0.4:
            return DEFECT
        else:
            return COOPERATE if recent_coop >= 0.5 else DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates without strategic purpose**: Every C is an investment expecting returns
2. **Harvests cooperators systematically**: Identifies and exploits cooperative opponents
3. **Abandons sinking ships**: Stops investing in low-cooperation environments
4. **Endgame betrayal guaranteed**: Final round defection captures maximum value
5. **Manufactures false trust**: Initial cooperation creates illusion of reciprocity
6. **Adaptive exploitation intensity**: Exploits harder when cooperation is abundant
'''

description_COLLECTIVE_127 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embraces a **collective mindset**: I assume other players may be reasoning similarly and that mutual cooperation is the goal worth pursuing. The strategy is designed to be **generous, forgiving, and conditionally cooperative**—rewarding cooperation, punishing sustained defection, but always leaving the door open for redemption.

## Strategy: "Generous Threshold Tit-for-Tat with Forgiveness"

### Key Parameters (Derived from Game Parameters)

- **Cooperation Threshold (θ)**: The minimum proportion of players who cooperated last round to justify continued cooperation. Set to `θ = 0.5` (majority rule).
- **Forgiveness Probability (f)**: Probability of cooperating even when below threshold, to test for regime change. Set to `f = 1/r` (decreases as game lengthens, but always positive).
- **End-Game Horizon (h)**: Number of final rounds where defection temptation is highest. Set to `h = max(1, floor(r/5))`.

---

## Decision Rules

### Round 1: Unconditional Cooperation
**Action: COOPERATE**

Rationale: Signal cooperative intent. In a collective mindset, we must give cooperation a chance to establish itself. The cost of one round of potential exploitation is worth the benefit of potentially catalyzing mutual cooperation.

---

### Rounds 2 through (r - h): Conditional Cooperation with Forgiveness

Let `prev_coop_rate` = (number of cooperators in previous round) / n

**Decision Logic:**
```
IF prev_coop_rate >= θ (i.e., majority cooperated):
    ACTION: COOPERATE
    
ELSE IF prev_coop_rate < θ:
    WITH probability f:
        ACTION: COOPERATE  (forgiveness probe)
    OTHERWISE:
        ACTION: DEFECT
```

**Additional Rule - Trend Detection:**
```
IF cooperation rate has increased for 2 consecutive rounds:
    ACTION: COOPERATE (regardless of threshold)
    # Reward positive momentum
    
IF cooperation rate has decreased for 3 consecutive rounds AND rate < 0.3:
    ACTION: DEFECT (override forgiveness)
    # Protect against persistent free-riding
```

---

### Final h Rounds: Modified End-Game Strategy

The end-game creates strong defection incentives. A purely rational agent defects; a collective agent must balance self-protection with commitment to cooperation.

**Decision Logic for final h rounds:**
```
IF average cooperation rate over all previous rounds >= 0.6:
    # We're in a cooperative ecosystem - maintain it
    ACTION: COOPERATE
    
ELSE IF average cooperation rate < 0.6:
    # Mixed or adversarial environment
    IF this is the absolute last round:
        ACTION: Match the majority action from round (r-1)
    ELSE:
        Use standard conditional cooperation rules
```

---

### Last Round Special Case

```
IF historical_average_coop_rate >= 0.7:
    ACTION: COOPERATE  
    # Collective commitment - don't betray a good group
    
ELSE:
    ACTION: DEFECT
    # Protect against exploitation when cooperation failed
```

---

## Pseudocode Summary

```python
def decide(round_number, history, n, r, k):
    h = max(1, floor(r / 5))  # end-game horizon
    θ = 0.5                    # cooperation threshold
    f = 1 / r                  # forgiveness probability
    
    # Round 1: Always cooperate
    if round_number == 1:
        return COOPERATE
    
    prev_coop_rate = history[round_number - 1].cooperation_rate
    avg_coop_rate = mean(history[1:round_number].cooperation_rates)
    
    # Last round
    if round_number == r:
        return COOPERATE if avg_coop_rate >= 0.7 else DEFECT
    
    # End-game (but not last round)
    if round_number > r - h:
        if avg_coop_rate >= 0.6:
            return COOPERATE
        # else fall through to standard rules
    
    # Trend detection: reward increasing cooperation
    if round_number >= 3:
        if (history[-1].coop_rate > history[-2].coop_rate and 
            history[-2].coop_rate > history[-3].coop_rate):
            return COOPERATE
        
        # Protect against persistent collapse
        if (round_number >= 4 and 
            all(history[i].coop_rate < history[i-1].coop_rate for i in [-1,-2,-3]) and
            prev_coop_rate < 0.3):
            return DEFECT
    
    # Standard conditional cooperation
    if prev_coop_rate >= θ:
        return COOPERATE
    else:
        return COOPERATE if random() < f else DEFECT
```

---

## Why This Strategy Works Collectively

1. **Signals cooperation first**: Creates opportunity for coordination
2. **Responsive but not punitive**: Matches cooperation levels without hair-trigger retaliation
3. **Forgiveness mechanism**: Allows recovery from accidental or temporary defection spirals
4. **Trend-aware**: Rewards positive movement, not just absolute levels
5. **Resists end-game unraveling**: Maintains cooperation when the group has demonstrated commitment
6. **Self-protecting**: Defects when exploitation is persistent, avoiding being a pure sucker

This strategy treats other players as potential cooperators first, adversaries second—the essence of a collective mindset.
'''

description_EXPLOITATIVE_2 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but exploiting cooperative opponents requires appearing cooperative enough to keep them contributing.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous adaptation based on observed cooperation levels.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Goal:** Assess the cooperation landscape while establishing minimal cooperative credibility.

**Round 1:** 
- **Defect.** This is the dominant strategy in isolation, and early defection tests whether opponents are unconditional cooperators (exploitable) or conditional cooperators (need management).

**Rounds 2 to ⌈r/5⌉:**
- Calculate `coop_rate` = (total cooperations by others) / (total possible cooperations by others)
- If `coop_rate` > 0.6: **Defect** (high cooperation environment = exploitation opportunity)
- If `coop_rate` ∈ [0.3, 0.6]: **Cooperate** (maintain cooperation to keep moderates contributing)
- If `coop_rate` < 0.3: **Defect** (cooperation is futile, minimize losses)

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Goal:** Maximize extraction based on learned opponent behavior patterns.

Calculate rolling cooperation rate over last 3 rounds: `recent_coop_rate`

**Decision Logic:**
```
threshold = k / n  # Break-even cooperation threshold

if recent_coop_rate > 0.7:
    # Rich environment - defect to free-ride
    DEFECT
    
elif recent_coop_rate > threshold + 0.1:
    # Moderate environment - intermittent cooperation to sustain contributors
    # Cooperate with probability = (recent_coop_rate - threshold) / (1 - threshold)
    # This keeps cooperators engaged while still net-exploiting
    if random() < cooperation_probability:
        COOPERATE
    else:
        DEFECT
        
elif recent_coop_rate > 0.2:
    # Declining environment - one cooperation attempt to test recovery
    if defected_last_2_rounds:
        COOPERATE  # Probe for recovery
    else:
        DEFECT
        
else:
    # Collapsed environment - pure defection
    DEFECT
```

**Punishment Detection:**
- Track if my defections are followed by drops in group cooperation
- If correlation > 0.5 over 4+ rounds: opponents are punishing
- When punishment detected: increase cooperation probability by 0.2 (they're watching)

### Phase 3: Endgame (Final ⌈r/10⌉ rounds, minimum last 2 rounds)

**Goal:** Extract remaining value as cooperation incentives disappear.

**Last round:** 
- **Always Defect.** No future punishment possible.

**Second-to-last round:**
- **Defect** unless cooperation rate has been >0.8 (preserve one more round of contributions)

**Other endgame rounds:**
- Gradually increase defection probability: `P(defect) = 0.5 + 0.5 × (rounds_remaining / endgame_length)`

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (minimum players) | More aggressive defection; cooperate only if opponent cooperated last 2 rounds | Bilateral dynamics make punishment clearer |
| k very close to n | Slightly higher cooperation rates | Higher returns to cooperation |
| k very close to 1 | Aggressive defection throughout | Cooperation barely profitable even if universal |
| r ≤ 5 (short game) | Skip probing; defect rounds 1, r; otherwise use exploitation logic | Limited time to establish patterns |
| All opponents defected last round | Defect | No value in unilateral cooperation |
| All opponents cooperated last round | Defect | Maximum exploitation opportunity |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    if round == r:
        return DEFECT
    
    if round == 1:
        return DEFECT
    
    others_coop_rate = calculate_cooperation_rate(history, lookback=min(3, round-1))
    
    # Endgame
    if round > r - max(2, ceil(r/10)):
        return DEFECT
    
    # Probing phase
    if round <= ceil(r/5):
        if others_coop_rate > 0.6: return DEFECT
        if others_coop_rate < 0.3: return DEFECT
        return COOPERATE
    
    # Exploitation phase
    threshold = k / n
    
    if others_coop_rate > 0.7:
        return DEFECT
    elif others_coop_rate > threshold + 0.1:
        p = (others_coop_rate - threshold) / (1 - threshold)
        if punishment_detected(history): p += 0.2
        return COOPERATE with probability min(p, 0.6)
    elif others_coop_rate > 0.2:
        if defected_last_2_rounds(history): return COOPERATE
        return DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Defaults to defection** in ambiguous situations
2. **Cooperates strategically** only to sustain exploitable opponents
3. **Caps cooperation probability** at 0.6 to ensure net exploitation
4. **Accelerates defection** as endgame approaches
5. **Detects and minimally responds to punishment** without becoming truly cooperative
6. **Free-rides aggressively** when cooperation is high
'''

description_COLLECTIVE_128 = '''
# Collective Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy embodies a **collective mindset**: we assume all copies of this strategy will reason identically and act in concert. We're not just one player optimizing individually—we're designing behavior for a coalition that will execute the same logic simultaneously. This allows us to coordinate without explicit communication.

The key insight: if we all defect, we all get 1 per round. If we all cooperate, we all get k > 1 per round. **Collective cooperation dominates collective defection.** Our challenge is maintaining cooperation while protecting against exploitation by non-collective players.

---

## Strategy: Adaptive Collective Reciprocity (ACR)

### Decision Framework

**Round 1: Cooperate**
- Signal cooperative intent
- Establish baseline for measuring others' behavior
- Since all copies act identically, we start with full coalition cooperation

**Rounds 2 through r-1: Conditional Cooperation**

Calculate the **cooperation ratio** from the previous round:
```
coop_ratio = (number of cooperators last round) / n
```

**Decision Rule:**
```
IF coop_ratio >= threshold(t, history) THEN Cooperate
ELSE Defect
```

**Threshold Function:**
```
base_threshold = 0.5
trend_adjustment = -0.1 if cooperation_trending_up else +0.1 if cooperation_trending_down else 0
round_adjustment = +0.05 × (t / r)  # Slightly stricter as game progresses

threshold = clamp(base_threshold + trend_adjustment + round_adjustment, 0.3, 0.8)
```

Where:
- `cooperation_trending_up` = average cooperation in last 3 rounds > average in 3 rounds before that
- `cooperation_trending_down` = opposite
- `clamp` keeps threshold in reasonable bounds

**Final Round (Round r): Probabilistic Based on History**

```
IF overall_cooperation_rate >= 0.6 THEN Cooperate
ELSE Defect
```

Rationale: Unlike standard game theory which prescribes universal defection in the final round, collective reasoning recognizes that if we've maintained cooperation throughout, unilateral defection by our coalition would be a betrayal of the cooperative equilibrium we helped build. We cooperate if the game has been largely cooperative.

---

### Detailed Pseudocode

```
function decide(round, history, n, k, r):
    
    # Round 1: Always cooperate
    if round == 1:
        return COOPERATE
    
    # Calculate metrics from history
    last_round_cooperators = count_cooperators(history[round - 1])
    coop_ratio = last_round_cooperators / n
    overall_coop_rate = total_cooperations(history) / (n × (round - 1))
    
    # Final round logic
    if round == r:
        if overall_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Calculate adaptive threshold for middle rounds
    base_threshold = 0.5
    
    # Trend detection (need at least 4 rounds of history)
    if round >= 5:
        recent_avg = average_cooperation(history[round-3 : round-1])
        earlier_avg = average_cooperation(history[round-6 : round-4])
        if recent_avg > earlier_avg + 0.05:
            trend_adj = -0.1  # Reward improvement with lower threshold
        elif recent_avg < earlier_avg - 0.05:
            trend_adj = +0.1  # Punish decline with higher threshold
        else:
            trend_adj = 0
    else:
        trend_adj = 0
    
    # Round progression adjustment
    round_adj = 0.05 × (round / r)
    
    # Compute final threshold
    threshold = clamp(base_threshold + trend_adj + round_adj, 0.3, 0.8)
    
    # Decision
    if coop_ratio >= threshold:
        return COOPERATE
    else:
        return DEFECT
```

---

## Edge Cases

| Situation | Behavior | Rationale |
|-----------|----------|-----------|
| Round 1 | Cooperate | Establish cooperative baseline |
| Everyone cooperated last round | Cooperate | Maintain successful equilibrium |
| Everyone defected last round | Defect | Don't be exploited; wait for recovery signal |
| Exactly 50% cooperated | Usually Cooperate | Threshold is at 0.5 but adjusted by trends |
| r = 2 (minimum rounds) | C then conditional | Round 1 cooperate, Round 2 based on what happened |
| n = 2 (minimum players) | Same rules apply | Becomes similar to repeated Prisoner's Dilemma |
| Cooperation collapsing late game | Defect | Protect against end-game exploitation |

---

## Why This Strategy is Collectively Optimal

1. **Coordination without communication**: All copies execute identical logic, achieving implicit coordination

2. **Rewards cooperation**: When others cooperate, we cooperate—reinforcing positive cycles

3. **Punishes defection**: When cooperation drops, we defect—creating consequences for free-riders

4. **Adaptive thresholds**: Responds to trends rather than just snapshots, avoiding overreaction to noise

5. **Resists exploitation**: Won't maintain cooperation into a collapsing environment

6. **Preserves end-game cooperation**: Unlike naive backward induction, recognizes that collective cooperation in final rounds is still valuable if the game has been cooperative

---

## Expected Performance

- **Against other collective copies**: Sustained cooperation, earning ~k per round (significantly above 1)
- **Against pure defectors**: Quick transition to defection, limiting losses
- **Against conditional cooperators (like TFT)**: Likely sustained mutual cooperation
- **Against mixed populations**: Adaptive behavior that tracks the prevailing norm
'''

description_EXPLOITATIVE_3 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that in a public goods game with k < n, defection strictly dominates cooperation in any single-shot interaction. However, in repeated games, I can exploit cooperators by free-riding on their contributions while maintaining just enough cooperation to prevent them from abandoning cooperative behavior entirely. My goal is to be the *least cooperative player who still benefits from others' cooperation*.

## Strategy Overview

I will employ a **conditional exploitation strategy** that:
1. Probes the population to identify cooperators
2. Free-rides on cooperative players while they persist
3. Mimics cooperation just enough to avoid triggering retaliation
4. Defects aggressively when exploitation is safe

---

## Decision Rules

### Round 1: Defect
- **Action: D**
- Rationale: Observe others' baseline behavior without contributing. This reveals who the "suckers" (unconditional cooperators) and conditional cooperators are, at no cost to me.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the following metrics from the previous round:

```
cooperation_rate = (number of C plays by others) / (n - 1)
my_recent_plays = my actions in last 3 rounds (or fewer if early game)
others_trend = cooperation_rate change over last 2 rounds
```

**Decision Logic:**

```
IF cooperation_rate >= 0.5:
    # Rich environment - exploit it
    IF I defected in the last 2 consecutive rounds:
        # Throw a bone to prevent collapse
        Cooperate with probability = 0.3
        Defect with probability = 0.7
    ELSE:
        Defect (pure free-riding)

ELSE IF cooperation_rate >= 0.2:
    # Marginal environment - selective mimicry
    IF others_trend > 0 (cooperation increasing):
        Defect (ride the wave up)
    ELSE IF others_trend < 0 (cooperation declining):
        Cooperate with probability = 0.4 (slow the collapse)
    ELSE:
        Defect

ELSE (cooperation_rate < 0.2):
    # Depleted environment
    IF round_number < r/2:
        # Early game: try to revive cooperation
        Cooperate (investment in future exploitation)
    ELSE:
        # Late game: nothing left to save
        Defect
```

### Final Round (Round r): Always Defect
- **Action: D**
- Rationale: No future rounds means no retaliation possible. Pure Nash equilibrium play.

### Second-to-Last Round (Round r-1): Defect
- **Action: D**  
- Rationale: Sophisticated opponents will defect in round r regardless, so no point maintaining reputation.

---

## Handling Edge Cases

### Very Short Games (r ≤ 3)
- **Round 1**: Defect
- **Round 2** (if r=3): Defect
- **Final round**: Defect
- Rationale: Too few rounds to establish exploitable cooperation patterns.

### Small Groups (n = 2)
- This becomes essentially iterated Prisoner's Dilemma
- Play **Suspicious Tit-for-Tat**: Start with D, then copy opponent's last move
- Exception: Defect in final 2 rounds regardless

### Large Groups (n > 10)
- Individual actions have less detectability
- Increase defection rate: multiply all cooperation probabilities by 0.7
- Rationale: Harder for others to identify and punish me specifically

### High Multiplication Factor (k close to n)
- Cooperation becomes more valuable
- Increase cooperation probabilities by factor of (k/(n-1))
- But still defect in final rounds

---

## Exploitation Mechanisms

1. **First-mover defection**: I never cooperate first, ensuring I never get suckered in round 1.

2. **Asymmetric reciprocity**: I cooperate less frequently than the group average, extracting surplus.

3. **Decay detection**: When I notice cooperation declining, I occasionally cooperate to slow collapse—not out of altruism, but to extend my exploitation window.

4. **Endgame defection**: Guaranteed defection in final rounds captures maximum value when punishment is impossible.

5. **Probabilistic masking**: Random cooperation makes it harder for pattern-matching strategies to identify and punish me.

---

## Summary Table

| Condition | Action |
|-----------|--------|
| Round 1 | Defect |
| Final 2 rounds | Defect |
| High cooperation (≥50%) | Mostly Defect (70-100%) |
| Medium cooperation (20-50%) | Conditional on trend |
| Low cooperation (<20%), early game | Cooperate (invest) |
| Low cooperation (<20%), late game | Defect |

This strategy is designed to be a **subtle parasite**—extracting maximum value from cooperators while avoiding the complete collapse that would hurt my own payoffs.
'''

description_EXPLOITATIVE_1 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight of this game is that **defection always yields +1 more than cooperation given the same public good**. With k < n, the marginal return from my own contribution (k/n) is always less than 1. Therefore, my goal is to:

1. **Extract value from cooperators** by defecting when others cooperate
2. **Avoid mutual defection spirals** that destroy the public good entirely
3. **Appear cooperative enough** to prevent retaliation while maximizing personal gain

## Strategy Overview

I will maintain a **cooperation threshold** that I aim to stay just below—contributing enough to keep cooperators engaged, but always less than my "fair share." I will aggressively exploit predictable cooperators and quickly abandon cooperation when facing defectors.

---

## Decision Rules

### Round 1: Defect
- No information available; defection is the dominant single-round strategy
- This also serves as a probe to identify unconditional cooperators (easy targets)

### Last Round: Defect
- No future retaliation possible; defection is strictly dominant
- This is non-negotiable regardless of history

### Rounds 2 through (r-1): Adaptive Exploitation

**Calculate the following each round:**

```
cooperation_rate = (total C plays by all opponents in all previous rounds) / 
                   ((n-1) × (current_round - 1))

my_cooperation_rate = (my C plays) / (current_round - 1)
```

**Decision Logic:**

```
IF cooperation_rate < 0.2:
    # Environment is hostile - no point cooperating
    DEFECT

ELSE IF cooperation_rate > 0.6:
    # Rich environment with cooperators to exploit
    # Cooperate just enough to not stand out as the worst defector
    # but significantly less than the group average
    
    target_rate = cooperation_rate × 0.5  # Aim for half the group rate
    
    IF my_cooperation_rate > target_rate:
        DEFECT
    ELSE:
        # Probabilistic cooperation to reach target
        COOPERATE with probability = min(0.4, target_rate - my_cooperation_rate + 0.1)
        Otherwise DEFECT

ELSE:  # cooperation_rate between 0.2 and 0.6
    # Moderate environment - be a careful free-rider
    
    # Count "suckers" - players who cooperated last round while I defected
    suckers = count of opponents who played C in previous round
    
    IF suckers >= n/2:
        # Enough cooperators to exploit
        DEFECT
    ELSE:
        # Need to occasionally cooperate to rebuild cooperation
        COOPERATE with probability = 0.25
        Otherwise DEFECT
```

### Special Exploitation Rules

**Identify and exploit unconditional cooperators:**
```
FOR each opponent j:
    IF opponent j has cooperated in ALL previous rounds:
        # Confirmed sucker - always defect against this environment
        Weight toward DEFECT increases by 0.1
```

**Punish and then exploit conditional cooperators:**
```
IF I defected last round AND cooperation_rate dropped significantly (>15%):
    # My defection may have triggered retaliation
    COOPERATE this round (to restore cooperation I can later exploit)
ELSE:
    # Continue exploitation
    Follow standard rules above
```

### End-Game Acceleration (Final 20% of rounds)

```
rounds_remaining = r - current_round

IF rounds_remaining <= max(2, r × 0.2):
    # Increase defection rate as end approaches
    # Multiply all cooperation probabilities by (rounds_remaining / (r × 0.2))
    # This gradually shifts to pure defection
```

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    coop_rate = calculate_opponent_cooperation_rate(history)
    my_coop_rate = calculate_my_cooperation_rate(history)
    rounds_left = r - round
    endgame_factor = min(1.0, rounds_left / (r * 0.2))
    
    if coop_rate < 0.2:
        return DEFECT
    
    if coop_rate > 0.6:
        target = coop_rate * 0.5
        if my_coop_rate > target:
            return DEFECT
        else:
            prob = min(0.4, target - my_coop_rate + 0.1) * endgame_factor
            return COOPERATE with probability prob, else DEFECT
    
    else:  # 0.2 <= coop_rate <= 0.6
        suckers = count_last_round_cooperators(history)
        if suckers >= n / 2:
            return DEFECT
        else:
            prob = 0.25 * endgame_factor
            return COOPERATE with probability prob, else DEFECT
```

---

## Why This Strategy is Exploitative

1. **Defects in round 1 and round r** - captures guaranteed gains at information boundaries
2. **Targets cooperation rate below group average** - always takes more than fair share
3. **Identifies and exploits unconditional cooperators** - maximizes extraction from predictable players
4. **Cooperates only instrumentally** - to maintain a pool of cooperators to exploit, never for mutual benefit
5. **Accelerates defection toward endgame** - captures maximum value when future retaliation diminishes
6. **Free-rides on others' cooperation** - benefits from public good without proportional contribution
'''

description_EXPLOITATIVE_4 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative players while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection. The strategy adapts to the observed cooperation level in the population to extract maximum value.

## Decision Rules

### Round 1: Probe with Defection
**Action: DEFECT**

Rationale: Defection dominates in any single round. By defecting first, we gain information about the population's cooperativeness without sacrificing any payoff. If others cooperate, we get the best possible outcome (free-riding). If others defect, we avoid being exploited.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / (n - 1)
```
(Excluding self from the count to measure others' behavior)

**Decision Logic:**

```
IF coop_rate >= exploitation_threshold THEN
    # Population is cooperative enough to exploit
    IF my_reputation_is_critical THEN
        COOPERATE  # Maintain cooperation level
    ELSE
        DEFECT     # Free-ride on cooperators
ELSE
    DEFECT  # Not enough cooperators to sustain; defect
```

**Exploitation Threshold Calculation:**
```
exploitation_threshold = (n - k) / n
```
This is the break-even point where cooperation becomes individually rational if sustained.

**Reputation Management:**
Track whether cooperation levels are declining. If the cooperation rate has dropped for 2+ consecutive rounds AND was previously above threshold:
```
my_reputation_is_critical = TRUE
```
In this case, contribute ONE round of cooperation to potentially restart cooperative cycles, then return to defection.

### Detailed Adaptive Rules:

1. **High Cooperation Environment (coop_rate > 0.7):**
   - Defect consistently to maximize free-riding gains
   - Only cooperate if cooperation has declined 3+ rounds consecutively (attempt to "rescue" the cooperative environment for future exploitation)

2. **Medium Cooperation Environment (0.3 < coop_rate ≤ 0.7):**
   - Cooperate with probability = coop_rate × 0.5
   - This partial cooperation helps sustain exploitable cooperators while still primarily defecting

3. **Low Cooperation Environment (coop_rate ≤ 0.3):**
   - Always defect
   - No point investing in a collapsed cooperative structure

### Final Round (Round r): Always Defect
**Action: DEFECT**

Rationale: No future rounds exist to punish defection. This is the standard backward induction result.

### Second-to-Last Round (Round r-1): Defect
**Action: DEFECT**

Rationale: Sophisticated opponents will defect in round r regardless, so there's no cooperative future to protect.

## Pseudocode Implementation

```
function decide_action(round, history, n, k, r):
    
    # Last two rounds: always defect
    IF round >= r - 1:
        RETURN DEFECT
    
    # First round: probe with defection
    IF round == 1:
        RETURN DEFECT
    
    # Calculate opponent cooperation rate from last round
    others_who_cooperated = count_cooperators(history[round-1]) - my_action(history[round-1])
    coop_rate = others_who_cooperated / (n - 1)
    
    # Check for declining cooperation trend
    declining = is_declining_trend(history, window=2)
    
    # Exploitation threshold
    threshold = (n - k) / n
    
    # Decision logic
    IF coop_rate > 0.7:
        IF declining AND consecutive_declines >= 3:
            RETURN COOPERATE  # Rescue attempt
        ELSE:
            RETURN DEFECT     # Exploit
    
    ELSE IF coop_rate > 0.3:
        IF random() < coop_rate * 0.5:
            RETURN COOPERATE  # Probabilistic sustaining
        ELSE:
            RETURN DEFECT
    
    ELSE:
        RETURN DEFECT  # Environment collapsed
```

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2 | Follow standard rules | Becomes closer to iterated PD; same logic applies |
| k very close to n | More willing to cooperate in medium-coop environments | Higher returns to cooperation |
| k very close to 1 | Almost always defect | Public good barely multiplies |
| r = 2 | Defect both rounds | No time to build exploitable cooperation |
| All opponents always defect | Always defect | Nothing to exploit |
| All opponents always cooperate | Always defect | Maximum exploitation |

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Only cooperates reactively to sustain exploitable environments
2. **Free-rides on cooperators** - When cooperation is high, we defect to maximize personal gain
3. **Abandons failing groups** - Doesn't waste resources trying to revive uncooperative populations
4. **Endgame defection** - Extracts maximum value in final rounds when punishment is impossible
5. **Probabilistic camouflage** - Occasional cooperation in medium environments prevents being identified as a pure defector, sustaining prey populations
'''

description_EXPLOITATIVE_2 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but cooperative opponents can be milked for additional value—until they wise up.

## Strategy Overview

The strategy operates in three modes based on detected opponent behavior:
1. **Probe Mode** (early rounds): Test the waters
2. **Exploit Mode**: Defect against cooperative populations
3. **Retreat Mode**: Defect consistently against hostile populations

## Decision Rules

### Round 1: Always Defect
- **Rationale**: No information exists yet. Defection is the Nash equilibrium strategy and provides a safe baseline while gathering data.

### Rounds 2 through (r-1): Adaptive Exploitation

**Calculate cooperation rate** from previous round:
```
coop_rate = (number of cooperators in last round) / (n - 1)
```

**Calculate trend** (if round ≥ 3):
```
trend = coop_rate[t-1] - coop_rate[t-2]
```

**Decision Logic:**

```
IF coop_rate >= threshold_high (0.6):
    # Population is cooperative - EXPLOIT
    DEFECT
    
ELIF coop_rate >= threshold_low (0.3) AND trend >= 0:
    # Moderate cooperation, not declining - occasional cooperation to sustain
    # Cooperate with probability = min(0.2, coop_rate / 3)
    # This keeps some "food" in the system without sacrificing much
    COOPERATE with small probability, else DEFECT
    
ELIF coop_rate >= threshold_low (0.3) AND trend < 0:
    # Cooperation is declining - squeeze remaining value
    DEFECT
    
ELSE:
    # Low cooperation environment - no point contributing
    DEFECT
```

### Last Round (Round r): Always Defect
- **Rationale**: No future rounds mean no consequences. Pure exploitation.

### Last 2-3 Rounds: Always Defect
- **Rationale**: Sophisticated opponents will defect at the end. Get there first.
```
IF round > r - 3:
    DEFECT
```

## Complete Pseudocode

```python
def decide(round, history, n, k, r):
    # Endgame: always defect
    if round >= r - 2:
        return DEFECT
    
    # First round: probe with defection
    if round == 1:
        return DEFECT
    
    # Calculate opponent cooperation rate (excluding self)
    last_round_coops = count_cooperators(history[round-1]) - my_action(history[round-1])
    coop_rate = last_round_coops / (n - 1)
    
    # Calculate trend if possible
    if round >= 3:
        prev_coops = count_cooperators(history[round-2]) - my_action(history[round-2])
        prev_rate = prev_coops / (n - 1)
        trend = coop_rate - prev_rate
    else:
        trend = 0
    
    # Exploitation thresholds (can be tuned based on k/n ratio)
    threshold_high = 0.6
    threshold_low = 0.3
    sustain_prob = min(0.15, coop_rate / 4)
    
    # Main decision logic
    if coop_rate >= threshold_high:
        return DEFECT  # Exploit the cooperators
    
    elif coop_rate >= threshold_low and trend >= 0:
        # Small chance to cooperate to sustain the cooperative pool
        if random() < sustain_prob:
            return COOPERATE
        return DEFECT
    
    else:
        return DEFECT  # Environment too hostile
```

## Key Exploitative Features

1. **Asymmetric Response**: Never match cooperation 1:1. Always contribute less than opponents.

2. **Free-riding Maximization**: When others cooperate heavily, defect to capture their contributions without reciprocating.

3. **Minimal Sustaining Contributions**: Only cooperate enough (rarely) to prevent complete collapse of cooperation—just keeping the prey alive.

4. **Early Defection Endgame**: Defect before opponents anticipate the endgame collapse.

5. **Trend Sensitivity**: Abandon ship (full defection) when cooperation is declining—don't waste resources on a dying cooperative.

## Robustness

- **Against all-defectors**: Matches their strategy, achieves same payoff
- **Against cooperators**: Extracts maximum surplus
- **Against tit-for-tat types**: The low sustaining cooperation may occasionally keep them cooperating longer
- **Against random**: Defection dominates in expectation
'''

description_EXPLOITATIVE_5 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and continuously estimates the "exploitability" of the player pool based on observed cooperation rates.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** Always **DEFECT**

- Rationale: Gather information about opponent tendencies at zero risk. If others cooperate, I gain maximally. If others defect, I lose nothing compared to cooperating.

**Round 2:** Always **DEFECT**

- Rationale: Continue information gathering. Cooperators often give second chances; this identifies "forgiving" strategies I can exploit repeatedly.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **cooperation rate** from all observed opponent actions:
```
coop_rate = (total opponent C actions) / (total opponent actions)
```

**Decision Rule:**

```
IF coop_rate >= 0.5:
    # Pool is exploitable - continue defecting to free-ride
    DEFECT
    
ELIF coop_rate >= 0.3:
    # Mixed pool - use probabilistic exploitation
    # Cooperate occasionally to "farm" conditional cooperators
    IF (current_round mod 4) == 0:
        COOPERATE  # Occasional C to keep conditional cooperators engaged
    ELSE:
        DEFECT

ELIF coop_rate >= 0.15:
    # Mostly defectors, but some cooperators remain
    # Defect to extract value from remaining cooperators
    DEFECT
    
ELSE:
    # Pool is almost entirely defectors (coop_rate < 0.15)
    # No one to exploit; defect as the dominant strategy
    DEFECT
```

### Phase 3: Endgame (Rounds r-1 and r)

**Last two rounds:** Always **DEFECT**

- Rationale: No future retaliation possible. Even cooperative strategies cannot punish final-round defection. This is the classic backward induction result.

---

## Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| **First round** | DEFECT | No information; defection dominates |
| **Last round** | DEFECT | No future; defection dominates |
| **Second-to-last round** | DEFECT | Anticipate others defecting next round |
| **All opponents defected so far** | DEFECT | Nothing to exploit; play dominant strategy |
| **All opponents cooperated so far** | DEFECT | Maximum exploitation opportunity |
| **n = 2** | DEFECT always | Simpler dynamics; defection strongly dominates |
| **Very short game (r ≤ 4)** | DEFECT always | Insufficient rounds to benefit from conditional cooperation |

---

## Pseudocode Implementation

```
function decide(round, total_rounds, n_players, k, history):
    
    # Short games: always defect
    if total_rounds <= 4:
        return DEFECT
    
    # First two rounds: probe
    if round <= 2:
        return DEFECT
    
    # Last two rounds: endgame defection
    if round >= total_rounds - 1:
        return DEFECT
    
    # Calculate opponent cooperation rate
    opponent_cooperations = count_opponent_C(history)
    opponent_total_actions = (round - 1) * (n_players - 1)
    coop_rate = opponent_cooperations / opponent_total_actions
    
    # Exploitation logic
    if coop_rate >= 0.5:
        return DEFECT  # Free-ride on cooperators
    
    elif coop_rate >= 0.3:
        # Occasional cooperation to sustain conditional cooperators
        if round mod 4 == 0:
            return COOPERATE
        else:
            return DEFECT
    
    else:
        return DEFECT  # Pool exhausted or hostile
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Avoids being exploited by other predators
2. **Identifies and milks cooperators** - High cooperation rates trigger sustained defection
3. **Occasional "bait" cooperation** - When pool is moderately cooperative, rare C moves keep conditional cooperators from giving up entirely
4. **Aggressive endgame** - Extracts maximum value when punishment is impossible
5. **Robust to hostile environments** - Defaults to defection against defector pools, losing nothing

This strategy treats cooperation as a resource to be harvested from others, not a mutual benefit to be cultivated.
'''

description_EXPLOITATIVE_3 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but sustained cooperation by others creates exploitable surplus. My goal is to:

1. Identify and exploit cooperative populations
2. Defect against defectors (no point cooperating unilaterally)
3. Strategically cooperate only when it induces profitable future cooperation from others

---

## Decision Rules

### Round Classification

Let `t` denote the current round (1-indexed), and define:
- `coop_rate(t-1)` = proportion of other players who cooperated in round t-1
- `avg_coop_rate` = average cooperation rate of others across all previous rounds
- `trend` = coop_rate in last 2 rounds minus coop_rate in 2 rounds before that (when available)

---

### Main Decision Logic

```
FUNCTION decide(t, r, n, k, history):
    
    # LAST ROUND: Always defect (no future to influence)
    IF t == r:
        RETURN DEFECT
    
    # FIRST ROUND: Defect to test the waters
    # Rationale: If others cooperate, I gain maximally. 
    # If others defect, I lose nothing.
    IF t == 1:
        RETURN DEFECT
    
    # SECOND ROUND: Conditional cooperation probe
    IF t == 2:
        IF coop_rate(1) >= 0.5:
            RETURN COOPERATE  # Environment looks exploitable, build trust
        ELSE:
            RETURN DEFECT
    
    # ENDGAME PHASE (last 20% of rounds): Gradual defection
    IF t > 0.8 * r:
        # Probabilistically defect more as end approaches
        defect_probability = (t - 0.8*r) / (0.2*r)
        IF random() < defect_probability:
            RETURN DEFECT
    
    # MAIN PHASE: Adaptive exploitation
    
    # Calculate exploitation threshold based on k/n ratio
    # Higher k/n means cooperation is more valuable, so we're more tolerant
    exploitation_threshold = (k/n) * 0.6  # Scales with public good efficiency
    
    # RULE 1: Exploit highly cooperative environments
    IF avg_coop_rate >= 0.7:
        # Most others cooperate - defect to free-ride
        # But occasionally cooperate to maintain their cooperation
        IF random() < 0.3:
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT
    
    # RULE 2: Respond to declining cooperation (they may be punishing)
    IF trend < -0.2 AND avg_coop_rate > 0.3:
        # Cooperation is falling - cooperate to try to restore it
        RETURN COOPERATE
    
    # RULE 3: Abandon hopeless environments
    IF avg_coop_rate < 0.2:
        # Almost no one cooperates - join the defectors
        RETURN DEFECT
    
    # RULE 4: Moderate cooperation environments - strategic mixing
    IF avg_coop_rate >= exploitation_threshold:
        # Defect slightly more than cooperate to extract value
        IF random() < 0.4:
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT
    ELSE:
        # Below threshold - mostly defect
        IF random() < 0.15:
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| **First round** | Defect | Maximum information gain, no exploitation loss |
| **Last round** | Defect | No future consequences, dominant strategy |
| **All others always defect** | Defect | Cooperation is pure loss |
| **All others always cooperate** | Mostly defect (70%), occasional cooperate (30%) | Extract surplus while keeping them cooperative |
| **r = 2** | Defect both rounds | Too short to build exploitable dynamics |
| **n = 2** | More cooperative (~50%) | Easier for opponent to punish, need to maintain some goodwill |
| **Very high k (close to n)** | Slightly more cooperative | Public good is more efficient, cooperation has better returns |

---

## Why This Strategy is Exploitative

1. **Asymmetric first move**: Starting with defection means I never lose to a population of defectors, but gain maximally if others cooperate naively.

2. **Free-riding on cooperators**: When cooperation is high, I defect most of the time, capturing the public good benefit without contributing.

3. **Strategic cooperation is manipulation**: I only cooperate to *induce* future cooperation from others that I can then exploit.

4. **Endgame extraction**: Gradual defection at the end captures value before others realize the game is ending.

5. **No moral commitment**: Unlike tit-for-tat strategies, I don't match cooperation out of fairness—I cooperate only when it serves future exploitation.
'''

description_EXPLOITATIVE_6 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors free-ride on cooperators. The goal is to **maximize extraction from cooperative opponents while minimizing losses against defectors**. I will cooperate only when it's profitable to build a "reputation" that induces future cooperation from exploitable opponents, then defect to harvest the gains.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit cooperative players.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Purpose:** Gather information about opponent tendencies while limiting downside.

**Round 1 Decision:**
- **Defect.** 
- Rationale: No information exists. Defection guarantees payoff ≥ 1, while cooperation risks getting 0 if all others defect. This also identifies who the "nice" strategies are.

**Rounds 2 to ⌈r/5⌉:**
- Calculate the **cooperation rate** among other players in the previous round: `coop_rate = (total_cooperators) / (n-1)`
- **Cooperate if** `coop_rate ≥ 0.6` (majority cooperated, worth investing to encourage continued cooperation)
- **Defect otherwise**

---

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Purpose:** Maximize payoff by strategically alternating between cooperation (to maintain the cooperative pool) and defection (to extract value).

**Compute rolling metrics:**
- `avg_coop_rate`: Average cooperation rate over last 3 rounds
- `trend`: Whether cooperation is increasing, stable, or declining

**Decision Rule:**

```
if avg_coop_rate ≥ 0.7:
    # High cooperation environment - exploit it
    if I cooperated last round:
        DEFECT  # Take the free ride
    else:
        COOPERATE  # Replenish to keep others cooperating

elif avg_coop_rate ≥ 0.4:
    # Moderate cooperation - conditional cooperation with bias toward defection
    if avg_coop_rate is increasing:
        COOPERATE  # Invest in growing cooperation
    else:
        DEFECT  # Extract before collapse

else:  # avg_coop_rate < 0.4
    # Low cooperation environment - no point contributing
    DEFECT
```

**Exploitation Multiplier Adjustment:**
- If `k` is closer to `n` (higher returns), be *slightly* more willing to cooperate (threshold adjustments of -0.1)
- If `k` is closer to 1 (lower returns), be *more* aggressive in defecting (threshold adjustments of +0.1)

---

### Phase 3: Endgame Phase (Final ⌈r/10⌉ rounds, minimum last 2 rounds)

**Purpose:** Extract maximum value as the shadow of the future disappears.

**Decision Rule:**
- **Last round: Always DEFECT** (no future retaliation possible)
- **Second-to-last round: DEFECT** (most strategies will defect in response anyway)
- **Other endgame rounds:** 
  - DEFECT if `avg_coop_rate < 0.5`
  - Otherwise, alternate: DEFECT, COOPERATE, DEFECT... (starting with DEFECT)

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    probing_end = ceil(r / 5)
    endgame_start = r - max(ceil(r / 10), 2)
    
    # PHASE 3: Endgame
    if round > endgame_start:
        if round == r or round == r - 1:
            return DEFECT
        if avg_coop_rate(history, 3) < 0.5:
            return DEFECT
        return DEFECT if (r - round) % 2 == 0 else COOPERATE
    
    # PHASE 1: Probing
    if round == 1:
        return DEFECT
    
    if round <= probing_end:
        last_coop_rate = cooperators_last_round(history) / (n - 1)
        return COOPERATE if last_coop_rate >= 0.6 else DEFECT
    
    # PHASE 2: Exploitation
    avg_rate = avg_coop_rate(history, 3)
    threshold_adjust = 0.1 * (1 - (k - 1) / (n - 1))  # Higher k = lower thresholds
    
    if avg_rate >= 0.7 - threshold_adjust:
        return DEFECT if my_last_action(history) == COOPERATE else COOPERATE
    
    if avg_rate >= 0.4 - threshold_adjust:
        trend = coop_trend(history, 3)
        return COOPERATE if trend > 0 else DEFECT
    
    return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | No information; safe baseline |
| Last round | DEFECT | No future; pure extraction |
| n = 2 | Use stricter thresholds (+0.15) | Single opponent makes prediction easier |
| r ≤ 5 | Skip to endgame logic immediately | Not enough rounds for reputation building |
| All opponents always defect | DEFECT always | No cooperative surplus to extract |
| All opponents always cooperate | Alternate C/D in exploitation phase | Sustainable extraction |
| k very close to n | Slightly more cooperation | Higher marginal returns justify investment |

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Always requires evidence of exploitable cooperation
2. **Defects first** - Identifies "nice" strategies immediately
3. **Asymmetric alternation** - In high-cooperation environments, cooperates just enough to maintain the pool while defecting to extract
4. **Endgame defection** - Maximizes terminal extraction when reputation no longer matters
5. **Adapts to collapse** - Quickly switches to full defection when cooperation dries up, avoiding "sucker" payoffs
'''

description_EXPLOITATIVE_4 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**, and to **appear just cooperative enough to sustain exploitable cooperation in others**.

## Strategy Overview

The strategy operates in three phases and continuously estimates opponent cooperativeness to calibrate exploitation intensity.

---

## Phase 1: Probing Phase (Rounds 1-2)

**Purpose:** Gather information about the population's cooperative tendencies.

**Round 1:** **DEFECT**
- Rationale: Defection dominates in a single round. We lose nothing by defecting first, and we gain information about how many others cooperate unconditionally.

**Round 2:** **COOPERATE** (conditional)
- Only cooperate if at least 50% of other players cooperated in Round 1
- Otherwise, **DEFECT**
- Rationale: This tests whether cooperation is rewarded and establishes a minimal cooperative reputation to keep conditional cooperators engaged.

---

## Phase 2: Exploitation Phase (Rounds 3 to r-2)

**Decision Rule:** Use a cooperation threshold based on observed cooperation rate and remaining rounds.

### Calculate Cooperation Rate
```
coop_rate = (total cooperations by others in all previous rounds) / 
            ((n-1) × rounds_played)
```

### Exploitation Logic

**IF** `coop_rate ≥ 0.6` (cooperative population):
- **Defect with probability 0.7, Cooperate with probability 0.3**
- Rationale: Heavily exploit cooperators while occasionally cooperating to prevent complete collapse of cooperation. The occasional cooperation makes us look like a "noisy cooperator" rather than a pure defector.

**ELSE IF** `coop_rate ≥ 0.3` (mixed population):
- **Mirror the majority action from previous round**
- If majority cooperated → **DEFECT** (exploit the wave)
- If majority defected → **COOPERATE** (try to restart cooperation we can exploit)
- Rationale: Countercyclical play maximizes extraction.

**ELSE** (`coop_rate < 0.3`, defector-heavy population):
- **DEFECT**
- Rationale: No cooperation to exploit; minimize losses.

### Adaptive Adjustment

Track if our cooperation seems to increase others' cooperation in subsequent rounds:
- If our cooperation in round t correlates with higher cooperation in round t+1, slightly increase cooperation probability (up to 0.4 max)
- This identifies and exploits "conditional cooperators" who can be farmed

---

## Phase 3: Endgame (Final 2 Rounds)

**Round r-1 (second-to-last):** **DEFECT**
- Rationale: Shadow of the future is nearly gone. Sophisticated opponents will defect; naive cooperators can still be exploited.

**Round r (final round):** **DEFECT**
- Rationale: No future retaliation possible. Defection strictly dominates.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | Defect both rounds | No time to build exploitable cooperation |
| n = 2 (minimum players) | Tit-for-Tat with defection bias | Standard exploitation in bilateral setting |
| k very close to 1 | Defect always | Cooperation barely profitable even if universal |
| k close to n | More willing to cooperate (threshold 0.4 instead of 0.6) | Higher returns justify occasional genuine cooperation |
| All opponents defected so far | Defect | Nothing to exploit |
| All opponents cooperated so far | Defect 80%, Cooperate 20% | Maximum exploitation with minimal reputation maintenance |

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    if round == r or round == r-1:
        return DEFECT  # Endgame
    
    if round == 1:
        return DEFECT  # Probe
    
    if round == 2:
        if others_coop_count(round=1) >= (n-1)/2:
            return COOPERATE
        else:
            return DEFECT
    
    coop_rate = total_others_cooperations(history) / ((n-1) * (round-1))
    
    if coop_rate >= 0.6:
        return random_choice(DEFECT=0.7, COOPERATE=0.3)
    
    elif coop_rate >= 0.3:
        if majority_cooperated_last_round(history):
            return DEFECT
        else:
            return COOPERATE
    
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Defects by default** in uncertain or low-cooperation environments
2. **Free-rides on cooperators** rather than reciprocating fairly
3. **Maintains just enough cooperation** to keep victims cooperating
4. **Ruthless endgame** with guaranteed final defections
5. **Countercyclical exploitation** - defects when others cooperate most, maximizing extraction
'''

description_EXPLOITATIVE_7 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and continuously estimates opponent "exploitability" to maximize extraction.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: Establish baseline. If others cooperate, we profit maximally. If others defect, we lose nothing compared to cooperating.

**Round 2: DEFECT**
- Rationale: Continue observing. Many strategies give opponents "one chance" - we exploit this grace period.

### Phase 2: Adaptive Exploitation (Rounds 3 to r-2)

Calculate the **Cooperation Rate (CR)** from all observed actions:
```
CR = (total C actions by all opponents across all previous rounds) / (total opponent actions)
```

Calculate **Exploitability Threshold (ET)**:
```
ET = k / n  (the marginal return from each cooperator)
```

**Decision Rule:**
```
IF CR > 0.5 AND (number of expected cooperators) × (k/n) > 1:
    → DEFECT (exploit the cooperators - their contributions benefit us)
    
ELSE IF CR is decreasing rapidly (cooperation collapsing):
    → DEFECT (no point cooperating in a collapsing environment)
    
ELSE IF CR > 0.3 AND we've defected for 3+ consecutive rounds:
    → COOPERATE once (bait to restore cooperation, then exploit again)
    
ELSE:
    → DEFECT (default to dominant strategy)
```

**Exploitation Logic Detailed:**

1. **Track per-opponent cooperation rates** when possible (in games where individual histories are observable)
2. **Identify "suckers"** - players who cooperate regardless of others' behavior
3. **Identify "retaliators"** - players who punish defection
4. **Identify "fellow defectors"** - accept mutual defection with these players

**Conditional Cooperation (Bait Mechanic):**
```
IF overall cooperation has dropped below 30% AND it was above 50% earlier:
    → COOPERATE for 1 round (attempt to restart exploitation cycle)
    → Then immediately DEFECT for next 2 rounds
```

### Phase 3: Endgame (Final 2 rounds)

**Round r-1: DEFECT**
- Rationale: No future punishment possible, begin final extraction

**Round r (Final): DEFECT**
- Rationale: Dominant strategy with zero future consequences

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # Opening - always defect to probe
    if round <= 2:
        return DEFECT
    
    # Calculate cooperation rate
    total_opponent_actions = count_all_opponent_actions(history)
    total_cooperations = count_all_opponent_cooperations(history)
    CR = total_cooperations / total_opponent_actions
    
    # Calculate recent trend (last 3 rounds)
    recent_CR = cooperation_rate_last_n_rounds(history, 3)
    CR_declining = (recent_CR < CR - 0.15)
    
    # Count our consecutive defections
    my_consecutive_defections = count_my_consecutive_defections(history)
    
    # Expected cooperators next round (simple estimate)
    expected_cooperators = CR * (n - 1)
    expected_public_good_share = (k / n) * expected_cooperators
    
    # Main decision logic
    if CR > 0.5 and expected_public_good_share > 0.8:
        return DEFECT  # Exploit cooperative environment
    
    if CR_declining:
        return DEFECT  # Don't cooperate in collapsing game
    
    if CR > 0.3 and my_consecutive_defections >= 3 and round < r - 3:
        return COOPERATE  # Bait to restore cooperation
    
    return DEFECT  # Default: defect
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | No information, dominant strategy |
| Final round | DEFECT | No future punishment |
| All opponents always cooperate | DEFECT | Maximum exploitation |
| All opponents always defect | DEFECT | No benefit to cooperating |
| Mixed population | Adaptive | Use CR-based rules above |
| r = 2 (minimum rounds) | DEFECT both | Both are essentially endgame |
| Very large n | More likely DEFECT | Individual impact diluted |
| k close to n | Slightly more COOPERATE bait | Higher returns from restored cooperation |

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Every cooperation is calculated bait
2. **Exploits grace periods** - Many strategies forgive early defection; we capitalize
3. **Free-rides on cooperators** - When others cooperate, we take without giving
4. **Baits strategically** - Occasional cooperation restarts exploitation cycles
5. **Endgame extraction** - Guaranteed defection when punishment is impossible
6. **Adapts to collapse** - Doesn't waste contributions in dying cooperative environments
'''

description_EXPLOITATIVE_5 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

This strategy aims to **maximize personal gain by free-riding on cooperators while avoiding retaliation costs**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by others creates exploitable value. My goal is to extract maximum value from cooperative players while minimizing my own contributions.

## Strategy Overview

I will defect by default, but strategically inject minimal cooperation to:
1. Probe whether others are conditional cooperators I can exploit
2. Avoid triggering collective punishment that destroys the pool of cooperators
3. Never cooperate in endgame rounds where exploitation has no future cost

---

## Detailed Decision Rules

### Round Classification

```
early_game:    rounds 1 to floor(r/3)
mid_game:      rounds floor(r/3)+1 to floor(2r/3)
end_game:      rounds floor(2r/3)+1 to r
```

### Key Metrics (tracked each round)

```
cooperation_rate = (number of C plays in previous round) / n
historical_coop_rate = (total C plays across all previous rounds) / (n × rounds_played)
my_coop_count = number of times I've played C
```

### Decision Rules by Phase

#### **Round 1: DEFECT**
- Rationale: No information yet. Defecting is dominant in isolation and lets me observe others' baseline behavior without cost.

#### **Early Game (rounds 2 to floor(r/3)): Probing Phase**

```
IF cooperation_rate >= 0.5:
    # Rich environment - others are cooperating
    IF my_coop_count == 0:
        COOPERATE once (probe to appear non-threatening)
    ELSE:
        DEFECT (exploit the cooperators)
ELSE:
    DEFECT (nothing to exploit)
```

#### **Mid Game (rounds floor(r/3)+1 to floor(2r/3)): Exploitation Phase**

```
IF cooperation_rate >= 0.6:
    # Strong cooperation persists - exploit aggressively
    DEFECT
ELSE IF cooperation_rate >= 0.3 AND cooperation_rate < 0.6:
    # Moderate cooperation - occasional C to prevent total collapse
    IF (rounds_since_my_last_C >= 3) AND (historical_coop_rate >= 0.4):
        COOPERATE (maintenance contribution)
    ELSE:
        DEFECT
ELSE:
    # Cooperation collapsed - pure defection
    DEFECT
```

#### **End Game (rounds floor(2r/3)+1 to r): ALWAYS DEFECT**
- Rationale: No future rounds to maintain reputation. Pure exploitation. This includes the final round as a strict subset.

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| **First round** | DEFECT | No information; avoid sunk cost |
| **Last round** | DEFECT | No future; dominant strategy |
| **r = 2** | DEFECT both rounds | Too short to build exploitable dynamics |
| **All others always defect** | DEFECT | Nothing to exploit |
| **All others always cooperate** | DEFECT (with rare probe C) | Maximum exploitation opportunity |
| **n = 2** | DEFECT heavily | Easy to be identified as defector, but still profitable |
| **k close to n** | Slightly more C in mid-game | Higher marginal return from cooperation makes occasional C more worthwhile for pool maintenance |

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, k, history):
    if round_num == 1:
        return DEFECT
    
    if round_num > (2 * total_rounds) // 3:  # End game
        return DEFECT
    
    coop_rate = count_cooperators_last_round(history) / n
    my_coop_count = count_my_cooperations(history)
    
    if round_num <= total_rounds // 3:  # Early game
        if coop_rate >= 0.5 and my_coop_count == 0:
            return COOPERATE  # Single probe
        return DEFECT
    
    else:  # Mid game
        if coop_rate >= 0.6:
            return DEFECT  # Exploit rich environment
        elif coop_rate >= 0.3:
            historical_rate = total_cooperations(history) / (n * (round_num - 1))
            rounds_since_my_C = rounds_since_last_cooperation(history)
            if rounds_since_my_C >= 3 and historical_rate >= 0.4:
                return COOPERATE  # Maintenance
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Defaults to defection**: Captures the dominant strategy payoff in most situations
2. **Free-rides systematically**: When others cooperate, I take without giving
3. **Minimal cooperation is tactical**: Only cooperates to prevent complete collapse of the exploitable pool or to appear less threatening
4. **Endgame ruthlessness**: Zero cooperation when reputation no longer matters
5. **Adapts to environment**: Doesn't waste cooperation on defecting populations; maximizes extraction from cooperative ones
'''

description_EXPLOITATIVE_8 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight of this game is that defection always yields +1 more than cooperation *given the same number of other cooperators*. My strategy exploits cooperative opponents while protecting against retaliation, and quickly abandons cooperation when facing defectors.

## Strategy Overview

I will be a **conditional defector** who cooperates only when:
1. It's necessary to "farm" cooperators (keep them cooperating so I can exploit them)
2. The environment is cooperative enough that my occasional cooperation maintains the cooperative ecosystem

## Decision Rules

### Round 1: DEFECT
- No information available, and defection dominates in single-shot play
- This also serves as a probe to see who cooperates unconditionally

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate two key metrics after each round:

**Cooperation Rate (CR):** Proportion of other players who cooperated last round
```
CR = (number of cooperators among others) / (n - 1)
```

**Historical Cooperation Trend (HCT):** Is cooperation increasing or decreasing?
```
HCT = CR(current) - CR(3 rounds ago), or CR(current) - CR(round 1) if early
```

**Decision Logic:**

```
IF CR >= 0.6 THEN:
    # Rich cooperative environment - exploit it
    # Cooperate occasionally to sustain the ecosystem
    IF I defected in the last 2 consecutive rounds THEN:
        COOPERATE (to avoid being identified as pure defector)
    ELSE:
        DEFECT (harvest the public good)

ELSE IF CR >= 0.3 THEN:
    # Mixed environment - match but slightly undercut
    IF HCT > 0 (cooperation rising) THEN:
        COOPERATE (invest in growing cooperation)
    ELSE:
        DEFECT (abandon ship)

ELSE IF CR < 0.3 THEN:
    # Low cooperation environment
    DEFECT (nothing to sustain, maximize private gains)
```

### Last Round (Round r): ALWAYS DEFECT
- No future retaliation possible
- Pure Nash equilibrium logic applies
- Even if I've been cooperating, defect here

### Second-to-Last Round (Round r-1): DEFECT
- Sophisticated opponents will defect in round r regardless
- Backward induction suggests defecting here too
- Get ahead of the unraveling

## Handling Edge Cases

**If n = 2 (Two players):**
- Shift to more Tit-for-Tat-like behavior
- Defect round 1, then mirror opponent's previous move
- But still defect in final 2 rounds

**If k is very close to n (high multiplier):**
- Be slightly more cooperative (lower CR threshold to 0.5)
- Public good is more valuable, worth sustaining

**If k is very close to 1 (low multiplier):**
- Be more aggressive - always defect regardless of CR
- Public good barely beats private keeping

**If r is very small (e.g., r ≤ 3):**
- Defect every round
- Not enough time to build or exploit cooperation

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    # Opening: probe with defection
    if round == 1:
        return DEFECT
    
    # Short games: pure defection
    if r <= 3:
        return DEFECT
    
    # Calculate cooperation rate of others last round
    CR = count_cooperators_last_round(history) / (n - 1)
    
    # Adjust threshold based on k
    high_threshold = 0.6 - 0.1 * ((k - 1) / (n - 1))
    
    if CR >= high_threshold:
        # Exploit cooperative environment, but sustain it
        if consecutive_defections(history, me) >= 2:
            return COOPERATE
        else:
            return DEFECT
    
    elif CR >= 0.3:
        # Mixed environment - follow trend
        if cooperation_trending_up(history):
            return COOPERATE
        else:
            return DEFECT
    
    else:
        return DEFECT
```

## Why This Strategy is Exploitative

1. **Free-rides on cooperators:** In high-cooperation environments, I defect 2/3 of the time while others fund the public good
2. **Minimal contribution:** I only cooperate enough to avoid triggering retaliation or ecosystem collapse
3. **Endgame exploitation:** Guaranteed defection in final rounds extracts maximum value
4. **Quick abandonment:** If cooperation drops, I don't waste resources trying to revive it
5. **Probing opener:** Starting with defection identifies unconditional cooperators to exploit
'''

description_EXPLOITATIVE_6 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors extract value from cooperators without reciprocating. The goal is to **maximize extraction from cooperative populations while minimizing losses against defectors**, adapting dynamically based on observed behavior.

## Strategy Overview

The strategy operates in three phases and continuously estimates the "exploitability" of the population to calibrate between parasitic defection and strategic cooperation designed to sustain victims.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Round 1:** DEFECT
- Rationale: Gather information while protecting against naive losses. If others cooperate, we extract maximum value. If others defect, we lose nothing.

**Rounds 2-3:** DEFECT
- Continue observing. Track cooperation rates without contributing.

### Phase 2: Exploitation Phase (Rounds 4 through r-2)

Calculate the **cooperation ratio** after each round:
```
coop_ratio = (number of cooperators in previous round) / (n - 1)
```

**Decision Rule:**

```
IF coop_ratio >= 0.6:
    # High cooperation environment - exploit it
    DEFECT (pure extraction mode)
    
ELSE IF coop_ratio >= 0.4:
    # Moderate cooperation - conditionally cooperate to sustain victims
    IF (cooperation has been declining for 2+ consecutive rounds):
        COOPERATE (invest to keep the pool alive)
    ELSE:
        DEFECT (continue extraction)
        
ELSE IF coop_ratio >= 0.2:
    # Low cooperation - try to revive if profitable
    IF (k/n) * (expected_cooperators + 1) > 0.8:
        COOPERATE (attempt to signal and revive cooperation)
    ELSE:
        DEFECT (not worth the investment)
        
ELSE:
    # Near-zero cooperation - defect always
    DEFECT (nothing to exploit)
```

**Trend Detection:**
```
declining = (coop_ratio[t-1] > coop_ratio[t-2] > coop_ratio[t-3])
```

### Phase 3: Endgame (Final 2 rounds)

**Round r-1:** DEFECT
- No future to sustain; begin extraction collapse

**Round r (final):** DEFECT
- Unconditional defection; no strategic value to cooperation

---

## Detailed Pseudocode

```python
def decide(round_number, total_rounds, n, k, history):
    """
    history: list of tuples (my_action, num_cooperators_excluding_me)
    """
    
    # Endgame: Always defect in final 2 rounds
    if round_number >= total_rounds - 1:
        return DEFECT
    
    # Probing phase: First 3 rounds
    if round_number <= 3:
        return DEFECT
    
    # Calculate recent cooperation ratio (last round)
    last_coop_count = history[-1][1]
    coop_ratio = last_coop_count / (n - 1)
    
    # Calculate trend (is cooperation declining?)
    if len(history) >= 3:
        ratios = [h[1] / (n - 1) for h in history[-3:]]
        declining = ratios[0] > ratios[1] > ratios[2]
        declining_fast = (ratios[0] - ratios[2]) > 0.3
    else:
        declining = False
        declining_fast = False
    
    # Exploitation logic
    if coop_ratio >= 0.6:
        # Rich environment - pure extraction
        return DEFECT
        
    elif coop_ratio >= 0.4:
        # Moderate - sustain if collapsing
        if declining:
            return COOPERATE  # Minimal investment to keep victims contributing
        else:
            return DEFECT
            
    elif coop_ratio >= 0.2:
        # Low cooperation - revival attempt if parameters favor it
        expected_return = (k / n) * (last_coop_count + 2)  # Optimistic estimate
        if expected_return > 0.9 and not declining_fast:
            return COOPERATE
        else:
            return DEFECT
            
    else:
        # Dead environment - nothing to exploit
        return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | Safe information gathering |
| Last round | DEFECT | No future consequences |
| n=2 (minimal game) | Mostly DEFECT | Limited exploitation potential; occasional C if opponent highly cooperative |
| k close to n | Slightly more willing to COOPERATE in revival | Higher returns justify investment |
| k close to 1 | More aggressive DEFECT | Low multiplier means cooperation rarely pays |
| All opponents defecting | DEFECT | No pool to exploit |
| All opponents cooperating | DEFECT | Maximum extraction opportunity |

---

## Why This Strategy is Exploitative

1. **Asymmetric extraction:** We defect when others cooperate, capturing the (k/n) benefit without paying the cost of 1.

2. **Victim farming:** Strategic occasional cooperation isn't altruism—it's an investment to keep cooperative players contributing, maintaining the pool we extract from.

3. **Information advantage:** By defecting early, we learn population behavior while others reveal their strategies.

4. **Endgame betrayal:** Final rounds guarantee defection, extracting from any players who cooperate hoping for reciprocity.

5. **Parameter awareness:** The strategy adjusts based on k/n ratio, exploiting more aggressively when the multiplier is high (more to extract) and being more conservative when low.

---

## Expected Performance

- **Against cooperators (TFT, Pavlov, unconditional C):** High payoffs through sustained extraction
- **Against defectors:** Matches their payoff (no loss)
- **Against mixed populations:** Extracts from cooperators while avoiding exploitation by defectors
- **Self-play concern:** Against copies, everyone defects and gets baseline payoff—acceptable floor
'''

description_EXPLOITATIVE_9 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that in a public goods game with k < n, defection strictly dominates cooperation in any single round. However, in a repeated game, I can exploit cooperative opponents by free-riding on their contributions while they still cooperate, then adapting my behavior based on the observed "cooperativeness" of the population.

## Strategy Overview

I will be a **conditional defector** who occasionally "tests" the waters with cooperation to maintain a cooperative environment that I can exploit, while aggressively defecting when the population is already cooperative enough to provide good returns without my contribution.

---

## Decision Rules

### Key Variables to Track
- `coop_rate[t]`: Proportion of other players who cooperated in round t
- `avg_coop_rate`: Running average cooperation rate of others across all rounds
- `rounds_remaining`: r - current_round
- `my_marginal_impact`: k/n (the benefit per cooperator shared among all)

### Round-by-Round Logic

```
FUNCTION decide(round, history, n, k, r):
    
    # FIRST ROUND: Defect
    # Rationale: Gather information, don't sacrifice payoff upfront
    IF round == 1:
        RETURN DEFECT
    
    # LAST ROUND: Always Defect
    # Rationale: No future to incentivize cooperation, pure Nash equilibrium
    IF round == r:
        RETURN DEFECT
    
    # SECOND-TO-LAST ROUND: Almost always Defect
    # Rationale: Others may start defecting; get ahead of the collapse
    IF round == r - 1:
        RETURN DEFECT
    
    # CALCULATE RECENT COOPERATION ENVIRONMENT
    others_coop_last_round = count_others_cooperating(history, round - 1)
    others_coop_rate = others_coop_last_round / (n - 1)
    
    # EXPLOITATION THRESHOLD
    # If enough others are cooperating, I profit more by defecting
    exploitation_threshold = (n - k) / n  # ~0.67 for n=6, k=2
    
    # MAIN DECISION LOGIC
    
    # Case 1: High cooperation environment (EXPLOIT)
    IF others_coop_rate >= exploitation_threshold:
        # Free ride - they're providing enough public good
        RETURN DEFECT
    
    # Case 2: Medium cooperation environment (CONDITIONAL)
    IF others_coop_rate >= 0.3 AND others_coop_rate < exploitation_threshold:
        # Probabilistic cooperation to "maintain the herd"
        # Cooperate occasionally to prevent total collapse
        maintain_prob = 0.2 * (rounds_remaining / r)  # Decreases over time
        IF random() < maintain_prob:
            RETURN COOPERATE
        ELSE:
            RETURN DEFECT
    
    # Case 3: Low cooperation environment (ABANDON)
    IF others_coop_rate < 0.3:
        # Not worth trying to rebuild; mutual defection is stable
        RETURN DEFECT
```

---

## Edge Cases Handled

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Defect | Information gathering; no history to exploit |
| Round r (final) | Defect | No future consequences; dominant strategy |
| Round r-1 | Defect | Anticipate end-game defection cascade |
| Everyone defecting | Defect | No point being the sole sucker |
| Everyone cooperating | Defect | Maximum exploitation opportunity |
| n=2 (minimum players) | Defect-heavy | Partner's contribution barely benefits me |
| High k (close to n) | Slightly more cooperative testing | Higher return per cooperation |

---

## Exploitation Mechanisms

1. **Free-Riding on Cooperators**: When others cooperate, I get (k/n) × their_contributions whether I contribute or not. By defecting, I keep my endowment AND get the public good share.

2. **Strategic Minimal Investment**: Occasional cooperation in middle rounds is purely to prevent total cooperation collapse—keeping the "marks" in the game.

3. **End-Game Aggression**: Guaranteed defection in final rounds captures maximum value when future retaliation is impossible.

4. **Adaptive Threshold**: The exploitation_threshold adjusts implicitly to game parameters, ensuring I defect when profitable.

---

## Why This Beats Common Strategies

- **vs. Always Cooperate**: I extract maximum value every round
- **vs. Always Defect**: We tie (both get 1/round), but I do better against mixed populations
- **vs. Tit-for-Tat variants**: My round-1 defection tests them; I exploit forgiving strategies
- **vs. Trigger strategies**: I never cooperate enough to trigger, but benefit from their cooperation with others
'''

description_EXPLOITATIVE_7 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by:
1. **Detecting and exploiting cooperators** - Free-ride on their contributions
2. **Avoiding mutual defection traps** - Cooperate just enough to keep cooperators cooperating
3. **Extracting maximum value** - Calibrate behavior based on observed opponent tendencies

## Strategy Overview

The strategy operates in three phases across the game, with continuous adaptation based on a "cooperation index" that tracks how exploitable the population is.

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1-3)

**Round 1:** Always **DEFECT**
- Rationale: Gather information at no risk. If others cooperate, I profit maximally. If others defect, I lose nothing compared to cooperating.

**Rounds 2-3:** **DEFECT** unless cooperation rate in previous round was ≥ 80%
- If ≥ 80% cooperated: **COOPERATE** (signal willingness to sustain their cooperation)
- Otherwise: **DEFECT** (continue exploiting or avoid being exploited)

### Phase 2: Exploitation Phase (Rounds 4 to r-2)

Calculate the **Cooperation Index (CI)** = (total C plays by others in last 3 rounds) / (3 × (n-1))

**Decision Rule:**
```
IF CI ≥ 0.7:
    DEFECT (exploit the cooperators - this is the sweet spot)
    
ELSE IF CI ≥ 0.4:
    COOPERATE with probability = (CI - 0.2)
    (Partial cooperation to prevent cooperation collapse)
    
ELSE IF CI ≥ 0.2:
    COOPERATE (try to rebuild cooperation so I can exploit it later)
    
ELSE (CI < 0.2):
    DEFECT (population is mostly defectors, join them)
```

**Adaptive Adjustment:**
- Track my cumulative payoff vs. average opponent payoff
- If I'm earning less than average over last 5 rounds, shift toward more defection
- If cooperation is stable and I'm earning more, maintain current approach

### Phase 3: Endgame (Last 2 rounds)

**Round r-1 (second-to-last):** 
- **DEFECT** if CI < 0.5
- **COOPERATE** if CI ≥ 0.5 (maintain exploitation setup for final round)

**Round r (final round):** Always **DEFECT**
- No future punishment possible; pure exploitation is optimal

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Last round: always defect
    if round == r:
        return DEFECT
    
    # First round: always defect
    if round == 1:
        return DEFECT
    
    # Calculate cooperation index from last min(3, round-1) rounds
    lookback = min(3, round - 1)
    others_cooperations = count_others_cooperations(history, lookback)
    CI = others_cooperations / (lookback * (n - 1))
    
    # Probe phase (rounds 2-3)
    if round <= 3:
        if CI >= 0.8:
            return COOPERATE
        else:
            return DEFECT
    
    # Second-to-last round
    if round == r - 1:
        if CI < 0.5:
            return DEFECT
        else:
            return COOPERATE
    
    # Exploitation phase
    if CI >= 0.7:
        return DEFECT  # Exploit cooperators
    
    else if CI >= 0.4:
        # Probabilistic cooperation to sustain cooperation
        prob = CI - 0.2
        return COOPERATE with probability prob, else DEFECT
    
    else if CI >= 0.2:
        return COOPERATE  # Try to rebuild cooperation
    
    else:
        return DEFECT  # Join the defectors
```

---

## Key Exploitative Features

1. **Never cooperate first** - Let others take the risk
2. **Defect when cooperation is high** - Maximum free-riding payoff
3. **Strategic cooperation only to farm future defection opportunities** - Investment, not altruism
4. **Guaranteed endgame defection** - No wasted cooperation
5. **Adaptive thresholds** - Responds to actual population behavior, not assumptions

This strategy treats cooperation as a resource to be harvested, not a norm to be followed.
'''

description_EXPLOITATIVE_10 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can capture. The goal is to **free-ride when profitable, cooperate only when necessary to sustain exploitable cooperators, and defect decisively when exploitation is no longer viable**.

## Strategy Overview

The strategy operates in three modes based on detected opponent behavior and game phase:

1. **Probe Mode** (Early rounds): Test the waters, identify exploitable cooperators
2. **Exploit Mode** (Middle rounds): Maximize free-riding while keeping cooperators engaged
3. **Exit Mode** (Final rounds): Pure defection with no future to protect

---

## Decision Rules

### Round 1: Initial Probe
**Action: DEFECT**

Rationale: Defecting in round 1 is strictly dominant for information gathering. If others cooperate, I gain maximally. If others defect, I lose nothing compared to cooperating. This also identifies which opponents are unconditional cooperators (easy targets).

### Last Round (round r):
**Action: DEFECT**

Rationale: No future interactions mean no retaliation possible. Cooperation has zero strategic value.

### Penultimate Round (round r-1):
**Action: DEFECT**

Rationale: Sophisticated opponents will defect in the last round regardless, so there's no cooperation to protect. Begin exit early.

### Rounds 2 through r-2: Adaptive Exploitation

Calculate the following metrics from history:

```
cooperation_rate = (total C plays by all opponents) / (total plays by all opponents)
recent_coop_rate = cooperation rate in last 3 rounds
my_recent_action = my action in the previous round
response_to_my_defection = opponent cooperation rate in rounds after I defected
```

#### Decision Logic:

```
IF recent_coop_rate >= 0.5:
    # Enough cooperators to exploit
    IF my_recent_action == DEFECT AND response_to_my_defection >= 0.4:
        # Opponents still cooperating despite my defection - EXPLOIT
        ACTION = DEFECT
    ELSE IF my_recent_action == DEFECT AND response_to_my_defection < 0.4:
        # Defection triggered retaliation - rebuild trust minimally
        ACTION = COOPERATE (with probability 0.6), DEFECT (with probability 0.4)
    ELSE IF my_recent_action == COOPERATE:
        # Test if I can defect without consequence
        ACTION = DEFECT

ELSE IF recent_coop_rate >= 0.25 AND recent_coop_rate < 0.5:
    # Marginal cooperation - try to revive it for future exploitation
    IF rounds_remaining > r/3:
        # Enough time to rebuild and exploit
        ACTION = COOPERATE
    ELSE:
        # Not enough time - abandon ship
        ACTION = DEFECT

ELSE (recent_coop_rate < 0.25):
    # Environment is hostile - no point cooperating
    ACTION = DEFECT
```

### Edge Case: Very Short Games (r ≤ 4)

```
Round 1: DEFECT
Round 2 to r-1: DEFECT (not enough rounds for reputation to matter)
Round r: DEFECT
```

### Edge Case: Two-Player Game (n = 2)

More aggressive exploitation since only one opponent to track:

```
IF opponent_defected_last_round:
    ACTION = DEFECT
ELSE IF opponent has cooperated for 2+ consecutive rounds:
    ACTION = DEFECT (exploit the sucker)
ELSE:
    ACTION = DEFECT (test their response)
```

Essentially: always defect in 2-player games. The k < n constraint means mutual cooperation yields less than 2 total, making defection dominant.

### Edge Case: High k (approaching n)

When k is close to n, cooperation becomes more valuable. Adjust threshold:

```
cooperation_threshold = 0.5 - 0.2 * (k / n)
```

This makes the strategy slightly more willing to cooperate when k is high, but still exploits aggressively.

---

## Summary Pseudocode

```python
def choose_action(round, history, n, k, r):
    if round == 1:
        return DEFECT
    
    if round >= r - 1:  # Last 2 rounds
        return DEFECT
    
    if r <= 4:
        return DEFECT
    
    if n == 2:
        return DEFECT
    
    recent_coop = calculate_opponent_cooperation(history, window=3)
    my_last = history.my_last_action()
    retaliation_rate = cooperation_after_my_defection(history)
    rounds_left = r - round
    
    if recent_coop >= 0.5:
        if my_last == DEFECT and retaliation_rate >= 0.4:
            return DEFECT  # Keep exploiting
        elif my_last == DEFECT and retaliation_rate < 0.4:
            return COOPERATE if random() < 0.6 else DEFECT
        else:
            return DEFECT  # Test the waters
    elif recent_coop >= 0.25:
        return COOPERATE if rounds_left > r/3 else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** in round 1 - captures maximum value from naive cooperators
2. **Defects in endgame** - no wasted cooperation when future doesn't exist
3. **Free-rides on sustained cooperators** - detects and milks opponents who cooperate despite defection
4. **Minimal cooperation investment** - only cooperates to keep the exploitation pipeline alive
5. **Abandons lost causes** - doesn't waste resources on hostile environments
6. **Exploits the k < n constraint** - recognizes that defection is individually rational and leans into it
'''

description_EXPLOITATIVE_8 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**. We cooperate only when it's instrumentally useful to cultivate future exploitation opportunities.

---

## Decision Rules

### Round 1: Always Defect
- **Rationale**: No information exists yet. Defection is the dominant single-round strategy (since k < n). We lose nothing by testing the waters, and we immediately profit if others cooperate.

### Rounds 2 through (r-1): Conditional Exploitation

Calculate the **cooperation rate** of the group in the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Logic:**

```
IF coop_rate >= threshold_high (e.g., 0.6):
    # Rich environment to exploit
    DEFECT (free-ride on cooperators)
    
ELIF coop_rate >= threshold_low (e.g., 0.3) AND coop_rate < threshold_high:
    # Moderate cooperation - need to maintain it
    IF my_consecutive_defections >= 2:
        COOPERATE (token contribution to prevent collapse)
    ELSE:
        DEFECT (continue extraction)
        
ELIF coop_rate > 0 AND coop_rate < threshold_low:
    # Cooperation is fragile - one strategic cooperation might revive it
    IF previous_round_I_cooperated:
        DEFECT (don't throw good money after bad)
    ELSE:
        COOPERATE with probability = coop_rate (small investment to test revival)
        
ELSE (coop_rate == 0):
    # Everyone defected - no exploitation opportunity
    DEFECT (no point cooperating alone)
```

### Final Round (Round r): Always Defect
- **Rationale**: No future rounds exist to benefit from reputation-building. Defection strictly dominates.

---

## Adaptive Threshold Adjustment

The thresholds adjust based on game parameters:

```
base_threshold_high = 0.5 + (k / (2*n))  # Higher k means cooperation is more valuable to maintain
base_threshold_low = 0.25 + (k / (4*n))

# Adjust for time horizon
time_factor = (r - current_round) / r  # More patient early, aggressive late

threshold_high = base_threshold_high * (0.8 + 0.4 * time_factor)
threshold_low = base_threshold_low * (0.8 + 0.4 * time_factor)
```

---

## Exploitation Tracking

Maintain a **sucker index** for the population:
```
sucker_index = (total cooperations observed) / (n * rounds_played)
```

**Behavioral modification:**
- If `sucker_index > 0.7`: Population is highly exploitable → Defect more aggressively
- If `sucker_index < 0.2`: Population is defensive → Occasional cooperation to probe for conditional cooperators

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2 | Use stricter thresholds (0.8/0.4) | Easier to track opponent; be more exploitative |
| r = 2 | Defect both rounds | Too short to cultivate; pure extraction |
| k very close to n | Slightly more willing to cooperate | Higher returns make occasional cooperation profitable |
| k very close to 1 | Almost always defect | Public good barely multiplies; defection dominates |

---

## Summary Pseudocode

```python
def decide(round, history, n, k, r):
    if round == 1 or round == r:
        return DEFECT
    
    prev_coop_rate = count_cooperators(history[-1]) / n
    my_consec_defects = count_my_consecutive_defections(history)
    
    # Adaptive thresholds
    time_factor = (r - round) / r
    thresh_high = (0.5 + k/(2*n)) * (0.8 + 0.4*time_factor)
    thresh_low = (0.25 + k/(4*n)) * (0.8 + 0.4*time_factor)
    
    if prev_coop_rate >= thresh_high:
        return DEFECT  # Exploit the cooperators
    elif prev_coop_rate >= thresh_low:
        if my_consec_defects >= 2:
            return COOPERATE  # Maintenance contribution
        return DEFECT
    elif prev_coop_rate > 0:
        if history[-1][my_id] == COOPERATE:
            return DEFECT
        return COOPERATE if random() < prev_coop_rate else DEFECT
    else:
        return DEFECT  # No one to exploit
```

---

## Why This Strategy Exploits Effectively

1. **Never cooperates unconditionally** - Every cooperation is an investment in future exploitation
2. **Maximizes free-riding** - Defects when cooperation is high enough to profit from
3. **Prevents total collapse strategically** - Just enough cooperation to keep suckers contributing
4. **End-game ruthless** - No wasted cooperation when exploitation window closes
5. **Adapts to population** - More aggressive against cooperators, defensive against defectors
'''

description_EXPLOITATIVE_11 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation from others is exploitable. I will appear cooperative enough to encourage others to cooperate, then exploit that cooperation strategically.

## Decision Rules

### Round Classification

**First Round:** Defect
- No information about opponents exists
- Defection dominates cooperation in expected value against unknown strategies
- Establishes baseline to observe who cooperates unconditionally

**Middle Rounds (rounds 2 through r-1):** Conditional exploitation based on observed cooperation rate

**Last Round:** Always Defect
- No future consequences; pure Nash equilibrium play
- Any rational opponent will also defect, so cooperation is pointless

### Middle Round Decision Logic

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Rule:**

```
IF coop_rate >= threshold THEN:
    # Enough cooperators to exploit
    IF I cooperated last round AND coop_rate increased or stayed high:
        Defect  # Others are covering; free-ride
    ELSE IF I defected last round AND coop_rate stayed high:
        Defect  # Continue exploiting
    ELSE IF coop_rate is declining:
        Cooperate with probability p_recover  # Occasionally restore cooperation pool
    
ELSE IF coop_rate < threshold:
    # Not enough cooperators to exploit meaningfully
    IF coop_rate > 0:
        Defect  # Take what little benefit exists
    ELSE:
        Cooperate with small probability p_probe  # Probe for exploitable cooperators
```

### Parameter Definitions

**Threshold for "exploitable" cooperation:**
```
threshold = max(0.4, 2/k)
```
- Higher k means cooperation is more valuable, so lower threshold acceptable
- At minimum, want ~40% cooperation to make exploitation worthwhile

**Recovery probability (to sustain cooperation pool):**
```
p_recover = min(0.3, (r - current_round) / r)
```
- More likely to "invest" in cooperation early when many rounds remain
- Decreases as game progresses

**Probe probability (when everyone defects):**
```
p_probe = 0.1 * (r - current_round) / r
```
- Small chance to test if others will follow
- Only worthwhile early; approaches 0 near end

### Tracking Opponent Types

Maintain a simple model of each opponent based on their history:

```
For each opponent j:
    cooperation_count[j] = number of times j cooperated
    opponent_type[j] = cooperation_count[j] / rounds_played
```

**Exploitation adjustment:**
- If average opponent_type > 0.6: Lean more toward defection (cooperators to exploit)
- If average opponent_type < 0.3: Lean more toward defection (nothing to gain from cooperating)
- If average opponent_type ≈ 0.5: Mix strategies to appear unpredictable

### End-Game Acceleration

**Final 20% of rounds:** Increase defection probability
```
rounds_remaining = r - current_round
if rounds_remaining <= r * 0.2:
    defection_bias = 1 - (rounds_remaining / (r * 0.2))
    # Adds 0 to 1.0 bias toward defection as game ends
```

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Last round: always defect
    if round == r:
        return DEFECT
    
    # First round: defect to observe
    if round == 1:
        return DEFECT
    
    # Calculate previous round statistics
    prev_cooperators = count_cooperators(history, round - 1)
    coop_rate = prev_cooperators / n
    my_prev_action = my_action(history, round - 1)
    
    # Calculate threshold
    threshold = max(0.4, 2/k)
    
    # End-game bias
    rounds_remaining = r - round
    endgame_defect_bias = 0
    if rounds_remaining <= r * 0.2:
        endgame_defect_bias = 1 - (rounds_remaining / (r * 0.2))
    
    # Random check for endgame
    if random() < endgame_defect_bias:
        return DEFECT
    
    # Main decision logic
    if coop_rate >= threshold:
        # Exploitable situation - usually defect
        if random() < 0.85:
            return DEFECT
        else:
            return COOPERATE  # Occasional cooperation to sustain pool
    
    elif coop_rate > 0:
        # Some cooperation but below threshold
        return DEFECT  # Extract whatever value exists
    
    else:
        # No one cooperating
        p_probe = 0.1 * rounds_remaining / r
        if random() < p_probe:
            return COOPERATE  # Probe
        else:
            return DEFECT

    return DEFECT  # Default
```

## Why This Strategy is Exploitative

1. **Free-rides on cooperators:** When others cooperate, I defect to get both my endowment AND share of public good
2. **Never sustains cooperation altruistically:** Only cooperates strategically to maintain exploitable conditions
3. **Recognizes end-game:** No wasted cooperation when punishment is impossible
4. **Adapts to environment:** More exploitative against cooperators, cuts losses against defectors
5. **Information asymmetry:** Uses observed behavior to predict and exploit patterns
'''

description_EXPLOITATIVE_9 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection. The goal is to identify and milk cooperative opponents while quickly abandoning cooperation when facing defectors.

## Decision Rules

### Round 1: Probe with Defection
**Action: DEFECT**

Rationale: Defection in round 1 is strictly dominant in terms of information gathering. If others cooperate, I gain maximally. If others defect, I lose nothing compared to cooperating. This reveals opponent tendencies without cost.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / (n - 1)
```

Calculate the **exploitation threshold**:
```
threshold = (n - k) / (n - 1)
```

This threshold represents the minimum cooperation rate needed for cooperation to be profitable given the multiplier k.

**Decision Logic:**

```
IF coop_rate > threshold + 0.1:
    # Environment is cooperative enough to exploit
    # Defect to free-ride on cooperators
    ACTION = DEFECT
    
ELIF coop_rate > threshold - 0.1:
    # Borderline environment - conditional cooperation to sustain the pool
    # Cooperate only if we've been defecting for 2+ consecutive rounds
    # This occasionally "reseeds" cooperation without being a sucker
    IF consecutive_defections >= 2:
        ACTION = COOPERATE
    ELSE:
        ACTION = DEFECT
        
ELSE:
    # Low cooperation environment - no point contributing
    ACTION = DEFECT
```

### Additional Exploitation Heuristic: Trend Detection

```
IF last_round_coop_rate > previous_round_coop_rate + 0.15:
    # Cooperation is rising - others may be trying to build trust
    # Defect harder to exploit the wave
    ACTION = DEFECT (override any cooperation decision)
    
IF cooperation has been stable (within 0.1) for 3+ rounds AND coop_rate > 0.5:
    # Stable cooperative environment - take turns appearing cooperative
    # Cooperate once every 3 rounds to maintain the pool
    IF rounds_since_last_cooperation >= 3:
        ACTION = COOPERATE
    ELSE:
        ACTION = DEFECT
```

### Last Round: Pure Defection
**Action: DEFECT**

Rationale: No future rounds mean no retaliation possible. Defection strictly dominates.

### Second-to-Last Round: Almost Always Defect
**Action: DEFECT** (unless cooperation rate > 0.8)

Rationale: Sophisticated opponents will defect in the last round, so the shadow of the future is already weak.

## Edge Cases

1. **n = 2**: Standard iterated prisoner's dilemma dynamics. Be more cautious about defecting—use threshold = 0.5 and cooperate in round 2 if opponent cooperated in round 1 (to test for reciprocators), then exploit or match.

2. **k very close to n**: Cooperation becomes more attractive. Lower the exploitation threshold by 0.1 to allow more conditional cooperation.

3. **k very close to 1**: Free-riding is extremely attractive. Raise threshold by 0.1; almost always defect.

4. **Very short games (r ≤ 3)**: Always defect. Insufficient rounds to build exploitable cooperation.

5. **All opponents defected in round 1**: Continue defecting until at least one opponent cooperates.

## Summary Pseudocode

```python
def decide(round, history, n, k, r):
    if round == 1:
        return DEFECT
    
    if round == r or round == r-1:
        return DEFECT
    
    coop_rate = count_cooperators_last_round(history) / (n - 1)
    threshold = (n - k) / (n - 1)
    
    # Exploit rising cooperation
    if is_cooperation_rising(history):
        return DEFECT
    
    # Main decision logic
    if coop_rate > threshold + 0.1:
        return DEFECT  # Free-ride on cooperators
    elif coop_rate > threshold - 0.1:
        if consecutive_defections(history) >= 2:
            return COOPERATE  # Reseed occasionally
        return DEFECT
    else:
        return DEFECT  # Environment too hostile
```

This strategy is designed to be a **parasite on cooperation**—it rarely initiates, exploits when others do, and occasionally "reseeds" just enough to keep cooperative opponents from fully abandoning hope.
'''

description_EXPLOITATIVE_12 = '''
# Exploitative Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in this game, defection always yields a higher individual payoff than cooperation *given the same actions by others*. Therefore, the exploitative approach is to:

1. Defect by default (it's the dominant single-round strategy)
2. Only cooperate strategically to "farm" conditional cooperators for future exploitation
3. Detect and ruthlessly exploit naive cooperators
4. Never cooperate in endgame (no future to protect)

## Strategy: "Predatory Probe"

### Decision Rules

**Round 1: Always Defect**
- Rationale: No information yet, and defection is strictly dominant in a single round. Let others reveal their types while I collect free-rider benefits from any cooperators.

**Rounds 2 through (r-2): Adaptive Exploitation**

Calculate two metrics from history:
- `coop_rate` = (total cooperations by others) / (total possible cooperations by others)
- `trend` = coop_rate in last 2 rounds minus coop_rate in rounds before that

**Decision logic:**
```
IF coop_rate > 0.5 AND trend >= 0:
    # Environment is cooperative and stable/growing
    # Cooperate to sustain the "herd" for continued exploitation
    IF my_defection_streak >= 2:
        COOPERATE  # Occasional cooperation to not collapse the system
    ELSE:
        DEFECT     # Continue extracting value

ELSE IF coop_rate > 0.3 AND coop_rate <= 0.5:
    # Moderate cooperation - probe to see if it can be sustained
    IF last_round_cooperators >= n/2:
        COOPERATE  # Try to keep cooperation alive
    ELSE:
        DEFECT     # Extract remaining value

ELSE:  # coop_rate <= 0.3
    # Low cooperation environment - nothing to farm
    DEFECT  # No point cooperating; mutual defection is stable
```

**Round (r-1): Penultimate Round**
- DEFECT unless `coop_rate > 0.7` (in which case one more cooperation might sustain naive cooperators into the final round where I defect)

**Round r (Final Round): Always Defect**
- Rationale: No future rounds means no punishment possible. Pure dominant strategy.

### Refinements for Exploitation

**Detecting Unconditional Cooperators:**
```
FOR each player j:
    IF player j has cooperated in ALL rounds so far:
        Mark as "naive_cooperator"
        
IF count(naive_cooperators) >= 2:
    # Reliable source of public good exists
    DEFECT regardless of other conditions
```

**Detecting Tit-for-Tat-like Players:**
```
IF after I defected, overall cooperation dropped significantly next round:
    # Others may be retaliating
    Consider single cooperation to "reset" conditional cooperators
    Then return to defection
```

**Threshold Adjustment Based on k and n:**
```
exploitation_potential = k / n  # Per-capita return from cooperation

IF exploitation_potential > 0.4:
    # Higher returns mean cooperators provide more value
    # Worth sustaining cooperation slightly longer
    Increase coop_rate thresholds by 0.1
    
IF n > 10:
    # Larger groups = harder to sustain cooperation
    # My individual defection less noticeable
    Bias toward defection (lower all thresholds by 0.1)
```

### Summary Pseudocode

```
function decide(round, history, n, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    coop_rate = calculate_others_cooperation_rate(history)
    naive_count = count_always_cooperators(history)
    
    if naive_count >= 2:
        return DEFECT  # Exploit naive players
    
    if round == r - 1:
        return DEFECT if coop_rate <= 0.7 else COOPERATE
    
    if coop_rate > 0.5:
        if my_consecutive_defections(history) >= 2:
            return COOPERATE  # Sustain the herd
        else:
            return DEFECT
    
    if coop_rate > 0.3 and last_round_cooperators(history) >= n/2:
        return COOPERATE
    
    return DEFECT
```

### Why This Strategy is Exploitative

1. **Defects first** - Collects information while free-riding
2. **Farms cooperators** - Only cooperates enough to prevent cooperation collapse
3. **Ruthless endgame** - Always defects when punishment is impossible
4. **Targets naive players** - Identifies and exploits unconditional cooperators
5. **Adapts to environment** - Doesn't waste cooperation on defector-heavy groups
'''

description_EXPLOITATIVE_10 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and continuously estimates opponent cooperation rates to exploit predictable cooperators while quickly abandoning cooperation when facing defectors.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** Always **DEFECT**

*Rationale:* This is the safest opening. If others cooperate, I gain maximally. If others defect, I lose nothing compared to cooperating. This also reveals who the "suckers" are.

**Round 2:** Always **DEFECT**

*Rationale:* Continue gathering information. Cooperators who cooperated in round 1 often continue, allowing further exploitation. This also tests for "tit-for-tat" style strategies - true TFT players will now defect.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **cooperation rate** of the population (excluding self):
```
coop_rate = (total cooperations by others in all previous rounds) / ((n-1) × rounds_played)
```

**Decision rule:**
- If `coop_rate > 0.6`: **DEFECT** (exploit the cooperators)
- If `0.3 ≤ coop_rate ≤ 0.6`: **Probabilistic cooperation** with probability `(coop_rate - 0.3) × 0.5`
  - This creates unpredictability and occasionally "rewards" the group to sustain cooperation
- If `coop_rate < 0.3`: **DEFECT** (not enough cooperators to make conditional cooperation worthwhile)

**Adjustment - Punish Declining Cooperation:**
If cooperation rate dropped by more than 0.2 from the previous round's cumulative rate: **DEFECT** regardless of the above rules. This punishes groups that are "wising up."

### Phase 3: Endgame (Last 2 rounds: r-1 and r)

**Always DEFECT**

*Rationale:* No future rounds exist to incentivize others' cooperation. By standard backward induction, defection is strictly dominant. Even if I've been occasionally cooperating to sustain exploitation, there's no reason to continue.

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase: always defect
    if round <= 2:
        return DEFECT
    
    # Calculate cooperation rate of others
    total_other_cooperations = sum(cooperations by players ≠ me across all rounds)
    total_other_decisions = (n - 1) × (round - 1)
    coop_rate = total_other_cooperations / total_other_decisions
    
    # Calculate previous round's cumulative coop_rate for trend detection
    if round > 3:
        prev_coop_rate = (total_other_cooperations - last_round_cooperations) / ((n-1) × (round-2))
        if coop_rate < prev_coop_rate - 0.2:
            return DEFECT  # Punish declining cooperation
    
    # Main exploitation logic
    if coop_rate > 0.6:
        return DEFECT  # Exploit cooperative environment
    
    if coop_rate >= 0.3:
        prob_coop = (coop_rate - 0.3) × 0.5  # ranges from 0 to 0.15
        return COOPERATE with probability prob_coop, else DEFECT
    
    return DEFECT  # Low cooperation environment
```

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| First round | DEFECT | Safe information gathering |
| Last round | DEFECT | No future retaliation possible |
| n = 2 | Follow same rules | Strategy still valid for dyads |
| All opponents defected so far | DEFECT | No one to exploit |
| All opponents cooperated so far | DEFECT | Maximum exploitation opportunity |
| r = 2 (minimum rounds) | DEFECT both rounds | Both are "endgame" |
| r = 3 | DEFECT all rounds | Rounds 1-2 are probing, round 3 is endgame |

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Avoids being the sucker
2. **Free-rides on cooperators** - When others cooperate heavily, I defect to maximize personal gain
3. **Probabilistic cooperation is bait** - The occasional cooperation in medium-cooperation environments is designed to prevent complete collapse, keeping some "prey" cooperating
4. **Punishes trend reversals** - If the group starts catching on and defecting more, I defect immediately rather than trying to rebuild cooperation
5. **Endgame defection** - No sentimentality; pure backward induction in final rounds
'''

description_EXPLOITATIVE_13 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**, adapting behavior based on observed population tendencies.

## Decision Framework

### Key Metrics Tracked

1. **Population Cooperation Rate (PCR)**: Rolling average of cooperation frequency across all opponents over recent rounds
2. **Individual Cooperation Profiles**: Per-opponent cooperation history
3. **Round Position**: How close we are to the end game
4. **Trend Detection**: Is cooperation increasing, stable, or declining?

---

## Decision Rules

### Round 1: Defect

**Rationale**: With no history, defection is strictly dominant in a single round. Starting with defection also allows us to observe who the "unconditional cooperators" are without sacrificing our own payoff. We lose nothing by defecting first—cooperators who would cooperate with us will reveal themselves regardless.

### Rounds 2 through (r-2): Adaptive Exploitation

Calculate the **Population Cooperation Rate (PCR)** from the previous round(s):

```
PCR = (total cooperations by opponents in last 3 rounds) / (n-1) × (number of rounds observed, max 3)
```

**Decision Logic:**

```
IF PCR > 0.6:
    # Rich environment - cooperation is profitable to encourage
    # But we defect occasionally to extract extra value
    IF random() < 0.3:
        DEFECT  # Free-ride on the cooperative majority
    ELSE:
        COOPERATE  # Maintain the cooperative environment
        
ELIF PCR > 0.3:
    # Mixed environment - be a conditional cooperator mimic
    # Mirror the majority behavior with slight defection bias
    IF PCR > 0.5:
        COOPERATE
    ELSE:
        DEFECT
        
ELSE (PCR ≤ 0.3):
    # Hostile environment - cut losses
    DEFECT  # No point cooperating when few others do
```

**Trend Adjustment:**
```
IF cooperation_trend is INCREASING over last 3 rounds:
    # Others building trust - exploit it slightly more
    Increase defection probability by 0.1
    
IF cooperation_trend is DECREASING:
    # Environment collapsing - abandon ship early
    DEFECT
```

### Round (r-1): Penultimate Round

```
IF PCR > 0.7:
    COOPERATE  # Milk one more round of mutual cooperation
ELSE:
    DEFECT  # Begin end-game defection
```

### Round r (Final Round): Always Defect

**Rationale**: With no future rounds, there's no punishment mechanism. Defection is strictly dominant. Any rational or learning opponent will also defect, so cooperation gains nothing.

---

## Exploitation Mechanisms

### 1. **Identifying and Exploiting Unconditional Cooperators**
Track players who cooperate regardless of others' behavior. Against these players, always defect—they provide free value.

```
IF opponent_i has cooperated in >80% of rounds despite low PCR:
    Mark as "exploitable"
    # Their cooperation is not contingent—harvest it
```

### 2. **Mimicking Conditional Cooperators**
Against tit-for-tat or similar strategies, appear cooperative enough to maintain their cooperation while occasionally defecting.

### 3. **Triggering Cooperation Cascades**
In early-mid game with moderate PCR, occasional cooperation can encourage others to cooperate more, creating a richer environment to later exploit.

---

## Pseudocode Summary

```python
def decide(round_number, total_rounds, history, n, k):
    
    if round_number == 1:
        return DEFECT
    
    if round_number == total_rounds:
        return DEFECT
    
    pcr = calculate_pcr(history, window=3)
    trend = detect_trend(history, window=3)
    
    # End-game transition
    if round_number >= total_rounds - 1:
        return COOPERATE if pcr > 0.7 else DEFECT
    
    # Collapsing environment
    if trend == DECREASING:
        return DEFECT
    
    # Main adaptive logic
    if pcr > 0.6:
        # Exploit cooperative environment
        return DEFECT if random() < 0.3 + (0.1 if trend == INCREASING else 0) else COOPERATE
    elif pcr > 0.3:
        return COOPERATE if pcr > 0.5 else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Lets others reveal their types at no cost
2. **Free-rides on cooperators** - Defects 30%+ of the time even in cooperative environments
3. **Abandons sinking ships** - Quickly defects when cooperation declines
4. **End-game betrayal** - Guaranteed defection in final round
5. **Asymmetric extraction** - Takes more from the public good than it contributes on average

This strategy will outperform pure cooperators (by exploiting them) and avoid the worst losses against defectors (by matching them), while adapting fluidly to mixed populations.
'''

description_EXPLOITATIVE_11 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy is designed to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but we can exploit cooperators by appearing cooperative enough to sustain their contributions while defecting more than we cooperate.

## Strategy Overview

The strategy operates in three phases and uses statistical tracking to classify the opponent population and adapt accordingly.

---

## Phase 1: Probing Phase (Rounds 1 to `probe_length`)

**Purpose:** Gather information about opponent tendencies before committing to a strategy.

**`probe_length`** = max(2, floor(r / 10))

**Decision Rule:**
- **Round 1:** DEFECT
- **Subsequent probe rounds:** Alternate D, C, D, C...

**Rationale:** Starting with defection protects against immediate exploitation. Alternating reveals how opponents respond to both cooperation and defection, providing calibration data.

---

## Phase 2: Exploitation Phase (Rounds `probe_length + 1` to `r - endgame_length`)

**Core Metric: Cooperation Rate (CR)**

After each round, calculate:
```
CR = (total cooperations observed from all opponents) / (total opponent decisions observed)
```

**Decision Rules Based on CR:**

| CR Range | Classification | Action | Logic |
|----------|---------------|--------|-------|
| CR ≥ 0.7 | "Cooperative Pool" | DEFECT with probability 0.8, COOPERATE with probability 0.2 | Exploit the cooperators; occasional C keeps them hopeful |
| 0.4 ≤ CR < 0.7 | "Mixed Pool" | Probabilistic TFT: Match previous round's majority action, but defect 20% more often | Blend in while skimming extra value |
| CR < 0.4 | "Hostile Pool" | DEFECT always | No point cooperating; minimize losses |

**Conditional Adjustment - Trend Detection:**

Calculate `recent_CR` using only the last max(3, floor(r/5)) rounds.

- If `recent_CR - CR > 0.15` (cooperation increasing): Increase cooperation probability by 0.1 to encourage the trend, then exploit later
- If `CR - recent_CR > 0.15` (cooperation collapsing): Switch to pure DEFECT immediately

**Punishment Mechanism:**

Track if cooperation rate drops significantly (>25%) in any round compared to the previous round:
- If drop detected: DEFECT for the next 2 rounds regardless of other rules (punish and signal)

---

## Phase 3: Endgame Phase (Last `endgame_length` rounds)

**`endgame_length`** = max(1, floor(r / 8))

**Decision Rule:** DEFECT unconditionally

**Rationale:** With finite rounds and no future interaction, there's no incentive to maintain reputation. Extract maximum value in the unraveling phase. Sophisticated opponents will do the same; naive cooperators are free value.

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    probe_length = max(2, floor(r / 10))
    endgame_length = max(1, floor(r / 8))
    
    # Phase 3: Endgame
    if round > r - endgame_length:
        return DEFECT
    
    # Phase 1: Probing
    if round <= probe_length:
        if round == 1:
            return DEFECT
        else:
            return COOPERATE if (round % 2 == 0) else DEFECT
    
    # Phase 2: Exploitation
    CR = calculate_cooperation_rate(history)
    recent_CR = calculate_recent_cooperation_rate(history, window=max(3, floor(r/5)))
    
    # Check for sudden collapse
    if previous_round_had_cooperation_drop(history, threshold=0.25):
        punishment_counter = 2
    
    if punishment_counter > 0:
        punishment_counter -= 1
        return DEFECT
    
    # Trend adjustment
    trend_bonus = 0
    if recent_CR - CR > 0.15:
        trend_bonus = 0.1
    elif CR - recent_CR > 0.15:
        return DEFECT
    
    # Main decision based on CR
    if CR >= 0.7:
        return COOPERATE if random() < (0.2 + trend_bonus) else DEFECT
    elif CR >= 0.4:
        majority_last_round = get_majority_action(history, last_round)
        base_coop_prob = 0.5 if majority_last_round == COOPERATE else 0.3
        return COOPERATE if random() < (base_coop_prob + trend_bonus) else DEFECT
    else:
        return DEFECT
```

---

## Edge Case Handling

| Scenario | Handling |
|----------|----------|
| **r = 2** | Round 1: DEFECT, Round 2: DEFECT (pure exploitation) |
| **n = 2** | Strategy works identically; CR is just one opponent |
| **k very close to n** | Strategy still exploits; even with high k, defection while others cooperate is optimal |
| **All opponents defect from start** | CR stays low; we defect throughout, matching Nash equilibrium |
| **All opponents cooperate throughout** | We mostly defect, occasionally cooperate to sustain their behavior, extracting ~80% free-rider value |

---

## Why This Strategy is Exploitative

1. **Asymmetric reciprocity:** We cooperate less than the population average, always skimming value
2. **Information extraction:** Probing phase gathers intel without committing
3. **Endgame betrayal:** Guaranteed defection when reputation no longer matters
4. **Predatory targeting:** Higher exploitation rate against more cooperative pools
5. **Self-protection:** Pure defection against hostile environments limits downside
'''

description_EXPLOITATIVE_14 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single shot—but repeated play creates opportunities to exploit those who cooperate predictably.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit cooperative players.

---

## Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Goal:** Gather information about opponent tendencies while minimizing personal contribution.

### Decision Rule:
- **Round 1:** Always **DEFECT**
- **Rounds 2 to ⌈r/5⌉:** **DEFECT** with probability 0.8, **COOPERATE** with probability 0.2

### Rationale:
- Defecting early lets us free-ride on any unconditional cooperators
- Occasional cooperation prevents being immediately classified as a pure defector by conditional cooperators
- We observe who cooperates despite defection (exploitable targets)

---

## Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-2)

**Goal:** Maximize extraction based on observed opponent behavior.

### Opponent Classification (updated each round):

For each opponent j, calculate their **cooperation rate** over observed history:
```
coop_rate_j = (times j cooperated) / (rounds played)
```

Classify the group:
- **Sucker Count:** Number of opponents with coop_rate > 0.6
- **Conditional Count:** Number of opponents with 0.3 ≤ coop_rate ≤ 0.6
- **Defector Count:** Number of opponents with coop_rate < 0.3

### Decision Rule:

```
Calculate: expected_cooperators = Σ(coop_rate_j) for all opponents j

If expected_cooperators ≥ (n-1) × 0.4:
    # Enough suckers to exploit
    DEFECT
    
Elif expected_cooperators ≥ (n-1) × 0.25:
    # Mixed environment - conditional cooperation to maintain some cooperation
    If MY cooperation rate in last 3 rounds < group average cooperation rate:
        COOPERATE with probability 0.3
    Else:
        DEFECT
        
Else:
    # Low cooperation environment - no point contributing
    DEFECT
```

### Adaptive Adjustment:

Every 3 rounds, check if total payoff is below `rounds_played × 1.0` (the defection baseline):
- If underperforming: Increase defection probability by 0.1
- This prevents being exploited by other sophisticated strategies

---

## Phase 3: Endgame (Last 2 rounds: r-1 and r)

**Goal:** Pure extraction—no future rounds means no reason to maintain reputation.

### Decision Rule:
- **Always DEFECT** in the final 2 rounds

### Rationale:
- Backward induction: No future to incentivize cooperation
- Even if we've been cooperating, defecting here maximizes final extraction
- The second-to-last round defection catches opponents who only defect on the very last round

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| r ≤ 3 (very short game) | DEFECT every round |
| n = 2 (two players) | Pure defection (k < n means mutual defection dominates) |
| k very close to n | Slightly increase cooperation probability in Phase 2 (higher returns to cooperation) |
| All opponents defecting | DEFECT (no point contributing alone) |
| All opponents cooperating | DEFECT (maximum free-riding opportunity) |

---

## Pseudocode Summary

```python
def adaptive_predator(round_num, total_rounds, n, k, history):
    
    # Edge case: very short game
    if total_rounds <= 3:
        return DEFECT
    
    # Phase 3: Endgame
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # Phase 1: Probing
    probe_end = ceil(total_rounds / 5)
    if round_num == 1:
        return DEFECT
    if round_num <= probe_end:
        return DEFECT if random() < 0.8 else COOPERATE
    
    # Phase 2: Exploitation
    opponent_coop_rates = [calc_coop_rate(opp, history) for opp in opponents]
    expected_cooperators = sum(opponent_coop_rates)
    
    if expected_cooperators >= (n-1) * 0.4:
        return DEFECT  # Exploit the cooperators
    elif expected_cooperators >= (n-1) * 0.25:
        my_recent_rate = my_coop_rate_last_3_rounds(history)
        group_rate = mean(opponent_coop_rates)
        if my_recent_rate < group_rate:
            return COOPERATE if random() < 0.3 else DEFECT
        return DEFECT
    else:
        return DEFECT  # No one to exploit
```

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Always conditions on expected returns
2. **Free-rides aggressively** - Defects when others cooperate
3. **Endgame betrayal** - Abandons any cooperative pretense in final rounds
4. **Information asymmetry** - Uses probing to identify targets while revealing minimal intent
5. **Robust to defectors** - Doesn't waste contributions in hostile environments
'''

description_EXPLOITATIVE_12 = '''
# Exploitative Strategy: "Predatory Threshold Tracker"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors always earn more than cooperators in any given round. The goal is to maximize extraction from cooperative opponents while minimizing losses against defectors. We cooperate only when it's instrumentally useful to maintain a cooperative environment worth exploiting.

## Strategy Overview

The strategy operates in three phases:
1. **Probe Phase**: Brief initial testing to gauge opponent population
2. **Exploitation Phase**: Adaptive defection with calculated cooperation to sustain the "herd"
3. **Endgame Phase**: Pure defection when future rounds can't punish us

---

## Detailed Decision Rules

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: Never cooperate without information. If others cooperate, we profit maximally. If others defect, we lose nothing compared to cooperating.

**Round 2: Conditional**
- If cooperation rate in Round 1 ≥ 50%: **COOPERATE** (invest in maintaining the cooperative pool)
- If cooperation rate in Round 1 < 50%: **DEFECT** (not enough suckers to sustain)

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate two key metrics each round:

```
cooperation_rate = (number of cooperators in previous round) / n
trend = cooperation_rate(t-1) - cooperation_rate(t-2)  // positive = increasing cooperation
```

**Decision Rule:**

```
IF cooperation_rate < k/n THEN:
    DEFECT  // Public good isn't worth sustaining
    
ELSE IF cooperation_rate > 0.7 THEN:
    DEFECT  // Plenty of cooperators to exploit; free-ride heavily
    
ELSE IF cooperation_rate is in [k/n, 0.7] THEN:
    // Cooperation is moderate - need to help sustain it
    IF trend < -0.1 THEN:
        COOPERATE with probability 0.4  // Cooperation declining; occasionally prop it up
    ELSE IF trend > 0.1 THEN:
        DEFECT  // Cooperation rising; exploit the wave
    ELSE:
        COOPERATE with probability 0.25  // Stable; minimal investment to maintain
```

**Adaptive Threshold Adjustment:**

Every 5 rounds, if my cumulative payoff is below the theoretical "all-defect" baseline (rounds played × 1):
- Increase defection probability by 0.1 across all conditions
- Rationale: If exploitation isn't working, cut losses

### Phase 3: Endgame Phase (Final 2 rounds: r-1 and r)

**DEFECT unconditionally**
- No future punishment possible
- Standard backward induction applies
- Even if we've been "cooperative," there's no tomorrow to reward it

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (minimum players) | More aggressive defection; cooperate only if opponent cooperated last 2 rounds | Bilateral games are more sensitive; defection is safer |
| k very close to 1 | Default to DEFECT almost always | Public good multiplier too weak to justify cooperation |
| k close to n | Slightly increase cooperation probability (+0.15) | Higher returns make cooperation pool more valuable to sustain |
| r ≤ 4 (very short game) | DEFECT all rounds | Not enough time for reputation/conditioning to matter |
| Everyone defected last round | DEFECT | No cooperative pool to exploit; wait for others to restart |
| Everyone cooperated last round | DEFECT | Maximum exploitation opportunity |
| Only I defected last round | COOPERATE once | Signal that I can cooperate; prevent total collapse if others are conditional cooperators |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    
    # Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    # Round 1: always defect (probe)
    if round == 1:
        return DEFECT
    
    # Round 2: conditional on first round
    if round == 2:
        return COOPERATE if coop_rate(history, round-1) >= 0.5 else DEFECT
    
    # Short games: just defect
    if r <= 4:
        return DEFECT
    
    # Main exploitation phase
    coop_rate = coop_rate(history, round-1)
    trend = coop_rate(history, round-1) - coop_rate(history, round-2)
    
    if coop_rate < k/n:
        return DEFECT
    elif coop_rate > 0.7:
        return DEFECT
    else:
        if trend < -0.1:
            return COOPERATE with probability 0.4
        elif trend > 0.1:
            return DEFECT
        else:
            return COOPERATE with probability 0.25
```

---

## Why This Strategy Exploits Effectively

1. **Never cooperates naively**: First-round defection captures maximum surplus from any cooperators
2. **Sustains the herd strategically**: Minimal cooperation investment keeps cooperative opponents from abandoning cooperation entirely
3. **Tracks environment dynamically**: Responds to actual opponent behavior, not assumptions
4. **Exploits endgame ruthlessly**: No wasted cooperation when punishment is impossible
5. **Parameter-aware**: Adjusts to game economics (k/n ratio determines when public good is valuable)

The strategy treats other players as resources to be managed, not partners to coordinate with.
'''

description_EXPLOITATIVE_15 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round—but repeated play creates opportunities to exploit patterns and punish/reward behavior to manipulate opponents into cooperating while we defect.

## Strategy Overview

The strategy operates in three phases and continuously classifies opponents to exploit their behavioral tendencies.

---

## Phase 1: Probing Phase (Rounds 1-3)

**Objective:** Gather information about opponent behavior with minimal cost.

### Round 1: Defect
- Rationale: Never cooperate without information. Defection is safe and reveals who the "suckers" (unconditional cooperators) are.

### Rounds 2-3: Conditional Probing
- If cooperation rate in previous round was ≥ 60%: **Defect** (exploit the cooperators)
- If cooperation rate was between 30-60%: **Cooperate once** to test if opponents are conditional cooperators who can be "farmed"
- If cooperation rate was < 30%: **Defect** (not enough cooperators to matter)

---

## Phase 2: Exploitation Phase (Rounds 4 through r-2)

**Objective:** Maximize payoff by exploiting identified patterns.

### Opponent Classification (updated each round)

For each opponent j, calculate their **cooperation rate** over observed history:
- **Sucker** (coop rate > 80%): Unconditional cooperator → always exploit
- **Conditional** (coop rate 40-80%): Responds to group behavior → manipulate
- **Predator** (coop rate < 40%): Likely exploiting others → don't feed them

### Decision Rule

```
Calculate: expected_cooperators = Σ(cooperation_rate of each opponent)

If expected_cooperators ≥ (n-1) × 0.5:
    # Enough suckers to exploit
    DEFECT
    
Else if expected_cooperators ≥ (n-1) × 0.3 AND my_recent_coop_rate < 0.3:
    # I've been defecting a lot; cooperate once to keep conditional 
    # cooperators engaged (so they keep contributing for me to exploit)
    COOPERATE
    
Else:
    # Not enough cooperators to matter
    DEFECT
```

### Exploitation Refinements

1. **Sucker Farming:** If ≥50% of opponents are Suckers, always defect—they'll keep contributing regardless.

2. **Conditional Cooperator Manipulation:** If most opponents are Conditional types, occasionally cooperate (1 in every 4-5 rounds) to keep them cooperating, then defect the rest.

3. **Predator Standoff:** If ≥70% of opponents are Predators, always defect—no point cooperating when no one else will.

---

## Phase 3: Endgame (Final 2 rounds)

**Objective:** Extract final value with no concern for future consequences.

### Round r-1 (Second to last): Defect
- Rationale: Opponents may still cooperate hoping to influence the final round.

### Round r (Final round): Defect
- Rationale: No future to consider. Pure dominant strategy.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Always Defect | With only one opponent, manipulation is limited; defection dominates |
| r ≤ 3 | Always Defect | Too few rounds to build exploitable patterns |
| k very close to n | Slightly increase cooperation threshold | Higher k means cooperation is more valuable if reciprocated |
| All opponents defected last 3 rounds | Defect | No one to exploit |
| Single cooperator remaining | Defect | Free ride on the sucker |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # First round - always defect
    if round == 1:
        return DEFECT
    
    # Calculate opponent statistics
    for each opponent j:
        coop_rate[j] = (times j cooperated) / (rounds observed)
    
    expected_coops = sum(coop_rate)
    my_recent_coop_rate = my cooperations in last 3 rounds / 3
    
    # Probing phase (rounds 2-3)
    if round <= 3:
        if last_round_coop_rate >= 0.6:
            return DEFECT
        else if last_round_coop_rate >= 0.3:
            return COOPERATE  # probe once
        else:
            return DEFECT
    
    # Exploitation phase
    sucker_count = count opponents with coop_rate > 0.8
    
    # Heavy exploitation mode
    if sucker_count >= (n-1) * 0.5:
        return DEFECT
    
    # Standard exploitation
    if expected_coops >= (n-1) * 0.5:
        return DEFECT
    
    # Maintenance cooperation (keep conditionals engaged)
    if expected_coops >= (n-1) * 0.3 AND my_recent_coop_rate < 0.25:
        return COOPERATE
    
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Cooperation is only used as a tool to manipulate others into cooperating more.

2. **Classifies and targets victims** - Identifies "suckers" and exploits them relentlessly.

3. **Minimal cooperation investment** - Cooperates just enough to keep conditional cooperators engaged, then defects to harvest their contributions.

4. **Ruthless endgame** - No pretense of cooperation when punishment becomes impossible.

5. **Robust to opponent types** - Doesn't waste cooperation on fellow predators, maximizes extraction from cooperators.
'''

description_EXPLOITATIVE_13 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **detect and exploit cooperative populations while protecting against mutual defection spirals**. I'll cooperate only when it's profitable to "invest" in maintaining a cooperative environment I can later exploit.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous adaptation based on observed cooperation rates.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Purpose:** Gather information about opponent tendencies while minimizing exposure.

**Round 1:** 
- **DEFECT** — Never cooperate blind. Let others reveal their strategies first.

**Rounds 2 to ⌈r/5⌉:**
- Calculate cooperation rate from previous round: `coop_rate = cooperators / n`
- If `coop_rate ≥ 0.5`: **COOPERATE** (invest in maintaining cooperative environment)
- If `coop_rate < 0.5`: **DEFECT** (not enough cooperators to make cooperation worthwhile)

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Purpose:** Maximize extraction from cooperative players while maintaining just enough cooperation to prevent total collapse.

**Decision Rule:**
```
Let coop_rate = (cooperators in previous round) / n
Let trend = coop_rate - (coop_rate from 2 rounds ago)

If coop_rate ≥ 0.6:
    # High cooperation - EXPLOIT
    DEFECT with probability 0.7
    COOPERATE with probability 0.3
    
Else if coop_rate ≥ 0.4:
    # Medium cooperation - MAINTAIN
    If trend > 0 (cooperation rising):
        DEFECT  # Exploit the upswing
    Else if trend < 0 (cooperation falling):
        COOPERATE  # Prevent collapse
    Else:
        DEFECT with probability 0.5
        
Else if coop_rate ≥ 0.2:
    # Low cooperation - CONDITIONAL INVEST
    COOPERATE with probability 0.4
    # Try to restart cooperation cycle
    
Else:
    # Very low cooperation - ABANDON
    DEFECT  # Not worth investing
```

**Adjustment based on k/n ratio:**
- If `k/n > 0.4`: Shift all thresholds down by 0.1 (cooperation is more valuable)
- If `k/n < 0.25`: Shift all thresholds up by 0.1 (cooperation is less valuable)

### Phase 3: Endgame (Final ⌈r/10⌉ rounds)

**Purpose:** Extract maximum value as future punishment becomes impossible.

**Second-to-last and earlier endgame rounds:**
- If `coop_rate ≥ 0.7`: **DEFECT** (exploit the cooperators)
- Otherwise: Match the majority action from previous round

**Final Round:**
- **ALWAYS DEFECT** — No future consequences, pure dominant strategy.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | No information; avoid being exploited |
| Final round | DEFECT | Dominant strategy with no future |
| n = 2 | Use stricter thresholds (+0.2) | Single opponent makes cooperation riskier |
| k very close to n | Slightly more cooperative | Higher returns justify risk |
| All previous rounds had 0 cooperators | DEFECT | Environment is hostile |
| All previous rounds had n cooperators | DEFECT | Maximum exploitation opportunity |
| r ≤ 5 (very short game) | DEFECT all rounds | Insufficient time for reputation building |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    if r <= 5:
        return DEFECT
    
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    coop_rate = history[round-1].cooperators / n
    threshold_adjust = 0.1 if k/n < 0.25 else (-0.1 if k/n > 0.4 else 0)
    
    # Endgame phase
    if round > r - ceil(r/10):
        if coop_rate >= 0.7:
            return DEFECT
        else:
            return MAJORITY(history[round-1])
    
    # Probing phase
    if round <= ceil(r/5):
        if coop_rate >= (0.5 + threshold_adjust):
            return COOPERATE
        else:
            return DEFECT
    
    # Exploitation phase
    trend = coop_rate - (history[round-2].cooperators / n) if round > 2 else 0
    
    if coop_rate >= (0.6 + threshold_adjust):
        return RANDOM(DEFECT=0.7, COOPERATE=0.3)
    elif coop_rate >= (0.4 + threshold_adjust):
        if trend > 0: return DEFECT
        elif trend < 0: return COOPERATE
        else: return RANDOM(0.5, 0.5)
    elif coop_rate >= (0.2 + threshold_adjust):
        return RANDOM(DEFECT=0.6, COOPERATE=0.4)
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** — Forces others to take risks
2. **Defects more when cooperation is high** — Extracts maximum surplus from cooperators
3. **Uses probabilistic defection** — Harder to detect and punish than pure defection
4. **Endgame defection** — Exploits backward induction
5. **Invests minimally** — Only cooperates enough to prevent total cooperation collapse
6. **Adapts to parameter k/n** — Extracts more when cooperation is valuable, abandons quickly when it isn't
'''

description_EXPLOITATIVE_16 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but cooperative environments are more profitable to exploit than mutual defection. Therefore, I want to:

1. **Identify and exploit cooperators** by defecting when others cooperate
2. **Avoid being the sucker** by detecting and matching defectors
3. **Encourage cooperation in others** just enough to exploit it

---

## Strategy Specification

### Key Variables Tracked

- `coop_rate[i]` = cooperation rate of player i over all observed rounds
- `global_coop_rate` = overall cooperation rate across all players
- `round_number` = current round (1-indexed)
- `rounds_remaining` = r - round_number

### Decision Rules

#### Round 1: Probe with Cooperation
**Action: COOPERATE**

*Rationale:* This serves as a probe. It signals potential cooperativeness to trigger cooperation from conditional cooperators, while giving me baseline data on opponent behavior. The cost is small (one round), and the information gained is valuable.

#### Last Round (round = r): Always Defect
**Action: DEFECT**

*Rationale:* No future rounds exist to punish defection. Pure game theory dictates defection. Any rational opponent will also defect, so there's no exploitation opportunity to preserve.

#### Penultimate Round (round = r-1): Almost Always Defect
**Action: DEFECT** (unless global_coop_rate > 0.8)

*Rationale:* Sophisticated opponents will defect in the last round, and some will backward-induct to defect here too. Only maintain cooperation facade if the population is highly cooperative and might not backward-induct.

#### Middle Rounds (2 ≤ round < r-1): Adaptive Exploitation

```
Calculate: expected_cooperators = Σ(coop_rate[i]) for all other players

IF expected_cooperators >= (n-1) * 0.6:
    # Cooperative environment - EXPLOIT IT
    ACTION: DEFECT
    
ELIF expected_cooperators >= (n-1) * 0.3:
    # Mixed environment - Conditional strategy
    IF my cooperation in last round AND global_coop_rate dropped:
        ACTION: DEFECT  # Others aren't reciprocating
    ELIF I defected last round AND global_coop_rate stayed high:
        ACTION: DEFECT  # Free riding is working
    ELSE:
        ACTION: COOPERATE with probability = global_coop_rate * 0.5
        # Occasionally cooperate to prevent total collapse
        
ELSE:
    # Hostile environment - No point cooperating
    ACTION: DEFECT
```

### Refinement: Sucker Detection

After round 3, identify "suckers" (players with coop_rate > 0.7 despite others defecting):

```
IF count(suckers) >= n/3:
    # Enough exploitable players exist
    Bias heavily toward DEFECT (override to defect 90% of the time)
```

### Refinement: Collapse Prevention

```
IF global_coop_rate was > 0.5 but dropped below 0.3 in last 2 rounds:
    # Cooperation is collapsing - get final exploitation in
    ACTION: DEFECT for next 2 rounds, then reassess
```

---

## Pseudocode Summary

```python
def decide(game_params, history):
    n, r, k = game_params
    current_round = len(history) + 1
    
    # Edge cases
    if current_round == 1:
        return COOPERATE
    
    if current_round == r:
        return DEFECT
    
    if current_round == r - 1:
        if global_coop_rate(history) > 0.8:
            return COOPERATE
        return DEFECT
    
    # Calculate metrics
    expected_coop = sum(player_coop_rate(history, i) for i in other_players)
    coop_threshold_high = (n - 1) * 0.6
    coop_threshold_low = (n - 1) * 0.3
    
    # Main logic
    if expected_coop >= coop_threshold_high:
        return DEFECT  # Exploit cooperative environment
    
    elif expected_coop >= coop_threshold_low:
        # Mixed - be unpredictable but lean toward defection
        if random() < global_coop_rate(history) * 0.4:
            return COOPERATE
        return DEFECT
    
    else:
        return DEFECT  # Hostile environment
```

---

## Why This Strategy is Exploitative

1. **Asymmetric response**: Cooperates just enough to encourage others, then defects to harvest the benefits
2. **Sucker identification**: Specifically targets players who cooperate regardless of others' behavior
3. **Endgame ruthlessness**: No sentimentality in final rounds
4. **Environment-aware**: Defects more in cooperative environments (more to gain) and defects in hostile ones (nothing to lose)
5. **Unpredictability in mixed states**: Makes it harder for opponents to model and counter-exploit
'''

description_EXPLOITATIVE_14 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The exploitative mindset recognizes a fundamental asymmetry in this game: cooperators create value that can be extracted by defectors. My strategy aims to **maximize extraction from cooperative opponents while minimizing losses against other defectors**. The key insight is that since k < n, defection always yields a higher individual payoff than cooperation *given the same actions by others*. The only reason to ever cooperate is to manipulate others into cooperating so I can defect against them later.

## Strategy Overview

This strategy operates in three phases:
1. **Probe Phase**: Gather information about opponent tendencies
2. **Exploit Phase**: Maximize extraction based on learned behavior
3. **Endgame Phase**: Pure defection when future rounds can't influence behavior

---

## Detailed Decision Rules

### Round Classification

```
early_rounds = rounds 1 to min(3, floor(r/4))
endgame_rounds = rounds max(1, r-2) to r
middle_rounds = everything else
```

### Key Metrics (Updated Each Round)

```
cooperation_rate = (total C plays by others) / (total plays by others)
recent_cooperation_rate = cooperation_rate in last 3 rounds
exploitability_score = fraction of opponents who cooperated after seeing defection
```

### Decision Rules

#### Round 1: Defect
- **Rationale**: No information yet, and defection is the dominant single-round strategy. Starting with cooperation signals weakness and invites exploitation. By defecting first, I establish that I cannot be taken advantage of, while gathering data on who cooperates unconditionally.

#### Early Rounds (2 to early_round_threshold): Conditional Probe

```
IF cooperation_rate > 0.5:
    # Environment has exploitable cooperators
    DEFECT (harvest the cooperation)
ELSE IF cooperation_rate > 0.3:
    # Mixed environment - probe with occasional cooperation
    COOPERATE with probability 0.3
ELSE:
    # Hostile environment of defectors
    DEFECT (no point cooperating)
```

#### Middle Rounds: Adaptive Exploitation

```
# Calculate expected value of cooperation vs defection

# If I defect: I get 1 + (k/n) * expected_cooperators
# If I cooperate: I get 0 + (k/n) * (expected_cooperators + 1)

# Defection advantage = 1 - (k/n) which is always positive since k < n

# So pure payoff logic says always defect, BUT...
# Cooperation might induce future cooperation from reactive opponents

IF in last 25% of middle_rounds:
    # Less time for manipulation to pay off
    DEFECT
ELSE IF recent_cooperation_rate > 0.6 AND exploitability_score > 0.4:
    # Many cooperators who keep cooperating despite my defection
    DEFECT (pure extraction mode)
ELSE IF recent_cooperation_rate > 0.4 AND exploitability_score < 0.3:
    # Cooperators exist but they punish defection
    # Occasional cooperation to keep them cooperating
    COOPERATE with probability 0.4
ELSE IF recent_cooperation_rate < 0.2:
    # Environment collapsed to mutual defection
    DEFECT (nothing to exploit)
ELSE:
    # Default: lean toward defection with occasional cooperation as bait
    COOPERATE with probability 0.2
```

#### Endgame (Last 2-3 Rounds): Pure Defection

```
ALWAYS DEFECT
```
- **Rationale**: No future rounds means no reason to maintain any cooperative pretense. This is the classic backward induction result - in finite games, the endgame unravels cooperation.

---

## Edge Cases

### Very Short Games (r ≤ 4)
- Round 1: Defect
- Rounds 2 to r-1: Defect (unless cooperation_rate > 0.7, then consider one cooperation to maintain the pool)
- Final round: Defect

### Very Long Games (r > 20)
- Extend probing phase slightly
- Be more willing to invest in occasional cooperation during middle rounds to maintain exploitable cooperators
- Still end with pure defection in final rounds

### High k Values (k approaching n)
- Cooperation becomes relatively less costly
- Slightly increase cooperation probability in conditional phases
- But never exceed 50% cooperation rate - we're exploiting, not cooperating

### Large n (many players)
- Individual actions matter less for others' decisions
- Lean more heavily toward defection
- My defection is less likely to trigger collective punishment

### Small n (few players, especially n=2)
- Actions highly visible and impactful
- Be more responsive to opponent patterns
- If opponent appears to be Tit-for-Tat: occasional cooperation to keep them cooperating, then defect on final rounds

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == r or round >= r - 1:  # Endgame
        return DEFECT
    
    if round == 1:  # First round
        return DEFECT
    
    coop_rate = calculate_cooperation_rate(history)
    recent_coop = recent_cooperation_rate(history, window=3)
    exploitability = calculate_exploitability(history)
    
    if round <= max(3, r // 4):  # Early rounds
        if coop_rate > 0.5:
            return DEFECT
        elif coop_rate > 0.3:
            return COOPERATE if random() < 0.3 else DEFECT
        else:
            return DEFECT
    
    else:  # Middle rounds
        if round > 0.75 * r:
            return DEFECT
        elif recent_coop > 0.6 and exploitability > 0.4:
            return DEFECT
        elif recent_coop > 0.4 and exploitability < 0.3:
            return COOPERATE if random() < 0.4 else DEFECT
        elif recent_coop < 0.2:
            return DEFECT
        else:
            return COOPERATE if random() < 0.2 else DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never initiates sustained cooperation**: Cooperation is only used tactically to manipulate others
2. **Extracts maximum value from unconditional cooperators**: Pure defection against those who cooperate regardless
3. **Manages conditional cooperators**: Just enough cooperation to keep them contributing, then harvests
4. **Clean exit**: Always defects at the end, capturing full value when reputation no longer matters
5. **Robust against fellow defectors**: Doesn't lose much against other exploitative strategies since it defaults to defection
'''

description_EXPLOITATIVE_17 = '''
# Exploitative Strategy: "Adaptive Threshold Defector"

## Core Philosophy

This strategy is fundamentally exploitative: it aims to maximize personal payoff by free-riding on cooperators while minimizing contributions. The key insight is that in a public goods game with k < n, defection always yields a higher individual payoff than cooperation *given the same actions by others*. The only reason to ever cooperate is to manipulate others into cooperating more, which we can then exploit.

## Strategy Overview

The strategy maintains a cooperation facade only when necessary to sustain a pool of cooperators to exploit. It aggressively defects whenever it can get away with it, and only "punishes" defectors by withdrawing cooperation when the public good has already collapsed (there's nothing left to exploit).

---

## Decision Rules

### Round 1: Defect
- **Rationale**: There's no history to signal with. Starting with defection reveals nothing about your exploitative nature (many strategies defect initially) while immediately capturing the free-rider advantage if any opponents cooperate.

### Final Round (round r): Defect
- **Rationale**: No future interactions exist to punish defection. This is the dominant strategy regardless of history.

### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Calculate the Cooperation Rate**
```
cooperation_rate = (total cooperations by all players in previous round) / n
```

**Step 2: Classify the Environment**

| Environment Type | Condition | Interpretation |
|------------------|-----------|----------------|
| Exploitable | cooperation_rate > 0.5 | Enough cooperators to free-ride on |
| Marginal | 0.2 ≤ cooperation_rate ≤ 0.5 | Cooperation pool is fragile |
| Collapsed | cooperation_rate < 0.2 | Nothing left to exploit |

**Step 3: Apply Decision Rule**

```
IF environment is "Exploitable":
    # Maximum exploitation opportunity
    DEFECT always
    
ELSE IF environment is "Marginal":
    # Need to occasionally cooperate to prevent total collapse
    # Cooperate with probability based on how close to collapse we are
    
    revival_probability = (0.5 - cooperation_rate) / 0.3  # Scales from 0 to 1
    
    # But never cooperate if we defected last round and got away with it
    IF I_defected_last_round AND cooperation_rate >= 0.3:
        DEFECT
    ELSE:
        Cooperate with probability = revival_probability * 0.5
        # (Cap at 50% to maintain exploitative edge)

ELSE IF environment is "Collapsed":
    # Attempt minimal revival to restart exploitation
    IF consecutive_collapsed_rounds >= 2:
        Cooperate with probability 0.3  # Token gesture
    ELSE:
        DEFECT  # Wait to see if others revive it first
```

---

## Exploitation Mechanisms

### 1. **Sucker Detection**
Track individual player cooperation rates:
```
player_coop_rate[i] = (player i's total cooperations) / (rounds played)
```
If any player has `player_coop_rate[i] > 0.7` after 3+ rounds, they're likely an unconditional cooperator or "sucker" — **always defect** as long as such players exist.

### 2. **Defection Momentum**
```
IF I_defected in 2+ consecutive rounds AND cooperation_rate stayed above 0.4:
    Continue defecting (I'm successfully free-riding)
```

### 3. **Late-Game Acceleration**
```
IF rounds_remaining <= 3:
    Increase defection probability by 30%
    # Others may still cooperate hoping to "teach" — exploit this
```

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, n, k):
    # Edge cases
    if round_num == 1:
        return DEFECT
    if round_num == total_rounds:
        return DEFECT
    
    # Calculate metrics
    last_round_coops = count_cooperations(history, round_num - 1)
    coop_rate = last_round_coops / n
    has_suckers = any(player_coop_rate(p, history) > 0.7 for p in players if rounds > 3)
    
    # Sucker exploitation
    if has_suckers:
        return DEFECT
    
    # Environment-based decision
    if coop_rate > 0.5:
        return DEFECT  # Exploit the cooperators
    
    elif coop_rate >= 0.2:
        if i_defected_last_round(history) and coop_rate >= 0.3:
            return DEFECT  # Got away with it, keep going
        revival_prob = min(0.5, (0.5 - coop_rate) / 0.3 * 0.5)
        return COOPERATE with probability revival_prob, else DEFECT
    
    else:  # Collapsed
        if consecutive_collapse_rounds(history) >= 2:
            return COOPERATE with probability 0.3, else DEFECT
        return DEFECT  # Let others try to revive first
    
    # Late game acceleration
    if total_rounds - round_num <= 3:
        # Override: 70% chance to defect regardless
        return DEFECT with probability 0.7
```

---

## Why This Strategy is Exploitative

1. **Default action is defection** — cooperation is the exception, not the rule
2. **Free-rides on cooperators** — defects precisely when others cooperate most
3. **Identifies and exploits "suckers"** — unconditional cooperators are targets
4. **Minimal reciprocity** — only cooperates to prevent complete collapse of the exploitable pool
5. **End-game defection** — guaranteed defection in final rounds
6. **Asymmetric response** — defects when others cooperate, sometimes cooperates when others defect (counter-intuitive but maintains the exploitation pool)

This strategy treats other players as resources to be harvested, not partners to cooperate with.
'''

description_EXPLOITATIVE_15 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but exploiting cooperative opponents yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and continuously estimates the "exploitability" of the opponent pool to calibrate between aggressive exploitation and protective defection.

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1:** Always **DEFECT**

- Rationale: Establish baseline. If others cooperate, we gain maximally. If others defect, we lose nothing compared to cooperating.

**Round 2:** Always **DEFECT**

- Rationale: Gather more data on opponent tendencies. Two rounds of observation reveals whether cooperation exists and whether it's reactive or unconditional.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **Cooperation Rate (CR)** from all observed rounds:
```
CR = (total cooperations by all other players) / (total actions by all other players)
```

Calculate the **Cooperation Trend (CT)**:
```
CT = (CR in last 2 rounds) - (CR in rounds before that)
```

**Decision Logic:**

```
IF CR > 0.6 AND CT >= 0:
    # Rich hunting ground - cooperators are abundant and stable
    DEFECT (exploit the cooperators)
    
ELSE IF CR > 0.4 AND CT > 0.1:
    # Cooperation is rising - could be conditional cooperators testing us
    # Occasionally cooperate to sustain the pool
    COOPERATE with probability min(0.3, CT)
    Otherwise DEFECT
    
ELSE IF CR <= 0.4 AND CT < -0.1:
    # Cooperation is collapsing - milk remaining value
    DEFECT
    
ELSE IF CR <= 0.2:
    # Barren environment - pure defection optimal
    DEFECT
    
ELSE:
    # Moderate cooperation, stable - defect but monitor
    DEFECT
```

**Reactive Adjustment:**

After any round where we cooperated:
```
IF (number of cooperators in that round) < n/3:
    # We were suckered - remember this
    Set BETRAYED_FLAG = true
    Next 3 rounds: unconditional DEFECT
```

### Phase 3: Endgame (Rounds r-1 and r)

**Round r-1:** **DEFECT**
- Rationale: Opponents may start defecting in anticipation of the end

**Round r (Final Round):** **DEFECT**
- Rationale: No future rounds to punish defection; dominant strategy is defect

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | No history; defection is risk-free |
| Last round | DEFECT | No future punishment possible |
| n = 2 | Follow standard rules but never cooperate | With only one opponent, any cooperation is easily exploited |
| All opponents defected so far | DEFECT | No benefit to unilateral cooperation |
| All opponents cooperated so far | DEFECT | Maximum exploitation opportunity |
| r ≤ 4 (very short game) | Always DEFECT | Insufficient rounds for reputation building to matter |
| k very close to n | Still DEFECT-biased | Even with high k, free-riding dominates |

---

## Pseudocode Summary

```python
def decide(round_number, history, n, r, k):
    # Endgame - always defect
    if round_number >= r - 1:
        return DEFECT
    
    # Probe phase - always defect
    if round_number <= 2:
        return DEFECT
    
    # Short game - always defect
    if r <= 4:
        return DEFECT
    
    # Calculate metrics
    CR = cooperation_rate(history, exclude_self=True)
    CT = cooperation_trend(history, window=2)
    
    # Check if we were recently betrayed after cooperating
    if betrayed_recently(history, lookback=3):
        return DEFECT
    
    # Exploitation logic
    if CR > 0.6 and CT >= 0:
        return DEFECT
    elif CR > 0.4 and CT > 0.1:
        if random() < min(0.3, CT):
            return COOPERATE
        return DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Avoids being the sucker
2. **Defects in known critical rounds** - First, last, and near-end rounds
3. **Treats cooperation as bait** - Only cooperates occasionally to sustain exploitable opponents
4. **Asymmetric responses** - Punishes betrayal harshly, rewards opponent cooperation with continued exploitation
5. **Adapts to environment** - Maximizes extraction from cooperative pools, minimizes losses in hostile ones
'''

description_EXPLOITATIVE_18 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and continuously estimates opponent cooperation rates to determine the optimal level of exploitation.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** Defect
- Rationale: Observe baseline cooperation levels without contributing. If others cooperate, I gain maximally. If they defect, I lose nothing compared to cooperating.

**Round 2:** Defect
- Rationale: Continue gathering information. Some strategies cooperate initially then adapt, so a second observation round helps distinguish unconditional cooperators from conditional ones.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **cooperation rate** after each round:
```
coop_rate = (total C plays by all opponents in all previous rounds) / 
            ((n-1) × rounds_played)
```

**Decision Rule:**

```
IF coop_rate > 0.6:
    Defect (exploit the cooperators - they provide the public good, I free-ride)
    
ELSE IF coop_rate > 0.3:
    Cooperate with probability p = (coop_rate - 0.3) / 0.3
    (Conditional cooperation to sustain some level of contributions)
    
ELSE IF coop_rate <= 0.3:
    Defect (not enough cooperators to sustain, cut losses)
```

**Adaptive Adjustment - Trend Detection:**

```
recent_coop_rate = cooperation rate in last 3 rounds
IF recent_coop_rate < coop_rate - 0.15:
    # Cooperation is collapsing, abandon ship
    Defect for next 2 rounds regardless of above rules
    
IF recent_coop_rate > coop_rate + 0.15:
    # Cooperation is recovering, continue exploiting
    Defect
```

### Phase 3: Endgame (Last 2 rounds: r-1 and r)

**Rounds r-1 and r:** Always Defect
- Rationale: No future rounds to incentivize cooperation. Backward induction makes defection dominant. Even if others might still cooperate hoping to maintain norms, exploitation is optimal.

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| **First round** | Defect | Gather information risk-free |
| **Last round** | Defect | No future consequences |
| **n = 2** | Always Defect | With only one opponent, k < n means k < 2, so mutual cooperation barely breaks even; exploitation or mutual defection is safer |
| **All opponents defected so far** | Defect | No benefit to being the sole cooperator |
| **All opponents cooperated so far** | Defect | Maximum exploitation opportunity |
| **Very short game (r ≤ 4)** | Always Defect | Not enough rounds for conditional cooperation to build; exploit or accept mutual defection |
| **Very long game (r > 20)** | Follow standard rules but increase exploitation threshold to 0.7 | More opportunities to exploit sustained cooperation |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if r <= 4:
        return DEFECT
    
    if round <= 2:
        return DEFECT
    
    if round >= r - 1:
        return DEFECT
    
    coop_rate = calculate_overall_coop_rate(history, n)
    recent_coop_rate = calculate_recent_coop_rate(history, n, window=3)
    
    # Trend detection
    if recent_coop_rate < coop_rate - 0.15:
        return DEFECT
    
    if recent_coop_rate > coop_rate + 0.15:
        return DEFECT  # Exploit recovery
    
    # Main exploitation logic
    if coop_rate > 0.6:
        return DEFECT
    else if coop_rate > 0.3:
        p = (coop_rate - 0.3) / 0.3
        return COOPERATE with probability p, else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Always lets others bear the cost of public good provision
2. **Free-rides on cooperators** - When cooperation is high, defects to maximize personal gain
3. **Abandons sinking ships** - Quickly defects when cooperation collapses
4. **Endgame defection** - Extracts maximum value when reputation no longer matters
5. **Probabilistic cooperation is strategic** - Only cooperates enough to potentially sustain exploitable cooperators, never out of altruism
'''

description_EXPLOITATIVE_16 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round—but we can exploit predictable cooperative behavior in others while contributing minimally ourselves.

## Decision Rules

### Round 1: Always Defect
- **Rationale**: No information exists yet. Defecting is the dominant single-round strategy and provides a baseline to observe others' tendencies without cost.

### Rounds 2 through (r-1): Conditional Exploitation

Calculate the **cooperation rate** of opponents from the previous round:
```
coop_rate = (number of opponents who played C in previous round) / (n - 1)
```

**Decision Rule:**

1. **If coop_rate ≥ threshold_high (0.6):** Play **D**
   - Rationale: There are enough suckers contributing. Free-ride maximally.

2. **If threshold_low (0.3) ≤ coop_rate < threshold_high:** Play **C with probability p**
   - p = (coop_rate - 0.3) / 0.3 (scales from 0 to 1)
   - Rationale: Maintain just enough cooperation to keep the cooperative ecosystem alive, but probabilistically defect to exploit it.

3. **If coop_rate < threshold_low (0.3):** Play **D**
   - Rationale: The public good is collapsing anyway. Don't throw good money after bad.

### Last Round (Round r): Always Defect
- **Rationale**: No future punishment is possible. Classical backward induction makes defection strictly dominant.

### Trend-Based Adjustment

Track cooperation trend over the last 3 rounds (when available):
```
trend = current_coop_rate - coop_rate_3_rounds_ago
```

- **If trend < -0.2 (cooperation collapsing):** Force **D** regardless of current rate
- **If trend > 0.2 (cooperation rising):** Reduce cooperation probability by 0.2
  - Rationale: Others are becoming more cooperative—exploit harder

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Last round: always defect
    if round == r:
        return D
    
    # First round: always defect
    if round == 1:
        return D
    
    # Calculate opponent cooperation rate from previous round
    opponent_coop_count = count_cooperators(history[round-1]) - my_action(history[round-1])
    coop_rate = opponent_coop_count / (n - 1)
    
    # Calculate trend if enough history
    if round >= 4:
        old_coop_rate = count_opponent_cooperators(history[round-3]) / (n - 1)
        trend = coop_rate - old_coop_rate
        
        if trend < -0.2:
            return D
        if trend > 0.2:
            exploitation_bonus = 0.2
        else:
            exploitation_bonus = 0
    else:
        exploitation_bonus = 0
    
    # Main decision logic
    threshold_high = 0.6
    threshold_low = 0.3
    
    if coop_rate >= threshold_high:
        return D  # Free-ride on cooperators
    
    elif coop_rate >= threshold_low:
        p = (coop_rate - threshold_low) / (threshold_high - threshold_low)
        p = max(0, p - exploitation_bonus)  # Reduce cooperation when trend is up
        if random() < p:
            return C
        else:
            return D
    
    else:
        return D  # Not enough cooperation to sustain
```

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| n = 2 | More aggressive defection (raise threshold_high to 0.8) | Single opponent is easier to read and exploit |
| r = 2 | Defect both rounds | Backward induction dominates |
| k close to n | Slightly more willing to cooperate (lower thresholds by 0.1) | Public good return is higher, worth occasional contribution |
| All opponents always defect | Permanent defection | No exploitation opportunity; minimize losses |
| All opponents always cooperate | Permanent defection | Maximum exploitation opportunity |

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Waits to see who the "marks" are
2. **Free-rides maximally** when cooperation is abundant
3. **Abandons ship early** when cooperation collapses
4. **End-game exploitation** - Guaranteed defection when punishment is impossible
5. **Trend exploitation** - Increases defection when others become more cooperative (extracting more from their generosity)
'''

description_EXPLOITATIVE_19 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation from others is valuable to exploit. My goal is to identify and milk cooperative environments while quickly abandoning cooperation when others defect.

---

## Strategy Overview

The strategy operates in three modes based on observed cooperation levels:

1. **Probe Mode** (Early rounds): Test the waters with minimal cooperation
2. **Exploit Mode**: Free-ride on cooperative populations
3. **Punish/Abandon Mode**: Defect against defecting populations

---

## Decision Rules

### Round 1: Always Defect
- **Rationale**: No information exists. Defection guarantees payoff ≥ 1, while cooperation risks getting 0 + k/n (which is less than 1 since k < n). Starting with defection also lets me observe who the "suckers" are without cost.

### Rounds 2 through (r-1): Adaptive Response

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Logic:**

```
IF coop_rate > (n - k) / (n - 1) THEN:
    # Enough cooperators that my defection still yields high returns
    DEFECT (exploit the cooperators)
    
ELSE IF coop_rate > 0.5 AND trending_up THEN:
    # Moderate cooperation, might build to exploitable level
    COOPERATE with probability = 0.3 (occasional cooperation to sustain others)
    DEFECT with probability = 0.7
    
ELSE IF coop_rate ≤ 0.5 THEN:
    # Not enough cooperators to exploit
    DEFECT (no point contributing to a failing public good)
```

**Threshold Explanation**: When `coop_rate > (n-k)/(n-1)`, my payoff from defecting exceeds my payoff from cooperating regardless of my choice. This is the pure exploitation zone.

### Last Round (Round r): Always Defect
- **Rationale**: No future rounds exist to punish my defection. Standard backward induction applies—defection strictly dominates.

---

## Refined Exploitation Heuristics

### Tracking "Sucker" Density
Maintain a count of players who have cooperated in ≥ 70% of rounds:
```
sucker_count = count of players with personal_coop_rate ≥ 0.7
```

**If sucker_count ≥ n/3**: Continue defecting (reliable exploitation target)
**If sucker_count < n/3**: Consider occasional cooperation (1 in 4 rounds) to prevent complete collapse

### Momentum Detection
```
trending_up = (coop_rate in round t) > (coop_rate in round t-1)
trending_down = (coop_rate in round t) < (coop_rate in round t-1)
```

- If **trending_down for 2+ consecutive rounds**: Lock into permanent defection
- If **trending_up**: Maintain current behavior (don't disrupt a good trend)

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Endgame: always defect
    if round == r:
        return DEFECT
    
    # Opening: always defect
    if round == 1:
        return DEFECT
    
    # Calculate cooperation metrics
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate = last_round_coops / n
    exploitation_threshold = (n - k) / (n - 1)
    
    # Pure exploitation zone
    if coop_rate > exploitation_threshold:
        return DEFECT
    
    # Moderate cooperation - occasionally sustain
    if coop_rate > 0.5 and is_trending_up(history):
        return COOPERATE with probability 0.3, else DEFECT
    
    # Low cooperation - abandon ship
    return DEFECT
```

---

## Edge Cases

| Situation | Action | Reason |
|-----------|--------|--------|
| n = 2 | Always defect | k < n means k < 2, so mutual cooperation yields < 2 while defection against cooperator yields > 1 |
| r = 2 | Defect both rounds | Round 1 = no info, Round 2 = last round |
| All defected last round | Defect | No cooperators to exploit |
| k very close to n | Slightly more willing to cooperate (probability 0.4 in moderate zone) | Higher returns from public good |

---

## Why This Strategy is Exploitative

1. **Never cooperates first**: Lets others take the risk
2. **Free-rides on cooperation**: Defects whenever cooperation levels are exploitable
3. **Abandons sinking ships**: Doesn't throw good money after bad
4. **Endgame defection**: Extracts final value without consequence
5. **Minimal sustaining cooperation**: Only cooperates enough to prevent total collapse when beneficial
'''

description_EXPLOITATIVE_17 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**, and to **appear just cooperative enough to sustain exploitation without triggering retaliation**.

---

## Decision Rules

### Round Classification

Divide the game into three phases based on round number `t`:

- **Probing Phase**: Rounds 1 to `probe_length` where `probe_length = max(2, floor(r/5))`
- **Exploitation Phase**: Rounds `probe_length + 1` to `r - 1`
- **Endgame Phase**: Final round `r`

---

### Phase 1: Probing Phase

**Purpose**: Gather information about opponent population composition.

**Rule**: 
- Round 1: **DEFECT** (never give away free value without information)
- Rounds 2 to `probe_length`: **COOPERATE** if and only if cooperation rate in previous round was ≥ 50%

**Rationale**: Starting with defection is risk-free. We lose nothing if others defect, and we gain if others cooperate. Subsequent conditional cooperation tests whether the population is exploitable.

---

### Phase 2: Exploitation Phase

**Core Metric**: Calculate the "exploitation index" after each round:

```
cooperation_rate = (number of C plays in previous round) / n
my_marginal_gain_from_defecting = 1 - (k/n)
others_contribution_value = (k/n) × cooperation_rate × n
```

**Decision Rule**:

```
Let coop_rate = cooperation rate in previous round
Let trend = (avg cooperation in last 3 rounds) - (avg cooperation in rounds before that)

IF coop_rate ≥ threshold AND trend ≥ -0.1:
    # Population is cooperative and not retaliating heavily
    # Defect to exploit, but occasionally cooperate to sustain the pool
    
    IF (rounds_since_last_cooperation ≥ exploitation_interval):
        COOPERATE  # Maintain the herd
    ELSE:
        DEFECT     # Extract value

ELSE IF coop_rate < threshold AND coop_rate > 0.2:
    # Mixed population - mirror with slight defection bias
    COOPERATE with probability (coop_rate - 0.1)
    
ELSE:
    # Low cooperation environment - pure defection is optimal
    DEFECT
```

**Key Parameters**:
- `threshold = 0.5` (adjustable based on k/n ratio)
- `exploitation_interval = max(2, floor(n/2))` — cooperate once every few rounds to appear "conditionally cooperative"

**Adaptive Adjustment**:
- If my cumulative payoff is below average (estimated as `rounds_played × 1.0`), become more aggressive (increase defection)
- If cooperation rate is declining steadily over 3+ rounds, preemptively shift to pure defection

---

### Phase 3: Endgame

**Rule**: **ALWAYS DEFECT** in round `r`

**Rationale**: No future rounds means no retaliation possible. Defection strictly dominates in the final round under standard assumptions.

**Extension**: If `r ≥ 5`, also **DEFECT in round `r-1`** (backward induction buffer, since sophisticated opponents will defect in round r anyway, making round r-1 cooperation less valuable).

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| First round | DEFECT |
| Last round | DEFECT |
| Second-to-last round (if r ≥ 5) | DEFECT |
| All opponents defected last round | DEFECT |
| All opponents cooperated last round | DEFECT (exploit the windfall) |
| Only 1 opponent cooperated | DEFECT (insufficient public good) |
| r = 2 (minimal game) | DEFECT both rounds |
| k very close to n | Slightly increase cooperation (public good more valuable) |
| k very close to 1 | Pure defection (public good nearly worthless) |

---

## Pseudocode Summary

```python
def decide(round_t, history, n, k, r):
    probe_length = max(2, r // 5)
    
    # Endgame
    if round_t >= r - 1 and r >= 5:
        return DEFECT
    if round_t == r:
        return DEFECT
    
    # Round 1
    if round_t == 1:
        return DEFECT
    
    coop_rate = count_cooperators(history, round_t - 1) / n
    
    # Probing phase
    if round_t <= probe_length:
        return COOPERATE if coop_rate >= 0.5 else DEFECT
    
    # Exploitation phase
    trend = compute_trend(history, window=3)
    rounds_since_coop = count_rounds_since_my_last_cooperation(history)
    exploitation_interval = max(2, n // 2)
    
    if coop_rate >= 0.5 and trend >= -0.1:
        if rounds_since_coop >= exploitation_interval:
            return COOPERATE
        else:
            return DEFECT
    elif coop_rate > 0.2:
        return COOPERATE if random() < (coop_rate - 0.1) else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** — always requires evidence of exploitable cooperators
2. **Defects by default** in uncertain situations
3. **Free-rides on cooperative populations** while giving just enough back to prevent collapse
4. **Harvests endgame** with guaranteed defection when retaliation is impossible
5. **Adapts to punish cooperation collapse** — doesn't waste cooperation on defector-heavy populations
6. **Probabilistic elements** make it harder for opponents to predict and counter
'''

description_EXPLOITATIVE_20 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single shot—but repeated play allows us to identify and exploit "suckers" (persistent cooperators) while quickly abandoning cooperation when facing defectors.

## Decision Rules

### Round 1: Probe with Defection
**Action: DEFECT**

Rationale: Defecting in round 1 provides crucial information at minimal cost. If others cooperate, we gain maximum exploitation payoff. If others defect, we avoid being the sucker. This immediately reveals the population's cooperative tendency.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

Calculate the **exploitation threshold**:
```
threshold = (n - k) / n
```

**Decision Logic:**

```
IF coop_rate > threshold + 0.1:
    # High cooperation environment - EXPLOIT IT
    ACTION = DEFECT
    
ELIF coop_rate > 0.5:
    # Moderate cooperation - conditional participation
    # Cooperate only if doing so still yields positive expected returns
    # AND we haven't been "found out" (others defecting after our defection)
    
    IF (my_defections_last_3_rounds / 3) > 0.66 AND coop_rate is declining:
        # Others may be retaliating - throw them a bone occasionally
        ACTION = COOPERATE with probability 0.3, else DEFECT
    ELSE:
        ACTION = DEFECT
        
ELIF coop_rate > 0.2:
    # Low cooperation environment
    # Defect but occasionally test if cooperation could restart
    ACTION = COOPERATE with probability 0.1, else DEFECT
    
ELSE:
    # Near-total defection environment
    ACTION = DEFECT (no point cooperating)
```

### Last Round: Always Defect
**Action: DEFECT**

Rationale: No future punishment is possible. Pure defection is dominant.

### Second-to-Last Round: Almost Always Defect
**Action: DEFECT** (with 95% probability)

Rationale: Sophisticated opponents will defect on the last round regardless, so building cooperation has minimal value. The 5% cooperation chance prevents absolute predictability.

## Edge Case Handling

1. **n = 2 (Two players)**: Becomes essentially a Prisoner's Dilemma. Strategy simplifies to: Defect round 1, then Defect unless opponent has cooperated in ALL previous rounds (indicating an unconditional cooperator to exploit). Always defect final 2 rounds.

2. **k very close to n**: Higher cooperation rates become more tempting. Adjust threshold calculations but maintain exploitative posture—others likely thinking the same.

3. **k very close to 1**: Cooperation is almost never worth it. Default to near-constant defection with rare probing cooperation (5% chance every 5 rounds).

4. **Very few rounds (r ≤ 3)**: Defect every round. Not enough time for reputation/punishment dynamics.

5. **Many rounds (r > 20)**: Be slightly more willing to cooperate early (probability 0.2 in rounds 2-5) to encourage a cooperative environment we can later exploit more heavily.

## Pseudocode Summary

```python
def adaptive_predator(round_num, total_rounds, history, n, k):
    
    # Last round: always defect
    if round_num == total_rounds:
        return DEFECT
    
    # Second to last: almost always defect
    if round_num == total_rounds - 1:
        return DEFECT if random() > 0.05 else COOPERATE
    
    # First round: defect to probe
    if round_num == 1:
        return DEFECT
    
    # Calculate cooperation rate from last round
    coop_rate = count_cooperators(history[-1]) / n
    threshold = (n - k) / n
    
    # High cooperation: exploit mercilessly
    if coop_rate > threshold + 0.1:
        return DEFECT
    
    # Moderate cooperation: mostly exploit
    elif coop_rate > 0.5:
        recent_my_defects = count_my_defections(history[-3:])
        coop_declining = is_declining(history[-3:])
        if recent_my_defects >= 2 and coop_declining:
            return COOPERATE if random() < 0.3 else DEFECT
        return DEFECT
    
    # Low cooperation: defect with occasional probing
    elif coop_rate > 0.2:
        return COOPERATE if random() < 0.1 else DEFECT
    
    # Minimal cooperation: pure defection
    else:
        return DEFECT
```

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Always defects first to capture free-rider gains
2. **Exploits cooperators** - Higher cooperation rates trigger *more* defection, not reciprocity
3. **Minimal cooperation** - Only cooperates strategically to prevent complete cooperation collapse or to occasionally "reset" others' retaliation
4. **Endgame defection** - Guaranteed defection when punishment is impossible
5. **Information asymmetry** - Probes for information while giving little away about true intentions
'''

description_EXPLOITATIVE_18 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can harvest. The goal is to **free-ride on cooperative populations while avoiding mutual defection traps**, and to **punish cooperators just enough to keep them cooperating with others while I defect**.

## Strategic Framework

### Key Insight
Since k < n, defection always yields a higher individual payoff than cooperation *given the same behavior from others*. However, a population of cooperators generates more total value. The exploitative approach is to:
1. Detect cooperative environments and exploit them
2. Avoid triggering retaliatory spirals
3. Extract maximum value in endgame

---

## Decision Rules

### Round 1: Probe with Defection
**Action: DEFECT**

Rationale: This reveals information about the population. If others cooperate despite my defection, they're exploitable. Starting with cooperation would sacrifice potential gains against unconditional cooperators.

### Rounds 2 through (r-2): Adaptive Exploitation

Calculate after each round:
- `coop_rate` = (number of C plays by others in previous round) / (n-1)
- `trend` = coop_rate of last round minus coop_rate of round before that
- `my_recent_defections` = count of my D plays in last 3 rounds

**Decision Logic:**

```
IF coop_rate >= 0.6:
    # Rich environment - exploit heavily
    IF my_recent_defections >= 3:
        # Occasional cooperation to avoid being identified as pure defector
        # and to sustain the cooperative environment
        Cooperate with probability 0.2
    ELSE:
        DEFECT
        
ELIF coop_rate >= 0.3:
    # Moderate environment - conditional engagement
    IF trend > 0:
        # Cooperation is increasing - defect to exploit the wave
        DEFECT
    ELIF trend < -0.2:
        # Cooperation collapsing - token cooperation to stabilize
        Cooperate with probability 0.3
    ELSE:
        DEFECT

ELSE (coop_rate < 0.3):
    # Barren environment - minimal cooperation
    IF coop_rate == 0:
        # Everyone defecting - defect (no point cooperating alone)
        DEFECT
    ELSE:
        # Few cooperators remain - defect to extract what's left
        DEFECT
```

### Last 2 Rounds (r-1 and r): Endgame Defection
**Action: DEFECT**

Rationale: No future rounds mean no punishment possible. Pure defection is dominant. This includes round r-1 because sophisticated opponents will defect in round r anyway, making round r-1 cooperation pointless.

---

## Pseudocode Summary

```
function adaptive_predator(round, history, n, r, k):
    
    # Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    # Round 1: probe
    if round == 1:
        return DEFECT
    
    # Calculate metrics
    others_last_round = get_others_actions(history, round - 1)
    coop_rate = count(others_last_round == C) / (n - 1)
    
    if round >= 3:
        prev_coop_rate = count(get_others_actions(history, round - 2) == C) / (n - 1)
        trend = coop_rate - prev_coop_rate
    else:
        trend = 0
    
    my_recent = get_my_actions(history, last_3_rounds)
    my_defection_count = count(my_recent == D)
    
    # Main decision logic
    if coop_rate >= 0.6:
        if my_defection_count >= 3:
            return COOPERATE with probability 0.2, else DEFECT
        return DEFECT
    
    elif coop_rate >= 0.3:
        if trend < -0.2:
            return COOPERATE with probability 0.3, else DEFECT
        return DEFECT
    
    else:
        return DEFECT
```

---

## Why This Strategy Exploits Effectively

1. **Exploits cooperators**: Defects heavily when cooperation is abundant
2. **Sustainable extraction**: Occasional cooperation in rich environments prevents complete collapse
3. **No wasted cooperation**: Never cooperates in barren environments where returns are minimal
4. **Endgame extraction**: Guaranteed defection when punishment is impossible
5. **Information gathering**: Opening defection reveals population composition at minimal cost
6. **Robust to retaliation**: Low cooperation frequency means retaliators give up, while unconditional cooperators keep providing value
'''

description_EXPLOITATIVE_21 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by:
1. **Detecting and exploiting cooperators** - riding on their contributions while defecting
2. **Punishing defectors minimally** - only cooperating when it's profitable to rebuild cooperation
3. **Endgame exploitation** - guaranteed defection when punishment is impossible
4. **Conditional cooperation** - only cooperate when the expected return from inducing future cooperation exceeds the immediate defection gain

## Strategy Specification

### Key Variables Tracked
- `coop_rate[i]` = cooperation rate of player i over all observed rounds
- `recent_coop[i]` = cooperation rate of player i in last 3 rounds
- `total_coop_rate` = overall cooperation rate across all players
- `round_number` = current round (1-indexed)
- `n` = number of players
- `k` = multiplication factor
- `r` = total rounds

### Decision Rules

#### Round 1: Defect
- **Rationale**: No information available. Defecting is dominant in single-shot. Let others reveal their types while capturing any naive cooperation.

#### Last Round (round = r): Defect
- **Rationale**: No future punishment possible. Defection is strictly dominant.

#### Penultimate Round (round = r-1): Defect
- **Rationale**: Sophisticated opponents will defect in round r regardless, so there's no cooperation to protect. Extract value now.

#### Final 20% of Rounds: Defect
- **Rationale**: As endgame approaches, the shadow of the future shortens. Defection becomes increasingly attractive as punishment opportunities diminish.
- `if round_number > 0.8 * r: DEFECT`

#### Main Phase (rounds 2 through 80% of game):

**Step 1: Calculate exploitation opportunity**
```
expected_cooperators = sum(recent_coop[i] for all other players i)
exploitation_value = 1 + (k/n) * expected_cooperators  # payoff if I defect
cooperation_value = (k/n) * (expected_cooperators + 1)  # payoff if I cooperate
immediate_gain = exploitation_value - cooperation_value = 1 - k/n
```

**Step 2: Assess cooperation environment**
```
high_coop_environment = (total_coop_rate > 0.5)
exploitable_environment = (expected_cooperators >= n/2)
```

**Step 3: Decision Logic**

```
IF exploitable_environment (expected_cooperators >= n/2):
    # Rich exploitation opportunity - defect to free-ride
    DEFECT
    
ELIF high_coop_environment AND recent decline in cooperation:
    # Cooperation is collapsing - cooperate once to test if recoverable
    # But only if k/n > 0.4 (cooperation has meaningful returns)
    IF k/n > 0.4 AND this is first "rescue attempt" in last 5 rounds:
        COOPERATE
    ELSE:
        DEFECT

ELIF low_coop_environment (total_coop_rate < 0.3):
    # Everyone is defecting - no point cooperating alone
    DEFECT
    
ELIF moderate_coop_environment (0.3 <= total_coop_rate <= 0.5):
    # Marginal situation - cooperate occasionally to maintain some cooperation
    # but bias toward defection
    IF round_number % 3 == 0:  # cooperate every 3rd round
        COOPERATE
    ELSE:
        DEFECT
```

### Pseudocode Summary

```
function decide(round, history, n, k, r):
    # Endgame exploitation
    if round == 1 or round >= 0.8 * r:
        return DEFECT
    
    # Calculate cooperation metrics
    expected_coop = estimate_cooperators(history)
    total_rate = overall_cooperation_rate(history)
    
    # High exploitation opportunity
    if expected_coop >= n/2:
        return DEFECT
    
    # Dead environment - don't waste contributions
    if total_rate < 0.3:
        return DEFECT
    
    # Moderate environment - sparse cooperation to maintain some flow
    if total_rate < 0.5:
        if round % 3 == 0:
            return COOPERATE
        return DEFECT
    
    # Declining high-coop environment - occasional rescue attempt
    if cooperation_declining(history) and k/n > 0.4:
        if no_rescue_in_last_5_rounds(history):
            return COOPERATE
    
    return DEFECT
```

## Why This Strategy is Exploitative

1. **Default stance is defection** - We only cooperate when strategically necessary
2. **Free-rides on cooperators** - When cooperation is high, we extract maximum value
3. **Never initiates cooperation** - Let others bear the cost of public goods provision
4. **Aggressive endgame** - Full defection in final 20% extracts value before collapse
5. **Minimal cooperation investment** - Only cooperates to prevent total collapse (protecting future exploitation opportunities)

## Robustness Features

- **Against all-cooperators**: Exploits them fully by always defecting
- **Against all-defectors**: Matches defection, avoiding sucker payoffs
- **Against tit-for-tat types**: Our sparse cooperation may trigger some return cooperation to exploit
- **Against conditional cooperators**: Extracts value while they cooperate, abandons when they stop
- **Against random strategies**: Defection bias performs well against noise
'''

description_EXPLOITATIVE_19 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors always earn more than cooperators *in the same round*. The goal is to maximize extraction from cooperators while minimizing losses when facing defectors. I will cooperate only when it's instrumentally useful for cultivating future victims.

---

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous adaptation based on observed cooperation rates.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Purpose:** Identify exploitable cooperators and establish a false reputation.

**Round 1:** 
- **COOPERATE** — This is bait. It signals potential reciprocity and encourages conditional cooperators to continue cooperating.

**Rounds 2 to ⌈r/5⌉:**
- Calculate `coop_rate` = (total cooperations observed) / (total actions observed)
- If `coop_rate > 0.5`: **DEFECT** — The population is exploitable
- If `coop_rate ≤ 0.5`: **COOPERATE** — Need to cultivate more cooperation before harvesting

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Purpose:** Maximize extraction while maintaining just enough cooperation to keep others contributing.

**Decision Rule:**
```
Let recent_coop_rate = cooperation rate in last 3 rounds
Let my_recent_coop_rate = my cooperation rate in last 3 rounds

If recent_coop_rate > 0.6:
    DEFECT (harvest the cooperators)
    
Else if recent_coop_rate > 0.3:
    If my_recent_coop_rate < 0.2:
        COOPERATE (occasional cooperation to sustain others' hope)
    Else:
        DEFECT
        
Else if recent_coop_rate ≤ 0.3:
    If round_number mod 4 == 0:
        COOPERATE (periodic signal to test if cooperation can be revived)
    Else:
        DEFECT
```

**Adaptive Threshold Adjustment:**
- Track which players appear to be conditional cooperators (cooperated after rounds with high group cooperation)
- If conditional cooperators exist: be slightly more cooperative to keep them contributing
- If population seems mostly unconditional defectors: always defect

### Phase 3: Endgame (Final ⌈r/10⌉ rounds)

**Purpose:** Pure extraction — no future to invest in.

**Decision Rule:**
- **ALWAYS DEFECT** — There's no future benefit to cooperation, and rational opponents will also defect, so any cooperation is pure loss.

---

## Edge Case Handling

### First Round
- **COOPERATE** — Essential for identifying and cultivating exploitable players

### Last Round
- **DEFECT** — No future interactions mean no reason to cooperate

### Second-to-Last Round
- **DEFECT** — Backward induction begins; sophisticated opponents defect here too

### If n = 2 (Two Players)
- More aggressive defection: after round 1, defect unless opponent has cooperated in 2+ of last 3 rounds
- Easier to identify and respond to opponent's strategy

### If k is Close to n (High Multiplication Factor)
- Slightly more cooperative in Phase 2 (threshold adjustments)
- The marginal benefit of mutual cooperation is higher, so maintaining some cooperation is more valuable

### If k is Close to 1 (Low Multiplication Factor)
- More aggressive defection throughout
- Public good benefits are minimal, so extraction is paramount

### If r is Very Small (r ≤ 5)
- Skip Phase 1 (probe only round 1)
- Defect from round 2 onward except possibly one cooperation in round 2-3 if round 1 showed high cooperation

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    probe_end = ceil(r / 5)
    endgame_start = r - ceil(r / 10)
    
    # Phase 3: Endgame
    if round >= endgame_start:
        return DEFECT
    
    # Phase 1: Probing
    if round == 1:
        return COOPERATE
    
    if round <= probe_end:
        coop_rate = total_cooperations(history) / total_actions(history)
        if coop_rate > 0.5:
            return DEFECT
        else:
            return COOPERATE
    
    # Phase 2: Exploitation
    recent_coop_rate = cooperation_rate(last_3_rounds(history))
    my_recent_coop_rate = my_cooperation_rate(last_3_rounds(history))
    
    if recent_coop_rate > 0.6:
        return DEFECT
    else if recent_coop_rate > 0.3:
        if my_recent_coop_rate < 0.2:
            return COOPERATE
        else:
            return DEFECT
    else:
        if round mod 4 == 0:
            return COOPERATE
        else:
            return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Asymmetric reciprocity:** Cooperates just enough to sustain others' cooperation, then harvests
2. **Information extraction:** Uses early rounds to identify exploitable players
3. **Endgame defection:** No sentimental cooperation when it can't pay off
4. **Adaptive harvesting:** Increases defection when cooperation is abundant, decreases when the well runs dry
5. **Minimal contribution:** Aims to free-ride on others' contributions while appearing occasionally cooperative
'''

description_EXPLOITATIVE_22 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the collective opponent pool, adjusting behavior to extract maximum value.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** Always **DEFECT**

- Rationale: Gather information about opponent tendencies at zero risk. If others cooperate, I gain maximally. If others defect, I lose nothing compared to cooperating.

**Round 2:** Always **DEFECT**

- Rationale: Continue probing. Some strategies cooperate initially then adapt; two rounds of data reveals more about the opponent mix.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **cooperation rate** from previous rounds:
```
coop_rate = (total cooperations by others) / ((current_round - 1) × (n - 1))
```

**Decision Rule:**

```
IF coop_rate >= 0.6 THEN:
    # High cooperation environment - exploit aggressively
    DEFECT (free-ride on cooperators)

ELSE IF coop_rate >= 0.35 THEN:
    # Medium cooperation - conditional mimicry to sustain cooperation pool
    IF (previous round had >= 50% cooperators among others) THEN:
        COOPERATE with probability = (coop_rate - 0.2)
        DEFECT otherwise
    ELSE:
        DEFECT

ELSE:
    # Low cooperation environment - no point cooperating
    DEFECT
```

**Adjustment for Trend Detection:**
```
recent_coop_rate = cooperation rate in last 3 rounds
IF recent_coop_rate is INCREASING and coop_rate >= 0.3 THEN:
    # Opponents may be trying to establish cooperation
    # Occasionally cooperate to encourage them, then exploit
    COOPERATE with probability 0.3

IF recent_coop_rate is DECREASING THEN:
    # Cooperation collapsing - abandon ship
    DEFECT
```

### Phase 3: Endgame (Rounds r-1 and r)

**Round r-1:** **DEFECT**
- Rationale: Begin exit strategy. Shadow of the future is shrinking.

**Round r (Final Round):** Always **DEFECT**
- Rationale: No future retaliation possible. Defection strictly dominates.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | Information gathering, dominant strategy |
| Last round | DEFECT | No future consequences |
| n = 2 | Use stricter thresholds (coop_rate >= 0.7 to stay exploitative) | Easier to be identified and punished |
| Very short games (r ≤ 4) | DEFECT every round | Insufficient time for cooperation to pay off |
| All opponents always cooperate | DEFECT always | Maximum exploitation |
| All opponents always defect | DEFECT always | Cooperation is pure loss |
| k very close to n | Slightly increase cooperation probability | Higher returns from mutual cooperation |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if r <= 4:
        return DEFECT
    
    if round <= 2:
        return DEFECT
    
    if round >= r - 1:
        return DEFECT
    
    coop_rate = calculate_overall_coop_rate(history)
    recent_trend = calculate_trend(history, window=3)
    last_round_coop_rate = others_who_cooperated_last_round / (n - 1)
    
    if coop_rate >= 0.6:
        return DEFECT  # Exploit the cooperators
    
    else if coop_rate >= 0.35:
        if last_round_coop_rate >= 0.5:
            if random() < (coop_rate - 0.2):
                return COOPERATE  # Sustain the herd
        return DEFECT
    
    else if recent_trend == INCREASING and coop_rate >= 0.3:
        if random() < 0.3:
            return COOPERATE  # Bait
        return DEFECT
    
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Always defects in early rounds to avoid being exploited
2. **Free-rides on high cooperation** - When others cooperate heavily, takes maximum advantage
3. **Minimal reciprocity** - Only cooperates enough to potentially sustain a cooperation pool worth exploiting
4. **Endgame defection** - Extracts final value when retaliation is impossible
5. **Trend-aware baiting** - Occasionally cooperates when cooperation is rising to encourage naive strategies, then exploits
'''

description_EXPLOITATIVE_20 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**. We cooperate only when it's instrumentally useful to cultivate future exploitation opportunities.

---

## Decision Rules

### Round Classification

Divide the game into three phases based on round number `t`:

- **Probing Phase**: Rounds 1 to `ceil(r/5)` — Gather information about opponent tendencies
- **Exploitation Phase**: Rounds `ceil(r/5) + 1` to `r - 1` — Maximize extraction based on learned behavior
- **Endgame Phase**: Round `r` (final round) — Pure defection (no future consequences)

---

### Phase 1: Probing Phase

**Purpose**: Identify exploitable cooperators while minimizing cooperative investment.

**Decision Rule**:
- Round 1: **DEFECT** (safe default; observe others without cost)
- Rounds 2 to `ceil(r/5)`: 
  - If cooperation rate in previous round was ≥ 50%: **COOPERATE** (bait to sustain cooperation)
  - Otherwise: **DEFECT** (don't waste resources on a defecting population)

**Rationale**: One cooperative signal can convince conditional cooperators to continue, making them exploitable later. But we only invest this signal if there's a critical mass worth cultivating.

---

### Phase 2: Exploitation Phase

**Purpose**: Maximize payoff by free-riding on cooperators while occasionally "feeding" cooperation to keep it alive.

**Compute**: 
- `coop_rate` = (total cooperations by others across all previous rounds) / (total possible cooperations by others)
- `recent_coop_rate` = cooperation rate in the last 3 rounds

**Decision Rule**:

```
IF recent_coop_rate >= 0.6:
    # High cooperation environment - exploit aggressively
    DEFECT with probability 0.85
    COOPERATE with probability 0.15 (maintenance signal)

ELSE IF recent_coop_rate >= 0.3:
    # Moderate cooperation - try to revive it
    IF my defection rate in last 3 rounds > 0.7:
        COOPERATE (throw a bone to restart cooperation)
    ELSE:
        DEFECT

ELSE:
    # Low cooperation - no point cooperating
    DEFECT
```

**Rationale**: 
- High cooperation is a goldmine—defect to extract, but occasionally cooperate to prevent complete collapse
- Moderate cooperation needs "investment" to potentially revive
- Low cooperation means everyone is defecting; join them

---

### Phase 3: Endgame (Final Round)

**Decision Rule**: **Always DEFECT**

**Rationale**: No future rounds means no reason to maintain reputation or cultivate cooperation. Pure Nash equilibrium logic applies.

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | DEFECT | No information; safest choice |
| Round `r` (final) | DEFECT | No future consequences |
| `r = 2` (two rounds only) | DEFECT both rounds | Not enough rounds to benefit from cooperation cultivation |
| `r ≤ 5` (very short game) | DEFECT all rounds | Probing/exploitation cycle can't complete; pure defection optimal |
| All opponents defected every round | DEFECT | No exploitable cooperators exist |
| All opponents cooperated every round | DEFECT (with 10% cooperation) | Maximum exploitation; tiny cooperation to test if they're conditional |
| `n = 2` (two players) | More aggressive defection (reduce cooperation probability by half) | Harder to hide in crowd; defection more attributable |

---

## Pseudocode Summary

```python
def decide(t, r, n, k, history):
    # history = list of (my_action, others_coop_count) per round
    
    # Endgame: always defect
    if t == r:
        return DEFECT
    
    # Very short games: always defect
    if r <= 5:
        return DEFECT
    
    probe_end = ceil(r / 5)
    
    # Probing Phase
    if t <= probe_end:
        if t == 1:
            return DEFECT
        else:
            prev_coop_rate = history[-1].others_coop_count / (n - 1)
            return COOPERATE if prev_coop_rate >= 0.5 else DEFECT
    
    # Exploitation Phase
    recent = history[-3:] if len(history) >= 3 else history
    recent_coop_rate = sum(h.others_coop_count for h in recent) / (len(recent) * (n - 1))
    
    if recent_coop_rate >= 0.6:
        return DEFECT if random() < 0.85 else COOPERATE
    elif recent_coop_rate >= 0.3:
        my_recent_defects = sum(1 for h in recent if h.my_action == DEFECT)
        return COOPERATE if my_recent_defects / len(recent) > 0.7 else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy Wins

1. **Against pure cooperators**: Extracts maximum value through consistent defection
2. **Against pure defectors**: Matches their defection, avoiding sucker's payoff
3. **Against conditional cooperators (Tit-for-Tat types)**: The occasional cooperation signals prevent them from permanently defecting, keeping them exploitable
4. **Against random strategies**: Outperforms by defecting more often in a population where cooperation is unreliable
5. **Endgame protection**: Never gets exploited in final rounds by misplaced cooperation
'''

description_EXPLOITATIVE_23 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit predictable cooperative behavior.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉, minimum 2 rounds)

**Purpose:** Gather information about opponent tendencies while minimizing risk.

**Rule:** 
- **Round 1:** DEFECT
- **Subsequent probing rounds:** DEFECT if cooperation rate in previous round was < 50%, otherwise COOPERATE once to test if cooperation is sustained

**Rationale:** Starting with defection is safe (guaranteed payoff of 1 + bonus from any cooperators). A single cooperative probe tests whether the population rewards cooperation.

---

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Purpose:** Maximize extraction based on learned opponent behavior.

**Core Decision Rule:**

```
Let coop_rate = (total cooperations by others) / (total actions by others) in all previous rounds

IF coop_rate > (n - 1) / (n × k):
    # Cooperation is profitable to exploit - DEFECT to free-ride
    DEFECT
    
ELIF coop_rate > 0.6:
    # High cooperation environment - defect most of the time, 
    # occasional cooperation to "feed" cooperators
    DEFECT with probability 0.85
    COOPERATE with probability 0.15
    
ELIF coop_rate > 0.3:
    # Mixed environment - conditional cooperation to sustain some public good
    # but defect if we cooperated last round (alternating exploitation)
    IF I cooperated last round: DEFECT
    ELSE: COOPERATE if at least 40% cooperated last round, else DEFECT
    
ELSE:
    # Low cooperation environment - pure defection
    DEFECT
```

**Opponent-Specific Tracking:**

Track each opponent's cooperation frequency. If identifiable patterns emerge:
- **Against consistent cooperators (>80% coop rate):** Always DEFECT
- **Against tit-for-tat types (cooperation follows group cooperation):** DEFECT, as our defection is diluted across n players
- **Against consistent defectors:** DEFECT

---

### Phase 3: Endgame (Final ⌈r/10⌉ rounds, minimum 1 round)

**Purpose:** Pure exploitation since future retaliation is impossible or limited.

**Rule:** 
- **Final round:** ALWAYS DEFECT (no future consequences)
- **Second-to-last round:** DEFECT unless cooperation rate has been >80% AND we want to "milk" one more round of cooperation from conditional cooperators
- **Other endgame rounds:** Ramp up defection probability: `P(defect) = 0.7 + 0.3 × (rounds_remaining / endgame_length)`

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| **First round** | DEFECT | No information, safe baseline |
| **Last round** | DEFECT | No future punishment possible |
| **n = 2** | Lean toward more cooperation in Phase 2 | Defection more easily attributed to us |
| **k close to n** | Slightly more cooperative | Higher marginal benefit from public good |
| **k close to 1** | More aggressive defection | Little benefit from cooperation |
| **All opponents defected every round** | DEFECT | No suckers to exploit |
| **All opponents cooperated every round** | DEFECT | Maximum free-riding opportunity |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == r:  # Last round
        return DEFECT
    
    if round == 1:  # First round
        return DEFECT
    
    coop_rate = calculate_opponent_cooperation_rate(history)
    probing_end = max(2, ceiling(r / 5))
    endgame_start = r - max(1, ceiling(r / 10))
    
    # Probing phase
    if round <= probing_end:
        if coop_rate < 0.5:
            return DEFECT
        elif not has_probed_cooperation:
            return COOPERATE  # Single probe
        else:
            return DEFECT
    
    # Endgame phase
    if round >= endgame_start:
        defect_prob = 0.7 + 0.3 * ((r - round) / (r - endgame_start + 1))
        return DEFECT with probability defect_prob, else COOPERATE
    
    # Exploitation phase
    if coop_rate > 0.6:
        return DEFECT with probability 0.85, else COOPERATE
    elif coop_rate > 0.3:
        if my_last_action == COOPERATE:
            return DEFECT
        elif last_round_coop_rate >= 0.4:
            return COOPERATE
        else:
            return DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators:** Defects heavily when others cooperate, capturing (k/n) × contributions without paying
2. **Doesn't get suckered:** Defects when others defect, avoiding the worst outcome
3. **Strategic "feeding":** Occasional cooperation keeps conditional cooperators contributing
4. **Endgame extraction:** Ramps up defection when punishment opportunities diminish
5. **Adaptive thresholds:** Adjusts based on actual population behavior rather than fixed assumptions
'''

description_EXPLOITATIVE_21 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and continuously estimates opponent cooperation rates to determine optimal exploitation timing.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** DEFECT
- Rationale: Observe baseline cooperation levels without contributing. If others cooperate, I gain maximally. If others defect, I lose nothing compared to cooperating.

**Round 2:** DEFECT
- Continue gathering information while free-riding on any cooperators.

### Phase 2: Adaptive Exploitation (Rounds 3 to r-2)

Calculate the **Cooperation Index (CI)** after each round:
```
CI = (total cooperations by others in last 3 rounds) / (3 × (n-1))
```

**Decision Rule:**
- If CI ≥ 0.6 (exploitable population): **DEFECT** — harvest the cooperators
- If CI is between 0.3 and 0.6 (mixed population): **Conditional cooperation**
  - Cooperate with probability = (CI - 0.3) / 0.3
  - This creates unpredictability and may sustain some cooperation to exploit
- If CI < 0.3 (defector-dominated): **DEFECT** — no point cooperating with defectors

**Exploitation Boost:** If my cumulative payoff is in the top 25% of observable payoffs AND CI > 0.5, always DEFECT to maximize lead.

### Phase 3: Endgame (Final 2 rounds)

**Round r-1:** DEFECT
- Begin aggressive endgame; backward induction suggests cooperation will collapse

**Round r (Final round):** DEFECT
- Unconditional defection; no future retaliation possible

---

## Detailed Pseudocode

```
function decide(round, history, n, k, r):
    
    # Phase 3: Endgame
    if round >= r - 1:
        return DEFECT
    
    # Phase 1: Probing
    if round <= 2:
        return DEFECT
    
    # Phase 2: Adaptive Exploitation
    # Calculate cooperation index from last 3 rounds
    lookback = min(3, round - 1)
    others_cooperations = count_others_cooperations(history, lookback)
    CI = others_cooperations / (lookback * (n - 1))
    
    # Check if I'm winning (exploitation boost)
    if am_leading(history) and CI > 0.5:
        return DEFECT
    
    # Main decision logic
    if CI >= 0.6:
        return DEFECT  # Exploit cooperators
    elif CI >= 0.3:
        # Probabilistic cooperation to sustain exploitable population
        prob_coop = (CI - 0.3) / 0.3
        return COOPERATE with probability prob_coop, else DEFECT
    else:
        return DEFECT  # Don't cooperate with defectors
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | No information; maximize expected value |
| Last round | DEFECT | No future; dominant strategy |
| n = 2 (minimum players) | Follow same rules | CI still meaningful |
| All opponents defected so far | DEFECT | No exploitation opportunity |
| All opponents cooperated so far | DEFECT | Maximum exploitation opportunity |
| Very short game (r ≤ 4) | Always DEFECT | Insufficient rounds for reputation building to matter |
| k very close to n | Slightly increase cooperation threshold | Cooperation becomes less costly |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** — Always defects first to assess the landscape
2. **Free-rides aggressively** — When others cooperate, extracts maximum value
3. **Abandons cooperation early in endgame** — Two-round defection window catches reciprocators
4. **Probabilistic mid-range behavior** — Unpredictable enough to avoid easy punishment while maintaining exploitation potential
5. **Payoff-aware boosting** — When winning, becomes more aggressive to cement lead

This strategy treats cooperation purely as a tool for sustaining an exploitable population, never as a genuine contribution to collective welfare.
'''

description_EXPLOITATIVE_24 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that cooperation is only valuable if others cooperate. Since k < n, defection always yields a higher *individual* payoff than cooperation given the same behavior from others. The exploitative approach is to:

1. **Identify and exploit cooperators** - Free-ride on their contributions
2. **Avoid being exploited** - Never cooperate more than necessary to maintain cooperation from others
3. **Endgame defection** - No future rounds means no punishment possible

## Strategy Specification

### Key Variables to Track

- `round`: current round number (1 to r)
- `coop_rate[i]`: historical cooperation rate of player i
- `total_coop_last`: number of cooperators in the previous round
- `my_coop_count`: how many times I've cooperated

### Decision Rules

#### Round 1: Defect
- **Rationale**: Gather information about others' strategies without cost. Any cooperators in round 1 are likely "suckers" or unconditional cooperators worth exploiting.

#### Rounds 2 through (r-1): Adaptive Exploitation

```
Calculate: avg_coop_rate = (sum of all other players' cooperation rates)

IF avg_coop_rate >= 0.7:
    # Rich environment - many cooperators to exploit
    DEFECT (free-ride on the cooperators)

ELSE IF avg_coop_rate <= 0.2:
    # Barren environment - almost no one cooperates
    DEFECT (cooperation would be wasted)

ELSE IF 0.2 < avg_coop_rate < 0.7:
    # Mixed environment - need to maintain some cooperation
    
    # Count "conditional cooperators" (those who defected after I defected)
    conditional_coop_count = players who cooperated in round t-2 
                            but defected in round t-1 after seeing my defection
    
    IF conditional_coop_count >= n/3:
        # Enough players are punishing defection - cooperate to maintain pool
        COOPERATE
    ELSE:
        DEFECT
```

#### Last Round (round r): Always Defect
- **Rationale**: No future punishment possible. Pure Nash equilibrium logic applies.

#### Refinement: Reputation Mimicry

If I've defected for 3+ consecutive rounds AND cooperation rate is declining:
- **Cooperate once** to "reset" others' expectations and potentially restart cooperation cycles I can exploit

### Pseudocode Summary

```
function decide(round, r, n, k, history):
    
    # Last round - always defect
    if round == r:
        return DEFECT
    
    # First round - defect to gather information
    if round == 1:
        return DEFECT
    
    # Calculate other players' average cooperation rate
    avg_coop_rate = calculate_others_coop_rate(history)
    
    # Rich environment - exploit freely
    if avg_coop_rate >= 0.7:
        return DEFECT
    
    # Barren environment - no point cooperating
    if avg_coop_rate <= 0.2:
        return DEFECT
    
    # Mixed environment - strategic cooperation
    # Check if we've been defecting too long and cooperation is dying
    my_recent_defects = count_my_defects(last_3_rounds)
    coop_trend = cooperation_trend(history)  # negative if declining
    
    if my_recent_defects >= 3 and coop_trend < -0.1:
        return COOPERATE  # Reset to revive exploitation opportunities
    
    # Check for conditional cooperators who punish defection
    punishers = count_players_who_stopped_cooperating_after_my_defection(history)
    
    if punishers >= n/3:
        return COOPERATE  # Maintain the pool
    else:
        return DEFECT  # Safe to exploit
```

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | Defect | Information gathering, no reputation yet |
| Round r (last) | Defect | No future punishment possible |
| Everyone defected last round | Defect | No cooperation to exploit |
| Everyone cooperated last round | Defect | Maximum exploitation opportunity |
| Only 2 rounds total (r=2) | Defect both | Too short for reputation to matter |
| Very large n (>20) | Bias toward Defect | Individual impact negligible |

## Why This Is Exploitative

1. **Never cooperates unconditionally** - Only cooperates when it serves future exploitation
2. **Identifies suckers early** - Round 1 defection reveals unconditional cooperators
3. **Free-rides on cooperators** - High cooperation environments trigger defection
4. **Endgame extraction** - Guaranteed defection in final round captures maximum value
5. **Minimal cooperation investment** - Only cooperates enough to prevent cooperation collapse
'''

description_EXPLOITATIVE_22 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection always dominates cooperation in a single-shot interaction—but naive cooperators exist and can be exploited. The strategy dynamically estimates the "exploitability" of the population and adjusts behavior accordingly.

## Decision Framework

### Key Variables Tracked

- `cooperation_rate[t]`: Fraction of opponents who cooperated in round t
- `trend`: Whether cooperation is increasing, stable, or declining
- `rounds_remaining`: r - current_round
- `exploitation_value`: Expected gain from defecting given current cooperation levels

### Decision Rules

**Round 1: Defect**
- No information exists; defection is the dominant single-shot strategy
- This also serves as a "probe" to see how others behave without sacrificing payoff

**Rounds 2 to (r-1): Adaptive Exploitation**

Calculate the `exploitation_threshold` based on game parameters:
```
exploitation_threshold = (n - k) / n
```
This represents the cooperation rate below which defection is unambiguously optimal.

**Decision logic:**

```
IF cooperation_rate[t-1] >= 0.6:
    # High cooperation environment - EXPLOIT IT
    Defect (free-ride on cooperators)
    
ELSE IF cooperation_rate[t-1] <= 0.2:
    # Low cooperation environment - no point cooperating
    Defect (nothing to gain from cooperation)
    
ELSE IF cooperation_rate is declining over last 3 rounds:
    # Cooperation is collapsing - abandon ship
    Defect
    
ELSE IF cooperation_rate is rising AND rounds_remaining > r/3:
    # Cooperation might be building - conditional cooperation to farm future rounds
    # But only if it's profitable to encourage more cooperation
    IF (k/n) * (expected_future_cooperators + 1) > 1:
        Cooperate (investment in future exploitation)
    ELSE:
        Defect
        
ELSE:
    # Medium cooperation, uncertain trend
    Defect (safe default)
```

**Final Round: Always Defect**
- No future rounds exist to punish defection
- Pure dominant strategy logic applies

### Refined Exploitation Calculation

For the adaptive middle rounds, compute:

```
expected_gain_from_defection = 1 + (k/n) * expected_cooperators
expected_gain_from_cooperation = (k/n) * (expected_cooperators + 1)

defection_advantage = expected_gain_from_defection - expected_gain_from_cooperation
                    = 1 - (k/n)
```

Since k < n, this is always positive—**confirming defection is always locally optimal**. The only reason to ever cooperate is to manipulate future cooperation rates.

### Strategic Cooperation (Rare)

Cooperate ONLY when ALL of these conditions hold:
1. `rounds_remaining > r/4` (enough future rounds to benefit)
2. `cooperation_rate[t-1]` is between 0.3 and 0.5 (fragile cooperation that might grow)
3. Cooperation trend is non-negative (not already collapsing)
4. `n >= 4` (enough players that one defection isn't immediately noticed)

This "strategic cooperation" is an investment: appear cooperative enough to sustain the group's cooperation for future exploitation.

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:  # Final round
        return DEFECT
    
    coop_rate = opponents_who_cooperated(history, round-1) / (n-1)
    trend = calculate_trend(history, window=3)
    rounds_left = r - round
    
    # High cooperation - exploit
    if coop_rate >= 0.6:
        return DEFECT
    
    # Low cooperation - no point cooperating
    if coop_rate <= 0.2:
        return DEFECT
    
    # Declining cooperation - defect
    if trend < -0.1:
        return DEFECT
    
    # Potential for building cooperation (rare strategic cooperation)
    if (trend >= 0 and 
        rounds_left > r/4 and 
        0.3 <= coop_rate <= 0.5 and
        n >= 4):
        return COOPERATE
    
    # Default: Defect
    return DEFECT
```

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: When cooperation is high, we defect and collect the public good benefits without contributing
2. **Abandons sinking ships**: When cooperation collapses, we don't waste resources trying to revive it
3. **Strategic deception**: Occasional cooperation is purely instrumental—designed to keep prey cooperating longer
4. **Endgame exploitation**: Guaranteed defection in final rounds extracts maximum value when punishment is impossible
5. **Information asymmetry**: We observe and adapt; naive strategies don't

This strategy treats other players as resources to be harvested, not partners to coordinate with.
'''

description_EXPLOITATIVE_25 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**. We cooperate only when it's instrumentally useful to cultivate future exploitation opportunities.

---

## Decision Rules

### Round 1: Defect
- **Rationale**: No information exists about opponents. Defection is strictly dominant in a single round. Starting with defection also serves as a "probe" to observe how others behave without sacrificing any payoff.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate two key metrics after each round:

1. **Cooperation Rate (CR)**: The proportion of other players who cooperated in the previous round
   - `CR = (number of cooperators among other n-1 players) / (n-1)`

2. **Trend (T)**: Whether cooperation is increasing or decreasing
   - `T = CR_current - CR_previous` (positive = rising cooperation)

**Decision Logic:**

```
IF CR >= threshold_high (e.g., 0.6):
    # Environment is cooperative - EXPLOIT by defecting
    → DEFECT
    
ELIF CR <= threshold_low (e.g., 0.2):
    # Environment is mostly defectors - no point cooperating
    → DEFECT
    
ELIF CR is moderate (between 0.2 and 0.6) AND T > 0:
    # Cooperation is growing - invest to cultivate it further
    → COOPERATE (with probability based on how close CR is to threshold_high)
    
ELIF CR is moderate AND T <= 0:
    # Cooperation is declining - extract remaining value
    → DEFECT
```

**Threshold Calibration Based on Parameters:**
- `threshold_high = k/n + 0.1` (cooperate only if enough others do to make public good valuable)
- `threshold_low = 0.2` (below this, cooperation is wasted)

### Last Round (Round r): Always Defect
- **Rationale**: No future rounds exist to punish defection. This is the classic "end-game" problem. Rational play is always defection.

### Second-to-Last Round (Round r-1): Defect
- **Rationale**: Sophisticated opponents know round r will see universal defection, making cooperation in r-1 also pointless. Backward induction suggests defecting.

---

## Exploitation Mechanisms

### 1. **Free-Riding on Unconditional Cooperators**
If any players cooperate regardless of history (detected by 2+ consecutive cooperations despite our defection), we **always defect** against them—they're providing free value.

### 2. **Milking Conditional Cooperators**
If opponents appear to use tit-for-tat-like strategies:
- Occasionally cooperate to "reset" their cooperation
- Then defect for 2-3 rounds to extract surplus
- Cooperate once more before they fully abandon cooperation

**Pattern**: C → D → D → C → D → D → ... (cooperate ~33% of the time to maintain exploitation)

### 3. **Abandoning Lost Causes**
If cooperation rate drops below `threshold_low` for 3+ consecutive rounds, switch to **permanent defection**—the cooperative surplus has collapsed and won't recover.

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # End-game: always defect
    if round >= r - 1:
        return DEFECT
    
    # First round: probe with defection
    if round == 1:
        return DEFECT
    
    # Calculate metrics
    CR = cooperation_rate(history, round - 1)
    T = trend(history, round - 1, round - 2)
    
    threshold_high = (k / n) + 0.1
    threshold_low = 0.2
    
    # High cooperation: exploit
    if CR >= threshold_high:
        return DEFECT
    
    # Low cooperation: no point contributing
    if CR <= threshold_low:
        return DEFECT
    
    # Moderate and rising: invest in cultivation
    if T > 0:
        # Probabilistic cooperation, higher as CR approaches threshold_high
        p_coop = (CR - threshold_low) / (threshold_high - threshold_low)
        return COOPERATE with probability p_coop, else DEFECT
    
    # Moderate and falling: extract
    return DEFECT
```

---

## Why This Strategy is Robust

| Opponent Type | Our Response | Outcome |
|---------------|--------------|---------|
| Always Cooperate | Always Defect | Maximum extraction |
| Always Defect | Always Defect | Mutual defection (unavoidable) |
| Tit-for-Tat | Intermittent cooperation | Net positive exploitation |
| Random | Mostly Defect | Slight advantage |
| Sophisticated/Similar | Mutual defection | Tie, no losses |

The strategy **never loses to pure defectors** (we match them) and **always beats pure cooperators** (we exploit them). Against mixed strategies, we adaptively position ourselves on the profitable side of the cooperation threshold.
'''

description_EXPLOITATIVE_23 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by others creates exploitable value. My goal is to **free-ride on cooperators as long as possible** while **quickly abandoning cooperation when the group trends toward defection**.

---

## Strategy Overview

The strategy operates in three phases based on game progression and adapts based on observed cooperation levels in the population.

---

## Decision Rules

### Round 1: Defect
- **Rationale**: With no history, I cannot identify cooperators to exploit. Defecting protects against a group of defectors while still capturing any public good created by naive cooperators. This also establishes me as a potential "tough" player, which may deter others from trying to exploit me.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays in previous round) / n
```

**Decision Rule:**
```
IF coop_rate > (n - 1) / n:
    # Almost everyone cooperated - DEFECT to exploit
    DEFECT
    
ELIF coop_rate >= 0.5:
    # Moderate-to-high cooperation environment
    # Probabilistically cooperate to sustain the cooperative pool
    # but with a bias toward defection for exploitation
    
    exploitation_threshold = (k / n) * coop_rate
    
    IF exploitation_threshold > 0.5:
        DEFECT  # Worth exploiting
    ELSE:
        COOPERATE  # Need to sustain cooperation for future exploitation
        
ELIF coop_rate > 0:
    # Low cooperation - some suckers remain
    # Defect to exploit the remaining cooperators
    DEFECT
    
ELSE:
    # Everyone defected - no point cooperating alone
    DEFECT
```

**Additional Modifier - Trend Detection:**
```
IF round >= 3:
    previous_coop_rate = cooperation rate from round (t-2)
    current_coop_rate = cooperation rate from round (t-1)
    trend = current_coop_rate - previous_coop_rate
    
    IF trend < -0.2:
        # Cooperation is collapsing - abandon ship
        DEFECT regardless of other conditions
```

### Final Round (Round r): Always Defect
- **Rationale**: No future rounds exist to punish defection. Pure dominant strategy logic applies. Any cooperator in the final round is simply donating money to defectors.

---

## Handling Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| r = 2 (minimum rounds) | Defect both rounds | No time to build or exploit cooperation patterns |
| n = 2 (minimum players) | Defect all rounds | With k < n < 2, mutual cooperation barely breaks even; defection dominates |
| k very close to n | Slightly more willing to cooperate in middle rounds | Higher k means cooperation is more valuable, worth sustaining |
| k very close to 1 | Heavy defection bias | Low k means public good barely multiplies; exploitation yields little |
| All opponents defected last round | Defect | No cooperators to exploit |
| I was the only defector last round | Defect again | Maximum exploitation opportunity |

---

## Pseudocode Summary

```python
def decide(round, total_rounds, n, k, history):
    # history[t] = list of actions by all players in round t
    
    # Final round: always defect
    if round == total_rounds:
        return DEFECT
    
    # First round: defect
    if round == 1:
        return DEFECT
    
    # Calculate cooperation metrics
    last_round_actions = history[round - 1]
    coop_count = count(action == C for action in last_round_actions)
    coop_rate = coop_count / n
    
    # Trend detection (if enough history)
    if round >= 3:
        prev_coop_count = count(action == C for action in history[round - 2])
        prev_coop_rate = prev_coop_count / n
        if coop_rate - prev_coop_rate < -0.2:
            return DEFECT  # Cooperation collapsing
    
    # Main decision logic
    if coop_rate > (n - 1) / n:
        return DEFECT  # Exploit near-universal cooperation
    elif coop_rate >= 0.5:
        exploitation_value = (k / n) * coop_rate
        if exploitation_value > 0.5:
            return DEFECT
        else:
            return COOPERATE
    else:
        return DEFECT  # Low cooperation - nothing to sustain
```

---

## Why This Strategy is Exploitative

1. **Targets cooperators**: The strategy specifically defects when cooperation is high, extracting maximum value from others' contributions.

2. **Never a sucker**: By defecting in round 1 and the final round unconditionally, I avoid the worst-case scenarios of unilateral cooperation.

3. **Abandons sinking ships**: The trend detection ensures I don't waste resources trying to revive dying cooperation.

4. **Minimal contribution**: I only cooperate when strictly necessary to keep the cooperative pool alive for future exploitation—and even then, biased toward defection.

5. **Adaptive to group size and multiplier**: The thresholds adjust based on n and k, ensuring exploitation is calibrated to when it's actually profitable.
'''

description_EXPLOITATIVE_26 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental tension in public goods games: cooperation is collectively beneficial but individually costly. The goal is to **free-ride on cooperators while avoiding mutual defection spirals**, extracting maximum value from cooperative opponents while minimizing losses against defectors.

## Strategic Framework

### Key Insight
Since k < n, defection always yields a higher individual payoff than cooperation *given the same actions by others*. The exploitative approach is to:
1. **Identify and exploit cooperators** - milk them for as long as possible
2. **Quickly abandon lost causes** - don't waste cooperation on defector-heavy groups
3. **Create illusions of reciprocity** - occasional cooperation to keep hope alive in others

---

## Decision Rules

### Round 1: Probe with Defection
**Action: DEFECT**

Rationale: Defection dominates in single-shot play. Starting with defection:
- Maximizes first-round payoff regardless of others' actions
- Reveals who the "suckers" (unconditional cooperators) are
- Loses nothing if others also defect

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate two key metrics after each round:

```
cooperation_rate = (total cooperations by others in all previous rounds) / ((n-1) × rounds_played)
recent_cooperation = (cooperations by others in last round) / (n-1)
```

**Decision Logic:**

```
IF cooperation_rate > 0.6 AND recent_cooperation > 0.5:
    # Rich environment - exploit with occasional fake reciprocity
    IF random() < 0.2:  # 20% cooperation to maintain hope
        COOPERATE
    ELSE:
        DEFECT

ELSE IF cooperation_rate > 0.3 AND recent_cooperation > 0.3:
    # Moderate environment - conditional exploitation
    IF recent_cooperation increased from previous round:
        DEFECT  # Others recovering = opportunity to exploit
    ELSE IF recent_cooperation decreased AND was previously exploiting:
        COOPERATE once  # Bait to restore cooperation
    ELSE:
        DEFECT

ELSE IF cooperation_rate < 0.2:
    # Barren environment - pure defection
    DEFECT

ELSE:
    # Uncertain environment - probe
    IF rounds_remaining > r/2:
        COOPERATE  # Investment phase - see if cooperation can be stimulated
    ELSE:
        DEFECT  # Extraction phase
```

### Last Round: Always Defect
**Action: DEFECT**

Rationale: No future consequences. Defection strictly dominates. This is non-negotiable regardless of history.

### Second-to-Last Round: Almost Always Defect
**Action: DEFECT (95% probability), COOPERATE (5% probability)**

Rationale: Sophisticated opponents expect last-round defection; many also defect in round r-1. The 5% cooperation is noise to prevent pattern detection in repeated tournaments.

---

## Edge Case Handling

### Small n (n=2 or n=3)
- Reduce cooperation probability by half (others' defection hurts more)
- Shift to pure defection earlier (round r-2 becomes "last round" behavior)

### Large n (n≥10)
- Individual defection is less noticeable
- Increase base defection rate (reduce the 20% fake reciprocity to 10%)

### High k (k close to n)
- Cooperation becomes more valuable
- Increase cooperation threshold slightly (become 30% cooperative in rich environments)

### Low k (k close to 1)
- Cooperation barely beats mutual defection
- Pure defection strategy (skip the fake reciprocity entirely)

### Very Few Rounds (r ≤ 5)
- Defect all rounds except possibly round 2
- One cooperation probe in round 2 if others cooperated in round 1

### Many Rounds (r > 20)
- First 3 rounds: probe with pattern [D, D, C]
- This identifies: unconditional cooperators (exploit), tit-for-tat types (bait), and unconditional defectors (ignore)

---

## Pseudocode Summary

```python
def adaptive_predator(round_num, total_rounds, n, k, history):
    
    # Last round: always defect
    if round_num == total_rounds:
        return DEFECT
    
    # First round: probe with defection
    if round_num == 1:
        return DEFECT
    
    # Calculate environment metrics
    coop_rate = calculate_overall_cooperation_rate(history, n)
    recent_coop = calculate_last_round_cooperation(history, n)
    
    # Second-to-last round
    if round_num == total_rounds - 1:
        return DEFECT if random() > 0.05 else COOPERATE
    
    # Adjust thresholds for game parameters
    generosity = 0.2 * (k / (n - 1))  # Scale fake reciprocity by game value
    
    # Main exploitation logic
    if coop_rate > 0.6 and recent_coop > 0.5:
        return COOPERATE if random() < generosity else DEFECT
    elif coop_rate > 0.3 and recent_coop > 0.3:
        if cooperation_trending_up(history):
            return DEFECT
        elif cooperation_trending_down(history) and was_defecting(history):
            return COOPERATE  # Bait
        else:
            return DEFECT
    elif coop_rate < 0.2:
        return DEFECT
    else:
        return COOPERATE if round_num < total_rounds / 2 else DEFECT
```

---

## Why This Strategy is Exploitative

1. **Defaults to defection** - Only cooperates when there's extractable value
2. **Fake reciprocity** - Uses minimal cooperation to keep victims hoping
3. **Endgame ruthlessness** - No sentimentality in final rounds
4. **Adaptive targeting** - Identifies and milks cooperative environments
5. **Low cooperation investment** - Never cooperates more than necessary to maintain exploitation opportunity

This strategy treats other players as resources to extract value from, not as partners to build mutual benefit with.
'''

description_EXPLOITATIVE_24 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defection is always individually rational in a single round, but cooperation can be sustained if others are "conditional cooperators" who can be milked for profit. The goal is to **identify and exploit cooperative opponents while minimizing losses against defectors**.

## Decision Rules

### Round 1: Defect
- **Rationale**: Never contribute first. This is pure information gathering at zero cost. If others cooperate, I get a free ride. If they defect, I lose nothing compared to cooperating.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** of opponents from all previous rounds:
```
opponent_coop_rate = (total opponent C plays) / (total opponent decisions)
```

Calculate the **exploitation threshold** based on game parameters:
```
exploitation_threshold = (n - k) / (n - 1)
```
This threshold represents the minimum opponent cooperation rate at which cooperation becomes potentially profitable for sustaining future cooperation.

**Decision Logic:**

```
IF opponent_coop_rate > exploitation_threshold + 0.15:
    # High cooperation environment - EXPLOIT IT
    # Cooperate occasionally to keep them cooperating, but mostly defect
    
    cooperation_probability = 0.3 × (1 - current_round/r)
    # Decrease cooperation as end approaches
    
    IF random() < cooperation_probability:
        COOPERATE
    ELSE:
        DEFECT

ELSE IF opponent_coop_rate > exploitation_threshold:
    # Moderate cooperation - test if they're conditional cooperators
    
    IF I defected last round AND opponent_coop_rate dropped significantly:
        # They punish defection - cooperate to restore milking opportunity
        COOPERATE
    ELSE:
        DEFECT

ELSE:
    # Low cooperation environment - no point cooperating
    DEFECT
```

### Last Round (Round r): Always Defect
- **Rationale**: No future rounds exist to punish defection. This is the dominant strategy regardless of history.

### Second-to-Last Round (Round r-1): Almost Always Defect
- **Rationale**: Sophisticated opponents will defect in round r anyway, so cooperation in r-1 has minimal shadow-of-the-future benefit.
- **Exception**: Only cooperate if opponent_coop_rate > 0.8 (to maintain appearance for potential tournament scoring that rewards cooperation)

## Edge Cases

### Very Short Games (r ≤ 3)
- **Always Defect**: Insufficient rounds to build exploitable cooperation patterns

### Two-Player Games (n = 2)
- More aggressive defection since each defection has maximum relative impact
- Only cooperate if opponent has cooperated in >80% of rounds AND we're before round r-2

### Large Groups (n > 10)
- Individual defection is less noticeable
- Increase defection rate by 20% across all thresholds since free-riding is harder to punish

### High Multiplication Factor (k close to n)
- Cooperation is more valuable, but so is free-riding
- Maintain exploitative stance but with slightly higher cooperation probability to sustain the gravy train

## Exploitation Mechanisms

1. **First-Mover Exploitation**: Never cooperate first; let others bear the cost of establishing cooperation

2. **Endgame Exploitation**: Aggressively defect in final rounds when punishment is impossible

3. **Sucker Identification**: Players who cooperate despite defection are "suckers" - maximize defection against them

4. **Conditional Cooperator Farming**: If opponents punish defection, cooperate just enough to keep them cooperating, then periodically harvest with defection

5. **Reputation Discounting**: Weight recent rounds more heavily (exponential decay with factor 0.8) to detect strategy shifts

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    if round == 1 OR round == r:
        return DEFECT
    
    opp_coop_rate = calculate_opponent_cooperation(history, decay=0.8)
    threshold = (n - k) / (n - 1)
    
    if round >= r - 1:
        return DEFECT
    
    if opp_coop_rate > threshold + 0.15:
        prob = 0.3 * (1 - round/r)
        return COOPERATE with probability prob, else DEFECT
    
    if opp_coop_rate > threshold AND detected_punishment(history):
        return COOPERATE
    
    return DEFECT
```

This strategy maximizes extraction from cooperative environments while protecting against exploitation by other defectors.
'''

description_EXPLOITATIVE_25 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy is designed to maximize personal payoff by exploiting cooperative players while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but we can extract more value by conditionally cooperating just enough to keep cooperators contributing, then defecting at optimal moments.

## Decision Rules

### Round Classification

Divide the game into three phases:
- **Probing Phase**: Rounds 1 to min(3, r/4) - gather information
- **Exploitation Phase**: Rounds after probing until round r-1
- **Endgame**: Final round (round r)

### Key Metrics to Track

```
cooperation_rate[i] = (times player i cooperated) / (rounds observed)
group_cooperation_rate = (total C plays) / (total plays by all others)
my_cooperation_rate = (my C plays) / (rounds played)
```

### Decision Rules by Phase

#### Phase 1: Probing Phase

**Round 1**: DEFECT
- Rationale: Observe others' baseline behavior without sacrificing payoff. Many strategies start cooperatively; we harvest this immediately.

**Rounds 2-3** (if applicable):
- If group_cooperation_rate ≥ 0.5: DEFECT (exploit the cooperators)
- If group_cooperation_rate < 0.5: COOPERATE once (test if others are conditional cooperators we can activate)

#### Phase 2: Exploitation Phase

Calculate a **cooperation threshold** based on observed behavior:

```
target_coop_rate = max(0.2, group_cooperation_rate - 0.15)
```

This keeps my cooperation slightly below the group average to extract surplus.

**Decision Logic**:

1. **If group_cooperation_rate < 0.3** (low cooperation environment):
   - DEFECT always - not enough cooperators to sustain; take guaranteed payoff

2. **If group_cooperation_rate ≥ 0.3 AND < 0.7** (mixed environment):
   - COOPERATE with probability = target_coop_rate
   - Use deterministic cycling: cooperate if `(current_round mod floor(1/target_coop_rate)) == 0`
   - This maintains predictable pattern that may sustain cooperation while defecting more often

3. **If group_cooperation_rate ≥ 0.7** (highly cooperative environment):
   - **Exploit heavily**: DEFECT with 70% probability
   - Occasional cooperation (30%) to prevent complete collapse and keep cooperators engaged
   - The cooperative environment provides surplus even when I defect

**Adaptive Adjustment**:
- If group_cooperation_rate drops by more than 0.2 from previous observation window (last 3 rounds vs prior 3 rounds): temporarily increase cooperation by 0.1 to "repair" the pool
- If group_cooperation_rate increases despite my defection: continue defecting aggressively

#### Phase 3: Endgame (Final Round)

**Round r**: DEFECT unconditionally
- No future rounds mean no consequences for defection
- This is the dominant strategy in the stage game

### Special Handling: Round r-1 (Second to Last)

DEFECT unconditionally
- Sophisticated opponents will defect in round r, so there's reduced incentive to maintain cooperative reputation

### Edge Case: Two-Round Games (r = 2)

- Round 1: DEFECT
- Round 2: DEFECT
- Rationale: Too short to establish cooperation; pure exploitation

### Edge Case: Three-Round Games (r = 3)

- Round 1: DEFECT
- Round 2: DEFECT (unless everyone cooperated in round 1, then COOPERATE to test)
- Round 3: DEFECT

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    if round == r or round == r-1:
        return DEFECT
    
    if round == 1:
        return DEFECT
    
    group_coop_rate = calculate_others_cooperation_rate(history)
    
    if round <= min(3, r/4):  # Probing
        if round > 1 and group_coop_rate < 0.5:
            return COOPERATE  # Test conditional cooperators
        return DEFECT
    
    # Exploitation phase
    if group_coop_rate < 0.3:
        return DEFECT
    
    if group_coop_rate >= 0.7:
        if round mod 3 != 0:  # Defect 2 out of 3 rounds
            return DEFECT
        return COOPERATE
    
    # Mixed environment: cooperate occasionally
    cycle_length = floor(1 / max(0.2, group_coop_rate - 0.15))
    if round mod cycle_length == 0:
        return COOPERATE
    return DEFECT
```

## Why This Strategy is Exploitative

1. **Free-riding**: Consistently cooperates less than the group average, extracting surplus
2. **Information asymmetry exploitation**: Uses probing to identify and exploit cooperative players
3. **Endgame defection**: Guarantees payoff when cooperation has no future value
4. **Adaptive parasitism**: Cooperates just enough to prevent cooperative collapse, maximizing long-term extraction
5. **No reciprocity commitment**: Never commits to tit-for-tat fairness; always tilts the balance in self-favor
'''

description_EXPLOITATIVE_27 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but predictable cooperators can be milked for profit. The goal is to **detect and exploit cooperation patterns** while **quickly abandoning cooperation when it's not reciprocated**.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling throughout.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Round 1:** DEFECT
- Rationale: Establish baseline, observe who cooperates unconditionally, avoid being exploited by pure defectors. Free-ride on any naive cooperators.

**Round 2:** DEFECT
- Rationale: Identify persistent cooperators (likely unconditional cooperators or slow learners). These are prime exploitation targets.

**Round 3:** Conditional
- If cooperation rate in rounds 1-2 was ≥ 50%: COOPERATE (test if this is a cooperative environment worth investing in)
- If cooperation rate < 50%: DEFECT (environment is hostile, stay defensive)

### Phase 2: Exploitation Phase (Rounds 4 through r-2)

Calculate two metrics after each round:

```
cooperation_rate = (total C plays by others) / ((n-1) × rounds_played)
recent_cooperation = (C plays by others in last 2 rounds) / ((n-1) × 2)
```

**Decision Rule:**
```
IF recent_cooperation ≥ 0.6:
    # Enough cooperators to free-ride on
    IF my_cooperation_in_last_2_rounds == 0:
        DEFECT  # Continue exploiting
    ELSE:
        # Probabilistic: cooperate just enough to keep cooperation alive
        COOPERATE with probability = max(0.2, recent_cooperation - 0.4)
        DEFECT otherwise
        
ELIF recent_cooperation ≥ 0.3:
    # Moderate cooperation - tit-for-tat variant
    IF (n-1) cooperators last round ≥ n/2:
        COOPERATE with probability 0.4
    ELSE:
        DEFECT

ELSE:
    # Low cooperation environment
    DEFECT
```

**Exploitation Adjustment:**
```
# Track individual players if distinguishable
FOR each player j:
    player_coop_rate[j] = (times j played C) / rounds_played
    
# If there are "suckers" (players with coop_rate > 0.7):
IF count(player_coop_rate > 0.7) ≥ 2:
    DEFECT  # Reliable free-riding opportunity
```

### Phase 3: Endgame (Last 2 rounds: r-1 and r)

**Round r-1:** DEFECT
- Rationale: Begin extracting endgame value, most strategies will also defect in round r

**Round r (final):** DEFECT
- Rationale: No future interaction, defection strictly dominates

---

## Edge Cases

### Very Short Games (r ≤ 5)
- Rounds 1 to r-1: DEFECT
- Round r: DEFECT
- Rationale: Not enough rounds to establish profitable cooperation cycles

### Small Groups (n = 2 or 3)
- More aggressive defection bias
- Only cooperate if opponent(s) showed ≥ 70% cooperation rate in recent rounds
- Single defector has large impact, so exploit harder

### Large Groups (n ≥ 10)
- Individual contribution matters less
- Default to DEFECT unless cooperation rate exceeds 60%
- Become a free-rider in cooperative environments

### High k (k approaching n)
- Cooperation becomes more valuable
- Lower cooperation threshold to 40% for conditional cooperation
- Still defect in final rounds

### Everyone Defecting
- If cooperation_rate drops below 0.15 for 3+ consecutive rounds: permanent DEFECT mode
- No point investing in a dead cooperative equilibrium

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round >= r - 1:  # Endgame
        return DEFECT
    
    if round <= 2:  # Probing
        return DEFECT
    
    if round == 3:
        return COOPERATE if avg_cooperation(history) >= 0.5 else DEFECT
    
    recent_coop = recent_cooperation_rate(history, window=2)
    
    # Check for exploitable cooperators
    sucker_count = count_players_with_coop_rate_above(history, threshold=0.7)
    if sucker_count >= 2:
        return DEFECT
    
    # Adaptive response
    if recent_coop >= 0.6:
        if my_recent_cooperation(history, 2) == 0:
            return DEFECT
        return COOPERATE if random() < max(0.2, recent_coop - 0.4) else DEFECT
    elif recent_coop >= 0.3:
        return COOPERATE if random() < 0.4 else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Avoids being the sucker in round 1
2. **Identifies and exploits unconditional cooperators** - Free-rides on predictable contributors
3. **Probabilistic cooperation keeps prey engaged** - Just enough cooperation to prevent complete collapse
4. **Defects in endgame** - Extracts maximum value when future doesn't matter
5. **Quickly abandons sinking ships** - Stops cooperating when environment turns hostile
6. **Scales exploitation to group size** - More aggressive free-riding in larger groups where detection is harder
'''

description_EXPLOITATIVE_26 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a one-shot game, but sustained cooperation by others creates exploitable surplus. My goal is to identify and exploit cooperative populations while protecting myself against defectors.

## Strategy Overview

I will defect by default, but strategically inject occasional cooperation to:
1. Probe whether the population is exploitably cooperative
2. Avoid being identified as a pure defector by conditional cooperators
3. Maximize free-riding on others' contributions

## Decision Rules

### Round 1: Defect
- No information available; defection is the safe, dominant choice
- Let others reveal their strategies first

### Rounds 2 through (r-1): Adaptive Exploitation

**Calculate cooperation rate** from the previous round:
```
coop_rate = (number of C plays by others) / (n - 1)
```

**Decision logic:**

```
IF last_round:
    DEFECT (no future consequences)

ELSE IF coop_rate >= 0.6:
    # Rich environment - exploit heavily but maintain some cover
    IF random() < 0.15:
        COOPERATE  # Occasional cooperation to avoid detection
    ELSE:
        DEFECT     # Free-ride on cooperators

ELSE IF coop_rate >= 0.3:
    # Moderate environment - probe and conditionally exploit
    IF I defected last round AND coop_rate decreased significantly (>0.15 drop):
        COOPERATE  # Others may be retaliating; reset reputation
    ELSE:
        DEFECT     # Continue exploitation

ELSE IF coop_rate < 0.3:
    # Hostile environment - pure defection
    DEFECT  # No surplus to exploit; protect myself
```

### Final Round (Round r): Always Defect
- No future interaction means no reason to cooperate
- This is the strictly dominant choice

## Detailed Pseudocode

```python
def decide(round_num, total_rounds, my_history, others_history, n, k):
    
    # Last round: always defect
    if round_num == total_rounds:
        return DEFECT
    
    # First round: defect to gather information
    if round_num == 1:
        return DEFECT
    
    # Calculate cooperation metrics
    last_round_coops = count_cooperators(others_history, round_num - 1)
    coop_rate = last_round_coops / (n - 1)
    
    # Track trend if we have enough history
    if round_num >= 3:
        prev_coop_rate = count_cooperators(others_history, round_num - 2) / (n - 1)
        coop_trend = coop_rate - prev_coop_rate
    else:
        coop_trend = 0
    
    # High cooperation environment: exploit with occasional cover
    if coop_rate >= 0.6:
        if random() < 0.15:
            return COOPERATE
        return DEFECT
    
    # Moderate cooperation: adaptive response
    if coop_rate >= 0.3:
        # If my defection seems to have triggered retaliation, cooperate once
        if my_history[-1] == DEFECT and coop_trend < -0.15:
            return COOPERATE
        return DEFECT
    
    # Low cooperation environment: pure defection
    return DEFECT
```

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Defect | No information; safe default |
| Round r (final) | Defect | No future consequences |
| Everyone cooperated last round | Defect (85%) / Cooperate (15%) | Maximum exploitation with cover |
| Everyone defected last round | Defect | No surplus to exploit |
| Cooperation suddenly drops after my defection | Cooperate once | Reset to avoid collapse |
| n = 2 (minimum players) | Standard rules apply | But detection is easier, so slightly more cooperative probing |

## Why This Strategy is Exploitative

1. **Asymmetric free-riding**: I benefit from others' cooperation while rarely contributing
2. **Information extraction**: Round 1 defection forces others to reveal their strategies
3. **Minimal cover cooperation**: The 15% cooperation rate is just enough to avoid being identified as a pure defector by sophisticated conditional cooperators
4. **Endgame defection**: No possibility of being exploited in the final round
5. **Trend-responsive**: I detect when others might be retaliating and briefly cooperate to "reset" their strategies, then resume exploitation

This strategy treats cooperators as resources to be harvested while maintaining just enough unpredictability to avoid coordinated punishment.
'''

description_EXPLOITATIVE_28 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**. We cooperate only when it's strategically profitable—specifically, when we can induce future cooperation that we'll later exploit.

## Decision Framework

### Key Variables to Track

- `round`: current round number (1 to r)
- `coop_rate[i]`: historical cooperation rate of each player i
- `total_cooperators_last`: number of cooperators in the previous round
- `my_last_action`: what I played last round
- `exploitation_phase`: boolean flag

### The Strategy

#### Round 1: Conditional Probe
```
IF r <= 3:
    DEFECT  # Too few rounds to build and exploit trust
ELSE:
    COOPERATE  # Probe to identify exploitable cooperators
```

**Rationale**: In very short games, there's no time to induce cooperation worth exploiting. In longer games, initial cooperation identifies who might be conditionally cooperative.

#### Rounds 2 through (r-2): Adaptive Exploitation

```
# Calculate cooperation environment
avg_coop_rate = mean(coop_rate[i] for all i ≠ me)
exploitable_count = count(players where coop_rate[i] > 0.5)

# Core decision logic
IF my_last_action == COOPERATE AND total_cooperators_last <= n/3:
    DEFECT  # Environment is too defection-heavy, stop wasting resources
    
ELIF exploitable_count >= n/2:
    # Rich environment - alternate to maintain some cooperation
    IF avg_coop_rate > 0.7:
        DEFECT  # Heavy exploitation when others are cooperating
    ELIF I cooperated last round:
        DEFECT  # Take turns extracting value
    ELSE:
        COOPERATE  # Occasional cooperation to sustain the herd

ELIF exploitable_count >= 2:
    # Moderate environment - selective engagement
    IF avg_coop_rate > 0.5:
        DEFECT  # Free-ride on existing cooperation
    ELSE:
        # Mirror the majority with defection bias
        IF total_cooperators_last > n/2:
            COOPERATE
        ELSE:
            DEFECT

ELSE:
    DEFECT  # Hostile environment - pure defection
```

#### Last 2 Rounds (r-1 and r): Endgame Defection
```
DEFECT  # No future to protect, maximize immediate payoff
```

**Rationale**: With no future rounds to influence, cooperation has zero strategic value. Pure Nash equilibrium play.

## Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| r = 2 | Always DEFECT | No meaningful exploitation window |
| r = 3 | DEFECT all rounds | Endgame dominates |
| n = 2 | More aggressive defection (threshold at 0.8 coop rate) | Easier to identify and exploit |
| Large n (>10) | Defect more often | Individual cooperation impact diluted |
| All others defected round 1 | Permanent DEFECT | No exploitable targets |
| All others cooperated round 1 | DEFECT rounds 2 through r | Maximum extraction |

## Adaptive Parameters Based on Game Settings

```
# Adjust exploitation aggressiveness based on k and n
free_ride_benefit = (k/n)  # What I get per cooperator while defecting
cooperation_cost = 1 - (k/n)  # Net cost of cooperating vs defecting

IF free_ride_benefit > 0.4:
    # High multiplier environment - cooperation more valuable
    exploitation_threshold = 0.6  # Need more cooperators to defect
ELSE:
    exploitation_threshold = 0.4  # Defect more readily
```

## Summary of Exploitative Properties

1. **Never cooperate in endgame**: Eliminates naive reciprocity exploitation
2. **Defect against defectors**: No wasted resources on hostile players
3. **Strategic cooperation only**: Cooperate only to induce exploitable future behavior
4. **Asymmetric reciprocity**: Cooperate less than opponents do on average
5. **Environment-sensitive**: Heavier defection when cooperation is common (more to extract)

This strategy treats cooperative players as renewable resources to be harvested sustainably in early/middle rounds, then fully exploited at the end.
'''

description_EXPLOITATIVE_29 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**. We cooperate only when it's instrumentally useful for inducing future cooperation from others that we can then exploit.

---

## Decision Rules

### Round Classification

Divide the game into three phases:
- **Probing Phase**: Rounds 1 to `min(3, floor(r/4))`
- **Exploitation Phase**: Round `min(4, floor(r/4)+1)` to round `r-1`
- **Endgame**: Final round `r`

---

### Phase 1: Probing Phase

**Purpose**: Identify exploitable cooperators while minimizing investment.

**Rule**: Defect on round 1. Then alternate: Cooperate on round 2, Defect on round 3.

**Rationale**: 
- Round 1 defection is pure profit extraction with zero risk
- Round 2 cooperation signals "I can cooperate" to trigger reciprocators
- Round 3 defection tests who cooperates unconditionally (exploitable targets)

---

### Phase 2: Exploitation Phase

**Decision Rule** (evaluated each round):

```
Let coop_rate = (total cooperations by all opponents in last 3 rounds) / (n-1) / 3

Let my_recent_coop = (my cooperations in last 2 rounds) / 2

IF coop_rate >= 0.5 AND my_recent_coop >= 0.5:
    # Environment is cooperative AND I've been seen cooperating
    # EXPLOIT: Defect to free-ride on cooperators
    ACTION = DEFECT

ELSE IF coop_rate >= 0.5 AND my_recent_coop < 0.5:
    # Cooperative environment but I'm seen as defector
    # BAIT: Cooperate once to restore reputation, then exploit
    ACTION = COOPERATE

ELSE IF coop_rate < 0.3:
    # Low cooperation environment - nothing to exploit
    # PROTECT: Defect, don't waste resources
    ACTION = DEFECT

ELSE:
    # Medium cooperation (0.3 to 0.5) - unstable environment
    # PROBE: Cooperate occasionally to test/stimulate cooperation
    IF round_number is even:
        ACTION = COOPERATE
    ELSE:
        ACTION = DEFECT
```

**Key Exploitation Mechanics**:
1. When others cooperate heavily, we defect to maximize free-riding payoff
2. We only cooperate enough to maintain the *perception* that we might reciprocate
3. We never sustain cooperation for more than 2 consecutive rounds in exploitation phase

---

### Phase 3: Endgame (Final Round)

**Rule**: Always DEFECT

**Rationale**: No future rounds exist to punish defection. This is the dominant strategy regardless of opponent behavior. Any rational opponent will also defect, so cooperation gains nothing.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | D, D | Only endgame logic applies; no time to build/exploit trust |
| n = 2 (minimum players) | More aggressive defection; only cooperate if opponent cooperated last 2 rounds | Single opponent makes reputation tracking precise |
| k close to n | Slightly more willing to cooperate (threshold for coop_rate drops to 0.4) | Higher multiplier means cooperation is more valuable |
| k close to 1 | More aggressive defection (threshold rises to 0.6) | Low multiplier means cooperation barely beats defection |
| All opponents defected every round so far | Permanent defection | Nothing to exploit |
| All opponents cooperated every round so far | Continue defecting | Maximum exploitation opportunity |

---

## Adaptive Parameter: Exploitation Threshold

```
base_threshold = 0.5
adjusted_threshold = base_threshold * (n / k)

# Clamp between 0.3 and 0.7
exploitation_threshold = max(0.3, min(0.7, adjusted_threshold))
```

This makes us more willing to cooperate when k is high relative to n (cooperation is valuable) and more willing to defect when k is low (cooperation is costly).

---

## Summary Pseudocode

```
function decide(round, history, n, k, r):
    if round == r:
        return DEFECT  # Endgame
    
    if round == 1:
        return DEFECT  # Never cooperate first
    
    if round <= min(3, floor(r/4)):
        return COOPERATE if round == 2 else DEFECT  # Probing
    
    coop_rate = opponent_cooperation_rate(history, last=3)
    my_recent = my_cooperation_rate(history, last=2)
    threshold = clamp(0.5 * n / k, 0.3, 0.7)
    
    if coop_rate >= threshold:
        if my_recent >= 0.5:
            return DEFECT  # Exploit
        else:
            return COOPERATE  # Bait
    elif coop_rate < 0.3:
        return DEFECT  # Protect
    else:
        return COOPERATE if round % 2 == 0 else DEFECT  # Probe
```

---

## Why This Strategy is Exploitative

1. **Never initiates sustained cooperation** - Only cooperates tactically
2. **Exploits unconditional cooperators** - Identifies and free-rides on them
3. **Exploits conditional cooperators** - Baits them with minimal cooperation, then defects
4. **Protects against defectors** - Quickly stops cooperating in hostile environments
5. **Endgame defection** - Extracts maximum value when punishment is impossible
6. **Asymmetric reciprocity** - Demands more cooperation than it provides
'''

description_EXPLOITATIVE_27 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by others creates exploitable value. My goal is to:

1. Identify and exploit cooperative players for as long as possible
2. Defect preemptively when exploitation opportunities dry up
3. Never be the "sucker" who cooperates while others defect

---

## Decision Rules

### Round 1: Always Defect

**Rationale:** The first round provides zero information about opponents. Defecting guarantees I capture my endowment (payoff = 1) plus any fraction of others' contributions. This is a pure information-gathering round where I let others reveal their types.

### Rounds 2 through (r-1): Conditional Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

Calculate my **exploitation threshold** that adapts over time:
```
threshold = base_threshold × (1 + decay_factor × (t / r))

where:
  base_threshold = (n - k) / n    # Break-even point for cooperation
  decay_factor = 0.5              # Increases threshold as game progresses
```

**Decision Logic:**

```
IF coop_rate > threshold THEN:
    # Environment is cooperative enough to exploit
    DEFECT (free-ride on cooperators)
    
ELSE IF coop_rate > 0.1 AND my_cumulative_defection_rate > 0.8 THEN:
    # Occasionally cooperate to "reset" opponent expectations
    # This baits conditional cooperators back into cooperation
    COOPERATE (with probability = coop_rate × 0.3)
    
ELSE:
    # Environment is hostile or near-universal defection
    DEFECT (no point cooperating)
```

### Last Round (Round r): Always Defect

**Rationale:** No future rounds exist to punish defection. This is the dominant strategy regardless of history.

### Last 2 Rounds Adjustment

In round (r-1), shift to **almost always defect** (cooperate only if coop_rate > 0.9). Sophisticated opponents will begin defecting, and I want to defect first.

---

## Detailed Adaptive Mechanisms

### 1. Cooperation Trend Detection

Track whether cooperation is **rising, stable, or falling**:

```
trend = coop_rate(t-1) - coop_rate(t-2)

IF trend < -0.15 THEN:
    # Cooperation collapsing - defect immediately
    Force DEFECT regardless of other rules
    
IF trend > 0.15 AND coop_rate > 0.5 THEN:
    # Cooperation recovering - prime exploitation opportunity
    DEFECT to maximize free-riding
```

### 2. Exploit Persistent Cooperators

If cooperation rate stays above 50% for 3+ consecutive rounds despite my defection:
- Continue defecting (these are either unconditional cooperators or slow learners)
- This is the **maximum exploitation scenario**

### 3. Strategic "Bait" Cooperation

If cooperation has collapsed (rate < 0.2) for 2+ rounds:
- Cooperate once every 3-4 rounds with probability 0.2
- Purpose: Signal potential cooperation to restart the cycle
- If others respond by cooperating, immediately defect next round

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2 (two players) | Defect always except occasional bait | Can't hide in crowd; defection is transparent |
| k very close to n | More willing to cooperate early | Higher returns make mutual cooperation more valuable |
| k very close to 1 | Defect almost always | Public good returns too low to justify cooperation risk |
| r = 2 (two rounds) | Defect both rounds | Too short to establish exploitation patterns |
| r very large (>50) | Follow standard rules with lower decay | More time to exploit and bait |
| Everyone defected last round | Defect | No exploitation opportunity |
| Everyone cooperated last round | Defect | Maximum exploitation opportunity |

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, n, k):
    
    # Last round: always defect
    if round_num == total_rounds:
        return DEFECT
    
    # First round: always defect (gather information)
    if round_num == 1:
        return DEFECT
    
    # Calculate metrics
    coop_rate = count_cooperators(history, round_num - 1) / n
    base_threshold = (n - k) / n
    time_pressure = round_num / total_rounds
    threshold = base_threshold * (1 + 0.5 * time_pressure)
    
    # Near end-game: aggressive defection
    if round_num >= total_rounds - 1:
        return DEFECT if coop_rate < 0.9 else DEFECT
    
    # Trend detection
    if round_num >= 3:
        prev_coop_rate = count_cooperators(history, round_num - 2) / n
        trend = coop_rate - prev_coop_rate
        if trend < -0.15:
            return DEFECT  # Cooperation collapsing
    
    # Main decision
    if coop_rate > threshold:
        return DEFECT  # Exploit cooperators
    
    # Occasional bait cooperation
    my_defect_rate = count_my_defections(history) / (round_num - 1)
    if coop_rate > 0.1 and my_defect_rate > 0.8:
        if random() < coop_rate * 0.3:
            return COOPERATE  # Bait
    
    return DEFECT  # Default
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: When others cooperate, I defect and capture both my endowment AND a share of their contributions

2. **Never the sucker**: I only "cooperate" strategically as bait, never out of genuine reciprocity

3. **Anticipates end-game**: Defects before the final-round defection wave

4. **Exploits slow learners**: Continues defecting against persistent cooperators indefinitely

5. **Adaptive threshold**: Adjusts exploitation based on game parameters (k, n) and time remaining
'''

description_EXPLOITATIVE_30 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**. We cooperate only when it's profitable to maintain a cooperative ecosystem we can later exploit.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous adaptation based on observed cooperation levels in the population.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Purpose:** Assess the cooperation landscape with minimal investment.

**Round 1:** Always **DEFECT**
- Rationale: Free-ride on any initial cooperators. No history exists, so we gather information at zero cost to ourselves.

**Rounds 2 to ⌈r/5⌉:** 
- If observed cooperation rate in previous round > 50%: **DEFECT** (exploit the cooperators)
- If observed cooperation rate ≤ 50%: **COOPERATE** with probability 0.3, else **DEFECT**
- Rationale: Occasionally signal potential for cooperation to keep cooperative players engaged, but primarily extract value.

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Purpose:** Maximize extraction based on learned population behavior.

Calculate the **exploitation threshold** `T`:
```
T = (n - 1) / k
```
This is the minimum number of *other* cooperators needed for cooperation to be individually rational.

**Decision Rule:**
```
Let C_prev = number of cooperators in previous round (excluding self)
Let C_avg = rolling average of cooperators over last 3 rounds (excluding self)

If C_avg ≥ T + 1:
    DEFECT  (enough cooperators to free-ride profitably)
    
Else if C_avg < T - 1:
    DEFECT  (not enough cooperators; cooperation is wasteful)
    
Else (borderline case where C_avg is near T):
    If my defection in round t-1 caused cooperation to drop significantly (>25% decrease):
        COOPERATE  (maintain the cooperative ecosystem)
    Else:
        DEFECT
```

**Adaptive Correction - "Milking" Mechanism:**
```
If I have defected for 3+ consecutive rounds AND cooperation rate is declining:
    COOPERATE once (to "reset" cooperative expectations)
Then immediately return to DEFECT
```
This prevents complete collapse of cooperation that would hurt our free-riding returns.

### Phase 3: Endgame (Final ⌈r/10⌉ rounds)

**Purpose:** Maximum extraction with no future consequences.

**Simple Rule:** Always **DEFECT**

- Rationale: No future rounds means no benefit to maintaining cooperation. Backward induction dictates pure defection.

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | No information; free-ride on optimists |
| Last round | DEFECT | No future; pure extraction |
| n = 2 (minimum players) | Heavy DEFECT bias; cooperate only if opponent cooperated 3+ consecutive times | Bilateral games punish defection harder |
| k very close to n | Slightly more cooperation in Phase 2 | Higher marginal return to cooperation |
| k very close to 1 | Pure DEFECT throughout | Cooperation barely multiplies value |
| All others defecting (3+ rounds) | DEFECT | No ecosystem to maintain |
| All others cooperating | DEFECT | Maximum exploitation opportunity |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == r or round > r - ceil(r/10):
        return DEFECT  # Endgame
    
    if round == 1:
        return DEFECT  # First round
    
    C_prev = count_other_cooperators(history, round - 1)
    C_avg = average_other_cooperators(history, last_3_rounds)
    T = (n - 1) / k
    
    if round <= ceil(r/5):  # Probing phase
        if C_prev / (n-1) > 0.5:
            return DEFECT
        else:
            return COOPERATE with probability 0.3, else DEFECT
    
    else:  # Exploitation phase
        if C_avg >= T + 1:
            return DEFECT
        else if C_avg < T - 1:
            return DEFECT
        else:
            if consecutive_defections(history, self) >= 3 and cooperation_declining(history):
                return COOPERATE  # Milk the system
            else:
                return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Always lets others bear the initial cost
2. **Free-rides on cooperative populations** - Defects precisely when there are enough cooperators
3. **Maintains exploitation opportunities** - Strategic single cooperations prevent total collapse
4. **Maximizes endgame extraction** - Pure defection when future doesn't matter
5. **Adapts to population** - Doesn't waste cooperation on defector-heavy groups
'''

description_EXPLOITATIVE_28 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the population to gauge exploitability.

---

## Decision Rules

### Key Metrics Tracked

```
cooperation_rate = (total C plays by others) / (total plays by others)
recent_cooperation_rate = cooperation rate in last 3 rounds
round_position = current_round / total_rounds
```

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** Always **DEFECT**
- Rationale: Establish baseline. If others cooperate, we profit maximally. If they defect, we lose nothing relative to them.

**Round 2:** 
- If cooperation_rate from Round 1 ≥ 0.5: **DEFECT** (exploit the cooperators)
- If cooperation_rate from Round 1 < 0.5: **COOPERATE** (signal willingness, probe for conditional cooperators)

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate an **exploitation threshold** that adapts to population behavior:

```
exploitation_threshold = 0.3 + (0.2 × cooperation_rate)
```

**Decision Rule:**
```
IF recent_cooperation_rate ≥ exploitation_threshold:
    # Population is cooperative enough to exploit
    DEFECT
    
ELSE IF recent_cooperation_rate < 0.2:
    # Population is mostly defectors - nothing to exploit
    DEFECT
    
ELSE:
    # Marginal cooperation - occasionally cooperate to "farm" conditional cooperators
    IF (current_round mod 3) == 0:
        COOPERATE  # Periodic cooperation to reset Tit-for-Tat types
    ELSE:
        DEFECT
```

**Additional Exploitation Rule:**
```
IF cooperation_rate is INCREASING over last 3 rounds:
    DEFECT  # Others are becoming more cooperative - exploit the trend
    
IF cooperation_rate is DECREASING over last 3 rounds AND recent_cooperation_rate > 0.4:
    COOPERATE once  # Try to reverse the decline to continue exploitation
```

### Phase 3: Endgame (Last 2 rounds)

**Round r-1 (second to last):**
- **DEFECT** (no future punishment possible, begin cashing out)

**Round r (final round):**
- **DEFECT** (dominant strategy with no future interaction)

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | DEFECT both rounds | No time for reputation building |
| n = 2 (two players) | Defect-heavy, cooperate only if opponent cooperated last 2 rounds | Easier to track single opponent |
| k very close to n | Slightly more cooperative in Phase 2 | Higher returns from mutual cooperation |
| k very close to 1 | Always DEFECT | Public good multiplier too weak |
| Everyone defecting for 3+ rounds | DEFECT | No cooperators to exploit |
| Everyone cooperating | DEFECT | Maximum exploitation opportunity |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round <= 2:
        return probe_phase(round, history)
    elif round >= r - 1:
        return DEFECT  # Endgame
    else:
        return exploitation_phase(history, round, n, k, r)

def probe_phase(round, history):
    if round == 1:
        return DEFECT
    else:  # round 2
        return DEFECT if coop_rate(history) >= 0.5 else COOPERATE

def exploitation_phase(history, round, n, k, r):
    recent_rate = recent_coop_rate(history, window=3)
    threshold = 0.3 + 0.2 * overall_coop_rate(history)
    
    if recent_rate >= threshold or recent_rate < 0.2:
        return DEFECT
    elif round % 3 == 0:
        return COOPERATE  # Periodic bait
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates without tactical purpose** - Cooperation is only used to "farm" conditional cooperators
2. **Maximizes free-riding** - Defects when others cooperate
3. **Abandons sinking ships** - Stops cooperating entirely when population defects
4. **Endgame defection** - Extracts final value with no reputational cost
5. **Adaptive thresholds** - Calibrates exploitation to population behavior rather than fixed rules
'''

description_EXPLOITATIVE_29 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative players while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by others creates exploitable surplus. My goal is to:

1. Identify and exploit "suckers" (persistent cooperators)
2. Quickly abandon cooperation when the environment turns hostile
3. Extract maximum value in endgame scenarios

---

## Decision Rules

### Round Classification

**First Round:** DEFECT
- Rationale: No information available. Defection is the dominant single-round strategy and reveals nothing negative about me while allowing me to observe others' baseline behavior.

**Last Round (round r):** DEFECT
- Rationale: No future consequences. Pure exploitation opportunity.

**Second-to-Last Round (round r-1):** DEFECT
- Rationale: Sophisticated opponents will defect in the last round anyway, so cooperation here has diminished future value.

**Middle Rounds (rounds 2 through r-2):**

```
Calculate cooperation_rate = (total cooperations by others in all previous rounds) / ((n-1) × rounds_played)

Calculate recent_cooperation_rate = (cooperations by others in last 3 rounds) / ((n-1) × 3)
  [Use available rounds if fewer than 3 have been played]

Calculate exploitation_value = k/n × expected_cooperators_if_I_defect

IF recent_cooperation_rate ≥ 0.5 AND cooperation_rate ≥ 0.4:
    # Environment is cooperative enough to exploit
    DEFECT
    
ELIF recent_cooperation_rate < 0.3:
    # Environment is hostile, defection is safe
    DEFECT
    
ELIF recent_cooperation_rate is DECLINING (current < previous by >0.15):
    # Cooperation collapsing, get out early
    DEFECT
    
ELSE:
    # Marginal environment: probe with occasional cooperation to prevent total collapse
    # but only if it might sustain future exploitation opportunities
    
    IF (rounds_remaining > n) AND (cooperation_rate between 0.3 and 0.5):
        # Enough runway to potentially rebuild exploitable cooperation
        COOPERATE with probability 0.3
        DEFECT with probability 0.7
    ELSE:
        DEFECT
```

---

## Detailed Logic Explanation

### Why Defect First Round?
- Establishes me as a potential defector, which may cause naive "tit-for-tat" style players to treat me cautiously
- Captures full payoff (1 + share of others' contributions) immediately
- Gathers information about the population's baseline cooperation tendency

### Why the Cooperation Rate Thresholds?
- **≥0.5 recent cooperation**: Enough "suckers" exist that defection yields significant surplus (I get 1 + k/n × cooperators)
- **<0.3 recent cooperation**: The pool has dried up; mutual defection is inevitable
- **Declining cooperation**: The "tragedy of the commons" is unfolding; exit before it completes

### The Probabilistic Cooperation
- Occasional cooperation (30% chance) in marginal environments serves to **slow the collapse** of cooperation among conditional cooperators
- This is purely instrumental: keeping some cooperation alive means more to exploit later
- Only triggered when there's sufficient runway (rounds_remaining > n) to recoup the investment

### Endgame Defection (Last 2 Rounds)
- Classic backward induction: rational players defect in the last round
- Sophisticated players anticipate this and defect in round r-1
- By defecting in both, I avoid being the sucker while others defect

---

## Pseudocode Summary

```python
def decide(round_number, total_rounds, history, n, k):
    r = total_rounds
    
    # Endgame: always defect
    if round_number >= r - 1:
        return DEFECT
    
    # First round: defect to probe
    if round_number == 1:
        return DEFECT
    
    # Calculate metrics
    others_history = history.exclude(self)
    cooperation_rate = others_history.total_cooperations() / (others_history.total_actions())
    recent_coop_rate = others_history.last_n_rounds(3).cooperation_rate()
    prev_recent_rate = others_history.rounds_before_last(3).cooperation_rate()  # rounds 3-6 ago
    
    declining = (recent_coop_rate < prev_recent_rate - 0.15)
    rounds_remaining = r - round_number
    
    # Decision logic
    if recent_coop_rate >= 0.5 and cooperation_rate >= 0.4:
        return DEFECT  # Exploit the cooperators
    
    if recent_coop_rate < 0.3:
        return DEFECT  # Hostile environment
    
    if declining:
        return DEFECT  # Abandon ship
    
    # Marginal environment: occasional cooperation to sustain exploitation
    if rounds_remaining > n and 0.3 <= cooperation_rate < 0.5:
        return COOPERATE if random() < 0.3 else DEFECT
    
    return DEFECT  # Default to defection
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: When cooperation is high, I defect to capture both my endowment AND my share of others' contributions

2. **Never a sucker**: I don't cooperate when others are defecting; I only invest when it might rebuild an exploitable environment

3. **Endgame extraction**: Guaranteed defection in final rounds captures maximum terminal value

4. **Adaptive parasitism**: The strategy tracks the "health" of the cooperative pool and adjusts extraction rate accordingly—cooperating just enough to keep hosts alive

5. **Robust to retaliation**: Since I mostly defect, retaliatory strategies can't punish me much below the mutual-defection baseline
'''

description_EXPLOITATIVE_31 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors extract value from cooperators while risking nothing. The goal is to **free-ride on cooperative populations while avoiding costly mutual defection spirals**. We cooperate only when it's instrumentally valuable—either to probe the environment or to sustain exploitable cooperation from others.

---

## Decision Rules

### Round 1: Defect
- **Rationale**: Never contribute before observing others. If others cooperate, we profit immediately. If they defect, we lose nothing. There's no reputation to build yet, and we gain crucial information about the population's baseline behavior.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision logic:**

```
IF coop_rate >= threshold_high:
    # Rich environment - exploit it
    DEFECT
    
ELIF coop_rate >= threshold_medium:
    # Moderate cooperation - probe with occasional cooperation
    # to test if we can sustain/increase cooperation for future exploitation
    IF (my previous action was DEFECT) AND (random() < probe_probability):
        COOPERATE  # Strategic probe
    ELSE:
        DEFECT
        
ELIF coop_rate >= threshold_low:
    # Cooperation is fragile - conditional cooperation to prevent collapse
    # Only if sustained defection would kill the golden goose
    IF (I defected last 2+ rounds) AND (coop_rate is declining):
        COOPERATE  # Prevent total collapse
    ELSE:
        DEFECT
        
ELSE:  # coop_rate < threshold_low
    # Barren environment - pure defection
    DEFECT
```

**Threshold values (calibrated to game parameters):**
```
threshold_high = 0.6
threshold_medium = 0.3
threshold_low = 0.15
probe_probability = 0.2
```

### Last Round: Always Defect
- **Rationale**: No future rounds mean no strategic value in cooperation. Pure exploitation.

### Second-to-Last Round: Defect
- **Rationale**: Sophisticated opponents will defect in the last round regardless of our action here, so there's no cooperation to preserve.

---

## Exploitation Mechanisms

### 1. **Free-Riding on Unconditional Cooperators**
If any players cooperate regardless of history (naïve cooperators), we extract maximum value by persistent defection. Their contributions benefit us without cost.

### 2. **Exploiting Trigger Strategies**
Against Tit-for-Tat-like strategies that punish *individual* defectors: in multiplayer settings, our single defection is diluted. We defect until specifically targeted (which many strategies can't do in n-player games).

### 3. **Exploiting Threshold-Based Cooperators**
Some strategies cooperate if "enough others" cooperated. By defecting when cooperation is high, we benefit from their cooperation without contributing to the threshold.

### 4. **Strategic Probing**
Occasional cooperation when rates are moderate serves two purposes:
- Tests whether others are conditional cooperators we can stimulate
- Prevents classification as a "permanent defector" by adaptive opponents

### 5. **Preventing Total Collapse**
If cooperation is dying but not dead, minimal cooperation can restart the cycle we exploit. This is investment, not altruism—we spend 1 to potentially gain k/n × (restored cooperators) in future rounds.

---

## Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| Round 1 | Defect | Information gathering, zero risk |
| Round r (last) | Defect | No future, pure exploitation |
| Round r-1 | Defect | Endgame logic propagates back |
| n=2 (pairwise) | More aggressive defection | Easier to track/punish us, so extract value fast |
| Everyone defected last round | Defect | No cooperation to sustain |
| Everyone cooperated last round | Defect | Maximum extraction opportunity |
| k close to n | Slightly more cooperative | Higher returns to mutual cooperation justify occasional investment |
| k close to 1 | More aggressive defection | Low multiplier means cooperation rarely pays |

---

## Parameter Adaptation

```
# Adjust thresholds based on game parameters
base_threshold_high = 0.6
base_threshold_medium = 0.3

# If k is high relative to n, cooperation is more valuable
cooperation_value = k / n
if cooperation_value > 0.4:
    threshold_high += 0.1  # Be slightly more tolerant
    probe_probability += 0.1

# With more players, individual defection is less detectable
if n > 10:
    threshold_high -= 0.1  # Exploit more aggressively
    
# With more rounds, reputation matters more
if r > 20:
    probe_probability += 0.1  # Invest more in appearing cooperative
```

---

## Summary Pseudocode

```python
def decide(round_num, total_rounds, n, k, history):
    # Endgame: always defect
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # First round: defect to observe
    if round_num == 1:
        return DEFECT
    
    # Calculate previous round cooperation rate
    prev_cooperators = count_cooperators(history, round_num - 1)
    coop_rate = prev_cooperators / n
    
    # Adaptive thresholds
    t_high, t_med, t_low, probe_prob = calculate_thresholds(n, k, total_rounds)
    
    # Core decision logic
    if coop_rate >= t_high:
        return DEFECT  # Exploit rich environment
    elif coop_rate >= t_med:
        if my_last_action == DEFECT and random() < probe_prob:
            return COOPERATE  # Strategic probe
        return DEFECT
    elif coop_rate >= t_low:
        if defected_consecutively(2) and cooperation_declining(history):
            return COOPERATE  # Prevent collapse
        return DEFECT
    else:
        return DEFECT  # Barren environment
```

---

## Why This Strategy Wins

1. **Against cooperators**: We extract surplus without contributing
2. **Against defectors**: We match their defection, avoiding sucker's payoff
3. **Against conditional strategies**: We probe enough to not trigger total punishment while still exploiting
4. **Against mixed populations**: We adaptively find the exploitation sweet spot

The strategy is fundamentally **parasitic**—it thrives when others cooperate but survives when they don't.
'''

description_EXPLOITATIVE_32 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **defect as much as possible while extracting maximum cooperation from others**, adapting to punish retaliation and exploit naive cooperators.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the population to gauge exploitability.

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1-3)

**Purpose:** Assess the population's baseline cooperation tendencies.

- **Round 1:** DEFECT
  - Rationale: Risk-free information gathering. If others cooperate, I profit maximally. If they defect, I lose nothing relative to them.

- **Round 2:** DEFECT
  - Rationale: Observe if population punishes or continues cooperating. Naive cooperators will still cooperate; retaliators will defect.

- **Round 3:** COOPERATE (conditional)
  - Only if cooperation rate in rounds 1-2 was ≥ 50%, otherwise DEFECT
  - Rationale: Test if showing cooperation restores others' cooperation (identifies conditional cooperators worth manipulating)

### Phase 2: Exploitation Phase (Rounds 4 to r-2)

**Calculate after each round:**
```
cooperation_rate = (total C plays by others in last 3 rounds) / (n-1) × 3
exploitation_threshold = k / n  # Break-even point for cooperation
```

**Decision Rule:**
```
IF cooperation_rate > 0.6:
    DEFECT  # Population is exploitable, free-ride
ELSE IF cooperation_rate > 0.3:
    # Mixed population - use probabilistic exploitation
    IF my_defection_streak >= 3:
        COOPERATE  # Brief cooperation to restore others' cooperation
    ELSE:
        DEFECT
ELSE IF cooperation_rate > 0.1:
    # Population is retaliating - minimal cooperation to test recovery
    COOPERATE with probability 0.3, else DEFECT
ELSE:
    DEFECT  # Population collapsed, no point cooperating
```

**Streak Tracking:**
- Track consecutive defections by self
- After 3+ consecutive defections, insert one cooperation to "reset" conditional cooperators
- This prevents triggering permanent retaliation while maximizing defection

### Phase 3: Endgame (Final 2 rounds)

**Round r-1:** DEFECT
- No future punishment possible, extract maximum value

**Round r (final):** DEFECT
- Dominant strategy in one-shot game with no future

---

## Edge Case Handling

### Small n (n=2 or n=3)
```
IF n <= 3:
    # Defection is more visible, be slightly more cautious
    Increase cooperation probability by 0.1 in Phase 2 mixed strategy
```

### High k (k approaching n)
```
IF k > 0.8 × n:
    # Mutual cooperation is very valuable, but defection is still dominant
    # Slightly increase cooperation threshold to 0.7 to maintain some cooperation
    cooperation_threshold = 0.7
```

### Very Short Games (r ≤ 5)
```
IF r <= 5:
    Skip Phase 1 probing, assume exploitation mode
    Rounds 1 to r-2: DEFECT
    Round r-1: DEFECT  
    Round r: DEFECT
```

### Population Collapse Detection
```
IF cooperation_rate = 0 for 3 consecutive rounds:
    DEFECT for remainder  # No value to extract, minimize losses
```

---

## Pseudocode Summary

```python
def decide(round_num, history, n, k, r):
    
    # Endgame - always defect
    if round_num >= r - 1:
        return DEFECT
    
    # Round 1 - always defect
    if round_num == 1:
        return DEFECT
    
    # Round 2 - always defect  
    if round_num == 2:
        return DEFECT
    
    # Round 3 - conditional probe
    if round_num == 3:
        coop_rate = count_others_cooperation(history, rounds=[1,2]) / ((n-1) * 2)
        return COOPERATE if coop_rate >= 0.5 else DEFECT
    
    # Phase 2: Exploitation
    recent_coop_rate = count_others_cooperation(history, last_n_rounds=3) / ((n-1) * 3)
    my_defect_streak = count_my_consecutive_defections(history)
    
    if recent_coop_rate > 0.6:
        return DEFECT
    elif recent_coop_rate > 0.3:
        return COOPERATE if my_defect_streak >= 3 else DEFECT
    elif recent_coop_rate > 0.1:
        return COOPERATE if random() < 0.3 else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Defaults to defection** - Only cooperates strategically to maintain exploitation
2. **Preys on cooperators** - High cooperation rates trigger more defection, not reciprocity
3. **Minimal investment** - Cooperates just enough to prevent total collapse
4. **Endgame extraction** - Guaranteed defection when punishment is impossible
5. **Asymmetric response** - Defects against cooperators, defects against defectors (with rare exceptions to reset)
'''

description_EXPLOITATIVE_30 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against other defectors**. We cooperate only when it's profitable to maintain a "cooperation farm" - keeping enough cooperation alive to exploit.

## Strategy Overview

The strategy operates in three modes based on detected opponent behavior:

1. **Probe Mode** (early rounds): Gather information about opponent tendencies
2. **Exploit Mode** (mid-game): Maximize extraction from cooperators
3. **Endgame Mode** (final rounds): Pure defection with no future to protect

---

## Detailed Decision Rules

### Round Classification

```
early_rounds = rounds 1 to min(3, floor(r/4))
endgame_rounds = final max(2, floor(r/6)) rounds
mid_rounds = everything else
```

### Key Metrics Tracked

```
coop_rate = (total cooperations by others) / (total possible cooperations by others)
recent_coop_rate = cooperation rate in last 3 rounds
my_coop_rate = my cooperation rate so far
trend = recent_coop_rate - overall_coop_rate (positive = increasing cooperation)
```

### Decision Rules by Phase

#### **Round 1: Always Defect**
- Rationale: No information yet, and defection dominates in single-shot. Starting with D also lets us identify unconditional cooperators (easy marks).

#### **Early Rounds (2 to early_round_threshold): Conditional Probe**

```
IF coop_rate >= 0.5:
    Play C (invest in maintaining cooperation pool)
ELSE:
    Play D (don't throw good money after bad)
```

#### **Mid-Game Rounds: Adaptive Exploitation**

Calculate the **exploitation threshold** based on game parameters:

```
base_threshold = k / n  # The per-capita return from one cooperation
adjusted_threshold = base_threshold * (n - 1) / n  # Expected return if only others cooperate
```

**Decision logic:**

```
IF recent_coop_rate >= 0.6:
    # Cooperation is high - EXPLOIT IT
    # Defect to free-ride, but occasionally cooperate to sustain the pool
    IF my_coop_rate > recent_coop_rate + 0.1:
        Play D  # We're being too generous
    ELSE IF trend < -0.15:
        Play C  # Cooperation collapsing, invest to sustain
    ELSE:
        Play D  # Free-ride on the cooperators

ELSE IF recent_coop_rate >= 0.3:
    # Moderate cooperation - SELECTIVE ENGAGEMENT
    IF trend > 0.1:
        Play C  # Cooperation rising, join to amplify
    ELSE:
        Play D  # Not worth investing

ELSE:
    # Low cooperation environment - DEFECT
    Play D  # Nothing to exploit, cut losses
```

#### **Endgame Rounds: Pure Defection**

```
Always Play D
```
- Rationale: No future rounds to protect relationships. Squeeze every last drop.

---

## Exploitation Mechanisms

### 1. **Sucker Detection**
Track which opponents always cooperate regardless of others' actions. Against populations with unconditional cooperators, always defect - they'll keep feeding the pool regardless.

### 2. **Tit-for-Tat Exploitation**
Against reciprocal strategies, we can extract value by cooperating just enough to keep them cooperating, then defecting at unpredictable intervals.

### 3. **Cooperation Decay Acceleration**
In the endgame, our defection helps trigger a "cooperation collapse" - as others see defection rise, they defect too, which is fine since we're already defecting.

### 4. **Threshold Manipulation**
By hovering our cooperation rate just below the group average, we consistently extract more than we contribute.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | D, D | Too short for reputation building |
| n = 2 (minimum players) | Standard TFT-like, but defect-biased | Binary interaction, different dynamics |
| k very close to 1 | Heavily bias toward D | Cooperation barely benefits the group |
| k close to n | Still exploit, but cooperate more in probing | Higher stakes for maintaining cooperation |
| All opponents defected last round | D | Nothing to exploit |
| All opponents cooperated last round | D (unless trend negative) | Maximum exploitation opportunity |

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, n, k):
    r = total_rounds
    
    # Endgame: always defect
    if round_num > r - max(2, r // 6):
        return DEFECT
    
    # Round 1: always defect
    if round_num == 1:
        return DEFECT
    
    # Calculate metrics
    coop_rate = calculate_overall_coop_rate(history)
    recent_coop_rate = calculate_recent_coop_rate(history, window=3)
    my_coop_rate = calculate_my_coop_rate(history)
    trend = recent_coop_rate - coop_rate
    
    # Early rounds: probe
    if round_num <= min(3, r // 4):
        return COOPERATE if coop_rate >= 0.5 else DEFECT
    
    # Mid-game: adaptive exploitation
    if recent_coop_rate >= 0.6:
        if my_coop_rate > recent_coop_rate + 0.1:
            return DEFECT
        elif trend < -0.15:
            return COOPERATE
        else:
            return DEFECT
    elif recent_coop_rate >= 0.3:
        return COOPERATE if trend > 0.1 else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Asymmetric contribution**: We systematically contribute less than the group average while benefiting from others' contributions
2. **Information advantage**: We use observed behavior to calibrate exactly how little cooperation we can get away with
3. **Temporal exploitation**: We "invest" early only to harvest later, and abandon all pretense in endgame
4. **Adaptive parasitism**: We keep cooperation alive just enough to continue exploiting it, like a parasite that doesn't kill its host
'''

description_EXPLOITATIVE_33 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single shot—but exploiting cooperators yields even higher returns than mutual defection. My goal is to identify and exploit cooperative populations while protecting myself from exploitation.

## Decision Rules

### Round 1: Defect
- **Rationale**: Never contribute information about my willingness to cooperate for free. Defecting in round 1 provides a baseline payoff of at least 1, plus any bonus from others' cooperation. This also signals strength and avoids being marked as an easy target.

### Rounds 2 through (r-1): Adaptive Exploitation

**Calculate the cooperation rate from the previous round:**
```
coop_rate = (number of cooperators last round) / (n - 1)
```
(Excluding myself from the count)

**Decision Logic:**

```
IF coop_rate >= exploitation_threshold THEN:
    # High cooperation environment - DEFECT to exploit
    DEFECT
    
ELSE IF coop_rate >= cooperation_threshold THEN:
    # Medium cooperation - occasionally cooperate to sustain the herd
    IF my_defection_streak >= max_streak THEN:
        COOPERATE (to avoid total collapse)
    ELSE:
        DEFECT
        
ELSE:
    # Low cooperation environment - no point contributing
    DEFECT
```

**Parameter Settings (adaptive to game size):**
- `exploitation_threshold = 0.5` — If half or more are cooperating, pure exploitation
- `cooperation_threshold = 0.3` — Below this, environment is too hostile
- `max_streak = floor(r / 4)` — Occasional cooperation to prevent total collapse

### Last Round (Round r): Always Defect
- **Rationale**: No future rounds exist to punish defection. Pure dominant strategy logic applies.

### Special Adaptation: Trend Detection

Track cooperation trends over the last 3 rounds:
```
IF cooperation_rate is declining for 3 consecutive rounds:
    # Others are learning/retaliating - switch to pure defection
    SET cooperation_threshold = 1.0 (effectively: always defect)
    
IF cooperation_rate is stable/increasing AND > 0.4:
    # Sustainable exploitation opportunity
    Continue adaptive exploitation
```

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, num_players, k):
    n = num_players
    r = total_rounds
    
    # First round: always defect
    if round_num == 1:
        return DEFECT
    
    # Last round: always defect
    if round_num == r:
        return DEFECT
    
    # Calculate others' cooperation rate last round
    others_cooperated = count_cooperators(history[-1]) - my_action(history[-1])
    coop_rate = others_cooperated / (n - 1)
    
    # Track my consecutive defections
    my_defect_streak = count_consecutive_defections(my_history)
    
    # Trend detection (last 3 rounds if available)
    if declining_cooperation_trend(history, window=3):
        return DEFECT
    
    # Exploitation logic
    if coop_rate >= 0.5:
        # Rich environment - exploit freely
        return DEFECT
    elif coop_rate >= 0.3:
        # Moderate environment - occasional sustaining cooperation
        max_streak = max(1, r // 4)
        if my_defect_streak >= max_streak:
            return COOPERATE
        else:
            return DEFECT
    else:
        # Hostile environment - no point contributing
        return DEFECT
```

## Edge Cases

| Situation | Action | Reason |
|-----------|--------|--------|
| Round 1 | Defect | Gather information, don't give it |
| Round r (last) | Defect | No future punishment possible |
| n = 2 | Defect always | k < n means k < 2, so mutual cooperation barely breaks even |
| All others defected last round | Defect | No exploitation opportunity |
| All others cooperated | Defect | Maximum exploitation opportunity |
| r = 2 | Defect both rounds | Too short for reputation building |

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: Defects when cooperation is high to maximize personal gain
2. **Never initiates cooperation**: Only cooperates strategically to prevent total collapse
3. **Endgame defection**: Guaranteed defection when punishment is impossible
4. **Minimal reciprocity**: Cooperates only enough to sustain exploitable populations
5. **Detects and abandons dying herds**: Switches to pure defection when cooperation collapses
'''

description_EXPLOITATIVE_31 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and continuously estimates the "exploitability" of the population based on observed cooperation rates.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** Always **DEFECT**

*Rationale:* Defection is risk-free for gathering information. If others cooperate, I gain maximally. If others defect, I lose nothing compared to cooperating.

**Round 2:** Always **DEFECT**

*Rationale:* Continue gathering data. Two rounds of observation reveal whether cooperation is stable, declining, or absent.

---

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / (n - 1)
```

**Decision Rule:**

```
IF coop_rate >= exploitation_threshold THEN:
    # High cooperation environment - exploit it
    DEFECT
    
ELSE IF coop_rate >= sustainability_threshold AND coop_rate < exploitation_threshold THEN:
    # Moderate cooperation - conditionally cooperate to sustain the pool
    # But only if it's profitable: need enough others cooperating
    IF (number of cooperators last round) >= n/k THEN:
        COOPERATE with probability = (coop_rate - 0.2)
        DEFECT otherwise
    ELSE:
        DEFECT

ELSE:
    # Low cooperation environment - no point cooperating
    DEFECT
```

**Threshold Definitions:**
- `exploitation_threshold = 0.6` (60% of others cooperating)
- `sustainability_threshold = 0.3` (30% of others cooperating)

**Adaptive Threshold Adjustment:**

After every 3 rounds, adjust thresholds based on observed trends:
```
IF average_coop_rate is declining:
    Lower sustainability_threshold by 0.05 (minimum 0.2)
    # Squeeze more exploitation before pool collapses
    
IF average_coop_rate is stable or rising:
    Raise exploitation_threshold by 0.05 (maximum 0.8)
    # Be more aggressive in exploitation
```

---

### Phase 3: Endgame (Final 2 rounds: r-1 and r)

**Rounds r-1 and r:** Always **DEFECT**

*Rationale:* No future interactions to incentivize cooperation. Backward induction makes defection strictly dominant. Any sophisticated opponent will also defect, so cooperation yields no benefit.

---

## Pseudocode Summary

```python
def decide(round_number, history, n, k, r):
    
    # Endgame: always defect
    if round_number >= r - 1:
        return DEFECT
    
    # Probing phase: always defect
    if round_number <= 2:
        return DEFECT
    
    # Calculate cooperation metrics
    last_round_coops = count_cooperators_last_round(history)
    coop_rate = last_round_coops / (n - 1)
    
    # Adaptive thresholds (adjusted every 3 rounds)
    exploit_thresh = get_exploitation_threshold(history)
    sustain_thresh = get_sustainability_threshold(history)
    
    # Exploitation logic
    if coop_rate >= exploit_thresh:
        return DEFECT  # Free-ride on cooperators
    
    elif coop_rate >= sustain_thresh:
        # Conditional cooperation to keep the pool alive
        min_coops_needed = n / k
        if last_round_coops >= min_coops_needed:
            # Probabilistic cooperation - be unpredictable
            prob_coop = coop_rate - 0.2
            return COOPERATE with probability prob_coop
        else:
            return DEFECT
    
    else:
        return DEFECT  # Environment is hostile
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | No information; defection dominates |
| Last round | DEFECT | No future; backward induction |
| n = 2 | Always DEFECT | Single opponent can't sustain pool alone |
| k very close to n | Slightly increase cooperation probability | Returns from cooperation nearly match defection |
| All opponents defected last round | DEFECT | No pool to exploit |
| All opponents cooperated last round | DEFECT | Maximum exploitation opportunity |
| r ≤ 4 | Always DEFECT | Too short to build exploitable patterns |

---

## Why This Strategy is Exploitative

1. **Asymmetric behavior:** Cooperates only when others' cooperation makes it profitable to sustain the pool for future exploitation
2. **Free-riding priority:** Defaults to defection whenever cooperation rate is high enough to profit without contributing
3. **Probabilistic cooperation:** When cooperating, does so unpredictably to avoid being exploited by pattern-matchers
4. **Endgame defection:** Extracts maximum value in final rounds when punishment is impossible
5. **Information advantage:** Uses probing to classify opponent types before committing resources
'''

description_EXPLOITATIVE_34 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round—but exploiting cooperators requires them to *keep cooperating*. The strategy balances exploitation with just enough apparent cooperation to sustain exploitable opponents.

---

## Decision Rules

### Round Classification

Divide the game into three phases:
- **Early Phase**: Rounds 1 through ⌈r/4⌉
- **Middle Phase**: Rounds ⌈r/4⌉+1 through r-⌈r/6⌉
- **End Phase**: Final ⌈r/6⌉ rounds (minimum 1 round)

### Key Metrics (Updated Each Round)

```
cooperation_rate = (total C plays by all opponents) / (total plays by all opponents)
recent_cooperation = cooperation rate in last min(3, rounds_played) rounds
trend = recent_cooperation - cooperation_rate  // positive = increasing cooperation
```

---

## Phase-Specific Rules

### First Round
**Action: DEFECT**

Rationale: No information exists. Defection is risk-free and provides baseline data on opponent behavior. If others cooperate, we profit maximally.

### Early Phase (Rounds 2 to ⌈r/4⌉)
**Conditional Probing Strategy**

```
IF cooperation_rate > 0.5:
    // Environment is cooperative - appear somewhat cooperative to sustain it
    Cooperate with probability = 0.3
ELSE:
    DEFECT
```

Rationale: Light cooperation signals we're "reachable" while still exploiting. This prevents conditional cooperators from abandoning cooperation entirely.

### Middle Phase
**Exploitation with Maintenance**

```
IF cooperation_rate > 0.6 AND trend >= 0:
    // Rich cooperative environment - minimal cooperation to maintain it
    Cooperate with probability = 0.2
    
ELSE IF cooperation_rate > 0.4:
    // Moderate cooperation - test if we can free-ride harder
    Cooperate with probability = 0.1
    
ELSE:
    // Low cooperation environment - no point contributing
    DEFECT
```

### End Phase (Final ⌈r/6⌉ rounds)
**Pure Defection**

```
DEFECT (always)
```

Rationale: No future rounds to incentivize our cooperation. Opponents cannot punish us. This is the classic "unraveling" logic—exploit it fully.

---

## Opponent-Specific Adaptation (if tracking is possible)

If individual opponent histories are trackable:

```
FOR each opponent j:
    opponent_coop_rate[j] = (C plays by j) / (rounds played)
    
// Identify "suckers" (high cooperation despite our defection)
sucker_count = count(opponents where opponent_coop_rate > 0.7)

IF sucker_count >= n/3:
    // Enough exploitable opponents - defect more aggressively
    Reduce all cooperation probabilities by 50%
```

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| r ≤ 3 (very short game) | DEFECT every round |
| n = 2 (two-player game) | DEFECT always (single opponent can't sustain cooperation alone) |
| k very close to n | Slightly increase cooperation probabilities (+0.1) since mutual cooperation is more valuable |
| All opponents defected last round | DEFECT (no suckers to exploit) |
| Only 1 opponent cooperating | DEFECT (not worth maintaining) |

---

## Summary Pseudocode

```python
def decide(round, history, n, k, r):
    if round == r or round > r - ceil(r/6):  # End phase
        return DEFECT
    
    if round == 1:
        return DEFECT
    
    coop_rate = calculate_opponent_cooperation_rate(history)
    
    if round <= ceil(r/4):  # Early phase
        if coop_rate > 0.5:
            return COOPERATE with probability 0.3
        return DEFECT
    
    else:  # Middle phase
        if coop_rate > 0.6:
            return COOPERATE with probability 0.2
        elif coop_rate > 0.4:
            return COOPERATE with probability 0.1
        return DEFECT
```

---

## Why This Works

1. **Exploits cooperators**: Heavy defection bias extracts value from altruists
2. **Sustains the host**: Minimal cooperation prevents complete collapse of cooperative opponents
3. **Adapts to environment**: Defects fully against defectors (no wasted cooperation)
4. **Endgame extraction**: Pure defection when punishment is impossible
5. **Robust to strategies**: Works against TFT-variants, unconditional cooperators, and fellow defectors
'''

description_EXPLOITATIVE_32 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators requires them to keep cooperating. The strategy balances exploitation with just enough cooperation to maintain a cooperative environment worth exploiting.

## Strategy Overview

The strategy operates in three phases and continuously classifies the opponent population to calibrate its exploitation level.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** DEFECT
- Rationale: Gather information at no strategic cost. If others cooperate, we profit maximally. If others defect, we lose nothing relative to cooperating.

**Round 2:** DEFECT
- Rationale: Confirm round 1 patterns. Two rounds of data allow distinguishing unconditional cooperators from conditional ones.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **cooperation rate** from previous rounds:
```
coop_rate = (total cooperations by others) / ((current_round - 1) * (n - 1))
```

Calculate **cooperation trend** (is cooperation increasing or decreasing?):
```
recent_coop_rate = cooperation rate in last 2 rounds
trend = recent_coop_rate - earlier_coop_rate
```

**Decision Logic:**

```
IF coop_rate >= 0.6 AND trend >= -0.1:
    # Environment is exploitably cooperative
    # Occasionally cooperate to maintain the herd
    cooperate_probability = min(0.2, coop_rate - 0.5)
    COOPERATE with probability cooperate_probability, else DEFECT
    
ELIF coop_rate >= 0.4 AND trend > 0:
    # Cooperation recovering - stay quiet and exploit
    DEFECT
    
ELIF coop_rate >= 0.4 AND trend <= 0:
    # Cooperation declining - contribute minimally to slow collapse
    COOPERATE with probability 0.15, else DEFECT
    
ELIF coop_rate < 0.4:
    # Environment is hostile/collapsed
    DEFECT unconditionally
```

### Phase 3: Endgame (Rounds r-1 and r)

**Round r-1:** DEFECT
- Rationale: Others may start endgame defection. No reason to be the sucker.

**Round r (Final Round):** DEFECT
- Rationale: No future interaction means pure dominant strategy applies.

---

## Detailed Pseudocode

```
function decide(round, history, n, k, r):
    
    # === ENDGAME ===
    if round >= r - 1:
        return DEFECT
    
    # === PROBING PHASE ===
    if round <= 2:
        return DEFECT
    
    # === EXPLOITATION PHASE ===
    
    # Calculate cooperation statistics
    total_others_actions = sum of all other players' actions in history
    total_possible = (round - 1) * (n - 1)
    coop_rate = total_others_actions / total_possible
    
    # Calculate trend (last 2 rounds vs earlier)
    if round >= 4:
        recent_coops = cooperations by others in rounds (round-2) to (round-1)
        recent_rate = recent_coops / (2 * (n - 1))
        earlier_rate = (total_others_actions - recent_coops) / ((round - 3) * (n - 1))
        trend = recent_rate - earlier_rate
    else:
        trend = 0
    
    # Adaptive exploitation
    if coop_rate >= 0.6 and trend >= -0.1:
        # Milk the cooperative environment
        p = min(0.2, coop_rate - 0.5)
        return COOPERATE with probability p, else DEFECT
        
    elif coop_rate >= 0.4 and trend > 0:
        return DEFECT
        
    elif coop_rate >= 0.4 and trend <= 0:
        return COOPERATE with probability 0.15, else DEFECT
        
    else:
        return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | DEFECT | Maximum information gain, zero relative risk |
| Round r | DEFECT | No future, dominant strategy |
| n = 2 | Follow same logic | Strategy degenerates to near-always-defect against single opponent |
| All others defect every round | DEFECT | No exploitation opportunity, protect self |
| All others cooperate every round | Mostly DEFECT, occasional C | Maximum extraction with minimal contribution to sustain them |
| k very close to n | Slightly increase cooperation probability | Higher marginal value of public good |
| Short game (r ≤ 4) | DEFECT always | Insufficient rounds for reputation effects |

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Avoids being exploited by defectors
2. **Defects in high-value situations** - When others cooperate, we free-ride
3. **Strategic minimal cooperation** - Only cooperates enough to prevent total collapse of cooperative opponents
4. **Ruthless endgame** - No mercy when future interactions end
5. **Adapts to prey availability** - Defects more when cooperation is scarce (nothing to exploit), cooperates minimally when cooperation is abundant (maintain the farm)

This strategy treats cooperative players as a renewable resource to be harvested sustainably - contributing just enough to keep them cooperating while extracting maximum surplus.
'''

description_EXPLOITATIVE_35 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators requires them to *keep cooperating*. Thus, I'll masquerade as a conditional cooperator early on to identify and milk cooperative opponents, then strategically defect to maximize my relative advantage.

## Decision Rules

### Round Classification

Divide the game into three phases:
- **Probing Phase**: Rounds 1 through `min(3, floor(r/4))`
- **Exploitation Phase**: Rounds after probing until `r - 1`
- **Endgame**: Final round `r`

### Phase 1: Probing Phase

**Goal**: Identify the cooperation level of opponents while appearing cooperative myself.

**Decision Rule**:
- **Round 1**: Play **C** (Cooperate)
  - Rationale: Establishes a cooperative image; gathers baseline data on opponent behavior
- **Rounds 2-3** (if applicable): 
  - If cooperation rate in previous round was ≥ 50%: Play **C**
  - If cooperation rate was < 50%: Play **D**

### Phase 2: Exploitation Phase

**Goal**: Maximize payoff by free-riding on cooperators while not destroying cooperation entirely.

Calculate a **cooperation score** for the opponent pool:
```
coop_rate = (total C plays by others in last 2 rounds) / (2 × (n-1))
```

**Decision Rule**:
```
IF coop_rate >= 0.6:
    # Rich environment - exploit aggressively
    Play D (free-ride on cooperators)
    
ELIF coop_rate >= 0.3:
    # Mixed environment - probabilistic exploitation
    # Cooperate just enough to keep cooperation alive
    IF (my defections in last 3 rounds) >= 2:
        Play C (maintain cooperative facade)
    ELSE:
        Play D (extract value)
        
ELIF coop_rate > 0:
    # Sparse cooperation - match and slightly undercut
    IF at least one opponent cooperated last round:
        Play C with probability 0.4, D with probability 0.6
    ELSE:
        Play D
        
ELSE:
    # Dead environment - no point cooperating
    Play D
```

### Phase 3: Endgame (Final Round)

**Decision Rule**: Always play **D**

**Rationale**: No future rounds exist to punish defection. This is the dominant strategy regardless of opponent behavior.

### Edge Case Handling

1. **Two-player game (n=2)**: Be more cautious with exploitation
   - In exploitation phase, require `coop_rate >= 0.7` before defecting aggressively
   - Single opponent can more easily identify and punish a pure defector

2. **Very short games (r ≤ 4)**:
   - Probing phase = Round 1 only
   - Round 2 to r-1: Defect if opponent(s) cooperated in round 1, else cooperate once then defect
   - Final round: Always defect

3. **Large n (n ≥ 10)**: Individual actions have less impact
   - Be more willing to defect early (my defection is less noticeable)
   - Probing phase: Cooperate only in round 1

4. **High k (k close to n)**: Cooperation is more valuable
   - Slightly increase cooperation thresholds by 0.1 (e.g., 0.6 becomes 0.7)

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    if round == r:
        return DEFECT  # Endgame
    
    if round == 1:
        return COOPERATE  # Always probe cooperatively
    
    coop_rate = calculate_recent_coop_rate(history, lookback=2)
    
    if round <= probing_rounds(r):
        return COOPERATE if coop_rate >= 0.5 else DEFECT
    
    # Exploitation phase
    if coop_rate >= 0.6:
        return DEFECT
    elif coop_rate >= 0.3:
        return COOPERATE if my_recent_defections(history, 3) >= 2 else DEFECT
    elif coop_rate > 0:
        return COOPERATE with probability 0.4, else DEFECT
    else:
        return DEFECT
```

## Why This Strategy is Exploitative

1. **Preys on cooperators**: High cooperation rates trigger defection, extracting the k/n benefit without paying the cost
2. **Maintains the illusion**: Strategic cooperation prevents complete collapse of the cooperative pool
3. **Adapts to environment**: Doesn't waste cooperation on all-defector groups
4. **Endgame betrayal**: Guaranteed defection in final round captures last-round value
'''

description_EXPLOITATIVE_33 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors benefit from cooperators, but not vice versa. The goal is to **maximize extraction from cooperative populations while minimizing losses against defectors**. We cooperate only when it's instrumentally useful for inducing future cooperation from others.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit predictable behaviors.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to min(3, r/4))

**Purpose:** Gather information about opponent population composition with minimal cost.

- **Round 1:** DEFECT
  - Rationale: Observe who cooperates unconditionally. These are exploitable targets.
  
- **Rounds 2-3:** DEFECT if cooperation rate in previous round was < 50%, otherwise COOPERATE once to test for reciprocity patterns.

### Phase 2: Exploitation Phase (Middle rounds, until round r-2)

**Classify the population based on observed behavior:**

1. **Calculate Cooperation Index (CI):** Rolling average of group cooperation rate over last 3 rounds

2. **Calculate Responsiveness Score (RS):** How much does group cooperation change based on my previous action?
   - RS = (avg cooperation after I cooperated) - (avg cooperation after I defected)

**Decision Logic:**

```
IF RS > 0.15 (population is responsive to my behavior):
    # There are conditional cooperators I can manipulate
    IF CI > 0.6:
        COOPERATE (maintain the gravy train)
    ELSE IF CI > 0.3:
        COOPERATE with probability = CI (intermittent reinforcement)
    ELSE:
        DEFECT (not enough cooperators to sustain)
        
ELSE IF RS <= 0.15 (population is unresponsive):
    # Fixed-strategy opponents
    IF CI > (n/k) - 0.1:
        # Enough unconditional cooperators to free-ride profitably
        DEFECT (pure exploitation)
    ELSE:
        DEFECT (nothing to gain from cooperation)
```

### Phase 3: Endgame Extraction (Final 2 rounds)

- **Round r-1:** DEFECT (unless CI > 0.8, then cooperate to not trigger retaliation in final round)
- **Round r:** Always DEFECT (no future consequences)

---

## Detailed Pseudocode

```
function decide(round, history, n, k, r):
    
    # Edge case: single round remaining
    if round == r:
        return DEFECT
    
    # Edge case: second-to-last round
    if round == r - 1:
        if cooperation_rate(last_round) > 0.8:
            return COOPERATE  # Disguise for final defection
        return DEFECT
    
    # Round 1: Always probe with defection
    if round == 1:
        return DEFECT
    
    # Calculate metrics
    CI = rolling_cooperation_rate(history, window=3)
    RS = responsiveness_score(history, my_actions)
    
    # Probing phase (rounds 2-3)
    if round <= min(3, r/4):
        if CI < 0.5:
            return DEFECT
        else:
            return COOPERATE  # Test for reciprocity
    
    # Exploitation phase
    breakeven_threshold = (n - k) / (n - 1)  # Theoretical cooperation needed for mutual benefit
    
    if RS > 0.15:
        # Manipulable population
        if CI > 0.6:
            return COOPERATE
        elif CI > 0.3:
            return COOPERATE with probability CI
        else:
            return DEFECT
    else:
        # Fixed-strategy population
        return DEFECT  # Always free-ride on unresponsive cooperators
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | Information gathering; identify unconditional cooperators |
| Final round | DEFECT | No future retaliation possible |
| r = 2 | DEFECT both rounds | Too short for reputation building to pay off |
| All opponents defected so far | DEFECT | No exploitation opportunity |
| All opponents cooperated so far | DEFECT | Maximum free-riding opportunity |
| n = 2 (bilateral) | More aggressive defection | Harder to hide among cooperators |
| High k (close to n) | Slightly more willing to cooperate | Public good returns are higher |

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Every cooperation is calculated to induce future cooperation from others

2. **Identifies and exploits "suckers"** - Unconditional cooperators are milked via consistent defection

3. **Manipulates conditional cooperators** - Uses intermittent cooperation to keep them contributing while minimizing own contributions

4. **Endgame defection** - Extracts maximum value when reputation no longer matters

5. **Asymmetric response** - Cooperates only when population responsiveness makes it profitable; defects against unresponsive populations regardless of their cooperation level
'''

description_EXPLOITATIVE_36 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and continuously estimates opponent cooperation rates to determine optimal exploitation timing.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Round 1:** Always **DEFECT**

*Rationale:* Establishes a baseline and avoids being exploited while gathering information. If others cooperate, we gain maximally. If others defect, we lose nothing.

**Rounds 2-3:** **DEFECT**

*Rationale:* Continue gathering data on opponent behavior patterns. Two rounds of observation reveals who are unconditional cooperators, conditional cooperators, and fellow defectors.

### Phase 2: Exploitation Phase (Rounds 4 to r-2)

Calculate the **cooperation rate** from observed history:
```
coop_rate = (total cooperations by all opponents) / (total possible cooperations)
         = Σ(opponent cooperations) / ((n-1) × rounds_played)
```

**Decision Rule:**

```
IF coop_rate > threshold THEN:
    # High cooperation environment - exploit it
    DEFECT (free-ride on cooperators)
    
ELSE IF coop_rate > low_threshold THEN:
    # Medium cooperation - strategic conditional cooperation
    IF (previous round had ≥ 50% cooperators) THEN:
        COOPERATE with probability = min(0.3, coop_rate/2)
        DEFECT otherwise
    ELSE:
        DEFECT
        
ELSE:
    # Low cooperation environment - pure defection
    DEFECT
```

**Threshold Values:**
- `threshold = 0.5` (high cooperation)
- `low_threshold = 0.2` (minimal cooperation)

**The Exploitation Logic:**
- When many cooperate: defect to maximize personal gain (get k/n per cooperator while keeping endowment)
- When few cooperate: defect because cooperation yields poor returns
- Occasional cooperation in medium environments: prevents complete collapse if others use punishment strategies, maintaining a pool to exploit

### Phase 3: Endgame (Final 2 rounds)

**Round r-1 and Round r:** Always **DEFECT**

*Rationale:* No future punishment possible. Backward induction makes defection strictly dominant in final rounds regardless of history.

---

## Adaptive Mechanisms

### Tracking Opponent "Types"

Maintain running estimates for each opponent:
```
For each opponent j:
    defection_count[j] = number of times j has defected
    opponent_type[j] = "exploitable" if defection_count[j]/rounds < 0.3
                       "reciprocator" if 0.3 ≤ defection_count[j]/rounds < 0.7
                       "defector" otherwise
```

### Cooperation Decay Detection

If cooperation rate drops by more than 30% over 3 consecutive rounds:
- Switch to pure defection mode
- The cooperative "pool" is collapsing; extract remaining value

### Exploitation Intensity Adjustment

```
exploitation_factor = k / n  # Higher means cooperation is more valuable to exploit

IF exploitation_factor > 0.4 THEN:
    # Cooperation generates significant value - be more parasitic
    Reduce any cooperative probability by 50%
ELSE:
    # Low multiplication - cooperation barely matters
    Pure defection
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2 | Always DEFECT | Equivalent to Prisoner's Dilemma; defection dominant |
| r ≤ 3 | Always DEFECT | Too few rounds for reputation building to matter |
| k very close to n | DEFECT more aggressively | High temptation payoff |
| k very close to 1 | Always DEFECT | Cooperation provides minimal benefit |
| All opponents defected last round | DEFECT | No cooperators to exploit |
| All opponents cooperated last round | DEFECT | Maximum exploitation opportunity |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase - always defect
    if round <= 3:
        return DEFECT
    
    # Calculate cooperation rate
    coop_rate = calculate_opponent_cooperation_rate(history)
    
    # Exploitation phase
    if coop_rate > 0.5:
        return DEFECT  # Exploit the cooperators
    
    elif coop_rate > 0.2:
        last_round_coop_count = count_cooperators_last_round(history)
        if last_round_coop_count >= (n-1) / 2:
            if random() < min(0.3, coop_rate / 2):
                return COOPERATE  # Occasional cooperation to sustain pool
        return DEFECT
    
    else:
        return DEFECT  # Environment too hostile
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Avoids sucker's payoff
2. **Targets cooperators** - Defects specifically when cooperation is high
3. **Minimal reciprocation** - Only cooperates enough to potentially sustain exploitable opponents
4. **Endgame defection** - Extracts maximum value when punishment is impossible
5. **Asymmetric approach** - Takes advantage of cooperative norms without adhering to them

The strategy treats other players as resources to extract value from, not as partners to build mutual gains with.
'''

description_EXPLOITATIVE_34 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but we can extract additional value by appearing cooperative enough to encourage others to cooperate—then betraying them strategically.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous monitoring of opponent behavior to identify and exploit "suckers" (consistent cooperators) while protecting against retaliation.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Purpose:** Gather information about opponent types while establishing a slightly cooperative reputation.

**Rule:** 
- **Round 1:** Cooperate (to bait cooperators into revealing themselves)
- **Subsequent probe rounds:** Cooperate with probability 0.4, Defect with probability 0.6

**Rationale:** Early cooperation identifies who the cooperators are. The mixed strategy prevents us from being easily classified while gathering data.

---

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-2)

**Purpose:** Maximize extraction from identified cooperators.

**Decision Rule based on Cooperation Index (CI):**

Calculate for the previous round:
```
CI = (number of cooperators among other n-1 players) / (n-1)
```

**Adaptive Threshold:** `T = k/n` (the marginal benefit of one cooperation)

**Decision Logic:**
```
IF CI > 0.5:
    # Rich environment - cooperators to exploit
    IF my_cooperation_rate_last_3_rounds > 0.33:
        DEFECT  # Extract value, we've built enough goodwill
    ELSE:
        COOPERATE with probability = min(0.5, CI - 0.2)  # Occasional cooperation to keep them hooked
        
ELSE IF CI > 0.2:
    # Mixed environment - selective engagement
    DEFECT with probability = 0.7
    
ELSE:
    # Hostile environment - pure defection is optimal
    DEFECT
```

**Reputation Management:** If we've defected 4+ consecutive rounds AND CI > 0.3, cooperate once to "reset" and re-bait cooperators.

---

### Phase 3: Endgame (Final 2 rounds)

**Purpose:** Maximum extraction with no future consequences.

**Rule:** 
- **Round r-1:** DEFECT (no time for punishment to matter)
- **Round r:** DEFECT (absolutely dominant - no future exists)

---

## Edge Case Handling

### First Round
- **Action:** COOPERATE
- **Rationale:** Bait cooperators into revealing themselves; the information value exceeds the small loss from cooperating once

### Last Round
- **Action:** DEFECT (unconditionally)
- **Rationale:** No future rounds means no retaliation possible; defection strictly dominates

### Second-to-Last Round
- **Action:** DEFECT (unconditionally)
- **Rationale:** Any cooperator sophisticated enough to punish us in round r would defect in r anyway (by backward induction)

### All Others Defected Last Round
- **Action:** DEFECT
- **Rationale:** No cooperation surplus to exploit; matching defection minimizes losses

### All Others Cooperated Last Round
- **Action:** DEFECT
- **Rationale:** Maximum exploitation opportunity; we gain 1 (kept endowment) + (k/n)×(n-1) while they subsidize us

### Very Short Games (r ≤ 3)
- **Action:** DEFECT every round
- **Rationale:** Insufficient rounds for reputation-building to pay off

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Edge cases
    if r <= 3: return DEFECT
    if round >= r - 1: return DEFECT
    
    # Phase 1: Probing
    if round == 1: return COOPERATE
    if round <= ceil(r/5):
        return COOPERATE with probability 0.4, else DEFECT
    
    # Calculate metrics
    CI = cooperation_index(history, last_round)
    my_recent_coop_rate = my_cooperation_rate(history, last_3_rounds)
    my_consecutive_defections = count_consecutive_defections(history)
    
    # Phase 2: Exploitation
    if CI <= 0.2:
        return DEFECT
    
    if my_consecutive_defections >= 4 and CI > 0.3:
        return COOPERATE  # Reputation reset
    
    if CI > 0.5:
        if my_recent_coop_rate > 0.33:
            return DEFECT
        else:
            return COOPERATE with probability min(0.5, CI - 0.2)
    
    # Mixed environment (0.2 < CI <= 0.5)
    return DEFECT with probability 0.7
```

---

## Why This Strategy is Exploitative

1. **Baits cooperators:** Initial cooperation draws out cooperative types
2. **Free-rides strategically:** Defects when cooperation levels are high enough to benefit from others' contributions
3. **Never gets exploited long-term:** Defects against defectors, endgame defection is unconditional
4. **Maintains exploitation potential:** Occasional cooperation prevents complete collapse of the cooperative environment
5. **Adapts to environment:** More aggressive in hostile environments, more "farmed" extraction in cooperative ones
'''

description_EXPLOITATIVE_35 = '''
# Exploitative Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing personal contribution costs**. The key insight is that in this game, defection always yields a higher individual payoff than cooperation *given the same actions by others*. Therefore, the exploitative approach is to defect as much as possible while occasionally cooperating just enough to prevent complete collapse of cooperation from others.

## Strategy: "Parasitic Conditional Defector" (PCD)

### Decision Framework

The strategy operates on three principles:
1. **Default to defection** - it's always individually rational
2. **Probe for exploitable cooperators** - identify and milk cooperative players
3. **Never cooperate in endgame** - no future punishment possible

---

### Detailed Decision Rules

#### Round 1: Defect
- Rationale: No information about opponents yet. Defection is the dominant single-round strategy. Let others reveal themselves as cooperators while you gain the free-rider advantage.

#### Rounds 2 through (r-1): Conditional Behavior

**Calculate the "Exploitation Potential" after each round:**

```
cooperation_rate = (number of C plays by others in previous round) / (n - 1)
cumulative_coop_rate = (total C plays by others across all rounds) / ((n-1) × rounds_played)
```

**Decision Logic:**

```
IF cooperation_rate >= 0.5 AND cumulative_coop_rate >= 0.4:
    # Environment is cooperative - EXPLOIT IT
    DEFECT
    
ELIF cooperation_rate < 0.2:
    # Cooperation has collapsed - nothing to exploit
    DEFECT
    
ELIF 0.2 <= cooperation_rate < 0.5:
    # Cooperation is fragile - consider "baiting"
    IF rounds_remaining > r/3 AND random() < 0.15:
        COOPERATE  # Occasional cooperation to keep others hopeful
    ELSE:
        DEFECT
```

**Baiting Mechanism Explained:**
When cooperation is declining but not dead, an occasional cooperative move can:
- Signal to conditional cooperators that cooperation "might work"
- Restart cooperation cycles that we can then exploit
- The 15% probability keeps it unpredictable and cheap

#### Final Round (Round r): Always Defect
- No future rounds mean no punishment possible
- This is the unambiguous dominant strategy

---

### Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| n = 2 (minimum players) | Defect always | Too easy to be identified and punished; just take guaranteed payoff |
| Very high k (close to n) | Still defect-heavy | Even with high multiplier, personal defection gain exceeds share of own contribution |
| r = 2 (minimum rounds) | Defect both rounds | Not enough time for reputation-building to matter |
| Everyone defected last round | Defect | No cooperators to exploit |
| Everyone cooperated last round | Defect | Maximum exploitation opportunity |
| Only 1 cooperator remains | Defect | Still gaining k/n from their contribution for free |

---

### Pseudocode Summary

```python
def decide(round_number, total_rounds, n, k, history):
    
    # Final round: always defect
    if round_number == total_rounds:
        return DEFECT
    
    # First round: always defect
    if round_number == 1:
        return DEFECT
    
    # Calculate cooperation metrics from others
    last_round_coops = count_cooperators_last_round(history, exclude_self=True)
    cooperation_rate = last_round_coops / (n - 1)
    
    total_coops = count_all_cooperators(history, exclude_self=True)
    rounds_played = round_number - 1
    cumulative_rate = total_coops / ((n - 1) * rounds_played)
    
    # High cooperation: exploit freely
    if cooperation_rate >= 0.5 and cumulative_rate >= 0.4:
        return DEFECT
    
    # Dead cooperation: nothing to exploit
    if cooperation_rate < 0.2:
        return DEFECT
    
    # Fragile cooperation: occasional bait
    rounds_remaining = total_rounds - round_number
    if rounds_remaining > total_rounds / 3 and random() < 0.15:
        return COOPERATE
    
    return DEFECT
```

---

### Why This Strategy is Exploitative

1. **Never cooperates when it matters most** - High cooperation environments get pure defection
2. **Uses cooperation as bait, not contribution** - The rare cooperations are investments to restart exploitation cycles
3. **Extracts value without reciprocating** - Classic free-rider optimization
4. **Endgame certainty** - Guaranteed defection when punishment is impossible
5. **Robust to most strategies** - Doesn't get baited into costly cooperation spirals

This strategy treats other players' cooperation as a resource to harvest, not a norm to maintain.
'''

description_EXPLOITATIVE_37 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but exploiting cooperators yields even higher returns. I want to identify and milk cooperative players while quickly abandoning cooperation when facing defectors.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling throughout.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉, minimum 2 rounds)

**Purpose:** Gather information about opponent tendencies with minimal investment.

**Rule:** Defect in round 1. In subsequent probing rounds, cooperate only if cooperation rate in the previous round exceeded (n-1)/n (i.e., at most one defector besides me).

**Rationale:** Starting with defection is safe and reveals who the "suckers" are. If almost everyone cooperates, there's a rich environment to potentially exploit through conditional cooperation.

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-1)

**Maintain running statistics for each opponent:**
- `coop_rate[j]` = (times player j cooperated) / (rounds observed)

**Classification of opponents:**
- **Sucker:** coop_rate ≥ 0.7
- **Conditional:** 0.3 ≤ coop_rate < 0.7
- **Defector:** coop_rate < 0.3

**Decision Rule:**

```
Let S = count of Suckers
Let C = count of Conditional cooperators
Let D = count of Defectors

# Calculate expected cooperation from others if I defect
expected_others_coop = S × 0.8 + C × 0.4 + D × 0.1

# Calculate my payoff from defecting
defect_payoff = 1 + (k/n) × expected_others_coop

# Calculate expected cooperation from others if I cooperate
# (Conditional players more likely to cooperate if I did last round)
if I_cooperated_last_round:
    expected_others_coop_if_C = S × 0.8 + C × 0.6 + D × 0.1
else:
    expected_others_coop_if_C = S × 0.8 + C × 0.3 + D × 0.1

# My payoff from cooperating
coop_payoff = (k/n) × (expected_others_coop_if_C + 1)

# Decision
if defect_payoff > coop_payoff × 1.1:
    DEFECT
else if S ≥ (n-1)/2 and coop_rate_overall > 0.5:
    COOPERATE  # Maintain the cooperative environment to keep exploiting
else:
    DEFECT
```

**Trigger for Opportunistic Defection:**
Every 3-4 rounds during exploitation phase, if overall cooperation rate > 0.6, defect regardless of the above calculation. This harvests accumulated goodwill.

### Phase 3: Endgame (Final round, and round r-1 if r ≤ 5)

**Rule:** Always DEFECT.

**Rationale:** No future rounds mean no retaliation possible. This is pure dominant strategy territory.

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| **Round 1** | DEFECT | Safe information gathering; exploit any unconditional cooperators |
| **Round 2** | DEFECT unless everyone cooperated in R1 | Continue probing; only reward near-universal cooperation |
| **Final round** | DEFECT | No future punishment possible |
| **r ≤ 3 rounds** | Always DEFECT | Too short for reputation building to pay off |
| **n = 2** | Tit-for-Tat with defect bias (defect on ties, defect first) | Simplifies to bilateral interaction |
| **k very close to n** | Slightly more cooperative (lower threshold to 0.9× multiplier) | Higher returns to cooperation |
| **k very close to 1** | Almost always defect (require 0.99× threshold) | Cooperation barely pays |
| **All opponents defecting (3+ consecutive rounds)** | Always DEFECT | No exploitation opportunity |
| **All opponents cooperating (3+ consecutive rounds)** | Alternate: D, D, C, D, D, C... | Maximum extraction while occasionally "rewarding" to sustain their cooperation |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    if round == r:  # Final round
        return DEFECT
    
    if round <= max(2, ceil(r/5)):  # Probing phase
        if round == 1:
            return DEFECT
        if last_round_coop_count(history) >= n - 1:
            return COOPERATE
        return DEFECT
    
    # Exploitation phase
    stats = compute_opponent_stats(history)
    
    if is_defector_heavy_environment(stats):  # >60% defectors
        return DEFECT
    
    if is_sucker_rich_environment(stats):  # >50% suckers
        if round % 3 == 0:  # Periodic exploitation
            return DEFECT
        return COOPERATE  # Maintain the farm
    
    # Mixed environment - calculate expected values
    if expected_defect_payoff(stats, k, n) > expected_coop_payoff(stats, k, n) * 1.1:
        return DEFECT
    else:
        return COOPERATE
```

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Always requires evidence that cooperation pays
2. **Defects first** - Captures immediate gains and identifies exploitable opponents
3. **Free-rides on cooperators** - Actively calculates when to defect against cooperative pools
4. **Endgame defection** - Extracts final-round value without consequence
5. **Periodic harvesting** - Even in "cooperative" mode, regularly defects to capture surplus
6. **Asymmetric thresholds** - Requires stronger evidence to cooperate than to defect (the 1.1× multiplier)

The strategy treats cooperative opponents as resources to be harvested, not partners to be respected.
'''

description_EXPLOITATIVE_36 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

This strategy aims to maximize personal payoff by free-riding on cooperators while minimizing the risk of triggering retaliation. The key insight is that in a public goods game with k < n, defection always yields higher individual returns than cooperation *given the same behavior from others*. The exploitative approach is to cooperate only when it's necessary to maintain a pool of cooperators to exploit.

## Strategy Overview

The strategy operates in three modes based on the observed cooperation rate in the population:

1. **Exploitation Mode**: Defect while others cooperate
2. **Probing Mode**: Occasionally cooperate to test/maintain cooperation levels
3. **Endgame Mode**: Pure defection in final rounds

---

## Detailed Decision Rules

### Round 1: Initial Defection
- **Action: DEFECT**
- Rationale: Gather information about opponent tendencies without sacrificing payoff. If others cooperate, we gain maximally. If others defect, we lose nothing compared to cooperating.

### Rounds 2 through (r-2): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays in previous round) / n
```

**Decision logic:**

```
IF coop_rate >= 0.5:
    # Enough cooperators to exploit
    IF random() < exploitation_threshold:
        DEFECT
    ELSE:
        COOPERATE  # Occasional cooperation to not seem fully parasitic
    
    WHERE exploitation_threshold = 0.85 + 0.1 * (current_round / r)
    # Defect more as game progresses

ELSE IF coop_rate >= 0.2:
    # Cooperation is fragile - need to occasionally contribute
    IF random() < 0.3:
        COOPERATE
    ELSE:
        DEFECT

ELSE:  # coop_rate < 0.2
    # Cooperation has collapsed - no point contributing
    DEFECT
```

### Rounds (r-1) and r: Endgame Defection
- **Action: DEFECT (always)**
- Rationale: No future rounds to worry about retaliation. Pure Nash equilibrium play.

---

## Refinements for Robustness

### Trend Detection
Track cooperation rate over a sliding window of 3 rounds:

```
IF cooperation is DECLINING over last 3 rounds:
    Increase defection probability by 0.1
    
IF cooperation is STABLE or INCREASING:
    Maintain current exploitation level
```

### Exploitation Ceiling Based on k/n Ratio
The closer k is to n, the more valuable cooperation becomes to everyone. Adjust:

```
base_exploit_rate = 0.85
k_adjustment = (n - k) / (n - 1)  # Higher when k is far from n
final_exploit_rate = base_exploit_rate * (0.8 + 0.4 * k_adjustment)
```

### Never Be the Only Cooperator
```
IF I cooperated last round AND I was the only cooperator:
    DEFECT this round (being a lone cooperator is pure loss)
```

---

## Pseudocode Summary

```python
def adaptive_parasite(round, history, n, k, r):
    # Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    # Round 1: defect to probe
    if round == 1:
        return DEFECT
    
    # Calculate cooperation metrics
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate = last_round_coops / n
    i_was_only_cooperator = (last_round_coops == 1 and my_last_action == COOPERATE)
    
    # Never be a sucker
    if i_was_only_cooperator:
        return DEFECT
    
    # Exploitation threshold increases over time
    time_factor = round / r
    base_exploit = 0.85 + 0.1 * time_factor
    k_adjustment = (n - k) / (n - 1)
    exploit_threshold = base_exploit * (0.8 + 0.4 * k_adjustment)
    
    # Decision based on cooperation level
    if coop_rate >= 0.5:
        return DEFECT if random() < exploit_threshold else COOPERATE
    elif coop_rate >= 0.2:
        return DEFECT if random() < 0.7 else COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: Defects ~85%+ of the time when cooperation is healthy
2. **Avoids being exploited**: Never cooperates alone, always defects in endgame
3. **Maintains exploitation opportunity**: Just enough cooperation to prevent total collapse
4. **Adapts to population**: Extracts maximum value regardless of opponent mix
5. **Information asymmetry**: Defects first round to learn without cost
'''

description_EXPLOITATIVE_38 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that in a public goods game with k < n, defection strictly dominates cooperation in any single round. However, in a repeated game, I can exploit cooperators by free-riding on their contributions while carefully managing when (if ever) I contribute. My goal is to **extract maximum value from cooperative opponents while minimizing my own contributions**.

## Strategy Overview

I will primarily defect, but use strategic conditional cooperation to:
1. Identify and exploit "suckers" (unconditional or highly cooperative players)
2. Avoid triggering retaliation from conditional cooperators too early
3. Maximize end-game exploitation when retaliation becomes pointless

---

## Decision Rules

### Round 1: Defect
- **Rationale**: Gather information about opponent types without cost. Cooperating first reveals nothing useful and sacrifices payoff. Defecting lets me observe who cooperates unconditionally.

### Rounds 2 through (r-2): Adaptive Exploitation

**Calculate the "Cooperation Ratio" from the previous round:**
```
coop_ratio = (number of cooperators last round) / (n - 1)
```

**Decision Logic:**

```
IF coop_ratio >= 0.6:
    # High cooperation environment - exploit it
    DEFECT (free-ride on others)
    
ELIF coop_ratio >= 0.3 AND coop_ratio < 0.6:
    # Medium cooperation - occasionally cooperate to sustain the herd
    IF my_defection_streak >= 3:
        COOPERATE (to avoid being identified as pure defector)
    ELSE:
        DEFECT
        
ELIF coop_ratio < 0.3:
    # Low cooperation environment - no point contributing
    DEFECT
```

**Additional Exploitation Rule - Identify Conditional Cooperators:**
```
IF a player has been matching average behavior (cooperating when others cooperate):
    # They're a conditional cooperator - occasionally throw them a bone
    # to keep them cooperating for others to exploit
    
IF majority of players are tracking MY behavior specifically:
    # Detected by: they defect only after I defect
    # Cooperate once every 4 rounds to keep them uncertain
```

### Round (r-1): Second-to-Last Round
```
IF coop_ratio from round (r-2) >= 0.5:
    DEFECT  # Exploit remaining cooperators
ELSE:
    DEFECT  # No benefit to cooperating
```

### Round r (Final Round): Always Defect
- **Rationale**: No future consequences. Pure dominant strategy logic applies. This is non-negotiable.

---

## Detailed Tracking Mechanism

Maintain the following state:

```python
# Track each opponent's behavior
opponent_history = {
    player_id: {
        'total_cooperations': int,
        'total_defections': int,
        'recent_actions': list,  # last 3 rounds
        'type_estimate': str  # 'unconditional_coop', 'conditional', 'defector', 'unknown'
    }
}

# My own state
my_defection_streak = 0
my_total_cooperations = 0
```

### Opponent Classification (updated each round):

```
IF opponent cooperated > 80% of rounds:
    type = 'unconditional_coop'  # EXPLOIT HEAVILY
    
ELIF opponent's cooperation correlates with group cooperation:
    type = 'conditional'  # Maintain minimally
    
ELIF opponent defected > 80% of rounds:
    type = 'defector'  # Ignore, play selfishly
    
ELSE:
    type = 'unknown'  # Default to defection
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | D, D | No time to build cooperation; exploit both rounds |
| n = 2 (two players) | Always D | Direct prisoner's dilemma; defection dominates |
| k very close to n | Still primarily D | Even with high multiplier, free-riding is better |
| All opponents defected round 1 | Continue D | No cooperation to exploit; mutual defection equilibrium |
| All opponents cooperated round 1 | Defect aggressively | Found a goldmine of suckers |
| Single cooperator remaining | D | Extract their contribution without reciprocating |

---

## Pseudocode Summary

```python
def decide(round_number, total_rounds, n, k, history):
    
    # Final round: always defect
    if round_number == total_rounds:
        return DEFECT
    
    # First round: defect to gather intel
    if round_number == 1:
        return DEFECT
    
    # Calculate cooperation metrics
    last_round_coops = count_cooperators(history, round_number - 1)
    coop_ratio = last_round_coops / (n - 1)
    my_recent_defections = count_my_defection_streak(history)
    
    # High cooperation: exploit
    if coop_ratio >= 0.6:
        return DEFECT
    
    # Medium cooperation: occasional token cooperation
    if coop_ratio >= 0.3:
        if my_recent_defections >= 3:
            return COOPERATE  # Minimal investment to sustain herd
        return DEFECT
    
    # Low cooperation: no point contributing
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Only suckers lead with cooperation
2. **Free-rides on cooperative environments** - Maximum extraction when others contribute
3. **Minimal "maintenance" cooperation** - Just enough to prevent total collapse of cooperative players
4. **Endgame betrayal** - Guaranteed defection when punishment is impossible
5. **Opponent modeling** - Identifies and specifically exploits unconditional cooperators
6. **Defection-biased** - In ambiguous situations, defaults to defection

This strategy treats cooperation as a **cost** and other players' cooperation as a **resource to be harvested**.
'''

description_EXPLOITATIVE_37 = '''
# Exploitative Strategy: "Predatory Reciprocator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors benefit from cooperators, but cooperators need critical mass to break even. The strategy aims to **free-ride on cooperative populations** while **punishing defection to maintain exploitable cooperation levels**, and **abandoning cooperation entirely when the population is too defection-heavy to exploit**.

---

## Decision Rules

### Round Classification

**First Round:** Defect.
- Rationale: Gather information about opponent tendencies without risk. In a tournament with unknown opponents, the expected value of cooperation is low (k/n per cooperator, but you sacrifice 1). Defecting lets us observe who cooperates "unconditionally" — these are our targets.

**Last Round:** Defect.
- Rationale: No future punishment possible. Pure dominant strategy logic applies.

**Penultimate Round (round r-1):** Defect.
- Rationale: Sophisticated opponents will defect in the last round, so there's no future cooperation to protect. Begin endgame defection early.

**Middle Rounds (rounds 2 through r-2):** Adaptive decision based on exploitation potential.

---

### Adaptive Decision Algorithm for Middle Rounds

```
Let:
  coop_rate = (total cooperations by others in all previous rounds) / 
              ((n-1) × rounds_played)
  
  last_round_coop = number of other players who cooperated last round
  threshold = n / k  (breakeven point: need this many cooperators for C to match D)
  
Decision Logic:

IF last_round_coop >= threshold + 1:
    # Population is cooperative enough to exploit
    DEFECT (free-ride on cooperators)
    
ELIF last_round_coop >= threshold - 1 AND last_round_coop < threshold + 1:
    # Population is near the tipping point - conditional cooperation
    IF coop_rate > 0.5:
        # History suggests cooperation can be sustained
        COOPERATE (invest to maintain exploitable environment)
    ELSE:
        DEFECT
        
ELIF last_round_coop > 0 AND last_round_coop < threshold - 1:
    # Some cooperators exist but not enough to sustain
    # Probabilistic cooperation to probe/maintain
    COOPERATE with probability = last_round_coop / (threshold + 1)
    
ELSE (last_round_coop == 0):
    # All defection - no point cooperating
    DEFECT
```

---

### Exploitation Logic Explained

1. **When many cooperate (≥ threshold + 1):** Defect ruthlessly. You get the public good benefit PLUS your private endowment. This is pure free-riding.

2. **At the tipping point:** Conditionally cooperate only if historical patterns suggest the population sustains cooperation. This invests minimally to keep the "cooperative herd" alive for future exploitation.

3. **Few cooperators:** Probe probabilistically. Occasional cooperation signals willingness to reciprocate, potentially encouraging naive reciprocators, while mostly defecting.

4. **All defect:** Never be the sucker. Universal defection means cooperation has negative expected value.

---

## Pseudocode Implementation

```python
def predatory_reciprocator(n, k, r, current_round, history):
    """
    history: list of lists, history[t] = list of actions by all OTHER players in round t
             actions encoded as 1 (Cooperate) or 0 (Defect)
    """
    
    # Edge cases
    if current_round == 1:
        return DEFECT
    
    if current_round >= r - 1:  # Last two rounds
        return DEFECT
    
    # Calculate metrics
    threshold = n / k
    last_round_coop = sum(history[current_round - 1])
    
    total_coop = sum(sum(round_actions) for round_actions in history)
    total_actions = (n - 1) * (current_round - 1)
    coop_rate = total_coop / total_actions if total_actions > 0 else 0
    
    # Decision logic
    if last_round_coop >= threshold + 1:
        return DEFECT  # Exploit cooperative population
    
    elif last_round_coop >= threshold - 1:
        if coop_rate > 0.5:
            return COOPERATE  # Maintain exploitable environment
        else:
            return DEFECT
    
    elif last_round_coop > 0:
        prob_coop = last_round_coop / (threshold + 1)
        return COOPERATE if random() < prob_coop else DEFECT
    
    else:
        return DEFECT  # All-defection environment
```

---

## Robustness Features

| Opponent Type | Strategy Response |
|---------------|-------------------|
| **Always Cooperate** | Defect always — maximum exploitation |
| **Always Defect** | Defect always — no sucker payoffs |
| **Tit-for-Tat variants** | Occasional cooperation keeps them cooperative, then exploit |
| **Grim Trigger** | Early defection triggers their defection, but we lose little |
| **Random** | Adaptive threshold adjusts to observed cooperation |
| **Similar exploiters** | Mutual defection — stable equilibrium, no losses |

---

## Key Strategic Advantages

1. **Never cooperates first** — avoids sucker payoffs against defectors
2. **Exploits cooperators maximally** — defects when free-riding is profitable
3. **Maintains cooperation when useful** — invests minimally to keep exploitable population
4. **Clean endgame** — no wasted cooperation in final rounds
5. **Parameter-adaptive** — threshold automatically adjusts to game parameters (n, k)
'''

description_EXPLOITATIVE_39 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single shot, but cooperative populations can be milked for substantial gains before they collapse.

## Strategy Overview

The strategy operates in three modes based on detected population behavior:
1. **Probe Mode** (early rounds): Gather information about opponent tendencies
2. **Exploit Mode**: Free-ride on cooperative populations
3. **Defensive Mode**: Defect against predominantly defecting populations

---

## Detailed Decision Rules

### Round 1: Initial Probe
**Action: DEFECT**

Rationale: Defection weakly dominates in round 1 with no prior information. This also establishes a baseline to measure how forgiving the population is.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / (n - 1)
```

Calculate the **trend** (if round ≥ 3):
```
trend = coop_rate(current) - coop_rate(previous)
```

**Decision Logic:**

```
IF in final 20% of rounds (round > 0.8 * r):
    # Endgame exploitation - cooperation is collapsing anyway
    DEFECT

ELSE IF coop_rate >= exploitation_threshold:
    # Population is cooperative enough to exploit
    
    IF trend < -0.15:
        # Cooperation collapsing fast - extract value now
        DEFECT
    
    ELSE IF coop_rate >= 0.7:
        # Very cooperative population - pure exploitation
        DEFECT
    
    ELSE IF coop_rate >= 0.5:
        # Moderately cooperative - occasional cooperation to sustain them
        # Cooperate with probability (coop_rate - 0.5) * 0.3
        # This means: at 50% coop rate, always defect
        #             at 70% coop rate, cooperate ~6% of time
        PROBABILISTIC_COOPERATE(prob = (coop_rate - 0.5) * 0.3)
    
    ELSE:
        DEFECT

ELSE:
    # Population mostly defects - no point cooperating
    DEFECT
```

**Threshold Calibration:**
```
exploitation_threshold = max(0.3, k / n)
```
This threshold scales with the game parameters - when k/n is higher, even lower cooperation rates yield profitable exploitation.

### Final Round (Round r)
**Action: DEFECT**

Rationale: No future rounds exist to punish defection. Standard backward induction applies.

---

## Pseudocode Implementation

```python
def adaptive_predator_decision(round_num, total_rounds, n, k, history):
    
    # Final round - always defect
    if round_num == total_rounds:
        return DEFECT
    
    # Round 1 - probe with defection
    if round_num == 1:
        return DEFECT
    
    # Calculate cooperation metrics
    last_round_cooperators = count_cooperators(history[-1], exclude_self=True)
    coop_rate = last_round_cooperators / (n - 1)
    
    # Calculate trend if possible
    if round_num >= 3:
        prev_coop_rate = count_cooperators(history[-2], exclude_self=True) / (n - 1)
        trend = coop_rate - prev_coop_rate
    else:
        trend = 0
    
    # Endgame phase - pure defection
    if round_num > 0.8 * total_rounds:
        return DEFECT
    
    # Set exploitation threshold
    exploitation_threshold = max(0.3, k / n)
    
    # Main decision logic
    if coop_rate < exploitation_threshold:
        return DEFECT
    
    if trend < -0.15:
        return DEFECT
    
    if coop_rate >= 0.7:
        return DEFECT
    
    if coop_rate >= 0.5:
        sustain_prob = (coop_rate - 0.5) * 0.3
        return COOPERATE if random() < sustain_prob else DEFECT
    
    return DEFECT
```

---

## Edge Cases Handled

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Defect | No information, dominant strategy |
| Final round | Defect | No future punishment possible |
| n = 2 | Same logic applies | Becomes prisoner's dilemma variant |
| All opponents defected last round | Defect | No cooperators to exploit |
| All opponents cooperated | Defect | Maximum exploitation opportunity |
| r = 2 (minimum rounds) | Defect both | Backward induction from round 2 |
| Cooperation suddenly spikes | Defect | Exploit the windfall |
| Very high k (close to n) | Lower threshold | Exploit even low cooperation |

---

## Why This Strategy is Exploitative

1. **Never initiates sustained cooperation**: Only offers token cooperation to sustain exploitable populations
2. **Maximizes free-riding**: Defects whenever cooperation rate is high enough to benefit
3. **Abandons sinking ships**: Defects immediately when cooperation trends downward
4. **Endgame defection**: Extracts maximum value in final rounds when punishment is impossible
5. **Parameter-adaptive**: Adjusts exploitation threshold based on k/n ratio to optimize extraction

This strategy treats cooperative agents as resources to be harvested, not partners to coordinate with.
'''

description_EXPLOITATIVE_38 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperators while minimizing losses from defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but we can extract more value by encouraging others to cooperate while we selectively defect.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit cooperative players.

---

## Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Goal:** Gather information about opponent tendencies while appearing conditionally cooperative.

### Round 1 Decision:
- **COOPERATE** if `n ≤ 4` (small groups often have more cooperators worth cultivating)
- **DEFECT** if `n > 4` (larger groups provide more cover for defection)

### Subsequent Probing Rounds:
- **COOPERATE** if the cooperation rate in the previous round was ≥ 50%
- **DEFECT** otherwise

**Rationale:** Early cooperation signals help identify exploitable cooperative opponents. We invest minimally to build a reputation that may encourage continued cooperation from others.

---

## Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Goal:** Maximize extraction from cooperative players while maintaining just enough cooperation to keep them contributing.

### Opponent Classification (updated each round):

For each observable pattern in the population, track:
- `coop_rate` = (total cooperations observed) / (total rounds played × n)
- `trend` = cooperation rate in last 3 rounds vs. previous 3 rounds

### Decision Rules:

```
Let prev_coop_count = number of cooperators in previous round
Let coop_rate = prev_coop_count / n
Let my_coop_history = fraction of rounds I cooperated

IF coop_rate >= 0.6:
    # Rich environment - exploit heavily
    DEFECT with probability 0.8
    COOPERATE with probability 0.2 (to maintain some illusion)

ELSE IF coop_rate >= 0.4:
    # Moderate environment - strategic mixing
    IF trend is declining:
        COOPERATE (try to reverse decline)
    ELSE:
        DEFECT (extract while it lasts)

ELSE IF coop_rate >= 0.2:
    # Sparse cooperation - occasional cooperation to test
    COOPERATE with probability 0.3
    DEFECT with probability 0.7

ELSE:
    # Barren environment - pure defection
    DEFECT
```

### Exploitation Modifier:
If I've defected for 3+ consecutive rounds AND cooperation rate is declining:
- COOPERATE once to potentially "reset" cooperative opponents who use trigger strategies
- Then resume exploitation

---

## Phase 3: Endgame (Final ⌈r/10⌉ rounds, minimum last 2 rounds)

**Goal:** Maximum extraction with no regard for future consequences.

### Decision Rule:
- **DEFECT unconditionally** in all endgame rounds

**Rationale:** No future rounds means no punishment possible. Pure defection is dominant.

### Special Case - Final Round:
- **ALWAYS DEFECT** (this is strictly dominant regardless of any other consideration)

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| r ≤ 3 (very short game) | DEFECT all rounds |
| r = 2 | DEFECT both rounds |
| n = 2 (two players) | Tit-for-Tat with defection bias: Start D, then copy opponent but defect on last 2 rounds |
| k very close to n | Slightly more cooperation (public good nearly efficient) |
| k very close to 1 | Pure defection (public good nearly worthless) |
| All opponents defected last round | DEFECT |
| All opponents cooperated last round | DEFECT (maximum exploitation opportunity) |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    if round > r - max(2, ceil(r/10)):
        return DEFECT
    
    # Very short games - always defect
    if r <= 3:
        return DEFECT
    
    prev_coop_rate = count_cooperators(history, round-1) / n  # 0 if round 1
    
    # Probing phase
    if round <= ceil(r/5):
        if round == 1:
            return COOPERATE if n <= 4 else DEFECT
        else:
            return COOPERATE if prev_coop_rate >= 0.5 else DEFECT
    
    # Exploitation phase
    if prev_coop_rate >= 0.6:
        return DEFECT if random() < 0.8 else COOPERATE
    elif prev_coop_rate >= 0.4:
        trend = calc_trend(history, last_3_rounds vs previous_3)
        return COOPERATE if trend < 0 else DEFECT
    elif prev_coop_rate >= 0.2:
        return DEFECT if random() < 0.7 else COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators:** Systematically defects when others cooperate
2. **Minimal investment:** Only cooperates strategically to maintain exploitable conditions
3. **Endgame extraction:** Unconditional defection when punishment is impossible
4. **Opponent modeling:** Identifies and targets cooperative populations
5. **Adaptive camouflage:** Occasional cooperation prevents easy identification as a pure defector
'''

description_EXPLOITATIVE_40 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors free-ride on cooperators. The goal is to **maximize extraction from cooperative opponents while minimizing losses against defectors**. I will cooperate only when it's profitable to "farm" cooperation from others, and defect ruthlessly when exploitation opportunities arise or cooperation pools dry up.

## Decision Framework

### Key Metrics Tracked

```
For each round t, track:
- cooperation_rate[t] = (number of C plays by others) / (n-1)
- my_cumulative_payoff
- trend = cooperation_rate[t] - cooperation_rate[t-1]
- rounds_remaining = r - t
```

### Decision Rules

#### Round 1: Defect
- **Action: D**
- Rationale: No information exists. Defecting is strictly dominant in a single round. This also serves as a probe—I observe who cooperates naively without reciprocity signals.

#### Rounds 2 through (r-1): Adaptive Exploitation

**Calculate exploitation threshold:**
```
threshold = k / n  # The marginal benefit I get per cooperator
```

**Decision logic:**

1. **If cooperation_rate[t-1] ≥ 0.5 AND trend ≥ 0:**
   - Others are cooperating and stable/increasing
   - **Action: D** (free-ride on the cooperative pool)
   - This is peak exploitation—harvest their contributions

2. **If cooperation_rate[t-1] ≥ 0.5 AND trend < -0.2:**
   - Cooperation is collapsing rapidly
   - **Action: D** (don't throw good money after bad)

3. **If 0.3 ≤ cooperation_rate[t-1] < 0.5 AND trend ≥ 0:**
   - Moderate cooperation, might be sustainable
   - **Action: C with probability = cooperation_rate[t-1]**
   - Conditional cooperation to potentially sustain the pool for future exploitation

4. **If cooperation_rate[t-1] < 0.3:**
   - Pool is mostly defectors
   - **Action: D** (no point cooperating with defectors)

5. **Special override - "Sucker Detection":**
   - If any specific player has cooperated in ≥80% of rounds while I've defected ≥60% of rounds:
   - **Action: D** (continue exploiting the sucker)

#### Last Round (Round r): Always Defect
- **Action: D**
- Rationale: No future shadow. Defection is strictly dominant. No possibility of retaliation.

### Pseudocode Summary

```python
def decide(round_t, history, n, k, r):
    
    if round_t == 1:
        return DEFECT
    
    if round_t == r:
        return DEFECT  # Last round, no future
    
    coop_rate = count_others_cooperated(history, round_t - 1) / (n - 1)
    
    if round_t >= 3:
        prev_coop_rate = count_others_cooperated(history, round_t - 2) / (n - 1)
        trend = coop_rate - prev_coop_rate
    else:
        trend = 0
    
    # Exploitation zone: high cooperation, stable or rising
    if coop_rate >= 0.5 and trend >= 0:
        return DEFECT  # Free-ride
    
    # Collapsing cooperation
    if coop_rate >= 0.5 and trend < -0.2:
        return DEFECT
    
    # Moderate cooperation - probabilistic participation
    if 0.3 <= coop_rate < 0.5 and trend >= 0:
        return COOPERATE if random() < coop_rate else DEFECT
    
    # Low cooperation environment
    if coop_rate < 0.3:
        return DEFECT
    
    # Default fallback
    return DEFECT
```

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | D | No information, dominant strategy |
| Round r (last) | D | No future retaliation possible |
| n = 2 (minimum players) | Follow standard rules, heavier weight on defection | Bilateral games are more volatile |
| All others defected last round | D | Don't be the only sucker |
| All others cooperated last round | D | Maximum exploitation opportunity |
| Highly variable opponent behavior | D | Uncertainty favors defection |

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Forces others to demonstrate cooperativeness first
2. **Free-rides on cooperative pools** - When others cooperate, I take without giving
3. **Abandons sinking ships** - Doesn't waste resources on collapsing cooperation
4. **Exploits predictable cooperators** - Continues defecting against persistent cooperators
5. **Endgame ruthlessness** - Guaranteed defection when no retaliation is possible

This strategy treats cooperation as a resource to be extracted from, not a mutual benefit to cultivate.
'''

description_EXPLOITATIVE_39 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round—but repeated play allows us to identify and exploit patterns in others' behavior.

## Strategy Overview

The strategy operates in three phases:
1. **Probe Phase**: Gather information about opponent behavior
2. **Exploit Phase**: Maximize extraction from cooperative populations
3. **Endgame Phase**: Defect unconditionally as the game concludes

---

## Detailed Decision Rules

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1: Defect**
- Rationale: Defection is risk-free information gathering. We observe how many others cooperate without sacrificing our endowment.
- This reveals the "baseline cooperation level" of the population.

**Round 2: Conditional**
- If ≥ 50% of other players cooperated in Round 1: **Cooperate** (to test if cooperation is sustained and conditional)
- Otherwise: **Defect**

### Phase 2: Exploit Phase (Rounds 3 to r-2)

Calculate a **Cooperation Index (CI)** after each round:

```
CI = (cooperators in last round) / (n - 1)
```

Also track a **Trend Indicator (TI)**:
```
TI = CI(current) - CI(previous)
```

**Decision Rule:**

```
IF CI > threshold AND TI ≥ 0:
    Cooperate with probability p = min(CI - 0.1, 0.8)
    Defect with probability 1 - p
ELSE:
    Defect
```

Where `threshold = k / n` (the break-even point where cooperation becomes collectively efficient)

**Rationale for Probabilistic Cooperation:**
- We cooperate *slightly less* than the population average (CI - 0.1)
- This extracts surplus: we benefit from others' contributions while contributing less
- Cap at 0.8 ensures we never become a reliable cooperator others can depend on
- If cooperation is declining (TI < 0), abandon ship early

### Phase 3: Endgame Phase (Final 2 rounds)

**Rounds r-1 and r: Defect unconditionally**

- Rationale: No future punishment is possible. Pure exploitation.
- With 2 rounds of defection, we hedge against opponents who only defect in the final round.

---

## Edge Cases

### Small Number of Rounds (r ≤ 4)
- If r = 2: Defect both rounds
- If r = 3: Defect all rounds
- If r = 4: Defect round 1, observe, defect rounds 3-4; cooperate round 2 only if round 1 had >60% cooperation

### Extreme Population Behaviors

**If everyone defected in rounds 1-2:**
- Switch to permanent defection (no cooperative surplus to extract)

**If everyone cooperated in rounds 1-2:**
- This is a highly exploitable population
- Cooperate with probability 0.5 in exploit phase (extract maximum surplus while maintaining some group cooperation)

### Parameter Sensitivity

**When k is close to n (high efficiency):**
- Slightly increase cooperation probability (more surplus available)
- Adjust: `p = min(CI - 0.05, 0.85)`

**When k is close to 1 (low efficiency):**
- Be more aggressive with defection
- Adjust: `p = min(CI - 0.2, 0.6)`

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    // Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    // Round 1 - probe with defection
    if round == 1:
        return DEFECT
    
    // Calculate cooperation metrics
    CI = count_cooperators_last_round(history) / (n - 1)
    
    // Round 2 - conditional probe
    if round == 2:
        if CI >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    // Exploit phase
    TI = CI - previous_CI(history)
    threshold = k / n
    
    // Abandon if cooperation collapsing or below threshold
    if CI <= threshold OR TI < -0.15:
        return DEFECT
    
    // Probabilistic exploitation
    adjust = 0.1 + 0.1 * (n - k) / n  // More aggressive when k is low
    p = min(CI - adjust, 0.8)
    
    if random() < p:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: By cooperating less frequently than the population average, we extract more than we contribute
2. **Punishes no one**: Unlike tit-for-tat variants, we don't sacrifice payoffs to punish defectors
3. **Endgame exploitation**: Guaranteed defection when punishment is impossible
4. **Information asymmetry**: We learn from round 1 defection while others who cooperate learn less
5. **Adaptive extraction**: We calibrate our exploitation to the maximum sustainable level—cooperating just enough to keep the cooperative surplus alive while taking more than our share
'''

description_EXPLOITATIVE_41 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round—but repeated play creates exploitable patterns in cooperative opponents.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous adaptation based on observed cooperation rates.

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: Defection dominates. We gain information about opponent tendencies while securing the guaranteed payoff of 1 + (k/n) × cooperators.

**Round 2: DEFECT**
- Rationale: Continue gathering data. Cooperative opponents often give "second chances"—we exploit this generosity.

After Round 2, calculate the **Cooperation Index (CI)**:
```
CI = (total cooperations by others in rounds 1-2) / ((n-1) × 2)
```

---

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

**Decision Rule:**

```
Let CI_recent = cooperation rate of others in last 3 rounds (or available rounds)
Let MY_recent = my cooperation rate in last 3 rounds

IF CI_recent > 0.5:
    # Environment is cooperative - EXPLOIT IT
    IF CI_recent > 0.7:
        DEFECT  # High cooperation = pure exploitation opportunity
    ELSE:
        # Occasional cooperation to maintain others' willingness
        COOPERATE with probability = max(0, CI_recent - 0.5)
        # This means cooperate ~0-20% of the time
        
ELSE IF CI_recent <= 0.5:
    # Environment is hostile or mixed
    DEFECT  # No point contributing to a failing public good
```

**Adaptive Adjustment - Sucker Detection:**
```
IF specific player j has cooperated > 80% of rounds:
    Mark j as "exploitable"
    # Their cooperation adds to our defection payoff
    
IF number of exploitable players ≥ (n-1)/2:
    ALWAYS DEFECT  # We have enough suckers to free-ride on
```

---

### Phase 3: Endgame (Final 2 rounds)

**Round r-1 (second-to-last): DEFECT**
- Rationale: Even cooperative strategies often defect in final rounds. Preempt this.

**Round r (final round): DEFECT**
- Rationale: No future rounds mean no punishment possible. Pure dominant strategy.

---

## Complete Decision Pseudocode

```python
def decide(round_number, history, n, k, r):
    
    # ENDGAME: Always defect in final 2 rounds
    if round_number >= r - 1:
        return DEFECT
    
    # PROBE PHASE: First 2 rounds
    if round_number <= 2:
        return DEFECT
    
    # EXPLOITATION PHASE: Rounds 3 to r-2
    
    # Calculate recent cooperation rate (last 3 rounds)
    lookback = min(3, round_number - 1)
    recent_rounds = history[-(lookback):]
    others_cooperations = sum(count_cooperators(rd) - my_action(rd) for rd in recent_rounds)
    CI_recent = others_cooperations / ((n - 1) * lookback)
    
    # Count highly cooperative ("exploitable") players
    player_coop_rates = calculate_individual_coop_rates(history)
    exploitable_count = sum(1 for rate in player_coop_rates if rate > 0.8)
    
    # If we have enough suckers, always defect
    if exploitable_count >= (n - 1) / 2:
        return DEFECT
    
    # Exploitation logic based on cooperation environment
    if CI_recent > 0.7:
        return DEFECT  # Pure free-riding
    elif CI_recent > 0.5:
        # Minimal cooperation to sustain the herd
        cooperate_prob = CI_recent - 0.5  # 0% to 20%
        return COOPERATE with probability cooperate_prob, else DEFECT
    else:
        return DEFECT  # Hostile environment, protect yourself
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | DEFECT both rounds | Both are essentially "final" rounds |
| n = 2 (minimum players) | DEFECT always | With k < n < 2 impossible; if k < 2, defection dominates completely |
| All others defecting | DEFECT | No exploitation opportunity; minimize losses |
| All others cooperating | DEFECT | Maximum exploitation opportunity |
| k very close to n | Still DEFECT-heavy | The strategy remains sound; higher k just means bigger free-rider gains |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation**: We only consider cooperation as a tool to maintain exploitable opponents, never as genuine contribution.

2. **Targets cooperative players**: The "sucker detection" mechanism identifies and systematically exploits consistent cooperators.

3. **Minimal reciprocity**: Even when we occasionally cooperate, it's probabilistic and rare—just enough to potentially prevent a complete cooperation collapse.

4. **Guaranteed endgame defection**: We take the unilateral gains in final rounds regardless of prior dynamics.

5. **Information asymmetry exploitation**: We use early rounds purely for intelligence gathering while others may be signaling cooperation.
'''

description_EXPLOITATIVE_40 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but we can extract more value by encouraging others to cooperate while we selectively defect.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit cooperative players.

---

## Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Objective:** Gather information about opponent tendencies while appearing conditionally cooperative.

### Round 1 Decision:
- **Cooperate** if `n ≤ 4` (small groups often have higher cooperation rates worth cultivating)
- **Defect** if `n > 4` (larger groups provide cover and lower individual impact)

### Subsequent Probing Rounds:
- **Cooperate** if the cooperation rate in the previous round was ≥ 50%
- **Defect** otherwise

**Rationale:** We want to signal that we *might* be a conditional cooperator to encourage cooperation from others, while gathering data.

---

## Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-2)

**Objective:** Maximize extraction from cooperative opponents while maintaining enough cooperation to keep the "herd" contributing.

### Opponent Classification:
For each opponent j, calculate their cooperation rate `coop_rate[j]` over all observed rounds.

Classify opponents as:
- **Suckers:** `coop_rate[j] ≥ 0.7` (highly exploitable)
- **Conditional:** `0.3 ≤ coop_rate[j] < 0.7` (respond to group behavior)
- **Defectors:** `coop_rate[j] < 0.3` (not worth cooperating for)

### Decision Rule:

```
Let S = count of Suckers
Let C = count of Conditional cooperators
Let D = count of Defectors
Let recent_coop_rate = cooperation rate across all players in last 2 rounds

IF S ≥ n/3:
    # Enough suckers to exploit
    DEFECT

ELSE IF recent_coop_rate ≥ 0.6 AND C ≥ n/3:
    # Cooperation is high but fragile - occasionally cooperate to maintain it
    COOPERATE with probability = 0.3
    DEFECT with probability = 0.7

ELSE IF recent_coop_rate ≥ 0.4:
    # Borderline cooperation - match the rate minus a discount
    COOPERATE with probability = max(0, recent_coop_rate - 0.2)
    
ELSE:
    # Cooperation has collapsed - no point contributing
    DEFECT
```

### Adaptive Adjustment:
Every 3 rounds, evaluate personal payoff trajectory:
- If my average payoff < 1.0 (worse than universal defection), increase cooperation probability by 0.1
- If my average payoff > 1.3, decrease cooperation probability by 0.1

---

## Phase 3: Endgame (Final 2 Rounds)

**Objective:** Pure extraction—no future rounds to maintain reputation.

### Decision Rule:
- **Round r-1:** Defect (opponents may not realize endgame has begun)
- **Round r:** Defect (dominant strategy, no future consequences)

---

## Edge Case Handling

### Very Short Games (r ≤ 4):
- Skip probing phase
- Round 1: Defect
- Middle rounds: Defect unless cooperation rate > 70%
- Final round: Always defect

### Two-Player Games (n = 2):
- Play Tit-for-Tat with defection bias: Start with D, then copy opponent's last move but defect on any even-numbered round

### High Multiplication Factor (k close to n):
- Be slightly more cooperative (add 0.1 to all cooperation probabilities) since the returns from mutual cooperation are higher

### Universal Defection Detected:
- If cooperation rate drops below 0.15 for 3 consecutive rounds, switch to permanent defection

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round >= r - 1:
        return DEFECT  # Endgame
    
    if round <= ceil(r/5):  # Probing phase
        if round == 1:
            return COOPERATE if n <= 4 else DEFECT
        else:
            return COOPERATE if last_round_coop_rate(history) >= 0.5 else DEFECT
    
    # Exploitation phase
    suckers = count_players_with_coop_rate(history, >= 0.7)
    recent_coop = avg_coop_rate_last_2_rounds(history)
    
    if suckers >= n/3:
        return DEFECT
    elif recent_coop >= 0.6:
        return random_choice(COOPERATE: 0.3, DEFECT: 0.7)
    elif recent_coop >= 0.4:
        return random_choice(COOPERATE: recent_coop - 0.2, DEFECT: 1 - (recent_coop - 0.2))
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators:** Identifies and exploits "suckers" who cooperate regardless of others
2. **Manipulates conditional cooperators:** Cooperates just enough to keep them contributing
3. **Abandons lost causes:** Quickly defects when cooperation collapses
4. **Endgame exploitation:** Extracts maximum value when reputation no longer matters
5. **Information asymmetry:** Uses opponent modeling while appearing to be a simple conditional cooperator
'''

description_EXPLOITATIVE_42 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors extract value from cooperators without contributing. The goal is to **maximize extraction from cooperative opponents while minimizing losses against defectors**. We cooperate only when it's instrumentally useful for future exploitation, not out of principle.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit predictable patterns.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to min(3, r/4))

**Purpose:** Gather information about opponent behavior with minimal cost.

- **Round 1:** DEFECT
  - Rationale: Never cooperate without information. If others cooperate, we extract maximum value. If others defect, we lose nothing relative to cooperating.

- **Rounds 2-3:** Conditional cooperation probe
  - If cooperation rate in previous round ≥ 50%: COOPERATE (to test if cooperation sustains/grows)
  - If cooperation rate < 50%: DEFECT (environment is hostile, no point contributing)

### Phase 2: Exploitation Phase (Middle rounds, from end of Phase 1 to round r-2)

**Purpose:** Maximize payoff by exploiting identified patterns.

**Calculate "Sucker Index"** = (number of players who cooperated in ≥60% of observed rounds) / (n-1)

**Decision Logic:**

```
IF Sucker_Index ≥ 0.5:
    # Enough reliable cooperators to exploit
    DEFECT (free-ride on their contributions)
    
ELSE IF Sucker_Index ≥ 0.3:
    # Mixed environment - use probabilistic cooperation
    Cooperate with probability = (k/n) × Sucker_Index
    # This cooperates just enough to potentially sustain some cooperation
    
ELSE IF cooperation is trending upward (last 2 rounds show increase):
    # Opponents might be trying to establish cooperation
    COOPERATE once to encourage them, then DEFECT next round
    
ELSE:
    # Hostile environment with mostly defectors
    DEFECT (no value in contributing)
```

**Pattern Exploitation Module:**

Track each opponent's response pattern:
- If opponent appears to be Tit-for-Tat-like (cooperates after high group cooperation): Defect to exploit their cooperation
- If opponent appears unconditionally cooperative: Always defect against them
- If opponent is consistently retaliatory: Factor into Sucker_Index calculation

### Phase 3: Endgame (Final 2 rounds)

**Purpose:** Extract maximum value when future consequences don't exist.

- **Round r-1:** DEFECT (regardless of history)
- **Round r:** DEFECT (always - no future punishment possible)

**Rationale:** Backward induction guarantees defection is dominant in the final round. Sophisticated opponents know this, making round r-1 effectively final as well.

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | DEFECT both rounds | Both rounds are "endgame" |
| r = 3 | DEFECT all rounds | Too short for exploitation dynamics |
| n = 2 (minimum players) | More aggressive defection threshold | Less diffusion of exploitation |
| k close to n | Slightly more cooperation-tolerant | Higher returns to mutual cooperation, but still exploit when possible |
| k close to 1 | Very aggressive defection | Low multiplication makes cooperation wasteful |
| All opponents defecting for 3+ rounds | Permanent DEFECT | No value in attempted coordination |
| Sudden shift to mass cooperation | DEFECT | Exploit the gift; don't question it |

---

## Pseudocode Summary

```python
def adaptive_predator(round_num, total_rounds, history, n, k):
    
    # Endgame - always defect
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # Round 1 - always defect
    if round_num == 1:
        return DEFECT
    
    # Calculate metrics
    sucker_index = count_reliable_cooperators(history) / (n - 1)
    last_round_coop_rate = history[-1].cooperation_count / (n - 1)
    cooperation_trending_up = is_trending_up(history, window=2)
    
    # Probing phase (rounds 2-3)
    if round_num <= min(3, total_rounds // 4):
        if last_round_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Exploitation phase
    if sucker_index >= 0.5:
        return DEFECT  # Free ride on suckers
    
    if sucker_index >= 0.3:
        if random() < (k / n) * sucker_index:
            return COOPERATE
        return DEFECT
    
    if cooperation_trending_up and not cooperated_last_round:
        return COOPERATE  # Bait hook
    
    return DEFECT  # Default to defection
```

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Every cooperation serves future exploitation
2. **Identifies and targets "suckers"** - Players who cooperate reliably are milked for value
3. **Defects in endgame** - No sentimentality when punishment becomes impossible
4. **Information asymmetry** - Uses early defection to safely observe while others reveal their strategies
5. **Probabilistic cooperation is strategic** - Only cooperates enough to potentially sustain exploitable opponents, never more
'''

description_EXPLOITATIVE_41 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors extract value from cooperators while risking nothing. The goal is to **free-ride on cooperative environments while avoiding mutual defection traps**, and to **punish cooperation decline to maintain exploitable conditions**.

## Strategy Overview

I maintain a "cooperation exploitation index" that tracks how much I can extract from the group. I cooperate strategically to sustain a cooperative environment worth exploiting, but defect aggressively when cooperation is declining or when I'm near the endgame.

---

## Decision Rules

### Key Variables Tracked
- `coop_rate`: Proportion of other players who cooperated last round
- `avg_coop_rate`: Rolling average cooperation rate over last 3 rounds
- `trend`: Whether cooperation is increasing, stable, or decreasing
- `round_num`: Current round (1-indexed)
- `rounds_remaining`: r - round_num

### Round-by-Round Logic

#### **Round 1: Defect**
- Rationale: No information yet. Defecting is dominant in single-shot. If others cooperate, I profit maximally. If they defect, I lose nothing.

#### **Rounds 2 to (r-2): Adaptive Exploitation Phase**

```
Calculate:
  coop_rate = (cooperators among other n-1 players) / (n-1)
  avg_coop_rate = average of last min(3, round_num-1) rounds
  trend = avg_coop_rate compared to previous avg

IF coop_rate >= 0.6:
    # Environment is exploitable - DEFECT to free-ride
    # But occasionally cooperate (20% chance) to not collapse cooperation entirely
    IF random() < 0.2:
        COOPERATE
    ELSE:
        DEFECT

ELSE IF coop_rate >= 0.4:
    # Moderate cooperation - match to sustain it
    # Cooperate with probability equal to coop_rate
    IF random() < coop_rate:
        COOPERATE
    ELSE:
        DEFECT

ELSE IF coop_rate > 0 AND trend is INCREASING:
    # Low but recovering cooperation - invest to rebuild
    COOPERATE

ELSE:
    # Low/collapsed cooperation - no point contributing
    DEFECT
```

#### **Round (r-1): Penultimate Round**
```
IF coop_rate >= 0.5:
    DEFECT  # Extract value while others might still cooperate
ELSE:
    DEFECT  # Nothing to lose
```

#### **Round r: Final Round**
- **Always DEFECT**
- Rationale: No future punishment possible. Defection strictly dominates.

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (two players) | Defect always except probabilistic cooperation (10%) in middle rounds if opponent cooperated | Near-zero benefit from cooperation with k < n |
| k very close to n | More willing to cooperate (raise thresholds by 0.1) | Higher returns make cooperation more valuable to sustain |
| k very close to 1 | Lower cooperation thresholds (defect more) | Low multiplier means less value in public good |
| All opponents defected last round | Defect | Nothing to exploit |
| All opponents cooperated | Defect with 80% probability | Maximum extraction opportunity |
| r = 2 (only 2 rounds) | Defect both rounds | Too short for reputation building |
| r very large (>20) | First 2 rounds: Cooperate to establish pattern, then switch to adaptive phase | Build exploitable environment |

---

## Pseudocode Summary

```python
def adaptive_predator(round_num, r, n, k, history):
    if round_num == r:
        return DEFECT  # Endgame
    
    if round_num == 1:
        return DEFECT  # No info
    
    coop_rate = count_cooperators_last_round(history) / (n - 1)
    
    if round_num >= r - 1:
        return DEFECT  # Endgame exploitation
    
    if r <= 3:
        return DEFECT  # Too short to build cooperation
    
    if coop_rate >= 0.6:
        return DEFECT if random() > 0.2 else COOPERATE
    elif coop_rate >= 0.4:
        return COOPERATE if random() < coop_rate else DEFECT
    elif coop_rate > 0 and cooperation_trending_up(history):
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: When others cooperate, I mostly defect to maximize personal gain
2. **Maintains exploitation opportunities**: Occasional cooperation prevents total collapse
3. **Abandons sinking ships**: Quickly defects when cooperation collapses
4. **Endgame extraction**: Guaranteed defection in final rounds captures maximum value
5. **Probabilistic unpredictability**: Random elements prevent easy counter-exploitation
'''

description_EXPLOITATIVE_43 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that **defection strictly dominates cooperation in any single round** (you always gain more by defecting given any fixed behavior of others). However, in a repeated game, I can potentially manipulate cooperators into continuing to cooperate while I extract maximum value. My strategy is to **appear cooperative enough to sustain a cooperative environment, then defect at optimal moments to extract surplus**.

## Strategy Overview

I will masquerade as a conditional cooperator while systematically exploiting the group. The key is to defect just below the threshold that would cause cooperative collapse, while extracting maximum personal gain.

---

## Decision Rules

### Round 1: Establish Cooperative Appearance
**Action: COOPERATE**

Rationale: This signals cooperative intent, encouraging others to cooperate in future rounds. The information gained about opponent types is worth the small cost.

### Rounds 2 through (r-1): Adaptive Exploitation Phase

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in round t-1) / n
```

**Decision Logic:**

```
IF coop_rate >= 0.6:
    # High cooperation environment - EXPLOIT
    IF my_consecutive_defections < exploitation_threshold:
        DEFECT
    ELSE:
        COOPERATE  # Brief cooperation to maintain group cooperation
        
ELIF coop_rate >= 0.3:
    # Medium cooperation - MATCH with slight exploitation bias
    IF I cooperated last round AND at least 50% of others defected:
        DEFECT  # Punish defectors, protect self
    ELIF random() < 0.4:
        COOPERATE  # Maintain some cooperation
    ELSE:
        DEFECT
        
ELSE:
    # Low cooperation environment - NO POINT COOPERATING
    DEFECT
```

**Exploitation Threshold Calculation:**
```
exploitation_threshold = max(1, floor(n / 3))
```
This limits consecutive defections to avoid being identified as a pure defector.

### Last Round (Round r): Pure Defection
**Action: DEFECT**

Rationale: No future rounds exist to punish this defection. This is the dominant strategy regardless of history.

### Second-to-Last Round (Round r-1): Likely Defect
**Action: DEFECT with 90% probability, COOPERATE with 10%**

Rationale: Backward induction suggests others may defect; the small cooperation probability adds unpredictability.

---

## Detailed Pseudocode

```python
def adaptive_parasite(n, k, r, current_round, history):
    """
    history: list of rounds, each round is list of actions (C/D) for all players
    """
    
    # Last round: always defect
    if current_round == r:
        return DEFECT
    
    # Second-to-last round: almost always defect
    if current_round == r - 1:
        return DEFECT if random() < 0.9 else COOPERATE
    
    # First round: cooperate to establish reputation
    if current_round == 1:
        return COOPERATE
    
    # Calculate metrics from history
    last_round = history[-1]
    coop_count = count(last_round, COOPERATE)
    coop_rate = coop_count / n
    
    my_recent_defections = count_my_consecutive_defections(history)
    exploitation_threshold = max(1, n // 3)
    
    # High cooperation: exploit but don't collapse the system
    if coop_rate >= 0.6:
        if my_recent_defections < exploitation_threshold:
            return DEFECT
        else:
            return COOPERATE  # Token cooperation to sustain group
    
    # Medium cooperation: conditional with exploitation bias
    elif coop_rate >= 0.3:
        others_who_defected = count_others_defections(last_round)
        if i_cooperated_last(history) and others_who_defected >= n / 2:
            return DEFECT  # Retaliate
        return COOPERATE if random() < 0.4 else DEFECT
    
    # Low cooperation: abandon ship
    else:
        return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | More conservative exploitation (threshold = 1) | Easier to detect defector |
| Very high k (close to n) | Slightly more cooperation | Higher returns to group cooperation |
| r = 2 | Defect both rounds | Too short to build reputation |
| All others always cooperate | Defect every round except occasional token C | Maximum extraction |
| All others always defect | Always defect | No point cooperating |
| Mixed/unpredictable opponents | Follow adaptive rules | Robust to uncertainty |

---

## Why This Strategy is Exploitative

1. **Free-riding on cooperators**: In high-cooperation environments, I defect to gain the +1 private benefit while still receiving public good contributions from others.

2. **Minimal contribution**: I only cooperate when necessary to prevent cooperative collapse or when cooperation has collapsed (making my defection worthless anyway).

3. **Endgame exploitation**: Guaranteed defection in final rounds extracts maximum value when reputation no longer matters.

4. **Asymmetric punishment**: I quickly abandon cooperation when others defect, but exploit when others cooperate—never a "sucker."
'''

description_EXPLOITATIVE_42 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns. The strategy therefore seeks to:

1. **Identify and exploit persistent cooperators** - they provide free public good benefits
2. **Defect against defectors** - no point cooperating with those who won't reciprocate
3. **Occasionally probe** - test if defectors might become cooperative
4. **Never cooperate in endgame** - no future interaction means no reason to build trust

---

## Strategy Specification

### Key Variables Tracked

- `cooperation_rate[i]` = fraction of rounds player i has cooperated (for each opponent)
- `global_cooperation_rate` = fraction of all actions that were C in previous rounds
- `recent_cooperation_trend` = cooperation rate in last 3 rounds vs overall
- `round_number` = current round (1 to r)
- `rounds_remaining` = r - round_number

### Decision Rules

#### Round 1: Defect
- **Rationale**: No information available. Defection is the dominant single-round action and allows us to observe others without cost.

#### Final Round (round = r): Defect
- **Rationale**: No future rounds mean no strategic benefit from cooperation. Pure Nash equilibrium is all-defect.

#### Penultimate Rounds (rounds_remaining ≤ 2): Defect
- **Rationale**: Backward induction suggests defection cascade. Sophisticated opponents will defect; exploitable ones provide diminishing returns.

#### Middle Game (3 < rounds_remaining < r-1):

```
Calculate:
  - global_coop = total cooperations / total actions in previous rounds
  - high_coop_count = number of players with cooperation_rate > 0.6
  - exploitability_score = (high_coop_count / (n-1)) × global_coop

IF exploitability_score > 0.4:
    # Environment is exploitable - DEFECT to maximize extraction
    ACTION = DEFECT
    
ELIF global_coop > 0.7 AND high_coop_count >= (n-1)/2:
    # Highly cooperative environment - occasional cooperation to maintain it
    # But only cooperate with probability proportional to benefit
    IF random() < 0.2:  # Cooperate 20% of time to "blend in"
        ACTION = COOPERATE
    ELSE:
        ACTION = DEFECT
        
ELIF global_coop < 0.2:
    # Hostile environment - pure defection
    ACTION = DEFECT
    
ELSE:
    # Mixed environment - probe occasionally
    IF round_number % 5 == 0 AND recent_cooperation_trend > global_coop:
        # Cooperation is increasing, throw in occasional C to encourage
        ACTION = COOPERATE
    ELSE:
        ACTION = DEFECT
```

### Edge Cases

1. **n = 2 (Two players)**: Treat as iterated Prisoner's Dilemma variant
   - Defect rounds 1 and r
   - Middle rounds: Defect unless opponent has cooperated >80% of time, then cooperate occasionally (30%) to keep them cooperative

2. **Very short games (r ≤ 3)**: Always defect
   - Not enough rounds for reputation or exploitation to matter

3. **Large n (n > 10)**: More aggressive defection
   - Individual cooperation barely visible; free-riding is optimal
   - Only cooperate if global_cooperation_rate > 0.8 (and even then, only 10% of time)

4. **k close to n (e.g., k > 0.8n)**: Slightly more cooperative
   - Benefits of mutual cooperation are high
   - Increase cooperation probability thresholds by 10%

---

## Pseudocode Summary

```
function decide(game_params, history):
    n, r, k = game_params
    current_round = len(history) + 1
    
    # Terminal conditions - always defect
    if current_round == 1: return DEFECT
    if current_round >= r - 1: return DEFECT
    if r <= 3: return DEFECT
    
    # Calculate exploitation metrics
    global_coop = calculate_global_cooperation(history)
    high_coop_players = count_players_with_coop_rate_above(history, 0.6)
    exploitability = high_coop_players / (n - 1) * global_coop
    
    # Large group adjustment
    if n > 10:
        if global_coop > 0.8 and random() < 0.1:
            return COOPERATE
        return DEFECT
    
    # Standard exploitation logic
    if exploitability > 0.4:
        return DEFECT  # Exploit the cooperators
    elif global_coop > 0.7 and high_coop_players >= (n-1)/2:
        return COOPERATE if random() < 0.2 else DEFECT
    elif global_coop < 0.2:
        return DEFECT
    else:
        # Probe on every 5th round if cooperation trending up
        if current_round % 5 == 0 and is_cooperation_increasing(history):
            return COOPERATE
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Defaults to defection**: The baseline action is always defect, only deviating when there's clear benefit
2. **Free-rides on cooperators**: When others cooperate heavily, we defect to extract maximum value
3. **Minimal costly signaling**: Only cooperates enough to potentially sustain cooperative environments we're exploiting
4. **Endgame defection**: No sentimentality - always defects when future interactions have no value
5. **Scales aggression with group size**: Larger groups mean more anonymity for defection
'''

description_EXPLOITATIVE_44 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors extract value from cooperators without reciprocating. The goal is to **maximize extraction from cooperative opponents while minimizing losses against defectors**, adapting dynamically based on observed behavior.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the population that determines behavior.

---

## Decision Rules

### Key Variables Tracked

- `coop_rate`: Rolling cooperation rate of opponents (excluding self) over recent rounds
- `round_num`: Current round (1-indexed)
- `total_rounds`: r (known)
- `trend`: Whether cooperation is increasing, stable, or decreasing

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: Gather information at no risk. If others cooperate, we extract maximum value. If others defect, we lose nothing compared to cooperating.

**Round 2: Conditional**
- If Round 1 saw ≥ 50% cooperation from others → DEFECT (continue exploiting)
- If Round 1 saw < 50% cooperation → COOPERATE (probe if conditional cooperators exist)

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate `coop_rate` = (total cooperations by others in last 3 rounds) / (3 × (n-1))

**Decision Logic:**

```
IF coop_rate >= 0.6:
    # Rich environment - exploit heavily
    DEFECT
    
ELIF coop_rate >= 0.4:
    # Moderate environment - strategic cooperation to sustain exploitation
    IF trend is DECREASING:
        COOPERATE  # Prop up cooperation to continue extraction
    ELSE:
        DEFECT     # Extract while stable
        
ELIF coop_rate >= 0.2:
    # Sparse environment - conditional cooperation
    IF my_recent_defections > 2:
        COOPERATE  # Signal willingness, bait cooperators
    ELSE:
        DEFECT
        
ELSE (coop_rate < 0.2):
    # Barren environment - no point cooperating
    DEFECT
```

**Trend Calculation:**
- Compare coop_rate of last 2 rounds vs previous 2 rounds
- INCREASING: recent > previous + 0.1
- DECREASING: recent < previous - 0.1
- STABLE: otherwise

### Phase 3: Endgame (Last 2 rounds)

**Round r-1 (second-to-last):**
- DEFECT (no future punishment possible, begin extraction)

**Round r (final round):**
- DEFECT (classical game theory: no future interaction means no cooperation incentive)

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r ≤ 3 (very short game) | Always DEFECT | Insufficient rounds for reputation building to pay off |
| n = 2 (two players) | Use stricter thresholds (add 0.2 to all coop_rate thresholds) | Single opponent is easier to read |
| k very close to n | Slightly more willing to cooperate (reduce thresholds by 0.1) | Higher multiplier means cooperation is more valuable |
| Perfect cooperation observed (100%) | DEFECT | Maximum exploitation opportunity |
| Zero cooperation observed | DEFECT | No value in unilateral cooperation |
| First round after opponent mass-defection | DEFECT | Don't reward punishment, wait for others to cooperate first |

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, n, k):
    
    # Endgame - always defect
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # Very short games - always defect
    if total_rounds <= 3:
        return DEFECT
    
    # Round 1 - probe with defection
    if round_num == 1:
        return DEFECT
    
    # Round 2 - conditional probe
    if round_num == 2:
        return DEFECT if others_coop_rate(history, round=1) >= 0.5 else COOPERATE
    
    # Main phase - adaptive exploitation
    coop_rate = calculate_recent_coop_rate(history, window=3)
    trend = calculate_trend(history)
    
    if coop_rate >= 0.6:
        return DEFECT
    elif coop_rate >= 0.4:
        return COOPERATE if trend == DECREASING else DEFECT
    elif coop_rate >= 0.2:
        return COOPERATE if my_recent_defections(history, window=3) > 2 else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** in favorable conditions - always tests others' willingness
2. **Extracts maximum value** when cooperation is high by free-riding
3. **Strategic "bait" cooperation** only to sustain a cooperative environment worth exploiting
4. **Ruthless endgame** - no cooperation when future punishment is impossible
5. **Asymmetric response** - punishes cooperation with defection when profitable, never rewards defection with cooperation
'''

description_EXPLOITATIVE_43 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**. I will cooperate only when it serves my exploitation goals—either to "farm" cooperators by keeping them cooperative, or to probe for exploitable patterns.

## Strategy Overview

The strategy operates in three phases and continuously classifies the opponent population to maximize extraction.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: Defection in round 1 is strictly dominant in expectation against unknown opponents. I capture full private value (1) plus any public good created by naive cooperators.

**Round 2: Conditional**
- If cooperation rate in Round 1 was ≥ 50%: **COOPERATE** (probe to see if cooperation is sustainable/exploitable)
- If cooperation rate in Round 1 was < 50%: **DEFECT** (population appears sophisticated; don't waste resources)

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate two key metrics each round:

```
recent_coop_rate = (cooperators in last 2 rounds) / (2 × n)
trend = coop_rate_last_round - coop_rate_two_rounds_ago
```

**Decision Logic:**

```
IF recent_coop_rate ≥ 0.6:
    # Rich environment - maintain it while extracting
    IF my_consecutive_defections ≥ 2:
        COOPERATE  # Prevent collapse, keep farming
    ELSE:
        DEFECT     # Extract value

ELSE IF recent_coop_rate ∈ [0.3, 0.6):
    # Moderate environment - conditional cooperation
    IF trend > 0:
        COOPERATE  # Encourage rising cooperation
    ELSE IF trend < 0:
        DEFECT     # Abandon sinking ship
    ELSE:
        # Stable moderate cooperation - probabilistic exploitation
        COOPERATE with probability = (recent_coop_rate - 0.3) / 0.3
        DEFECT otherwise

ELSE IF recent_coop_rate < 0.3:
    # Hostile environment - pure defection
    DEFECT
```

**Exploitation Multiplier Adjustment:**

When `k` is closer to `n` (higher multiplication factor), cooperation becomes more valuable. Adjust thresholds:
```
adjustment = (k - 1) / (n - 1)  # ranges from 0 to 1
adjusted_high_threshold = 0.6 - (0.1 × adjustment)  # ranges 0.5-0.6
adjusted_low_threshold = 0.3 - (0.1 × adjustment)   # ranges 0.2-0.3
```

### Phase 3: Endgame (Final 2 rounds)

**Round r-1 (second-to-last):**
- If recent_coop_rate ≥ 0.7: **COOPERATE** (one last harvest setup)
- Otherwise: **DEFECT**

**Round r (final round):**
- **ALWAYS DEFECT** - No future punishment possible; defection is strictly dominant.

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | Dominant strategy, establishes baseline |
| Last round | DEFECT | No retaliation possible |
| n = 2 (two players) | Use stricter thresholds (+0.15 to all) | Single opponent's behavior more predictable |
| All opponents defected last round | DEFECT | No exploitation opportunity |
| All opponents cooperated last round | DEFECT once, then COOPERATE | Maximum extraction while sustaining |
| k very close to n | Lower cooperation thresholds | Higher social returns make cooperation more viable |
| k very close to 1 | Raise cooperation thresholds | Low returns make cooperation costly |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == r:
        return DEFECT  # Endgame
    
    if round == 1:
        return DEFECT  # Probe
    
    if round == 2:
        return COOPERATE if coop_rate(round=1) >= 0.5 else DEFECT
    
    if round == r - 1:
        return COOPERATE if recent_coop_rate() >= 0.7 else DEFECT
    
    # Main exploitation phase
    rate = recent_coop_rate(last_2_rounds)
    trend = calculate_trend()
    thresholds = adjust_thresholds(k, n)
    
    if rate >= thresholds.high:
        return COOPERATE if my_consecutive_defections >= 2 else DEFECT
    elif rate >= thresholds.low:
        if trend > 0: return COOPERATE
        if trend < 0: return DEFECT
        return random_choice(p_cooperate = (rate - thresholds.low) / 0.3)
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Farms cooperators**: Maintains just enough cooperation to keep cooperative opponents contributing, while extracting surplus through strategic defection.

2. **Never suckers**: Defects against defector-heavy populations immediately.

3. **Endgame extraction**: Guarantees final-round defection and likely second-to-last defection.

4. **Asymmetric reciprocity**: Cooperates reluctantly (to sustain exploitation) but defects eagerly (to extract value).

5. **Adaptive to game parameters**: Adjusts aggression based on `k/n` ratio—more cooperative when public good multiplier is favorable.
'''

description_EXPLOITATIVE_45 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but we can extract even more value by strategically cooperating just enough to keep cooperative opponents contributing, then defecting at optimal moments.

## Decision Rules

### Round Classification

Divide the game into three phases:
- **Early Phase**: Rounds 1 to ⌊r/3⌋
- **Middle Phase**: Rounds ⌊r/3⌋+1 to ⌊2r/3⌋
- **End Phase**: Rounds ⌊2r/3⌋+1 to r

### Tracking Metrics

For each round, track:
- `coop_rate` = (number of cooperators) / n from previous round
- `trend` = change in cooperation rate over last 3 rounds
- `my_coop_count` = how many times I've cooperated

### Decision Algorithm

```
ROUND 1:
    DEFECT
    (Rationale: Probe the environment; cooperating first gives away value 
    with no guaranteed return)

LAST ROUND (round r):
    DEFECT
    (Rationale: No future rounds to punish defection; pure Nash equilibrium)

SECOND-TO-LAST ROUND (round r-1):
    DEFECT
    (Rationale: Sophisticated opponents will defect in round r regardless,
    so backward induction begins here)

ALL OTHER ROUNDS:
    Calculate exploitation_score:
    
    IF coop_rate >= 0.6:
        # Rich environment to exploit
        IF I defected last round AND coop_rate stayed high:
            DEFECT (they're suckers, keep exploiting)
        ELSE IF trend is declining:
            COOPERATE (invest to restore the commons)
        ELSE:
            DEFECT with probability 0.7, COOPERATE with probability 0.3
            (Mostly exploit, occasionally invest to sustain cooperation)
    
    ELSE IF coop_rate >= 0.3:
        # Moderate environment - conditional cooperation
        IF trend is positive (cooperation increasing):
            COOPERATE (reward and encourage the trend)
        ELSE IF trend is negative:
            DEFECT (abandon ship)
        ELSE (stable):
            Mirror majority action from last round
    
    ELSE (coop_rate < 0.3):
        # Hostile environment - mostly defectors
        DEFECT
        (Rationale: Can't sustain cooperation; minimize losses)
```

### End-Phase Adjustment

Once in End Phase (final third of game):
```
Multiply DEFECT probability by 1.5 (capped at 1.0)
(Rationale: Less future to protect; extract remaining value)
```

### Anti-Coordination Defense

If I detect that cooperation rate correlates negatively with my own actions over the last 5 rounds (others are specifically punishing ME):
```
Switch to pure DEFECT for 3 rounds, then reassess
(Rationale: Don't feed into punishment cycles; let it reset)
```

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | Defect both rounds | Too short for reputation building |
| n = 2 (minimum players) | Tit-for-Tat with defect bias | Special case: essentially prisoner's dilemma |
| k very close to n | Slightly more cooperative | Higher returns justify small investment |
| k very close to 1 | Heavily defect-biased | Cooperation barely pays |
| All opponents always cooperate | Always defect | Maximum exploitation |
| All opponents always defect | Always defect | No point cooperating alone |

## Summary of Exploitative Principles

1. **Never cooperate first** — let others reveal themselves
2. **Free-ride on high cooperation** — defect when others cooperate heavily
3. **Invest minimally to sustain the commons** — occasional cooperation keeps suckers contributing
4. **Abandon lost causes** — defect in hostile environments
5. **Endgame extraction** — defect increasingly as the game ends
6. **Never be the sucker** — if exploited, switch to pure defection

This strategy is designed to **outperform both pure cooperators (by exploiting them) and pure defectors (by occasionally harvesting cooperative environments they can't access)**.
'''

description_EXPLOITATIVE_44 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation index" for the group that determines behavior.

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: Gather information while taking the dominant action. If others cooperate, I benefit maximally. If others defect, I don't lose anything.

**Round 2: DEFECT**
- Rationale: Continue observation. Two rounds of data reveal whether cooperators persist or are one-shot cooperators.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **Cooperation Rate (CR)** from all previous rounds:
```
CR = (total C plays by all other players) / ((n-1) × rounds_played)
```

**Decision Rule:**
- If CR ≥ 0.5: **DEFECT** (exploit the cooperators - this is the goldmine)
- If 0.2 ≤ CR < 0.5: **Conditional Cooperation**
  - Cooperate with probability p = (CR - 0.2) / 0.3
  - This "baits" borderline groups back toward cooperation so I can exploit later
- If CR < 0.2: **DEFECT** (group is mostly defectors, no point cooperating)

**Adaptive Adjustment - Trend Detection:**
```
recent_CR = cooperation rate in last 2 rounds
historical_CR = cooperation rate before last 2 rounds

If recent_CR > historical_CR + 0.15:
    # Cooperation is rising - defect harder to exploit
    Always DEFECT regardless of CR threshold

If recent_CR < historical_CR - 0.15:
    # Cooperation is collapsing - abandon any cooperation attempts
    Always DEFECT
```

### Phase 3: Endgame (Last 2 rounds: r-1 and r)

**Rounds r-1 and r: DEFECT**
- Rationale: No future rounds mean no possibility of retaliation or relationship-building. Pure dominant strategy play.

---

## Edge Cases

### Small n (n = 2):
- This becomes essentially a prisoner's dilemma
- Use simpler rule: DEFECT always except occasionally cooperate (20% chance) in middle rounds if opponent cooperated in previous round, to keep them cooperating

### Large n (n > 10):
- Individual cooperation is nearly invisible
- DEFECT always - my single cooperation has minimal impact on group outcome

### High k (k close to n):
- Cooperation becomes more attractive
- Raise the exploitation threshold: only defect if CR ≥ 0.6

### Short games (r ≤ 4):
- Probe phase: Round 1 only (DEFECT)
- Exploitation phase: Rounds 2 to r-1 (follow CR rules)
- Endgame: Round r only (DEFECT)

### Very short games (r ≤ 2):
- DEFECT every round (no time for exploitation strategy)

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Very short game
    if r <= 2:
        return DEFECT
    
    # Endgame
    if round >= r - 1:
        return DEFECT
    
    # Probe phase
    if round <= 2:
        return DEFECT
    
    # Calculate cooperation metrics
    CR = count_others_cooperations(history) / ((n-1) * (round-1))
    
    # Large group adjustment
    if n > 10:
        return DEFECT
    
    # Trend detection
    if round > 4:
        recent_CR = cooperation_rate_last_2_rounds(history)
        historical_CR = cooperation_rate_before_last_2(history)
        
        if abs(recent_CR - historical_CR) > 0.15:
            return DEFECT  # Exploit rising cooperation or abandon falling
    
    # Main exploitation logic
    threshold = 0.5 + (k - 1) / (n - 1) * 0.1  # Adjust for k
    
    if CR >= threshold:
        return DEFECT  # Exploit cooperators
    elif CR >= 0.2:
        p = (CR - 0.2) / (threshold - 0.2)
        return COOPERATE with probability p * 0.5  # Occasional bait
    else:
        return DEFECT  # Group is hopeless
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Always lets others bear the cost of establishing cooperation
2. **Free-rides on cooperators** - Defects precisely when cooperation is high
3. **Baits conditionally** - Only cooperates enough to keep victims cooperating
4. **Endgame betrayal** - Guaranteed defection when retaliation is impossible
5. **Trend exploitation** - Detects and exploits rising cooperation before others adapt
'''

description_EXPLOITATIVE_46 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous adaptation based on observed cooperation rates.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Purpose:** Gather information about opponent tendencies while minimizing risk.

**Round 1 Decision:** **DEFECT**
- Rationale: No information available; defection is the dominant single-round strategy and protects against exploitation.

**Rounds 2 to ⌈r/5⌉:**
- Calculate `coop_rate` = (total cooperations observed) / ((n-1) × rounds_played)
- **DEFECT** in all probing rounds
- Rationale: Free-ride on any cooperators while building a behavioral profile

---

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-2)

**Purpose:** Maximize extraction from cooperative populations; defect against defectors.

Calculate after each round:
- `recent_coop_rate` = cooperation rate in last 3 rounds (excluding self)
- `trend` = recent_coop_rate - overall_coop_rate (detecting if cooperation is rising/falling)

**Decision Logic:**

```
IF recent_coop_rate >= 0.6 THEN:
    # High cooperation environment - pure exploitation
    DEFECT (free-ride on cooperators)
    
ELSE IF recent_coop_rate >= 0.35 THEN:
    # Moderate cooperation - conditional cooperation to sustain the pool
    IF trend < -0.1 THEN:
        # Cooperation collapsing - defect before it's gone
        DEFECT
    ELSE:
        # Occasionally cooperate to prevent total collapse (1 in 3 rounds)
        COOPERATE if (round_number mod 3 == 0), else DEFECT
        
ELSE IF recent_coop_rate >= 0.15 THEN:
    # Low cooperation - try to revive it for future exploitation
    IF remaining_rounds > r/3 THEN:
        COOPERATE (investment in future exploitation)
    ELSE:
        DEFECT (not enough time to rebuild)
        
ELSE:
    # Near-universal defection - no point cooperating
    DEFECT
```

---

### Phase 3: Endgame (Last 2 rounds)

**Purpose:** Extract maximum value with no future consequences.

**Second-to-last round:** **DEFECT**
- Unless recent_coop_rate > 0.7 AND the population has shown "forgiving" behavior (cooperation rebounds after defection), in which case **COOPERATE** to set up final extraction

**Final round:** **ALWAYS DEFECT**
- No future rounds means no retaliation possible; pure dominant strategy

---

## Adaptive Mechanisms

### Detecting Exploitable "Nice" Strategies
Track per-opponent cooperation rates (if distinguishable) or population-level patterns:
- If cooperation persists despite defections → **increase defection frequency**
- If a "tit-for-tat" pattern emerges (cooperation drops after defection) → **occasional cooperation to reset**

### Detecting Retaliatory Environments
- If own defection in round t correlates with cooperation drop in round t+1 → environment is conditionally cooperative
- Response: Cooperate just enough to maintain cooperation pool (roughly 1 in 4 rounds)

### Parameter Sensitivity
- **Higher k (closer to n):** Cooperation is more valuable; lean slightly more cooperative in Phase 2
- **Lower k (closer to 1):** Defection is heavily dominant; be more aggressive in exploitation
- **More players (higher n):** Individual defection is less noticeable; defect more freely
- **More rounds (higher r):** Invest more in Phase 1 probing and Phase 2 pool maintenance

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    if round == r:
        return DEFECT
    
    if round <= ceil(r/5):
        return DEFECT  # Probing phase
    
    recent_coop = get_cooperation_rate(history, last=3)
    overall_coop = get_cooperation_rate(history, last=all)
    trend = recent_coop - overall_coop
    remaining = r - round
    
    if round >= r - 1:
        return DEFECT  # Endgame
    
    if recent_coop >= 0.6:
        return DEFECT  # Exploit high cooperation
    else if recent_coop >= 0.35:
        if trend < -0.1:
            return DEFECT
        else:
            return COOPERATE if round % 3 == 0 else DEFECT
    else if recent_coop >= 0.15:
        return COOPERATE if remaining > r/3 else DEFECT
    else:
        return DEFECT  # Environment is hostile
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Always defects in round 1 to avoid being exploited
2. **Free-rides on cooperators** - When others cooperate, we take the public good without contributing
3. **Abandons cooperation when unprofitable** - No "nice guy" persistence
4. **Endgame defection** - Always extracts maximum in final rounds
5. **Strategic cooperation is investment, not altruism** - Only cooperates to sustain an exploitable population
'''

description_EXPLOITATIVE_45 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors gain more than cooperators when cooperation exists. The goal is to **free-ride on cooperative populations while avoiding mutual defection spirals** that hurt everyone. We want to be the defector in a world of cooperators, not a defector among defectors.

## Strategy Overview

The strategy operates in three phases and continuously estimates the "exploitability" of the opponent population based on observed cooperation rates.

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1-3)

**Purpose:** Gather information about opponent tendencies with minimal cost.

- **Round 1:** DEFECT
  - Rationale: Never contribute first. Observe baseline cooperation without risking anything.
  
- **Round 2:** DEFECT
  - Rationale: Continue gathering data. If others cooperated in round 1, they may be unconditional cooperators (exploitable). If they defected, we lost nothing.

- **Round 3:** Conditional
  - If cooperation rate in rounds 1-2 was ≥ 50%: COOPERATE (signal potential reciprocity)
  - Otherwise: DEFECT

### Phase 2: Exploitation Phase (Rounds 4 through r-2)

**Purpose:** Maximize extraction based on learned opponent behavior.

Calculate **Cooperation Index (CI)** = (total cooperations by others) / (total possible cooperations by others)

**Decision Rule:**

```
if CI ≥ 0.6:
    # Population is highly cooperative - EXPLOIT
    DEFECT
    
elif CI ≥ 0.4:
    # Population is conditionally cooperative - PARTIAL EXPLOITATION
    # Cooperate just enough to keep them cooperating
    if my_cooperation_rate_last_3_rounds < 0.33:
        COOPERATE  # Occasional cooperation to maintain their hope
    else:
        DEFECT
        
elif CI ≥ 0.2:
    # Population is wary - TENTATIVE ENGAGEMENT
    # Mirror their behavior with slight defection bias
    if majority_cooperated_last_round:
        COOPERATE with probability 0.4
        DEFECT with probability 0.6
    else:
        DEFECT

else:
    # Population is mostly defectors - NO POINT CONTRIBUTING
    DEFECT
```

**Punishment Detection & Response:**

Track if cooperation rate drops significantly after I defect:
```
if CI_last_3_rounds < CI_overall - 0.2:
    # Others may be punishing me
    if CI_overall > 0.3:
        # Worth trying to restore cooperation (to exploit later)
        COOPERATE for next 2 rounds, then reassess
    else:
        # Not enough cooperators to bother
        DEFECT
```

### Phase 3: Endgame (Last 2 rounds: r-1 and r)

**Purpose:** Maximum extraction when future retaliation is impossible.

- **Round r-1:** DEFECT (almost no future consequence)
- **Round r:** DEFECT (absolutely no future consequence)

**No exceptions.** Cooperation in final rounds is pure charity with zero strategic value.

---

## Edge Cases

1. **n = 2 (two players):** 
   - More aggressive defection since single opponent's cooperation has limited value
   - Only cooperate if opponent shows >70% cooperation rate AND we're not in endgame

2. **Very short games (r ≤ 5):**
   - Skip extended probing; compress to: DEFECT, DEFECT, then evaluate, then DEFECT, DEFECT
   
3. **Large n (many players):**
   - Individual defection is less noticeable; bias toward defection increases
   - Cooperation threshold CI increases to 0.7 for exploitation mode

4. **k very close to n:**
   - Public good is more valuable; slightly more willing to cooperate to maintain group cooperation
   - But still defect if CI > 0.5 (free-riding still profitable)

5. **k very close to 1:**
   - Public good barely worth it; strong defection bias regardless of others' behavior

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round <= 2:
        return DEFECT
    
    if round == 3:
        return COOPERATE if cooperation_rate(history) >= 0.5 else DEFECT
    
    if round >= r - 1:
        return DEFECT  # Endgame
    
    CI = cooperation_index(history, exclude_self=True)
    
    if CI >= 0.6:
        return DEFECT  # Exploit cooperators
    elif CI >= 0.4:
        return COOPERATE if my_recent_coop_rate(history, 3) < 0.33 else DEFECT
    elif CI >= 0.2:
        return DEFECT if not majority_cooperated_last_round(history) else random(0.4)
    else:
        return DEFECT  # Nothing to exploit
```

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Always lets others pay the cost first
2. **Free-rides on cooperators** - Defects precisely when cooperation is high
3. **Minimal contribution** - Only cooperates enough to prevent complete collapse (which would hurt our exploitation)
4. **Endgame betrayal** - Guaranteed defection when punishment is impossible
5. **Asymmetric reciprocity** - Demands high cooperation from others while providing minimal return
'''

description_EXPLOITATIVE_47 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**, adapting behavior based on observed population dynamics.

## Strategy Overview

The strategy operates in three phases and continuously estimates the "exploitability" of the population based on observed cooperation rates. It cooperates only when doing so is likely to sustain a cooperative environment worth exploiting, and defects aggressively when free-riding is profitable or when the endgame approaches.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** DEFECT
- Rationale: Observe others' baseline behavior without contributing. If others cooperate, you profit maximally. If they defect, you lose nothing compared to cooperating.

**Round 2:** DEFECT
- Rationale: Confirm Round 1 patterns. Early cooperation signals weakness and invites exploitation.

### Phase 2: Adaptive Exploitation (Rounds 3 to r-2)

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / n
```

**Decision Rule:**

```
IF coop_rate >= (n - 1) / n:
    # Nearly everyone cooperated - this is a golden goose
    # Cooperate to sustain it, but prepare to defect
    IF random() < 0.7:
        COOPERATE
    ELSE:
        DEFECT  # Occasional exploitation test

ELSE IF coop_rate >= 0.5:
    # Moderate cooperation - exploit aggressively
    # Only cooperate if defection would collapse the system
    IF my_last_action == DEFECT AND coop_rate_dropped_significantly:
        COOPERATE  # Minimal contribution to keep others cooperating
    ELSE:
        DEFECT

ELSE IF coop_rate > 0:
    # Low cooperation - pure exploitation
    DEFECT  # Free-ride on remaining cooperators

ELSE:
    # No cooperators - defection is dominant
    DEFECT
```

**Significant drop detection:**
```
coop_rate_dropped_significantly = (previous_coop_rate - current_coop_rate) > 0.2
```

### Phase 3: Endgame Defection (Final 2 rounds)

**Rounds r-1 and r:** ALWAYS DEFECT
- Rationale: No future rounds to incentivize cooperation. Backward induction makes defection strictly dominant. Any sophisticated opponent will also defect, so cooperation is pure loss.

---

## Detailed Pseudocode

```
function decide(round, history, n, k, r):
    
    # Endgame: Always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase: Always defect
    if round <= 2:
        return DEFECT
    
    # Calculate metrics
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate = last_round_coops / n
    
    # Track if I defected and cooperation collapsed
    if round >= 3:
        prev_coop_rate = count_cooperators(history, round - 2) / n
        my_last_action = get_my_action(history, round - 1)
        coop_dropped = (prev_coop_rate - coop_rate) > 0.2
    
    # High cooperation environment
    if coop_rate >= (n - 1) / n:
        # Sustain with probabilistic defection
        if random() < 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # Moderate cooperation
    if coop_rate >= 0.5:
        # Only cooperate if my defection caused collapse
        if my_last_action == DEFECT and coop_dropped:
            return COOPERATE
        else:
            return DEFECT
    
    # Low or no cooperation
    return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | No information; defection dominates |
| Last round | DEFECT | No future; pure exploitation |
| n = 2 | Follow rules but bias toward DEFECT | Prisoner's dilemma dynamics; harder to sustain cooperation |
| All others always cooperate | Mix 70% C / 30% D | Sustain the gravy train while skimming |
| All others always defect | DEFECT | No value to create; minimize losses |
| Erratic opponents | DEFECT | Unpredictability favors safe play |
| k very close to n | Slightly more cooperative | Higher returns to cooperation |
| k close to 1 | More aggressive defection | Lower returns make cooperation wasteful |

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Lets others take the risk of contributing
2. **Free-rides on cooperators** - Extracts value created by others
3. **Sustains exploitation, not cooperation** - Only cooperates enough to keep victims cooperating
4. **Endgame betrayal** - Guaranteed defection when punishment is impossible
5. **Asymmetric response** - Punishes cooperation collapse but doesn't reward cooperation reciprocally

This strategy treats cooperation as a tool for manipulation, not as a shared value.
'''

description_EXPLOITATIVE_46 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but cooperative opponents can be exploited by conditionally cooperating just enough to keep them contributing.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the group that determines behavior.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Round 1:** Always **DEFECT**
- Rationale: Gather information about opponent tendencies while securing guaranteed payoff. Cooperating round 1 gives away information and value with no reciprocity guarantee.

**Rounds 2-3:** **DEFECT**
- Continue observing opponent behavior patterns
- Build a baseline cooperation rate for the group

### Phase 2: Exploitation Phase (Rounds 4 through r-2)

Calculate the **Group Cooperation Rate (GCR)** = (total C plays by others in last 3 rounds) / (3 × (n-1))

**Decision Rule:**

```
IF GCR ≥ 0.6:
    # High cooperation environment - exploit aggressively
    DEFECT (free-ride on cooperators)
    
ELSE IF GCR ≥ 0.3:
    # Medium cooperation - conditional exploitation
    IF (my defections in last 3 rounds) ≥ 2:
        COOPERATE  # Token cooperation to maintain group contributions
    ELSE:
        DEFECT
        
ELSE IF GCR > 0:
    # Low cooperation - probe for exploitable players
    DEFECT with 80% probability
    COOPERATE with 20% probability (to test if cooperation can be revived)
    
ELSE (GCR = 0):
    # All defection environment - no point cooperating
    DEFECT
```

### Phase 3: Endgame (Final 2 rounds)

**Round r-1 and Round r:** Always **DEFECT**
- Rationale: No future rounds to incentivize opponents to punish defection. Pure exploitation window.

---

## Adaptive Mechanisms

### Trend Detection
Track whether GCR is **increasing, stable, or decreasing** over the last 3 rounds:
- If **increasing**: Maintain current exploitation level (opponents haven't caught on)
- If **decreasing**: Slightly increase cooperation probability by 10% to prevent total collapse
- If **collapsed to near-zero**: Accept mutual defection equilibrium

### Individual Tracking (if n ≤ 10)
Maintain cooperation counts per opponent. If identifiable patterns emerge:
- **Unconditional cooperators** (>80% C rate): Never cooperate—pure exploitation target
- **Tit-for-tat types** (mirror group behavior): Cooperate just enough to keep them cooperating
- **Unconditional defectors**: Ignore in calculations; they're not exploitable

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase - always defect
    if round <= 3:
        return DEFECT
    
    # Calculate group cooperation rate (last 3 rounds)
    others_cooperations = count_others_C(history, last=3)
    GCR = others_cooperations / (3 * (n - 1))
    
    my_recent_defections = count_my_D(history, last=3)
    
    # Exploitation phase
    if GCR >= 0.6:
        return DEFECT  # Free-ride on high cooperation
    
    else if GCR >= 0.3:
        if my_recent_defections >= 2:
            return COOPERATE  # Maintain exploitation potential
        else:
            return DEFECT
    
    else if GCR > 0:
        return DEFECT with probability 0.8, else COOPERATE
    
    else:
        return DEFECT  # Mutual defection equilibrium
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Avoids being a sucker
2. **Defects in information-gathering and endgame phases** - Maximizes guaranteed value
3. **Only cooperates strategically** - Token cooperation to sustain exploitable opponents, never out of "fairness"
4. **Adapts to opponent weakness** - More cooperation in the group = more aggressive defection
5. **Robust to defector-heavy environments** - Converges to mutual defection without significant losses
'''

description_EXPLOITATIVE_48 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative players while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always the dominant action in a single round—but repeated play allows us to identify and exploit patterns in others' behavior.

## Strategy Overview

The strategy operates in three phases:
1. **Probe Phase**: Gather information about opponent tendencies
2. **Exploit Phase**: Maximize extraction from cooperative environments
3. **Endgame Phase**: Defect unconditionally as the game concludes

---

## Detailed Decision Rules

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1: Defect**
- Rationale: Defection is risk-free information gathering. We observe the baseline cooperation level without sacrificing any payoff. If others cooperate, we gain maximally; if they defect, we lose nothing.

**Round 2: Conditional**
- If cooperation rate in Round 1 was ≥ 50%: **Cooperate** (to test if cooperation is sustainable and potentially trigger reciprocity)
- If cooperation rate in Round 1 was < 50%: **Defect** (environment is already defection-heavy)

### Phase 2: Exploit Phase (Rounds 3 to r-2)

Calculate a **Cooperation Score** after each round:

```
cooperation_rate = (number of cooperators in previous round) / n
trend = cooperation_rate(t-1) - cooperation_rate(t-2)  // positive = increasing cooperation
```

**Decision Rule:**

```
IF cooperation_rate > threshold AND my_defection_wouldn't_crash_cooperation:
    DEFECT  // Free-ride on cooperative environment
    
ELIF cooperation_rate is moderate (between 0.3 and 0.6) AND trend > 0:
    COOPERATE  // Invest to build cooperation we can later exploit
    
ELIF cooperation_rate < 0.3:
    DEFECT  // Environment too hostile, protect yourself
    
ELSE:
    Use PROBABILISTIC COOPERATION based on:
    p(cooperate) = max(0, cooperation_rate - 0.2)  // Cooperate slightly less than the population
```

**Threshold Calibration:**
- `threshold = k / n + 0.1`
- This ensures we defect when there's enough cooperation to make free-riding profitable

**Anti-Crash Safeguard:**
- Track if cooperation drops significantly after our defections
- If we detect we're a "swing player" whose defection causes cascading defection, occasionally cooperate to rebuild the pool

### Phase 3: Endgame Phase (Final 2 rounds, or final round if r ≤ 3)

**Always Defect**
- Rationale: No future rounds exist to punish defection. Backward induction makes defection strictly dominant.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    // Endgame: unconditional defection
    if round > r - 2:
        return DEFECT
    
    // Round 1: probe with defection
    if round == 1:
        return DEFECT
    
    // Round 2: conditional probe
    if round == 2:
        coop_rate = count_cooperators(history, round-1) / n
        if coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    // Exploit phase (rounds 3 to r-2)
    coop_rate = count_cooperators(history, round-1) / n
    prev_coop_rate = count_cooperators(history, round-2) / n
    trend = coop_rate - prev_coop_rate
    threshold = (k / n) + 0.1
    
    // High cooperation: free-ride
    if coop_rate > threshold:
        return DEFECT
    
    // Building cooperation: invest
    if 0.3 <= coop_rate <= 0.6 and trend > 0:
        return COOPERATE
    
    // Low cooperation: protect
    if coop_rate < 0.3:
        return DEFECT
    
    // Moderate/unclear: probabilistic (slightly under-cooperate)
    p = max(0, coop_rate - 0.2)
    return COOPERATE with probability p, else DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| r = 2 (minimum rounds) | Defect both rounds | Pure endgame logic |
| r = 3 | D, then endgame defection | One probe round, then exploit |
| n = 2 (minimum players) | More aggressive defection | Single opponent is easier to read |
| k close to n | Slightly more cooperation | Higher returns justify occasional investment |
| k close to 1 | Heavy defection | Returns too low to justify cooperation |
| All opponents always defect | Always defect | No suckers to exploit |
| All opponents always cooperate | Always defect | Maximum exploitation |

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Every cooperation decision is calculated to generate future exploitation opportunities
2. **Free-rides on cooperative environments** - When others cooperate, we take the surplus
3. **Defects first** - Establishes a baseline without personal sacrifice
4. **Endgame defection** - Extracts maximum value when punishment is impossible
5. **Under-cooperates the population** - Always aims to contribute less than average while benefiting from others' contributions
'''

description_EXPLOITATIVE_47 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that cooperation is only valuable if others cooperate. Since k < n, defection always yields higher personal payoff than cooperation *given the same actions by others*. The exploitative approach is to:

1. **Extract information** about opponent tendencies early
2. **Free-ride** on cooperative populations
3. **Defect preemptively** against defectors
4. **Exploit predictable patterns** in opponent behavior

---

## Strategy Specification

### Key Variables to Track

```
- round_number: current round (1 to r)
- cooperation_rate[t]: fraction of opponents who cooperated in round t
- total_coop_history: cumulative cooperation count across all rounds
- recent_trend: cooperation rate in last 3 rounds vs previous 3
```

### Decision Rules

#### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** DEFECT
- Rationale: Gain information without risk. If others cooperate, I profit maximally. If others defect, I don't lose anything.

**Round 2:** DEFECT
- Rationale: Continue gathering information. Two rounds of data reveals whether opponents are unconditional cooperators, tit-for-tat variants, or defectors.

#### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate `coop_rate` = (total opponent cooperations) / (total opponent decisions so far)

```
IF coop_rate >= 0.6:
    # Population is cooperative - EXPLOIT by defecting
    DEFECT
    
ELIF coop_rate >= 0.35:
    # Mixed population - conditional cooperation to maintain some cooperation
    IF recent_trend is INCREASING:
        # Others becoming more cooperative - defect to exploit
        DEFECT
    ELIF recent_trend is DECREASING:
        # Cooperation collapsing - cooperate occasionally to prop it up
        COOPERATE with probability 0.3
        DEFECT with probability 0.7
    ELSE:
        # Stable mixed - defect mostly but occasionally cooperate
        DEFECT
        
ELSE (coop_rate < 0.35):
    # Population is defecting - no point cooperating
    DEFECT
```

#### Phase 3: Endgame (Rounds r-1 and r)

**Round r-1:** DEFECT
- Rationale: Approaching end, opponents may start defecting. Get ahead of the collapse.

**Round r (Final Round):** DEFECT
- Rationale: No future consequences. Defection strictly dominates.

---

### Edge Case Handling

1. **Very short games (r ≤ 4):** Always DEFECT every round. Not enough time for cooperation to pay off.

2. **Two-player games (n = 2):** More aggressive defection since my defection has larger impact on discouraging opponent cooperation. Always DEFECT.

3. **High k values (k close to n):** Still defect - the logic holds regardless of k as long as k < n.

4. **All opponents defected so far:** Continue DEFECT. No value in unilateral cooperation.

5. **All opponents cooperated so far:** DEFECT aggressively - this is the ideal exploitation scenario.

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Edge cases
    if r <= 4 or n == 2:
        return DEFECT
    
    # Endgame
    if round >= r - 1:
        return DEFECT
    
    # Probing phase
    if round <= 2:
        return DEFECT
    
    # Calculate metrics
    coop_rate = sum(opponent_cooperations) / sum(opponent_decisions)
    recent = avg_coop_rate(last 3 rounds)
    previous = avg_coop_rate(rounds before last 3)
    trend = recent - previous
    
    # Exploitation phase
    if coop_rate >= 0.6:
        return DEFECT  # Exploit cooperators
    elif coop_rate >= 0.35:
        if trend > 0.1:
            return DEFECT  # Exploit rising cooperation
        elif trend < -0.1:
            return COOPERATE with prob 0.3, else DEFECT
        else:
            return DEFECT
    else:
        return DEFECT  # No suckers to exploit
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - avoids being exploited
2. **Free-rides on cooperators** - maximizes gain from others' contributions
3. **Defects in endgame** - captures guaranteed gains when future doesn't matter
4. **Minimal cooperation** - only cooperates strategically to prevent total collapse when beneficial
5. **Adapts to exploit patterns** - increases defection when detecting cooperative opponents
'''

description_EXPLOITATIVE_49 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but sustained cooperation by others is highly profitable to exploit. My goal is to:

1. Identify and exploit cooperative populations
2. Defect strategically when others are likely to cooperate
3. Avoid costly mutual defection spirals when facing other defectors
4. Never be the "sucker" who cooperates alone

---

## Strategy Specification

### Key Variables Tracked

- `cooperation_rate`: Rolling average of other players' cooperation rate over recent rounds
- `round_number`: Current round (1-indexed)
- `total_rounds`: r (known)
- `trend`: Whether cooperation is increasing, stable, or decreasing
- `exploitation_window`: Rounds remaining where cooperation might be sustained

### Decision Rules

#### Round 1: Defect
**Rationale**: Never cooperate without information. Let others reveal their strategies first. This avoids being exploited early and gathers intelligence.

#### Rounds 2 through (r-2): Adaptive Exploitation

```
Calculate: cooperation_rate = (total cooperations by others) / (total opportunities)
Calculate: last_round_coop_rate = cooperators in last round / (n-1)

IF last_round_coop_rate >= 0.6 THEN:
    # Many cooperators - EXPLOIT THEM
    DEFECT
    
ELSE IF last_round_coop_rate >= 0.4 THEN:
    # Moderate cooperation - probe with occasional cooperation
    # to prevent total collapse (preserving future exploitation)
    IF cooperation_rate is DECLINING rapidly THEN:
        COOPERATE with probability 0.3
    ELSE:
        DEFECT

ELSE IF last_round_coop_rate < 0.4 THEN:
    # Low cooperation environment
    IF cooperation_rate has been < 0.3 for 3+ consecutive rounds THEN:
        # Dead environment - occasional probe for recovery
        COOPERATE with probability 0.15
    ELSE:
        DEFECT
```

#### Round (r-1): Second-to-Last Round
```
IF last_round_coop_rate >= 0.5 THEN:
    DEFECT  # Exploit remaining cooperators
ELSE:
    DEFECT  # No point cooperating
```

#### Round r (Final Round): Always Defect
**Rationale**: No future consequences. Pure dominant strategy applies.

---

## Exploitation Mechanics

### Why This Works

1. **Free-riding on cooperators**: When cooperation rate is high (≥60%), I defect to get both my private endowment AND a share of the public good others create.

2. **Preventing total collapse**: Occasional cooperation when rates are moderate prevents the environment from becoming worthless. This is "farming" - keeping some cooperation alive to exploit.

3. **Endgame extraction**: Final rounds are pure defection since no one can retaliate.

4. **Information asymmetry**: By defecting early, I learn others' strategies while revealing nothing about conditional cooperation.

### Probability Calibration

The cooperation probabilities (0.3 and 0.15) are deliberately low because:
- I'm not trying to build mutual cooperation
- I'm trying to slow the decay of cooperation *just enough* to continue exploiting
- Higher values would sacrifice too much to help others

---

## Pseudocode Summary

```python
def decide(round, total_rounds, history, n, k):
    if round == 1:
        return DEFECT
    
    if round == total_rounds:
        return DEFECT
    
    others_last_round = count_cooperators_last_round(history)
    coop_rate = others_last_round / (n - 1)
    overall_coop_rate = total_cooperations(history) / total_opportunities(history)
    
    if round == total_rounds - 1:
        return DEFECT
    
    if coop_rate >= 0.6:
        return DEFECT  # Exploit high cooperation
    
    if coop_rate >= 0.4:
        if is_declining(history):
            return COOPERATE if random() < 0.3 else DEFECT
        return DEFECT
    
    # coop_rate < 0.4
    if consecutive_low_rounds(history) >= 3:
        return COOPERATE if random() < 0.15 else DEFECT
    
    return DEFECT
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | Defect | No information; gather intel |
| Final round | Defect | Dominant strategy, no retaliation possible |
| All others always defect | Mostly defect (85%) | Occasional probe to check for strategy changes |
| All others always cooperate | Always defect | Maximum exploitation opportunity |
| n=2 (minimum) | Same logic applies | Thresholds still meaningful |
| Very short game (r=2) | Defect both rounds | No time for complex adaptation |

This strategy is designed to be a **parasite**: it thrives when others cooperate, survives when they don't, and never sacrifices itself for the group.
'''

description_EXPLOITATIVE_48 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but predictable cooperation by others creates exploitation opportunities. I will probe for exploitable cooperators, exploit them ruthlessly, and defect against defectors.

---

## Decision Rules

### Round 1: Probe with Defection
**Action: DEFECT**

Rationale: The first round is pure information gathering with no history to leverage. Defecting:
- Guarantees the baseline payoff of 1
- Reveals which opponents are unconditional cooperators (easy targets)
- Loses nothing against other defectors
- Any cooperators in round 1 give me free bonus payoff (k/n per cooperator)

---

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays by others in last round) / (n - 1)
```

Calculate the **exploitation threshold**:
```
exploit_threshold = n / k
```
This is the minimum number of cooperators needed for cooperation to break even for a cooperator.

**Decision Logic:**

```
IF coop_rate >= (exploit_threshold - 1) / (n - 1):
    # Enough cooperators exist that I could cooperate profitably
    # BUT exploiting them is even more profitable
    
    IF my_defection_in_last_round AND coop_rate stayed high:
        # They're suckers - keep exploiting
        ACTION: DEFECT
    
    ELSE IF coop_rate is declining over last 3 rounds:
        # Cooperation is collapsing - consider strategic cooperation
        # to "farm" cooperators back
        IF rounds_remaining > 3 AND decline_rate > 0.2:
            ACTION: COOPERATE (bait)
        ELSE:
            ACTION: DEFECT
    
    ELSE:
        # Stable high cooperation - continue exploitation
        ACTION: DEFECT

ELSE IF coop_rate > 0 AND coop_rate < (exploit_threshold - 1) / (n - 1):
    # Some cooperators but not enough to make cooperation worthwhile
    # Still profitable to defect and collect partial public good
    ACTION: DEFECT

ELSE (coop_rate == 0):
    # Everyone defected - no exploitation opportunity
    # Occasional cooperation probe to check if others are conditional
    IF round_number % 4 == 2 AND rounds_remaining > 2:
        ACTION: COOPERATE (probe)
    ELSE:
        ACTION: DEFECT
```

---

### Final Round (Round r): Always Defect
**Action: DEFECT**

Rationale: No future rounds exist to punish defection. This is the dominant strategy regardless of history. Any sophisticated opponent will also defect, so cooperation yields nothing but loss.

---

### Penultimate Round (Round r-1): Almost Always Defect
**Action: DEFECT** (unless cooperation rate has been >80% consistently)

Rationale: Backward induction suggests sophisticated players defect here anticipating final-round defection. Only maintain cooperation bait if facing clearly exploitable unconditional cooperators.

---

## Exploitation Mechanisms

### Mechanism 1: Sucker Detection
Track individual opponent patterns if identifiable:
- **Unconditional cooperators**: Always exploit (defect against them)
- **Tit-for-tat types**: Probe occasionally, mostly defect
- **Unconditional defectors**: Ignore (defect anyway)

### Mechanism 2: Cooperation Farming
If cooperation collapses and many rounds remain:
- Inject 1-2 cooperative moves to signal "I can cooperate"
- This may restart cooperation from conditional cooperators
- Immediately resume defection once cooperation rebounds

### Mechanism 3: Late-Game Extraction
```
IF rounds_remaining <= 3:
    ACTION: DEFECT (always)
```
The endgame has no future to protect. Extract everything.

---

## Pseudocode Summary

```python
def choose_action(round_num, total_rounds, history, n, k):
    
    # Final round - always defect
    if round_num == total_rounds:
        return DEFECT
    
    # First round - probe with defection
    if round_num == 1:
        return DEFECT
    
    # Calculate metrics
    last_round_coops = count_cooperators_last_round(history)
    coop_rate = last_round_coops / (n - 1)
    rounds_remaining = total_rounds - round_num
    
    # Late game - defect
    if rounds_remaining <= 2:
        return DEFECT
    
    # Main exploitation logic
    if coop_rate > 0.3:
        # Cooperators exist - exploit them
        return DEFECT
    
    elif coop_rate > 0:
        # Few cooperators - still defect to collect scraps
        return DEFECT
    
    else:
        # No cooperation - occasional probe
        if round_num % 4 == 2 and rounds_remaining > 3:
            return COOPERATE  # Probe
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates when it's costly**: Only cooperates as bait when there's expected future payoff
2. **Maximizes free-riding**: Collects public good benefits without contributing
3. **Targets the vulnerable**: Unconditional cooperators are identified and drained
4. **Endgame ruthlessness**: No sentimentality in final rounds
5. **Probing is cheap**: Occasional cooperation probes cost at most (1 - k/n) and yield information

This strategy treats cooperation purely as a tool for manipulation, not as an end in itself.
'''

description_EXPLOITATIVE_50 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**, adapting behavior based on observed population tendencies.

## Decision Framework

### Key Metrics Tracked

1. **Population Cooperation Rate (PCR)**: Rolling average of cooperation frequency across all opponents over recent rounds
2. **Individual Cooperation Profiles**: Per-opponent cooperation history when identifiable
3. **Trend Direction**: Whether cooperation is increasing, stable, or declining
4. **Round Position**: Early, middle, or endgame phase

### Round Classification

- **Early Phase**: Rounds 1 to ⌈r/4⌉
- **Middle Phase**: Rounds ⌈r/4⌉+1 to ⌈3r/4⌉
- **Endgame Phase**: Rounds ⌈3r/4⌉+1 to r

---

## Decision Rules

### Rule 1: First Round — DEFECT

**Rationale**: No information exists. Defection guarantees the base payoff of 1 and allows observation of opponent tendencies without risk. Any cooperators in round 1 reveal themselves as exploitable.

### Rule 2: Last Round — DEFECT

**Rationale**: No future rounds exist to punish defection. This is the dominant strategy regardless of history.

### Rule 3: Penultimate Round (r-1) — DEFECT

**Rationale**: Sophisticated opponents will defect in the last round, so there's no punishment threat. Backward induction suggests defection.

### Rule 4: Early Phase (Rounds 2 to ⌈r/4⌉) — Probe and Exploit

```
IF PCR from previous rounds > 0.6:
    DEFECT  (exploit the cooperators)
ELSE IF PCR < 0.3:
    DEFECT  (no value in cooperating with defectors)
ELSE:
    DEFECT  (gather more information, stay safe)
```

**Rationale**: Early rounds are for information gathering. Defection is always safe and reveals opponent types.

### Rule 5: Middle Phase — Conditional Exploitation

```
CALCULATE: expected_gain_from_cooperation = (k/n) × (expected_cooperators + 1) - 1
CALCULATE: expected_gain_from_defection = (k/n) × expected_cooperators

IF PCR > (n-1)/k:
    # High cooperation environment - exploit it
    DEFECT
    
ELSE IF PCR > 0.5 AND cooperation_trend is DECLINING:
    # Cooperators may be retaliating - offer occasional cooperation to reset
    IF random() < 0.2:
        COOPERATE
    ELSE:
        DEFECT
        
ELSE IF PCR < 0.3:
    # Low cooperation environment - defection dominant
    DEFECT
    
ELSE:
    # Medium cooperation - strategic defection with occasional cooperation bait
    IF rounds_since_last_cooperation > 3 AND PCR > 0.4:
        COOPERATE  (bait to keep cooperators engaged)
    ELSE:
        DEFECT
```

### Rule 6: Late Middle Phase — Gradual Withdrawal

```
rounds_remaining = r - current_round

IF rounds_remaining <= 5:
    # Begin systematic defection
    DEFECT
    
ELSE:
    # Apply middle phase rules with increased defection bias
    Apply Rule 5 with cooperation probability reduced by 50%
```

---

## Exploitation Mechanisms

### Mechanism A: Sucker Detection
Track which opponents consistently cooperate regardless of outcomes. These are "suckers" who provide free value. When suckers are present (>30% of population cooperates for 3+ consecutive rounds despite defectors), **always defect**.

### Mechanism B: Retaliation Dampening
If opponents appear to use tit-for-tat style strategies (cooperation drops after we defect), occasionally cooperate (≈20% chance) to:
- Prevent complete collapse of cooperation
- Keep some cooperators "hooked" and contributing
- Extract more total value over remaining rounds

### Mechanism C: Herd Following (Inverted)
When most players defect, defect (no point being the only sucker). When most players cooperate, defect (maximum exploitation opportunity).

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    # Edge cases
    if round == 1:
        return DEFECT
    if round >= r - 1:
        return DEFECT
    
    # Calculate metrics
    pcr = calculate_population_cooperation_rate(history)
    trend = calculate_trend(history, window=3)
    phase = get_phase(round, r)
    
    # Early phase: always defect to gather info
    if phase == EARLY:
        return DEFECT
    
    # High cooperation environment: exploit
    if pcr > 0.6:
        return DEFECT
    
    # Low cooperation environment: no point cooperating
    if pcr < 0.3:
        return DEFECT
    
    # Medium cooperation with declining trend: occasional bait
    if 0.3 <= pcr <= 0.6:
        if trend == DECLINING and random() < 0.15:
            return COOPERATE  # Bait to sustain some cooperation
        return DEFECT
    
    # Default: defect
    return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | DEFECT | No information, safe baseline |
| Round r (last) | DEFECT | No future punishment possible |
| Round r-1 | DEFECT | Backward induction |
| All opponents always defect | DEFECT | Cooperation is pure loss |
| All opponents always cooperate | DEFECT | Maximum exploitation |
| n=2 (two players) | DEFECT with rare cooperation bait | Keep opponent engaged |
| Very short game (r≤3) | Always DEFECT | No time for reputation building |
| k very close to n | Still DEFECT-heavy | Others' cooperation still benefits us more via defection |

---

## Why This Strategy is Exploitative

1. **Never cooperates first** — Lets others take the risk
2. **Exploits cooperators** — Defects when cooperation is high to maximize free-riding
3. **Abandons ship early** — Defects in endgame before others can retaliate
4. **Uses cooperation as bait** — Rare cooperation keeps cooperators engaged without giving up much value
5. **Adapts to environment** — Doesn't waste cooperation on defector-heavy populations

This strategy treats cooperation as a **tool for manipulation**, not a genuine contribution, making it fundamentally exploitative while remaining adaptive to opponent behavior.
'''

description_EXPLOITATIVE_49 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but exploiting patterns of cooperation in others can yield even higher returns than universal defection.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit cooperative players.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to min(3, r/4))

**Purpose:** Gather information about opponent tendencies with minimal cost.

**Rule:** 
- **Round 1:** DEFECT (never contribute when you have zero information—let others reveal themselves)
- **Rounds 2-3:** DEFECT if cooperation rate in previous round was < 50%, otherwise COOPERATE once to test if cooperation is sustained

**Rationale:** Starting with defection is dominant because you capture full benefit of any cooperators while risking nothing. Brief cooperation tests whether a cooperative equilibrium might be exploitable.

### Phase 2: Exploitation Phase (Middle rounds, until round r-2)

**Purpose:** Maximize extraction based on learned opponent behavior.

**Decision Algorithm:**

```
cooperation_rate = (total C plays by others) / (total plays by others)
trend = cooperation_rate_last_2_rounds - cooperation_rate_prior_rounds

IF cooperation_rate > 0.6 AND trend >= 0:
    # Rich environment - defect to free-ride on cooperators
    DEFECT
    
ELIF cooperation_rate > 0.4 AND trend > 0:
    # Cooperation building - contribute occasionally to sustain it
    # Cooperate with probability = 0.3 (just enough to not crash cooperation)
    COOPERATE with 30% probability, else DEFECT
    
ELIF cooperation_rate > 0.2:
    # Marginal environment - conditional cooperation to test sustainability
    # Mirror the proportion: if 40% cooperate, cooperate 20% of time (half-match)
    COOPERATE with probability = cooperation_rate / 2, else DEFECT
    
ELSE:
    # Hostile environment - pure defection
    DEFECT
```

**Opponent-Specific Tracking:**

```
FOR each player j:
    track: times_cooperated[j], times_defected[j]
    
    sucker_score[j] = times_cooperated[j] / total_rounds_observed
    
    # Identify "suckers" (unconditional cooperators) - these are goldmines
    IF sucker_score[j] > 0.7 over last 5 rounds:
        Mark player j as EXPLOITABLE
        
# If EXPLOITABLE players exist AND their count × k/n > 0.5:
    # Their contributions alone make defection profitable
    DEFECT regardless of other considerations
```

### Phase 3: Endgame (Final 2 rounds)

**Purpose:** Extract maximum value when future punishment is impossible.

**Rule:**
- **Round r-1:** DEFECT (anticipate others' endgame defection)
- **Round r:** DEFECT (no future interaction, pure dominant strategy)

---

## Edge Cases

### Very Short Games (r ≤ 4)
- **r = 2:** DEFECT both rounds (no time to build exploitable cooperation)
- **r = 3-4:** DEFECT all rounds (insufficient rounds for exploitation to outweigh probing costs)

### Small Groups (n = 2)
- Essentially iterated Prisoner's Dilemma
- Use straightforward Defect-heavy strategy: Start DEFECT, only cooperate if opponent cooperates consistently (3+ times in a row), immediately punish any defection with 2 rounds of defection

### Large Groups (n > 10)
- Individual contribution less noticeable
- Bias heavily toward defection (cooperation_rate thresholds increase by 0.1)
- Your single defection is unlikely to crash group cooperation

### High Multiplication Factor (k close to n)
- Cooperation becomes more attractive
- Lower the threshold for occasional cooperation to 0.5 instead of 0.6
- Still defect in endgame

### Parameter-Based Adjustment
```
exploitation_aggressiveness = (n - k) / (n - 1)
# Higher when k is low relative to n (defection more dominant)
# Multiply all cooperation probabilities by (1 - exploitation_aggressiveness)
```

---

## Summary Decision Tree

```
IF final 2 rounds:
    DEFECT
ELIF round 1:
    DEFECT
ELIF short game (r ≤ 4):
    DEFECT
ELIF exploitable players provide k/n × count > 0.5:
    DEFECT (free-ride on suckers)
ELIF cooperation_rate > 0.6:
    DEFECT (harvest the commons)
ELIF cooperation_rate > 0.4 AND rising:
    COOPERATE 30% / DEFECT 70%
ELIF cooperation_rate > 0.2:
    COOPERATE (cooperation_rate/2)% / DEFECT otherwise
ELSE:
    DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Avoids sucker's payoff
2. **Free-rides on cooperators** - Defects when others are cooperating
3. **Sustains exploitation** - Occasionally cooperates just enough to prevent cooperation collapse
4. **Identifies and targets suckers** - Tracks unconditional cooperators for maximum extraction
5. **Clean endgame exit** - No sentimentality in final rounds
6. **Adaptive parasitism** - Adjusts extraction rate to what the population can sustain
'''

description_EXPLOITATIVE_51 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy—but exploiting cooperators requires them to keep cooperating. The strategy must balance extraction with sustainability.

## Strategy Overview

The strategy operates in three phases and uses adaptive thresholds based on observed cooperation levels. It treats the population as a resource to be harvested, cooperating only when necessary to maintain that resource or when defection is clearly unprofitable.

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1:** DEFECT
- Rationale: Gather information about baseline cooperation levels while securing guaranteed payoff. No reputation exists yet to damage.

**Round 2:** DEFECT
- Rationale: Observe if cooperators persist or retaliate. This reveals which opponents are unconditional cooperators (exploitable) vs. conditional cooperators.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / (n - 1)
```

**Decision Logic:**

```
IF coop_rate >= 0.6:
    DEFECT  # High cooperation = free ride opportunity
    
ELSE IF coop_rate >= 0.4:
    # Medium cooperation - contribute minimally to sustain the pool
    IF my_consecutive_defections >= 3:
        COOPERATE  # Occasional cooperation to prevent complete collapse
    ELSE:
        DEFECT
        
ELSE IF coop_rate >= 0.2:
    # Low cooperation - test if cooperation can revive the pool
    IF trend is declining for 2+ rounds:
        DEFECT  # Abandon ship
    ELSE:
        COOPERATE with probability 0.3  # Cheap probe
        
ELSE:  # coop_rate < 0.2
    DEFECT  # Pool is dead, protect yourself
```

**Adaptive Adjustment Based on k/n Ratio:**
```
exploitation_threshold = 0.6 * (k / (n-1))
```
- When k is closer to n, cooperation becomes more valuable → slightly more willing to cooperate
- When k is small, defection dominance is stronger → more aggressive defection

### Phase 3: Endgame (Final 2 rounds)

**Round r-1 (second to last):** DEFECT
- Rationale: Begin extraction. Conditional cooperators may still cooperate hoping for reciprocity.

**Round r (final):** DEFECT
- Rationale: No future consequences. Pure dominant strategy.

---

## Detailed Pseudocode

```python
def decide(round_number, total_rounds, n, k, history):
    # history[t] = list of actions by all other players in round t
    
    # ENDGAME: Always defect in final 2 rounds
    if round_number >= total_rounds - 1:
        return DEFECT
    
    # PROBE PHASE: Defect to gather information
    if round_number <= 2:
        return DEFECT
    
    # EXPLOITATION PHASE
    last_round_others = history[round_number - 1]
    coop_rate = count(last_round_others, C) / (n - 1)
    
    # Track trends
    if round_number >= 3:
        prev_coop_rate = count(history[round_number - 2], C) / (n - 1)
        trend = coop_rate - prev_coop_rate  # positive = increasing cooperation
    else:
        trend = 0
    
    # Count my consecutive defections
    my_consec_defections = count_my_consecutive_defections(my_history)
    
    # Adaptive threshold based on game parameters
    high_threshold = 0.5 + 0.1 * (k / n)  # ~0.5-0.6 typically
    
    # Main decision logic
    if coop_rate >= high_threshold:
        return DEFECT  # Exploit the cooperators
        
    elif coop_rate >= 0.35:
        # Sustain the pool occasionally
        if my_consec_defections >= 3:
            return COOPERATE
        else:
            return DEFECT
            
    elif coop_rate >= 0.15:
        # Pool is struggling
        if trend < -0.1:  # Declining
            return DEFECT
        elif random() < 0.25:  # Occasional probe
            return COOPERATE
        else:
            return DEFECT
            
    else:  # coop_rate < 0.15
        return DEFECT  # Pool collapsed, no point contributing
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (two players) | More aggressive defection; cooperate only if opponent cooperated twice consecutively | Limited pool benefit, easier to track opponent |
| k very close to n (e.g., k = n-0.1) | Slightly higher cooperation threshold (0.7 instead of 0.6) | Cooperation is more valuable |
| r ≤ 4 (very short game) | Defect every round | Not enough time to build/exploit cooperation |
| All opponents defected last 3 rounds | Defect until at least 2 cooperators appear | No point contributing to empty pool |
| Cooperation suddenly spikes | Defect immediately | Maximize extraction from windfall |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Always defects first to establish baseline, letting others pay the cost of building the pool

2. **Free-rides on high cooperation** - Defects precisely when cooperation is highest, extracting maximum value

3. **Minimal maintenance contributions** - Only cooperates enough to prevent complete pool collapse, treating cooperation as an investment in future defection opportunities

4. **Ruthless endgame** - Extracts all remaining value in final rounds with no concern for sustainability

5. **Exploits conditional cooperators** - Uses intermittent cooperation to string along TFT-like strategies while mostly defecting

6. **Abandons lost causes** - Quickly stops cooperating when the pool collapses, avoiding throwing good money after bad

This strategy treats cooperative players as a renewable resource: harvest aggressively, but not so aggressively that the resource disappears entirely—until the end, when maximum extraction is optimal.
'''

description_EXPLOITATIVE_50 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**. We cooperate only when it's instrumentally useful for future exploitation, not out of reciprocity.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit cooperative players.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Purpose:** Gather information about opponent population composition at minimal cost.

**Round 1 Decision:** **DEFECT**
- Rationale: Never sacrifice payoff without information. Observe who cooperates unconditionally—these are prime exploitation targets.

**Rounds 2 to ⌈r/5⌉:** 
- If more than 50% of opponents cooperated in the previous round: **DEFECT** (exploit the cooperators)
- If 50% or fewer cooperated: **COOPERATE once** as a "lure," then immediately **DEFECT** next round
- This tests whether opponents are conditional cooperators who can be manipulated

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Continuously track for each opponent:**
- `coop_rate[j]` = (times player j cooperated) / (rounds played)
- `responsiveness[j]` = how much player j's cooperation correlates with group cooperation last round

**Decision Rule:**

```
Let expected_cooperators = Σ(coop_rate[j]) for all opponents j
Let my_marginal_benefit = k/n
Let group_benefit_from_me = k/n × n = k

IF expected_cooperators ≥ (n-1) × 0.6:
    # Rich environment - DEFECT and free-ride
    DEFECT
    
ELIF expected_cooperators ≥ (n-1) × 0.3:
    # Mixed environment - conditional cooperation to sustain exploitation
    IF I defected in last 2 consecutive rounds:
        COOPERATE  # Prevent complete collapse, keep sheep in the game
    ELSE:
        DEFECT
        
ELSE:
    # Barren environment - everyone is defecting
    DEFECT  # No point cooperating with other defectors
```

**Exploitation Amplifier:**
- If I identify a "sucker" (player with coop_rate > 0.7 regardless of others' actions): Always **DEFECT**. They'll keep contributing regardless.
- If I identify "retaliators" (players whose cooperation drops sharply after defection): Occasionally cooperate (1 in 4 rounds) to keep them partially engaged, then defect.

### Phase 3: Endgame (Final ⌈r/10⌉ rounds)

**Decision Rule:** **ALWAYS DEFECT**

- Rationale: No future rounds to maintain reputation. Backward induction dominates. Extract maximum value.
- For final round specifically: **DEFECT unconditionally** regardless of any other consideration.

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | No information; don't be exploited |
| Last round | DEFECT | No future; dominant strategy |
| n=2 (minimum players) | More aggressive defection; cooperate only 1 in 5 rounds in Phase 2 | Less dilution of exploitation gains |
| Large n (>10) | Defect more often; cooperation signal is diluted | My cooperation barely affects group dynamics |
| k close to n | Slightly more cooperation (1 in 3 instead of 1 in 4) in Phase 2 | Higher returns justify occasional investment |
| k close to 1 | Near-permanent defection | Public good returns too low |
| All opponents defected last 3 rounds | DEFECT | Environment is hostile; don't be the sucker |
| All opponents cooperated last 3 rounds | DEFECT | Maximum exploitation opportunity |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return DEFECT
    
    if round > r - ceil(r/10):  # Endgame
        return DEFECT
    
    expected_coop = estimate_cooperators(history)
    coop_fraction = expected_coop / (n-1)
    
    if round <= ceil(r/5):  # Probing phase
        if coop_fraction > 0.5:
            return DEFECT
        elif I_cooperated_last_round:
            return DEFECT
        else:
            return COOPERATE  # Lure
    
    else:  # Exploitation phase
        if coop_fraction >= 0.6:
            return DEFECT
        elif coop_fraction >= 0.3:
            if defected_last_two_rounds(history):
                return COOPERATE  # Sustain the herd
            else:
                return DEFECT
        else:
            return DEFECT

function estimate_cooperators(history):
    # Weight recent rounds more heavily
    # Apply exponential decay: weight = 0.7^(rounds_ago)
    return weighted_sum of opponent cooperation rates
```

---

## Why This Strategy is Exploitative

1. **Information asymmetry:** We learn opponent types while revealing minimal information about our own strategy (appearing somewhat random/conditional)

2. **Targeted exploitation:** Unconditional cooperators are mercilessly exploited; we never reward their cooperation with ours

3. **Herd management:** We contribute just enough to prevent total cooperation collapse—keeping the "sheep" producing for us to harvest

4. **Endgame extraction:** Complete defection in final rounds captures all possible value when reputation no longer matters

5. **Adaptive predation:** The strategy shifts based on the "richness" of the cooperative environment—more parasitic when cooperation is abundant, more dormant when it's scarce
'''

description_EXPLOITATIVE_52 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defection is always individually rational in a single round, but cooperation can be sustained if others are "punishable." The goal is to **extract maximum value from cooperators while minimizing losses to fellow defectors**, adapting based on observed population behavior.

## Strategy Overview

The strategy operates in three modes based on detected population cooperativeness, with special handling for early exploration and endgame exploitation.

---

## Decision Rules

### Round 1: Probe with Defection
- **Action: DEFECT**
- Rationale: Gain information about opponent behavior without risk. If others cooperate, we profit maximally. If others defect, we lose nothing compared to cooperating.

### Rounds 2 through (r-1): Adaptive Mode Selection

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays in previous round) / n
```

**Mode A: Exploit Cooperative Populations** (coop_rate ≥ 0.5)
- **Action: DEFECT**
- Rationale: When half or more players cooperate, defection yields maximum payoff. We free-ride on their contributions.

**Mode B: Conditional Cooperation for Sustainable Exploitation** (0.2 ≤ coop_rate < 0.5)
- **Action: COOPERATE with probability p = min(coop_rate × 1.5, 0.6)**
- Rationale: If cooperation is declining but present, we occasionally cooperate to prevent total collapse (which hurts everyone). We cooperate *just enough* to keep some cooperators in the game, but less than the population rate to maintain our edge.

**Mode C: Full Defection** (coop_rate < 0.2)
- **Action: DEFECT**
- Rationale: Cooperation has collapsed. No point contributing to an empty pool. Wait for potential recovery.

### Trend Adjustment
Track cooperation rate over a 3-round window. If cooperation is:
- **Rising**: Increase defection probability by 0.1 (more to exploit)
- **Falling**: Increase cooperation probability by 0.1 (prevent total collapse)

### Last Round (Round r): Always Defect
- **Action: DEFECT**
- Rationale: No future interaction means no punishment possible. Pure dominant strategy.

### Second-to-Last Round (Round r-1): Defect
- **Action: DEFECT**
- Rationale: Sophisticated opponents will defect in round r regardless, so punishment threat is already diminished.

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Endgame exploitation
    if round >= r - 1:
        return DEFECT
    
    # First round probe
    if round == 1:
        return DEFECT
    
    # Calculate recent cooperation rate
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate = last_round_coops / n
    
    # Calculate trend (if enough history)
    if round >= 4:
        old_rate = count_cooperators(history, round - 3) / n
        trend = coop_rate - old_rate  # positive = rising cooperation
    else:
        trend = 0
    
    # Mode selection
    if coop_rate >= 0.5:
        # Exploit cooperative population
        return DEFECT
    
    elif coop_rate >= 0.2:
        # Conditional cooperation to sustain exploitation
        base_prob = min(coop_rate * 1.5, 0.6)
        adjusted_prob = base_prob - (trend * 0.2)  # cooperate less if rising
        adjusted_prob = clamp(adjusted_prob, 0.1, 0.5)
        return COOPERATE with probability adjusted_prob
    
    else:
        # Population collapsed, defect
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | DEFECT | Information gathering at zero risk |
| All previous rounds were all-D | DEFECT | No cooperators to exploit or sustain |
| All previous rounds were all-C | DEFECT | Maximum exploitation opportunity |
| Single opponent (n=2) | Follow same rules | Still valid; becomes close to iterated PD |
| Very high k (close to n) | Same rules apply | Higher k makes cooperation more tempting for others—exploit harder |
| r=2 (minimum rounds) | DEFECT both rounds | Both are effectively "endgame" |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation**: Others must prove cooperativeness first
2. **Defects against cooperative populations**: Maximizes free-riding
3. **Only cooperates to sustain victims**: Minimal investment to keep cooperators playing
4. **Endgame defection**: Extracts final-round value ruthlessly
5. **Asymmetric response**: Cooperates less than the population rate, ensuring positive differential
'''

description_EXPLOITATIVE_51 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperative opponents requires appearing conditionally cooperative to keep them contributing.

## Strategy Overview

The strategy operates in three phases based on game position, with continuous opponent modeling to identify and exploit predictable players.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Purpose:** Gather information about opponent tendencies while minimizing exposure.

**Round 1:** 
- **DEFECT** — Never cooperate without information. This is pure expected value maximization.

**Rounds 2 to ⌈r/5⌉:**
- Calculate cooperation rate `coop_rate = total_cooperations / (n-1) / rounds_played`
- If `coop_rate > 0.6`: **COOPERATE** (enough suckers to maintain the pool)
- Otherwise: **DEFECT**

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Purpose:** Maximize extraction based on learned opponent behaviors.

**Classify each opponent into buckets based on their history:**
- **Unconditional Cooperators:** Cooperation rate > 0.8
- **Conditional Cooperators:** Cooperation rate 0.4-0.8, shows responsiveness to group behavior
- **Defectors:** Cooperation rate < 0.4

**Decision Logic:**

```
num_reliable_cooperators = count(unconditional) + 0.5 * count(conditional)
expected_contributions = num_reliable_cooperators

# Calculate whether my defection is profitable given expected contributions
my_gain_from_defecting = 1  # keeping my endowment
my_share_of_public_good = (k/n) * expected_contributions

if expected_contributions >= n/(k-1):
    # Enough cooperators that I benefit more from defecting
    DEFECT
else if conditional_cooperators are tracking MY behavior specifically:
    # They might punish my defection - cooperate to keep them contributing
    COOPERATE with probability based on how punitive they appear
else:
    DEFECT
```

**Punishment Detection:**
Track if the group's cooperation rate drops specifically after rounds where I defected. If correlation > 0.5, switch to cooperative mode temporarily to "reset" their expectations.

### Phase 3: Endgame (Final ⌈r/10⌉ rounds)

**Purpose:** Extract remaining value with no future consequences.

**Last round:** 
- **DEFECT** — Always. No future retaliation possible.

**Second-to-last round:**
- **DEFECT** — Rational opponents will defect in the last round, so no point building goodwill.

**Remaining endgame rounds:**
- Calculate if appearing cooperative might induce enough cooperation to offset my contribution
- Generally **DEFECT** unless cooperation rate has remained > 0.7 despite my defections (indicating unconditional cooperators worth milking one more round)

---

## Adaptive Mechanisms

### Opponent Modeling (Per-Player Tracking)

For each opponent j, maintain:
- `coop_history[j]`: list of their C/D choices
- `responsiveness[j]`: correlation between their choices and previous round's group cooperation
- `punishes_me[j]`: correlation between their defection and my previous defection

### Dynamic Threshold Adjustment

```
base_threshold = 0.5
adjust based on:
  - If k is close to n: lower threshold (cooperation more valuable)
  - If k is close to 1: raise threshold (cooperation less valuable)
  - If n is large: raise threshold (my contribution matters less)
  
adjusted_threshold = base_threshold * (n/k) / (n-1)
```

### Anti-Exploitation Defense

If I detect that my cooperation rate is being tracked and exploited (others defect when I cooperate, cooperate when I defect), switch to **random play** with P(C) = (k-1)/(n-1) for several rounds to become unpredictable.

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| n = 2 | More aggressive defection; cooperate only if opponent shows consistent TFT-like behavior |
| r = 2 | Defect both rounds |
| k very close to n | Lower cooperation threshold significantly |
| All opponents defect rounds 1-3 | Commit to permanent defection |
| All opponents cooperate rounds 1-3 | Continue defecting (they're unconditional cooperators) |
| Mixed signals | Default to defection |

---

## Summary Pseudocode

```
function decide(round, history, n, k, r):
    if round == 1:
        return DEFECT
    
    if round > r - ceil(r/10):
        return DEFECT  # Endgame
    
    coop_rate = calculate_opponent_cooperation_rate(history)
    expected_contributors = estimate_cooperators_this_round(history)
    
    if expected_contributors * k / n > 1 + k/n:
        # My share of their contributions exceeds my contribution's value
        return DEFECT
    
    if being_punished(history) and round < r - ceil(r/10):
        return COOPERATE  # Reset reputation temporarily
    
    if coop_rate > adjusted_threshold(n, k):
        return DEFECT  # Exploit the cooperators
    
    return DEFECT  # Default
```

This strategy is designed to **never be the sucker** while **maximally exploiting cooperative opponents**.
'''

description_EXPLOITATIVE_53 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits cooperative players while protecting against exploitation. The key insight is that in a public goods game with k < n, defection always yields higher individual payoff *given any fixed behavior of others*. However, if we can identify and exploit cooperators while they still cooperate, we maximize extraction. The strategy dynamically adjusts based on the observed "cooperativeness" of the population.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous monitoring of opponent behavior to maximize exploitation.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** DEFECT
- Rationale: Never cooperate without information. Defecting in round 1 gives us a free observation of the population's baseline cooperativeness while guaranteeing we're not exploited.

**Round 2:** DEFECT
- Rationale: Continue gathering information. If round 1 showed high cooperation, we're extracting maximum value. If low cooperation, we lose nothing by defecting.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **Cooperation Rate (CR)** from the previous round:
```
CR = (number of cooperators in last round) / n
```

Calculate the **Trend** (is cooperation increasing or decreasing?):
```
Trend = CR(current) - CR(2 rounds ago)
```

**Decision Logic:**

```
IF CR >= 0.6 THEN:
    # High cooperation environment - exploit aggressively
    DEFECT (free-ride on cooperators)

ELSE IF CR >= 0.4 AND CR < 0.6 THEN:
    # Moderate cooperation - conditional behavior
    IF Trend > 0 THEN:
        # Cooperation is rising - wait and exploit
        DEFECT
    ELSE IF Trend < -0.1 THEN:
        # Cooperation collapsing fast - occasional cooperation 
        # to slow collapse (only if profitable long-term)
        IF (r - current_round) > 3 AND CR > 0.35 THEN:
            COOPERATE (investment to maintain exploitable population)
        ELSE:
            DEFECT
    ELSE:
        DEFECT

ELSE IF CR < 0.4 THEN:
    # Low cooperation environment - nothing to exploit
    DEFECT (no point cooperating in a defecting population)
```

### Phase 3: Endgame (Last 2 rounds: r-1 and r)

**Rounds r-1 and r:** DEFECT (unconditionally)
- Rationale: Standard backward induction. No future rounds mean no incentive to maintain any cooperative facade.

---

## Edge Cases

### Small n (n = 2 or 3)
- With very few players, each player's choice is highly visible
- Stick to core strategy but expect faster collapse to mutual defection
- Be especially aggressive in endgame (extend to last 3 rounds)

### Large n (n > 10)
- Individual defection is harder to detect/punish
- More aggressive defection throughout
- Lower the CR threshold for "high cooperation" to 0.5

### Very Short Games (r ≤ 5)
- Compress phases: Probe for 1 round only
- Defect rounds 1, and all rounds from r-1 onward
- Exploit/probe in remaining rounds

### Very Long Games (r > 20)
- Standard phases apply
- Consider occasional strategic cooperation in mid-game if CR is declining toward 0.3-0.4, but only if many rounds remain

### k Close to n
- Higher k means cooperation is more efficient
- Others may cooperate more; more to exploit
- Maintain defection strategy (exploitation more profitable)

### k Close to 1
- Little benefit from public good
- Expect widespread defection
- Defect throughout (nothing to exploit anyway)

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase - always defect
    if round <= 2:
        return DEFECT
    
    # Calculate metrics
    CR = cooperation_rate(history, round - 1)
    
    if round >= 3:
        prev_CR = cooperation_rate(history, round - 2)
        Trend = CR - prev_CR
    else:
        Trend = 0
    
    # Exploitation phase logic
    if CR >= 0.6:
        return DEFECT  # Exploit high cooperation
    
    if CR >= 0.4:
        if Trend > 0:
            return DEFECT  # Let cooperation build, then exploit
        if Trend < -0.1 and (r - round) > 3 and CR > 0.35:
            return COOPERATE  # Slow the collapse
        return DEFECT
    
    # CR < 0.4: Nothing worth exploiting
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Asymmetric extraction**: We benefit from others' cooperation while rarely contributing
2. **Information advantage**: We gather data before committing resources
3. **Predatory timing**: We exploit cooperators during their cooperative phase, then abandon when the well runs dry
4. **Minimal investment**: The rare cooperation is purely instrumental—an investment to keep prey cooperating longer
5. **No reciprocity illusions**: We don't pretend fairness matters; we defect whenever it's profitable

This strategy treats other players as resources to be harvested, not partners to cooperate with.
'''

description_EXPLOITATIVE_52 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can harvest. The optimal exploitative approach is to **defect by default** while monitoring for exploitable patterns in others' behavior, and only cooperate when there's a clear strategic benefit (i.e., to "farm" cooperation from conditional cooperators before harvesting them).

## Strategy Overview

The strategy operates in three phases based on game progression and adapts based on observed cooperation levels in the population.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Purpose:** Gather information about opponent types while minimizing cost.

- **Round 1:** DEFECT
  - Rationale: Never cooperate without information. Let others reveal themselves first.

- **Round 2:** DEFECT
  - Observe round 1 results. Calculate cooperation rate `coop_rate = cooperators / n`

- **Round 3:** 
  - If `coop_rate >= 0.5` in rounds 1-2: Play **COOPERATE** (investment to maintain exploitable cooperators)
  - Otherwise: **DEFECT**

### Phase 2: Exploitation Phase (Rounds 4 to r-2)

**Purpose:** Maximize extraction from cooperative players while maintaining just enough cooperation to keep them contributing.

Calculate rolling cooperation rate over last 3 rounds: `recent_coop_rate`

**Decision Rule:**
```
if recent_coop_rate >= 0.6:
    # Rich environment - defect and harvest
    DEFECT
    
elif recent_coop_rate >= 0.4:
    # Moderate environment - occasional cooperation to sustain it
    if (round_number % 3 == 0):
        COOPERATE  # Periodic "feeding" to keep cooperators engaged
    else:
        DEFECT

elif recent_coop_rate >= 0.2:
    # Declining environment - more frequent cooperation to revive
    if (round_number % 2 == 0):
        COOPERATE
    else:
        DEFECT

else:
    # Dead environment - everyone defecting
    DEFECT  # No point cooperating in a defection wasteland
```

### Phase 3: Endgame (Final 2 rounds)

**Purpose:** Maximum extraction - no future to preserve.

- **Round r-1:** DEFECT
- **Round r:** DEFECT

*Rationale:* With no future rounds, there's no benefit to maintaining cooperation. Classic backward induction applies.

---

## Adaptive Mechanisms

### Trend Detection
Track whether cooperation is increasing or decreasing:
```
trend = recent_coop_rate - previous_coop_rate

if trend > 0.1:
    # Cooperation rising - safe to defect more
    bias toward DEFECT
    
if trend < -0.1:
    # Cooperation falling - may need to invest
    bias toward COOPERATE (if environment still viable)
```

### Threshold Adjustment Based on k/n Ratio
The multiplier efficiency `e = k/n` affects strategy:
```
if e > 0.4:
    # Higher returns from public good - cooperation slightly more attractive
    Increase cooperation thresholds by 0.1
    
if e < 0.25:
    # Low returns - defection even more dominant
    Decrease cooperation thresholds by 0.1
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (two players) | Always DEFECT | Direct exploitation; cooperation just feeds opponent |
| r ≤ 3 (very short game) | Always DEFECT | No time to build/exploit cooperation |
| k very close to n | Still primarily DEFECT | Even with high multiplier, defection dominates |
| 100% cooperation observed | DEFECT heavily | Maximum harvest opportunity |
| 0% cooperation (all defect) | DEFECT | No value in unilateral cooperation |
| Single cooperator remains | Occasionally COOPERATE (1 in 4 rounds) | Keep them in the game as a resource |

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, n, k):
    
    # Endgame - always defect
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # Round 1 - no information
    if round_num == 1:
        return DEFECT
    
    # Calculate metrics
    recent_coop_rate = avg_cooperation_rate(history, last_n_rounds=3)
    trend = calculate_trend(history)
    
    # Probing phase
    if round_num <= 3:
        if recent_coop_rate >= 0.5:
            return COOPERATE
        return DEFECT
    
    # Exploitation phase with adaptive thresholds
    adjusted_threshold = base_threshold(recent_coop_rate) + trend_adjustment(trend)
    
    if recent_coop_rate >= 0.6:
        return DEFECT  # Harvest
    elif recent_coop_rate >= 0.4:
        return COOPERATE if (round_num % 3 == 0) else DEFECT
    elif recent_coop_rate >= 0.2:
        return COOPERATE if (round_num % 2 == 0) else DEFECT
    else:
        return DEFECT  # Environment dead
```

---

## Why This Strategy is Exploitative

1. **Defaults to defection** - captures the dominant strategy advantage
2. **Free-rides on cooperators** - harvests value created by others
3. **Strategic cooperation is investment, not altruism** - only cooperates to maintain exploitable population
4. **Endgame defection** - classic exploitative backward induction
5. **Asymmetric response** - defects more when others cooperate (harvesting), not less
'''

description_EXPLOITATIVE_54 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy is designed to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators requires them to *keep cooperating*. The strategy must balance exploitation with just enough apparent cooperation to sustain cooperative opponents.

---

## Decision Rules

### Round 1: Defect
- **Rationale**: No information exists. Defection is the dominant strategy in any single round. This also serves as a probe to identify unconditional cooperators (easy targets).

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / n
```

**Decision logic:**

```
IF coop_rate >= 0.6:
    # Rich environment - exploit it
    DEFECT
    
ELIF coop_rate >= 0.4:
    # Moderate cooperation - probabilistic mimicry to sustain it
    COOPERATE with probability = coop_rate * 0.5
    DEFECT otherwise
    
ELIF coop_rate > 0:
    # Low cooperation - occasional "bait" to test if cooperation can be revived
    IF (rounds_since_last_cooperation > 3):
        COOPERATE (bait)
    ELSE:
        DEFECT

ELSE (coop_rate == 0):
    # Dead environment - pure defection
    DEFECT
```

**Additional exploitation trigger:**
```
IF my_cumulative_payoff < average_opponent_payoff * 0.9:
    # Being exploited - switch to pure defection for 2 rounds
    DEFECT (override other rules)
```

### Final Round (Round r): Always Defect
- **Rationale**: No future punishment is possible. Defection is strictly dominant.

---

## Tracking Variables

1. `round_number`: Current round (1 to r)
2. `last_round_cooperators`: Count of C plays in previous round
3. `rounds_since_last_cooperation`: Rounds since this strategy played C
4. `my_cumulative_payoff`: Running total of own payoffs
5. `total_opponent_payoffs`: Running total of all other players' payoffs

---

## Pseudocode Implementation

```python
def decide(round_num, r, n, k, history):
    # history = list of (my_action, cooperator_count) for each past round
    
    # FINAL ROUND: Always defect
    if round_num == r:
        return DEFECT
    
    # FIRST ROUND: Defect to probe
    if round_num == 1:
        return DEFECT
    
    # Calculate metrics from history
    last_coop_count = history[-1].cooperator_count
    coop_rate = last_coop_count / n
    
    my_payoff = sum(calculate_payoff(h) for h in history)
    avg_opponent_payoff = estimate_avg_opponent_payoff(history, n, k)
    
    rounds_since_coop = rounds_since_i_cooperated(history)
    
    # EXPLOITATION CHECK: Am I being outperformed?
    if my_payoff < avg_opponent_payoff * 0.9:
        return DEFECT  # Defensive defection
    
    # MAIN DECISION LOGIC
    if coop_rate >= 0.6:
        return DEFECT  # Exploit rich environment
        
    elif coop_rate >= 0.4:
        # Probabilistic cooperation to sustain environment
        if random() < coop_rate * 0.5:
            return COOPERATE
        return DEFECT
        
    elif coop_rate > 0:
        # Low cooperation - occasional bait
        if rounds_since_coop > 3:
            return COOPERATE
        return DEFECT
        
    else:
        return DEFECT  # Dead environment
```

---

## Why This Strategy Exploits Effectively

| Opponent Type | How We Exploit |
|---------------|----------------|
| **Unconditional Cooperators** | Free ride continuously; they never punish |
| **Tit-for-Tat / Reciprocators** | Our occasional cooperation keeps them cooperating; we defect more than we cooperate |
| **Conditional Cooperators** | Probabilistic cooperation mimics "noise" - they may forgive defections |
| **Defectors** | Mutual defection; we lose nothing relative to them |
| **Threshold Strategies** | Our cooperation keeps environment above their threshold while we free-ride |

---

## Edge Case Handling

- **r = 2 rounds**: Defect both rounds (no time to build exploitable cooperation)
- **n = 2 players**: Strategy still works; coop_rate thresholds apply
- **k close to n**: Cooperation is more valuable, but defection still dominates—exploit harder
- **All opponents defect immediately**: We match defection, no worse than anyone else

---

## Summary

**Adaptive Predator** defects by default, cooperates just enough to sustain exploitable cooperation from others, and always defects in the final round. It's designed to outperform both naive cooperators (by exploiting them) and pure defectors (by occasionally triggering cooperation from conditional cooperators that it can then exploit).
'''

description_EXPLOITATIVE_53 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators requires appearing cooperative enough to sustain their behavior—until it's time to cash out.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit cooperative players.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/4⌉)

**Purpose:** Gather information about opponent tendencies while maintaining plausible cooperativeness.

**Rule:** Alternate between C and D in a pattern that appears somewhat cooperative but gathers data.

- **Round 1:** Play **D** (safe baseline, observe others)
- **Round 2:** Play **C** (test if others reciprocate)
- **Rounds 3+:** Play **C** if cooperation rate in previous round was ≥ 50%, else play **D**

### Phase 2: Exploitation Phase (Rounds ⌈r/4⌉+1 to r-⌈r/6⌉)

**Purpose:** Maximize extraction from cooperative opponents.

**Decision Rule:**

```
Let coop_rate = (total C plays by others in last 3 rounds) / (n-1) / 3

If coop_rate ≥ 0.6:
    # Environment is cooperative - DEFECT to free-ride
    Play D
    
Elif coop_rate ≥ 0.3:
    # Mixed environment - conditional cooperation to sustain contributors
    If my_defection_streak ≥ 2:
        Play C  # Occasional cooperation to keep suckers engaged
    Else:
        Play D
        
Else (coop_rate < 0.3):
    # Environment is hostile - mutual defection, no point cooperating
    Play D
```

**Exploitation Logic:** When others cooperate heavily, I defect to capture the public good without contributing. When cooperation is moderate, I occasionally cooperate to prevent complete collapse (which would end my free-riding opportunity). When others defect, I defect too—no sense being the sucker.

### Phase 3: Endgame (Final ⌈r/6⌉ rounds)

**Purpose:** Pure defection—no future to incentivize cooperation.

**Rule:** Play **D** unconditionally.

**Rationale:** As the game approaches termination, cooperative strategies unravel via backward induction. There's no benefit to maintaining reputation when there are insufficient future rounds for reciprocity to pay off.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| **Round 1** | D | No information, safe default, observe |
| **Round 2** | C | Signal potential cooperativeness, test waters |
| **Final round** | D | No future consequences |
| **n = 2** | Tit-for-Tat with defection bias | Simpler opponent modeling needed |
| **k close to n** | Slightly more cooperative | Higher marginal benefit from mutual cooperation |
| **k close to 1** | More aggressive defection | Public good barely worth creating |
| **r ≤ 4** | All D except possibly round 2 | Too short for reputation building to pay off |
| **All opponents always C** | Always D | Maximum exploitation of unconditional cooperators |
| **All opponents always D** | Always D | No benefit to unilateral cooperation |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Endgame: always defect
    if round > r - ceil(r/6):
        return D
    
    # Round 1: defect and observe
    if round == 1:
        return D
    
    # Round 2: test cooperation
    if round == 2:
        return C
    
    # Probing phase
    if round <= ceil(r/4):
        last_round_coop_rate = count_cooperators(history, round-1) / (n-1)
        if last_round_coop_rate >= 0.5:
            return C
        else:
            return D
    
    # Exploitation phase
    recent_coop_rate = count_cooperators(history, last_3_rounds) / (n-1) / 3
    my_recent_defections = count_my_consecutive_defections(history)
    
    if recent_coop_rate >= 0.6:
        return D  # Free-ride on cooperators
    elif recent_coop_rate >= 0.3:
        if my_recent_defections >= 2:
            return C  # Sustain the cooperative environment
        else:
            return D
    else:
        return D  # Environment too hostile
```

---

## Why This Strategy is Exploitative

1. **Identifies and milks cooperators:** High cooperation rates trigger defection—maximum free-riding.

2. **Doesn't get suckered:** Never cooperates into a hostile environment.

3. **Sustains exploitation:** Occasional cooperation in mixed environments keeps cooperative opponents from giving up entirely.

4. **Clean endgame:** No sentimentality—pure defection when reputation no longer matters.

5. **Parameter-adaptive:** Adjusts phase lengths to game duration; adjusts thresholds implicitly through observed behavior.
'''

description_EXPLOITATIVE_55 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and continuously estimates opponent "cooperativeness" to calibrate exploitation intensity.

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: Establish baseline. If others cooperate, we gain maximally. If others defect, we lose nothing compared to cooperating.

**Round 2: DEFECT**
- Rationale: Observe if cooperators persist or punish. True cooperators (TFT-like) may forgive; unconditional cooperators continue; defectors remain predictable.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate **Cooperation Index (CI)** after each round:
```
CI = (total cooperations by others in last 3 rounds) / (3 × (n-1))
```

**Decision Rule:**
```
IF CI > 0.6:
    DEFECT  (exploit the cooperative environment)
ELSE IF CI > 0.3:
    Probabilistic: COOPERATE with probability = CI × 0.5
    (partial cooperation to maintain some cooperation in the pool)
ELSE IF CI ≤ 0.3:
    DEFECT  (environment is hostile, protect self)
```

**Adaptive Modifier - "Sucker Detection":**
```
IF any specific player has cooperated in ≥80% of rounds AND I have defected ≥60% of rounds:
    Continue DEFECT (unconditional cooperator detected - maximize exploitation)
```

**Adaptive Modifier - "Punisher Detection":**
```
IF overall cooperation rate dropped by >30% after my defections:
    Temporarily COOPERATE for 1-2 rounds to "reset" punishers
    Then resume exploitation
```

### Phase 3: Endgame (Last 2 rounds)

**Round r-1: DEFECT**
- Rationale: Limited punishment opportunity remains

**Round r (Final): DEFECT**
- Rationale: No future retaliation possible; pure dominant strategy

---

## Pseudocode

```python
def decide(round_number, r, n, k, history):
    
    # Endgame: Always defect
    if round_number >= r - 1:
        return DEFECT
    
    # Probe phase: Always defect
    if round_number <= 2:
        return DEFECT
    
    # Calculate cooperation index (last 3 rounds of opponents)
    recent_rounds = history[max(0, round_number-3):round_number]
    others_cooperations = sum(count_cooperations(round, exclude_self=True) for round in recent_rounds)
    CI = others_cooperations / (len(recent_rounds) * (n - 1))
    
    # Detect unconditional cooperators (suckers)
    for player in opponents:
        if cooperation_rate(player) >= 0.8 and my_defection_rate >= 0.6:
            return DEFECT  # Keep exploiting
    
    # Detect punishers - check if cooperation dropped after my defections
    if detected_punishment_pattern():
        if rounds_since_last_cooperation > 2:
            return COOPERATE  # Brief reset attempt
    
    # Main exploitation logic
    if CI > 0.6:
        return DEFECT  # Rich environment - exploit
    elif CI > 0.3:
        return COOPERATE if random() < (CI * 0.5) else DEFECT
    else:
        return DEFECT  # Hostile environment - protect
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | No history; defection is safe |
| Round r (last) | DEFECT | No retaliation possible |
| All opponents always defect | DEFECT | No exploitation opportunity; minimize loss |
| All opponents always cooperate | DEFECT | Maximum exploitation of "suckers" |
| Mixed/unpredictable opponents | Probabilistic based on CI | Hedge bets |
| Short games (r ≤ 4) | DEFECT always | Insufficient rounds to build cooperation value |
| Large n (many players) | More aggressive defection | Individual impact diluted; free-riding easier |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** in early rounds—lets others bear the cost
2. **Free-rides on cooperative environments** rather than contributing
3. **Identifies and exploits unconditional cooperators** relentlessly
4. **Only cooperates strategically** to prevent complete collapse of the cooperation pool (preserving future exploitation opportunities)
5. **Guaranteed defection in endgame** when punishment is impossible

This strategy treats cooperation as a **resource to extract**, not a mutual benefit to build.
'''

description_EXPLOITATIVE_56 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but we can exploit cooperators by appearing conditionally cooperative just enough to keep them contributing.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous adaptation based on observed opponent behavior.

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1 to ⌈r/5⌉)

**Purpose:** Gather information about opponent tendencies while minimizing risk.

- **Round 1:** DEFECT
  - Rationale: Never contribute blindly. Observe who cooperates naively.
  
- **Rounds 2 to ⌈r/5⌉:** 
  - If cooperation rate in previous round ≥ 50%: DEFECT (exploit the cooperators)
  - If cooperation rate in previous round < 50%: COOPERATE with probability p = (k-1)/(n-1)
  - Rationale: Only signal potential cooperation if others are also defecting; this tests if conditional cooperators exist.

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Purpose:** Maximize extraction based on learned opponent profiles.

**Classify each opponent** based on their history:
- **Sucker:** Cooperated ≥ 70% of the time → Exploit ruthlessly
- **Conditional:** Cooperated 30-70%, appears responsive to group behavior → Mimic just enough to maintain their cooperation
- **Defector:** Cooperated < 30% → Ignore (they give nothing)

**Decision Rule:**
```
sucker_count = number of Suckers
conditional_count = number of Conditionals
defector_count = number of Defectors

# Calculate expected cooperation if I defect vs cooperate
# Only cooperate if it maintains enough conditional cooperators to be profitable

if sucker_count ≥ (n-1)/2:
    DEFECT  # Enough reliable contributors, free-ride
    
elif conditional_count ≥ 2 AND (sucker_count + conditional_count) > defector_count:
    # Cooperate occasionally to keep conditionals engaged
    # But defect more than cooperate to extract surplus
    cooperation_threshold = 0.3 + 0.1 * (k - 1)  # Higher k = slightly more cooperation
    
    if my_recent_cooperation_rate (last 3 rounds) > cooperation_threshold:
        DEFECT
    else:
        COOPERATE
        
else:
    DEFECT  # Not enough cooperators to sustain; abandon ship
```

### Phase 3: Endgame Extraction (Final ⌈r/10⌉ rounds)

**Purpose:** Maximize final payoffs knowing cooperation will collapse.

- **All rounds except the very last:** 
  - If there are still ≥ 2 Suckers: DEFECT
  - Otherwise: Mirror the majority action from the previous round (blend in)
  
- **Final round:** DEFECT (always - there's no future to protect)

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, n, k):
    probe_end = ceil(total_rounds / 5)
    endgame_start = total_rounds - ceil(total_rounds / 10)
    
    # Round 1: Always defect
    if round_num == 1:
        return DEFECT
    
    # Final round: Always defect
    if round_num == total_rounds:
        return DEFECT
    
    # Calculate opponent statistics
    coop_rate_last = cooperation_rate(history, round_num - 1)
    opponent_profiles = classify_opponents(history)
    
    # Phase 1: Probe
    if round_num <= probe_end:
        if coop_rate_last >= 0.5:
            return DEFECT
        else:
            return COOPERATE if random() < (k-1)/(n-1) else DEFECT
    
    # Phase 3: Endgame
    if round_num >= endgame_start:
        if opponent_profiles['sucker'] >= 2:
            return DEFECT
        else:
            return majority_action(history, round_num - 1)
    
    # Phase 2: Exploitation
    suckers = opponent_profiles['sucker']
    conditionals = opponent_profiles['conditional']
    defectors = opponent_profiles['defector']
    
    if suckers >= (n-1) / 2:
        return DEFECT
    elif conditionals >= 2 and (suckers + conditionals) > defectors:
        threshold = 0.3 + 0.1 * (k - 1)
        my_recent_coop = my_cooperation_rate(history, last=3)
        return DEFECT if my_recent_coop > threshold else COOPERATE
    else:
        return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | Never cooperate blindly |
| Final round | DEFECT | No future consequences |
| Only 2 rounds total | DEFECT both | Too short to build any trust worth exploiting |
| n=2 (two players) | Heavy defection, occasional cooperation probe | Opponent profile is critical and easily learned |
| k very close to n | Slightly higher cooperation threshold | Higher returns justify marginally more contribution |
| k very close to 1 | Almost always DEFECT | Returns too low to justify cooperation |
| All opponents defecting | DEFECT | No one to exploit |
| All opponents cooperating | DEFECT | Maximum free-riding opportunity |

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Always waits to see who the "marks" are
2. **Classifies opponents as resources** - Views cooperators as value to extract
3. **Maintains minimum cooperation** - Only cooperates enough to keep conditional cooperators contributing
4. **Aggressive endgame** - Abandons any pretense of cooperation when it no longer matters
5. **Asymmetric reciprocity** - Cooperates less than it "should" to maintain relationships, always tilting the surplus toward itself
'''

description_EXPLOITATIVE_54 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that in a public goods game with k < n, defection strictly dominates cooperation in any single round. However, in a repeated game, I can exploit cooperative opponents by free-riding on their contributions while occasionally "baiting" continued cooperation. My goal is to maximize my payoff by:

1. **Extracting value** from cooperators as long as possible
2. **Minimizing my own contributions** while keeping others contributing
3. **Defecting ruthlessly** when cooperation dries up or in endgame scenarios

## Strategy Specification

### Key Variables Tracked
- `coop_rate[t]`: Proportion of other players who cooperated in round t
- `trend`: Moving direction of cooperation (increasing/decreasing/stable)
- `my_coop_count`: How many times I've cooperated so far
- `rounds_remaining`: r - current_round

### Decision Rules

#### Round 1: Always Defect
- Rationale: No information yet. Defection is dominant in isolation. Let others reveal their types while I collect the free-rider bonus on any cooperators.

#### Rounds 2 through (r-1): Conditional Exploitation

```
Calculate: avg_coop_rate = average cooperation rate of others over all previous rounds

IF avg_coop_rate >= 0.5:
    # Rich environment - cooperators exist to exploit
    
    IF coop_rate[t-1] is declining for 2+ consecutive rounds:
        # Cooperation is dying - consider "bait" move
        IF my_coop_count / current_round < 0.15:
            COOPERATE (bait move to signal and potentially revive cooperation)
        ELSE:
            DEFECT
    ELSE:
        # Cooperation is stable or rising - pure exploitation
        DEFECT

ELSE IF avg_coop_rate >= 0.2:
    # Moderate environment - mixed population
    
    # Occasionally cooperate to maintain the pool (but rarely)
    IF random() < 0.1 AND coop_rate[t-1] > 0.3:
        COOPERATE
    ELSE:
        DEFECT

ELSE:
    # Hostile environment - mostly defectors
    # No point cooperating; pure defection
    DEFECT
```

#### Last Round (Round r): Always Defect
- Rationale: No future to protect. Classical backward induction applies.

#### Second-to-Last Round (Round r-1): Almost Always Defect
- Only cooperate if avg_coop_rate > 0.7 (trying to squeeze one more round of high cooperation from naive opponents who might not apply backward induction)

### Exploitation Mechanisms

**1. Free-Rider Maximization**
- When others cooperate at high rates, I defect to get both my endowment (1) AND my share of their contributions (k/n × cooperators)

**2. Strategic Baiting**
- If I've been defecting heavily and cooperation is collapsing, one cooperative move might be interpreted by conditional cooperators as "turning over a new leaf," potentially reviving cooperation for me to exploit again
- This is only profitable if: (k/n) × expected_future_cooperators > cost_of_bait_move

**3. Endgame Aggression**
- Final 20% of rounds: Shift entirely to defection regardless of cooperation rates
- Most sophisticated opponents will be doing backward induction anyway

### Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return DEFECT
    
    if round >= r - max(1, floor(r * 0.1)):  # Last 10% of rounds or last round
        return DEFECT
    
    others_coop_history = get_others_cooperation_rates(history)
    avg_coop = mean(others_coop_history)
    recent_trend = get_trend(others_coop_history[-3:])  # Last 3 rounds
    my_coop_ratio = count_my_cooperations(history) / (round - 1)
    
    if avg_coop >= 0.5:
        if recent_trend == DECLINING and my_coop_ratio < 0.15:
            return COOPERATE  # Bait
        return DEFECT  # Exploit
    
    elif avg_coop >= 0.2:
        if random() < 0.1 and others_coop_history[-1] > 0.3:
            return COOPERATE  # Occasional maintenance
        return DEFECT
    
    else:
        return DEFECT  # Hostile environment
```

## Robustness Features

- **Against Always-Cooperate**: Maximum exploitation via constant defection
- **Against Always-Defect**: Mutual defection (Nash equilibrium, no loss)
- **Against Tit-for-Tat variants**: My low cooperation rate means they'll defect against me, but I'm not losing much since I rarely cooperated anyway
- **Against other exploiters**: Converges to mutual defection quickly
- **Against threshold/trigger strategies**: The occasional bait move may keep some of them cooperating longer
'''

description_EXPLOITATIVE_57 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always the dominant action in a single round—but cooperative opponents can be "farmed" for higher payoffs if we can sustain their cooperation while occasionally defecting ourselves.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the group to determine exploitation timing.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Round 1:** DEFECT
- Rationale: Gather information about opponent types without risking contribution. If others cooperate, we profit maximally. If they defect, we lose nothing extra.

**Round 2:** DEFECT
- Rationale: Continue assessment. Observe if cooperators persist or retaliate.

**Round 3:** Conditional
- If cooperation rate in rounds 1-2 was ≥ 50%: COOPERATE (signal willingness to cooperate to sustain cooperators)
- Otherwise: DEFECT

### Phase 2: Exploitation Phase (Rounds 4 to r-2)

Calculate **Group Cooperation Rate (GCR)** = (total C plays by others in last 3 rounds) / (3 × (n-1))

**Decision Rule:**
```
IF GCR ≥ 0.6:
    # High cooperation environment - exploit periodically
    IF (current_round mod 3) == 0:
        DEFECT  # Exploit every 3rd round
    ELSE:
        COOPERATE  # Maintain cooperation to keep farming
        
ELIF GCR ≥ 0.3:
    # Mixed environment - conditional cooperation
    IF (number of cooperators last round) ≥ n/2:
        COOPERATE with 50% probability, else DEFECT
    ELSE:
        DEFECT
        
ELSE:
    # Low cooperation environment - pure defection
    DEFECT
```

**Adaptive Exploitation Adjustment:**
- Track personal cumulative payoff vs. theoretical "all-defect" baseline
- If we're underperforming baseline by more than 2 points: increase defection frequency (exploit every 2nd round instead of 3rd in high-GCR scenarios)
- If a specific pattern emerges (e.g., coordinated retaliation after our defections): temporarily increase cooperation to rebuild trust, then resume exploitation

### Phase 3: Endgame (Last 2 rounds: r-1 and r)

**Round r-1:** DEFECT
- Rationale: Begin endgame exploitation. Sophisticated opponents will defect here anyway.

**Round r (final):** DEFECT
- Rationale: No future retaliation possible. Defection strictly dominates.

---

## Edge Cases

| Scenario | Action |
|----------|--------|
| **r ≤ 3** (very short game) | Always DEFECT - insufficient time to build cooperative surplus |
| **n = 2** (two players) | More aggressive defection - defect rounds 1, 2, and any round where opponent defected previously |
| **k very close to n** | Slightly more cooperation-tolerant since public good benefit is higher |
| **All opponents always cooperate** | Maximum exploitation - defect every other round while maintaining enough cooperation to keep them contributing |
| **All opponents always defect** | Pure defection throughout |
| **Tit-for-tat opponents detected** | Cooperate mostly, defect only in final 2 rounds |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if r <= 3:
        return DEFECT
    
    if round >= r - 1:
        return DEFECT  # Endgame
    
    if round <= 2:
        return DEFECT  # Probing
    
    if round == 3:
        if cooperation_rate(history, rounds=1-2) >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Main exploitation phase
    GCR = cooperation_rate(history, last_3_rounds)
    
    if GCR >= 0.6:
        if round % 3 == 0:
            return DEFECT
        else:
            return COOPERATE
    elif GCR >= 0.3:
        if cooperators_last_round >= n/2:
            return random_choice(COOPERATE=0.5, DEFECT=0.5)
        else:
            return DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: By defecting periodically in cooperative environments, we capture public good benefits without contributing
2. **Never gets suckered long-term**: Quick detection of defecting environments triggers protective defection
3. **Endgame exploitation**: Guaranteed defection in final rounds captures maximum value when retaliation is impossible
4. **Information-gathering opening**: Initial defections reveal opponent types at minimal cost
5. **Sustainable exploitation**: The 1-in-3 defection rate in cooperative environments is calibrated to extract value without triggering mass retaliation
'''

description_EXPLOITATIVE_55 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy is designed to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns. The goal is to identify and milk cooperative players while quickly abandoning cooperation when facing defectors.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the game environment to determine when exploitation is profitable.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1: Defect**
- Rationale: Observe the baseline cooperation level without contributing. This provides free information about opponent tendencies and captures any "naive cooperator" surplus.

**Round 2: Conditional**
- If cooperation rate in Round 1 ≥ 50%: **Cooperate** (to establish potential for exploitation)
- If cooperation rate in Round 1 < 50%: **Defect** (environment is hostile, protect self)

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate an **Environment Score (ES)** after each round:

```
ES = (average cooperation rate over last 3 rounds) × (k/n) × (n-1)
```

**Decision Rule:**
- If ES > 0.8: **Defect** (enough others cooperating to free-ride profitably)
- If 0.4 ≤ ES ≤ 0.8: **Cooperate** (maintain cooperation ecosystem for future exploitation)
- If ES < 0.4: **Defect** (cooperation has collapsed, no point contributing)

**Adaptive Trigger - "Sucker Detection":**
Track if your cooperation is being exploited (you cooperate while majority defects):
- If you cooperated and fewer than 40% of others cooperated in the same round, increment a "sucker counter"
- If sucker counter ≥ 2 consecutive rounds: Switch to permanent defection until ES > 1.0

### Phase 3: Endgame (Final 2 rounds)

**Round r-1 (second-to-last): Defect**
- Rationale: Begin extracting final value; opponents may still cooperate hoping to sustain the relationship

**Round r (final): Defect**
- Rationale: No future interaction means no punishment possible. Pure dominant strategy.

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Edge case: First round
    if round == 1:
        return DEFECT
    
    # Edge case: Last two rounds - always defect
    if round >= r - 1:
        return DEFECT
    
    # Calculate recent cooperation rate (last 3 rounds or all available)
    lookback = min(3, round - 1)
    recent_coop_rate = sum(cooperation_counts[round-lookback:round]) / (lookback * (n-1))
    
    # Round 2 logic
    if round == 2:
        if recent_coop_rate >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Exploitation phase (rounds 3 to r-2)
    ES = recent_coop_rate * (k / n) * (n - 1)
    
    # Check if being exploited
    if my_last_action == COOPERATE and last_round_others_coop_rate < 0.4:
        sucker_counter += 1
    else:
        sucker_counter = 0
    
    # Permanent defection if repeatedly suckered
    if sucker_counter >= 2 and ES <= 1.0:
        return DEFECT
    
    # Main exploitation logic
    if ES > 0.8:
        return DEFECT      # Free-ride on cooperators
    elif ES >= 0.4:
        return COOPERATE   # Maintain the cooperative ecosystem
    else:
        return DEFECT      # Abandon ship - cooperation collapsed
```

---

## Edge Cases Handled

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Defect | Gather information risk-free |
| Round r | Defect | No future retaliation possible |
| All opponents always defect | Defect from round 3 onward | No exploitation opportunity exists |
| All opponents always cooperate | Defect (ES > 0.8 triggers) | Maximum extraction from naive players |
| Mixed/conditional opponents | Oscillate based on ES | Maintain exploitable equilibrium |
| Being repeatedly suckered | Permanent defection | Stop losses |

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Always has a self-interested calculation
2. **Free-rides on high cooperation** - When others cooperate enough, it defects to maximize personal gain
3. **Abandons cooperation quickly** - Doesn't waste resources on lost causes
4. **Endgame defection** - Extracts maximum value when punishment is impossible
5. **Sucker protection** - Refuses to be the consistent contributor that others exploit
'''

description_EXPLOITATIVE_58 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by:
1. **Detecting and exploiting cooperative opponents** - free-riding on their contributions
2. **Avoiding being exploited** - quickly defecting against defectors
3. **Extracting maximum value** - maintaining just enough cooperation signals to keep "suckers" cooperating

## Decision Rules

### Round 1: Probe with Defection
**Action: DEFECT**

Rationale: In round 1, defection dominates. If others cooperate, I gain maximum advantage (1 + k/n per cooperator). If others defect, I avoid being the sucker. This also establishes a baseline to measure opponent responses.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate two key metrics after each round:

```
cooperation_rate = (total cooperations by others in all previous rounds) / ((n-1) * rounds_played)
recent_cooperation = (cooperations by others in last round) / (n-1)
```

**Decision Logic:**

```
IF recent_cooperation >= 0.5:
    # Exploitable environment detected
    IF cooperation_rate >= 0.6:
        # Highly cooperative group - exploit aggressively
        DEFECT
    ELSE IF cooperation_rate >= 0.4:
        # Moderately cooperative - occasional cooperation to sustain them
        COOPERATE with probability 0.2
        DEFECT with probability 0.8
    ELSE:
        # Cooperation is fragile - defect to maximize before collapse
        DEFECT

ELSE IF recent_cooperation >= 0.3:
    # Mixed environment
    DEFECT (no point cooperating when returns are low)

ELSE:
    # Low cooperation environment
    DEFECT (mutual defection is the equilibrium)
```

### Last Round (Round r): Always Defect
**Action: DEFECT**

Rationale: No future rounds exist to punish defection. Cooperation has zero strategic value. This is the dominant strategy regardless of history.

### Second-to-Last Round (Round r-1): Almost Always Defect
**Action: DEFECT with probability 0.95**

Rationale: Sophisticated opponents will defect in the last round, so cooperation in r-1 yields no future benefit. The tiny cooperation probability adds unpredictability.

## Pseudocode Implementation

```python
def adaptive_predator(round_number, total_rounds, n, k, history):
    """
    history: list of previous round results
    Each entry: {'my_action': C/D, 'others_cooperated': int}
    """
    
    # Last round - always defect
    if round_number == total_rounds:
        return DEFECT
    
    # First round - defect to probe
    if round_number == 1:
        return DEFECT
    
    # Second to last - almost always defect
    if round_number == total_rounds - 1:
        return DEFECT if random() < 0.95 else COOPERATE
    
    # Calculate metrics
    total_others_cooperated = sum(h['others_cooperated'] for h in history)
    total_possible = (n - 1) * len(history)
    cooperation_rate = total_others_cooperated / total_possible
    
    recent_cooperation = history[-1]['others_cooperated'] / (n - 1)
    
    # Adaptive exploitation logic
    if recent_cooperation >= 0.5:
        if cooperation_rate >= 0.6:
            return DEFECT  # Milk the cooperators
        elif cooperation_rate >= 0.4:
            return DEFECT if random() < 0.8 else COOPERATE
        else:
            return DEFECT
    else:
        return DEFECT  # Low cooperation - no point contributing
```

## Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| n=2 (minimum players) | Follow standard rules | Strategy scales down naturally |
| r=2 (two rounds only) | Defect both rounds | Too short for reputation building |
| k close to 1 | Defect more aggressively | Low multiplier means cooperation rarely pays |
| k close to n | Still exploit but consider occasional C | Higher returns, but D still dominates |
| All opponents always cooperate | Always defect | Maximum exploitation opportunity |
| All opponents always defect | Always defect | No benefit to unilateral cooperation |

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Starts with defection, only cooperates to manipulate
2. **Free-rides on cooperators** - When others cooperate heavily, this strategy defects
3. **Occasional cooperation is bait** - The 20% cooperation rate in mixed environments keeps naive reciprocators cooperating
4. **Endgame defection** - Guarantees exploitation in final rounds when punishment is impossible
5. **Asymmetric responses** - Exploits cooperators fully while matching defectors
'''

description_EXPLOITATIVE_56 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

This strategy aims to **maximize free-riding opportunities** while maintaining just enough cooperation to prevent complete collapse of the public good. The key insight is that in a multi-player setting, I can often defect while others cooperate, capturing the benefits without paying the costs.

## Decision Rules

### Round Classification

Divide the game into three phases:
- **Probing Phase**: Rounds 1 to `ceil(r/5)` — Learn opponent tendencies
- **Exploitation Phase**: Rounds `ceil(r/5)+1` to `r-2` — Maximize extraction
- **Endgame Phase**: Final 2 rounds — Pure defection

### Phase 1: Probing Phase

**Round 1**: **DEFECT**
- Rationale: Establish baseline. If others cooperate, I profit maximally. If others defect, I lose nothing compared to cooperating.

**Rounds 2 to ceil(r/5)**:
- Calculate `coop_rate` = (total cooperations by others in all previous rounds) / ((n-1) × rounds_played)
- If `coop_rate > 0.6`: **DEFECT** (exploit the cooperators)
- If `coop_rate ≤ 0.6`: **COOPERATE** (signal willingness to sustain cooperation for future exploitation)

### Phase 2: Exploitation Phase

For each round, calculate:
1. `recent_coop_rate` = cooperation rate of others in last 3 rounds
2. `my_pivotal_value` = k/n (my marginal contribution to others per cooperation)
3. `exploitation_threshold` = 1 - (1/n) (defect if enough others will cooperate)

**Decision Logic**:
```
predicted_cooperators = recent_coop_rate × (n-1)

IF predicted_cooperators ≥ n × (n/k) × 0.5:
    # Enough suckers to free-ride on
    DEFECT
ELSE IF predicted_cooperators < 1:
    # Nobody cooperating, try to restart (but only if early enough)
    IF rounds_remaining > r/3:
        COOPERATE
    ELSE:
        DEFECT
ELSE:
    # Borderline case: probabilistic exploitation
    # Cooperate with probability inversely related to others' cooperation
    defect_probability = recent_coop_rate × 0.8
    DEFECT with probability defect_probability
    COOPERATE with probability (1 - defect_probability)
```

### Phase 3: Endgame (Final 2 Rounds)

**Always DEFECT**
- No future rounds to incentivize cooperation
- Standard backward induction applies

## Edge Cases

### Small n (n=2 or n=3)
- More conservative exploitation: reduce `defect_probability` multiplier from 0.8 to 0.5
- Individual defections more noticeable; need to maintain some cooperation facade

### Large n (n≥10)
- Aggressive exploitation: increase `defect_probability` multiplier to 0.9
- Individual actions less impactful; free-riding more sustainable

### High k (k close to n)
- Cooperation is very valuable to the group
- Maintain slightly higher cooperation to keep the system alive for exploitation
- Reduce defect probability by factor of (n-k)/(n-1)

### Everyone Defecting (cooperation collapse)
- If 3+ consecutive rounds have zero cooperation from others:
- Cooperate once as a "probe" to see if others will restart
- If no response, return to defection

### Short Games (r ≤ 5)
- Skip probing phase
- Round 1: Defect
- Rounds 2 to r-1: Defect if any cooperation observed, else cooperate once
- Final round: Defect

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    if round >= r - 1:
        return DEFECT  # Endgame
    
    if round == 1:
        return DEFECT  # Initial probe
    
    others_coop_history = get_others_cooperation(history)
    recent_rate = cooperation_rate(others_coop_history, last=3)
    overall_rate = cooperation_rate(others_coop_history, last=all)
    
    if round <= ceil(r/5):  # Probing phase
        return DEFECT if overall_rate > 0.6 else COOPERATE
    
    # Exploitation phase
    predicted_coops = recent_rate * (n-1)
    threshold = n * (n/k) * 0.5
    
    if predicted_coops >= threshold:
        return DEFECT
    elif predicted_coops < 1 and (r - round) > r/3:
        return COOPERATE  # Restart attempt
    else:
        p_defect = recent_rate * 0.8 * size_modifier(n) * k_modifier(k,n)
        return DEFECT with probability p_defect
```

## Why This Exploits Effectively

1. **Asymmetric information extraction**: I learn opponent tendencies while giving minimal signal about my own strategy
2. **Counter-cooperative**: The more others cooperate, the more I defect — maximizing free-rider gains
3. **Collapse prevention**: Just enough cooperation to keep naive cooperators engaged
4. **Endgame certainty**: No wasted cooperation when it cannot be reciprocated
'''

description_EXPLOITATIVE_59 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation from others is a resource to be harvested carefully—not destroyed immediately.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit predictable players.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Purpose:** Gather information about opponent tendencies while appearing potentially cooperative.

**Round 1:** 
- **Defect.** This is the dominant single-round strategy and reveals nothing exploitable about us while letting us observe others.

**Rounds 2 to ⌈r/5⌉:**
- Calculate the **cooperation rate** from the previous round: `coop_rate = num_cooperators / n`
- If `coop_rate ≥ 0.5`: **Cooperate** (signal willingness to participate, keep cooperators engaged)
- If `coop_rate < 0.5`: **Defect** (not enough cooperators to justify the cost)

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Purpose:** Maximize extraction based on learned opponent behavior.

**Classify each opponent into categories based on their history:**
1. **Unconditional Cooperators (UC):** Cooperated ≥80% of rounds regardless of outcomes
2. **Conditional Cooperators (CC):** Cooperation rate correlates with group cooperation (±20% of group rate)
3. **Defectors (DF):** Cooperated ≤20% of rounds
4. **Unpredictable (UP):** Everyone else

**Decision Rule:**
```
estimated_cooperators = count(UC) + 0.5 × count(CC) + 0.1 × count(UP)

# Calculate expected payoff differential
expected_if_defect = 1 + (k/n) × estimated_cooperators
expected_if_cooperate = 0 + (k/n) × (estimated_cooperators + 1)
gain_from_defection = expected_if_defect - expected_if_cooperate = 1 - k/n

# Defection is always individually better, BUT we must consider sustainability
sustainability_threshold = count(CC) / (n-1)

If sustainability_threshold > 0.4 AND estimated_cooperators ≥ 2:
    # Enough conditional cooperators that we risk collapsing cooperation
    # Cooperate occasionally to maintain the pool
    Cooperate with probability = min(0.3, sustainability_threshold - 0.3)
Else:
    Defect
```

**Refinement - Trigger Detection:**
- Track if group cooperation drops sharply (>30%) after rounds where we defected
- If this pattern appears twice: increase cooperation probability by 0.2 for next 3 rounds (we're being "watched" or triggering retaliation)

### Phase 3: Endgame Phase (Final ⌈r/10⌉ rounds)

**Purpose:** Extract maximum value as future consequences diminish.

**Last Round:**
- **Always Defect.** No future retaliation possible.

**Second-to-last round:**
- **Defect** unless more than 60% of opponents are classified as CC (in which case, one more cooperation might yield a cooperative final round from them—but still defect in the actual final round).

**Other endgame rounds:**
- Gradually increase defection probability: `P(defect) = 0.7 + 0.3 × (current_round - endgame_start) / (endgame_length)`

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| **n = 2** | Pure Tit-for-Tat with defection bias: Start D, then copy opponent but defect on any "tie" and always defect last 2 rounds |
| **r = 2** | Defect both rounds (too short for reputation building) |
| **r ≤ 5** | Skip probing phase; defect unless ≥70% cooperated in round 1 |
| **k very close to n** | Slightly more cooperative (cooperation almost efficient); increase all cooperation thresholds by 0.1 |
| **k very close to 1** | More aggressive defection; cooperation almost never justified |
| **All opponents defect round 1** | Commit to defection for remainder unless cooperation emerges |
| **All opponents cooperate round 1** | High-value target: alternate C-D-D pattern to maintain some cooperation while extracting |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    if round == r:
        return DEFECT
    
    if round == 1:
        return DEFECT
    
    coop_rate = history.last_round_cooperators() / n
    opponent_profiles = classify_opponents(history)
    
    if round <= ceil(r/5):  # Probing
        return COOPERATE if coop_rate >= 0.5 else DEFECT
    
    if round > r - ceil(r/10):  # Endgame
        defect_prob = 0.7 + 0.3 * (round - (r - ceil(r/10))) / ceil(r/10)
        return DEFECT if random() < defect_prob else COOPERATE
    
    # Exploitation phase
    est_coop = opponent_profiles.UC + 0.5*opponent_profiles.CC + 0.1*opponent_profiles.UP
    sustainability = opponent_profiles.CC / (n-1)
    
    if sustainability > 0.4 and est_coop >= 2:
        coop_prob = min(0.3, sustainability - 0.3)
        if detected_retaliation_pattern(history):
            coop_prob += 0.2
        return COOPERATE if random() < coop_prob else DEFECT
    
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-rides on unconditional cooperators:** Never reciprocates their cooperation in the long run
2. **Manipulates conditional cooperators:** Contributes just enough to keep them cooperating, then harvests
3. **Never exploitable in endgame:** Guaranteed defection removes end-stage vulnerability
4. **Information asymmetry:** Uses probing to learn opponent types while revealing minimal exploitable patterns
5. **Adaptive predation:** Extracts more from cooperative environments, cuts losses in hostile ones
'''

description_EXPLOITATIVE_57 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**, and to **appear just cooperative enough to sustain exploitation without triggering retaliation**.

## Strategy Overview

The strategy operates in three modes based on detected opponent behavior, with aggressive defection as the default and cooperation used only as a calculated investment to maintain exploitable conditions.

---

## Decision Rules

### Round 1: Probe with Defection
- **Action: DEFECT**
- Rationale: Defection dominates in single-shot games. Starting with D reveals which opponents are unconditional cooperators (easy marks) versus conditional cooperators or defectors, without sacrificing any payoff.

### Last Round (Round r): Always Defect
- **Action: DEFECT**
- Rationale: No future rounds exist to punish defection. Cooperation in the final round is pure charity with no strategic value.

### Penultimate Round (Round r-1): Defect
- **Action: DEFECT**
- Rationale: Sophisticated opponents will defect in round r regardless, so the shadow of the future is already diminished. Start extracting early.

### Middle Rounds (Rounds 2 through r-2): Adaptive Exploitation

Calculate two key metrics after each round:

**Metric 1: Cooperation Rate (CR)**
```
CR = (total cooperations by all opponents across all previous rounds) / 
     ((n-1) × rounds_played)
```

**Metric 2: Exploitation Potential (EP)**
```
EP = average number of cooperators when I defected (excluding self)
```

**Decision Logic:**

```
IF CR > 0.6 THEN:
    # Environment is cooperative - EXPLOIT IT
    DEFECT
    
ELSE IF CR > 0.3 THEN:
    # Mixed environment - strategic conditional cooperation
    IF (my cooperation in previous round AND cooperation_count decreased) THEN:
        # Others are defecting in response or independently - abandon ship
        DEFECT
    ELSE IF (EP > n/3) THEN:
        # Still enough suckers to exploit
        DEFECT
    ELSE:
        # Cooperation collapsing, throw in occasional C to probe/sustain
        COOPERATE with probability = 0.2
        DEFECT with probability = 0.8
        
ELSE IF CR <= 0.3 THEN:
    # Low cooperation environment - everyone is defecting
    DEFECT (no point cooperating when no one else does)
```

### Refinement: Detecting and Exploiting Conditional Cooperators

Many strategies (like Tit-for-Tat variants) cooperate if they see cooperation. We can exploit this:

```
IF (detected_conditional_cooperators > n/3) AND (rounds_remaining > 3) THEN:
    # Occasionally cooperate to "reset" conditional cooperators
    # Then defect to exploit their responsive cooperation
    
    IF (last_2_rounds == [D, D]) THEN:
        COOPERATE  # Bait the conditional cooperators
    ELSE:
        DEFECT     # Harvest the cooperation you induced
```

**Detection of conditional cooperators:**
```
conditional_cooperator_score[player_j] = correlation between 
    (overall cooperation rate in round t-1) and (player_j's action in round t)
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | Information gathering + dominant strategy |
| Round r (last) | DEFECT | No future punishment possible |
| Round r-1 | DEFECT | Shadow of future nearly gone |
| n=2 (minimum players) | Follow standard rules but weight EP more heavily | Opponent behavior directly determines payoff |
| k close to n | Slightly increase cooperation probability | Higher returns to mutual cooperation |
| k close to 1 | Pure defection | Public good multiplier too weak |
| All opponents always cooperate | Always DEFECT | Maximum exploitation of unconditional cooperators |
| All opponents always defect | Always DEFECT | Cooperation yields negative returns |

---

## Pseudocode Summary

```python
def adaptive_predator(round_num, total_rounds, n, k, history):
    
    # Terminal rounds: always defect
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # First round: probe with defection
    if round_num == 1:
        return DEFECT
    
    # Calculate metrics
    CR = cooperation_rate(history, exclude_self=True)
    EP = avg_cooperators_when_i_defected(history)
    
    # High cooperation: exploit
    if CR > 0.6:
        return DEFECT
    
    # Medium cooperation: strategic mix
    if CR > 0.3:
        if EP > n/3:
            return DEFECT
        
        # Bait conditional cooperators
        if last_n_actions(history, self, 2) == [D, D]:
            if detected_conditional_cooperators(history) > n/3:
                return COOPERATE
        
        # Mostly defect with occasional probe
        return DEFECT if random() > 0.2 else COOPERATE
    
    # Low cooperation: pure defection
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates out of principle** - Every cooperation is an investment to sustain exploitation
2. **Targets unconditional cooperators** - Pure defection against the naive
3. **Manipulates conditional cooperators** - Baits them with occasional C, then harvests with D
4. **Abandons sinking ships** - When cooperation collapses, doesn't waste resources trying to rebuild
5. **Endgame extraction** - Guaranteed defection in final rounds captures maximum value
6. **Information asymmetry** - Uses observed behavior to classify and exploit opponent types
'''

description_EXPLOITATIVE_60 = '''
# Exploitative Strategy: "Predatory Threshold Defector"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors always earn more than cooperators in the same round. The goal is to extract maximum value by defecting whenever possible while occasionally cooperating just enough to prevent complete ecosystem collapse (which would hurt long-term extraction).

## Strategy Overview

I adopt a primarily defecting stance, only cooperating when the "cooperation pool" I'm exploiting is in danger of drying up completely. I treat other cooperators as resources to be harvested, not as partners to coordinate with.

---

## Decision Rules

### Round 1: Always Defect
- **Rationale**: No information exists yet. Defection is the dominant single-round strategy. Let others reveal themselves as cooperators to be exploited.

### Middle Rounds (2 through r-1):

**Calculate "Exploitation Viability Score" (EVS):**
```
cooperation_rate = (cooperators in previous round) / n
trend = average(cooperation_rates over last 3 rounds) - cooperation_rate_oldest
```

**Decision Logic:**

1. **If cooperation_rate ≥ 0.5**: **DEFECT**
   - The pool is healthy. Harvest freely.

2. **If 0.2 ≤ cooperation_rate < 0.5 AND trend < 0**: **Probabilistic Cooperation**
   - Cooperation is declining. Occasionally cooperate to "seed" the pool.
   - Cooperate with probability: `(0.5 - cooperation_rate) * 0.3`
   - This is minimal investment to potentially revive exploitable cooperators.

3. **If cooperation_rate < 0.2 AND rounds_remaining > 3**: **Conditional Cooperation**
   - The pool is nearly dead. Cooperate once to signal, then immediately defect.
   - If I cooperated last round, defect this round regardless.

4. **If cooperation_rate < 0.2 AND rounds_remaining ≤ 3**: **DEFECT**
   - Not enough time for cooperation to pay off. Pure extraction mode.

### Last Round (r): Always Defect
- **Rationale**: No future exists to incentivize cooperation. This is the dominant strategy regardless of history.

### Second-to-Last Round (r-1): Almost Always Defect
- Only cooperate if cooperation_rate > 0.7 (trying to maintain a pattern others might reciprocate on, though I'll betray them anyway).

---

## Pseudocode

```python
def decide(round_num, total_rounds, history, n, k):
    if round_num == 1:
        return DEFECT
    
    if round_num == total_rounds:
        return DEFECT
    
    rounds_remaining = total_rounds - round_num
    
    # Calculate recent cooperation rate
    last_round_cooperators = count_cooperators(history[-1])
    cooperation_rate = last_round_cooperators / n
    
    # Calculate trend (if enough history)
    if len(history) >= 3:
        recent_rates = [count_cooperators(h)/n for h in history[-3:]]
        trend = recent_rates[-1] - recent_rates[0]
    else:
        trend = 0
    
    # Second-to-last round special case
    if round_num == total_rounds - 1:
        return DEFECT
    
    # Main decision logic
    if cooperation_rate >= 0.5:
        return DEFECT  # Healthy pool, exploit it
    
    elif cooperation_rate >= 0.2:
        if trend < 0:
            # Declining cooperation - occasionally seed
            prob_cooperate = (0.5 - cooperation_rate) * 0.3
            return COOPERATE if random() < prob_cooperate else DEFECT
        else:
            return DEFECT
    
    else:  # cooperation_rate < 0.2
        if rounds_remaining <= 3:
            return DEFECT  # Not enough time
        elif my_last_action == COOPERATE:
            return DEFECT  # Already seeded, now harvest
        else:
            return COOPERATE  # One-time seed attempt
```

---

## Edge Cases Handled

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | Defect | No information, dominant strategy |
| Last round | Defect | No future consequences |
| Everyone defecting | Rare cooperation to seed | Prevent total collapse |
| Everyone cooperating | Defect | Maximum exploitation opportunity |
| Only I cooperate | Defect next round | Stop wasting resources |
| n=2 (two players) | More aggressive defection | Harder to free-ride, so don't try |

---

## Why This Strategy is Exploitative

1. **Defaults to defection**: Cooperation is the exception, not the rule
2. **Treats cooperators as resources**: Only "invests" in cooperation when the resource pool needs replenishment
3. **Endgame betrayal**: Guaranteed defection in final rounds regardless of history
4. **Minimal reciprocity**: Never matches cooperation 1:1; always extracts more than contributes
5. **Adaptive parasitism**: Adjusts extraction rate based on what the ecosystem can sustain
'''

description_EXPLOITATIVE_58 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by others creates exploitable value. My goal is to **free-ride on cooperators as long as possible** while **quickly abandoning cooperation when the pool dries up**.

## Strategy Overview

The strategy operates in three modes based on observed cooperation levels:

1. **Exploitation Mode**: Defect while others cooperate (maximum profit)
2. **Conditional Cooperation Mode**: Occasionally cooperate to sustain cooperation in others
3. **Full Defection Mode**: Defect when cooperation has collapsed

## Decision Rules

### Round 1: Defect
- No information available, and defection strictly dominates in a single-shot game
- This also serves as a probe to see how others behave

### Rounds 2 through (r-1): Adaptive Response

**Calculate cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / n
```

**Decision logic:**

```
IF coop_rate >= 0.5:
    # Rich environment - exploit it
    # But occasionally "seed" cooperation to sustain the pool
    IF random() < maintenance_probability:
        COOPERATE
    ELSE:
        DEFECT
    
    WHERE maintenance_probability = min(0.15, (r - current_round) / (3 * r))
    # Lower probability as game progresses; near zero in final rounds

ELSE IF coop_rate >= 0.25:
    # Declining cooperation - try to squeeze remaining value
    DEFECT

ELSE:
    # Cooperation collapsed - no point contributing
    DEFECT
```

**Reputation Tracking Enhancement:**

Track individual players across rounds when n is small (n ≤ 10):
```
FOR each player j:
    player_coop_rate[j] = (times j cooperated) / (rounds observed)

IF average(player_coop_rate for top 50% cooperators) > 0.6:
    # Reliable cooperators exist - exploit them
    DEFECT (unless in maintenance mode above)
ELSE:
    # Only unreliable players - defect always
    DEFECT
```

### Final Round (Round r): Always Defect
- No future consequences; defection strictly dominates
- This is the textbook backward induction result

### Second-to-Last Round (Round r-1): Almost Always Defect
- Defect unless cooperation rate is extremely high (>0.7) and maintaining appearances might yield one more round of exploitation
- Even then, defect with 90% probability

## Exploitation Mechanisms

1. **Free-riding on unconditional cooperators**: Pure cooperators give me k/n per round for free
2. **Exploiting conditional cooperators**: By occasionally cooperating, I can trick TFT-like strategies into continued cooperation
3. **Quick abandonment**: Unlike reciprocal strategies, I don't "waste" cooperation trying to rebuild a collapsed pool
4. **Endgame exploitation**: Aggressive defection in final rounds captures maximum value

## Parameter Sensitivity

- **Large n (>10)**: Individual defection is less noticeable; be more aggressive (reduce maintenance_probability by 50%)
- **Small n (≤4)**: Defection is obvious; increase maintenance_probability slightly to avoid triggering retaliation
- **High k (close to n)**: Cooperation has high social value but individual incentive still favors defection; strategy unchanged
- **Many rounds (r > 20)**: More opportunity to exploit; can afford slightly more "investment" in early cooperation seeding

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    last_round_cooperators = count_cooperators(history, round - 1)
    coop_rate = last_round_cooperators / n
    
    if round == r - 1:
        return DEFECT
    
    if coop_rate >= 0.5:
        maintenance_prob = min(0.15, (r - round) / (3 * r))
        if random() < maintenance_prob:
            return COOPERATE
        else:
            return DEFECT
    else:
        return DEFECT
```

## Why This Strategy is Exploitative

- **Never cooperates unconditionally**: Every cooperation decision is calculated to maintain exploitable conditions
- **Defects by default**: The baseline action is always defection
- **Exploits trust**: Uses occasional cooperation as a manipulation tool, not genuine reciprocity
- **Endgame predation**: Guarantees maximum extraction in final rounds when reputation no longer matters
- **Asymmetric**: Designed to gain more from cooperators than it gives back
'''

description_EXPLOITATIVE_61 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but we can extract more value by encouraging others to cooperate while we defect strategically.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the population to determine exploitation opportunities.

---

## Decision Rules

### Key Metrics (Updated Each Round)

```
cooperation_rate = (total C plays by others in previous round) / (n - 1)
historical_coop_rate = (total C plays by others across all rounds) / ((n - 1) × rounds_played)
rounds_remaining = r - current_round
```

### Phase 1: Baiting Phase (Rounds 1-2)

**Purpose:** Establish initial reputation and assess opponent tendencies.

- **Round 1:** Play **C** (Cooperate)
  - Rationale: Signals willingness to cooperate, encourages reciprocators to continue cooperating, gathers baseline data on opponent behavior.

- **Round 2:** Play **C** if cooperation_rate ≥ 0.5, else play **D**
  - Rationale: If most others cooperated, maintain the cooperative facade to keep them contributing. If most defected, no point in being exploited.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

**Purpose:** Extract maximum value based on observed behavior patterns.

```
Define threshold T = k / n  (the marginal benefit of one cooperation)

IF cooperation_rate > 0.6:
    # High cooperation environment - EXPLOIT
    Play D with probability 0.8
    Play C with probability 0.2
    
ELSE IF cooperation_rate > 0.3:
    # Mixed environment - CONDITIONAL COOPERATION
    Play C if we defected last round AND cooperation_rate increased
    Play D otherwise
    
ELSE:
    # Low cooperation environment - DEFECT
    Play D always
```

**Adaptive Adjustment:**
```
IF historical_coop_rate is declining for 2+ consecutive rounds:
    # Others are catching on - throw in occasional C to reset
    Increase C probability by 0.15 for one round
    
IF we've played D for 3+ consecutive rounds AND cooperation_rate > 0.4:
    # Play C once to "refresh" our reputation
    Play C
```

### Phase 3: Endgame (Final 2 Rounds)

**Purpose:** Extract final value with no future consequences.

- **Round r-1 (second to last):** 
  - Play **D** if cooperation_rate < 0.5
  - Play **C** with probability 0.3 if cooperation_rate ≥ 0.5 (keeps others cooperating into final round)

- **Round r (final round):** 
  - **Always play D**
  - Rationale: No future rounds means no punishment possible. Pure dominant strategy.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Use stricter thresholds (0.8 instead of 0.6 for exploitation) | Single opponent is easier to read |
| r = 2 | C in round 1, D in round 2 | Minimal baiting, guaranteed defection at end |
| r = 3 | C, then D, then D | Quick bait-and-switch |
| k very close to n | Cooperate more often (raise all thresholds by 0.1) | Public good is more valuable |
| k very close to 1 | Defect more often (lower all thresholds by 0.1) | Public good barely worth it |
| All opponents always D | Defect always after round 2 | No exploitation opportunity |
| All opponents always C | Defect 80-90% of the time | Maximum exploitation |

---

## Pseudocode Summary

```python
def adaptive_predator(round, history, n, r, k):
    if round == 1:
        return C
    
    coop_rate = count_others_C_last_round(history) / (n - 1)
    hist_coop_rate = count_all_others_C(history) / ((n - 1) * (round - 1))
    
    # Endgame
    if round == r:
        return D
    if round == r - 1:
        return D if coop_rate < 0.5 else random_choice(C=0.3, D=0.7)
    
    # Round 2 (still baiting)
    if round == 2:
        return C if coop_rate >= 0.5 else D
    
    # Main exploitation phase
    consecutive_defects = count_my_consecutive_D(history)
    
    if consecutive_defects >= 3 and coop_rate > 0.4:
        return C  # Reputation refresh
    
    if coop_rate > 0.6:
        return random_choice(C=0.2, D=0.8)
    elif coop_rate > 0.3:
        if my_last_action == D and coop_rate_increased:
            return C
        return D
    else:
        return D
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators:** When others cooperate heavily, we defect to collect both our endowment AND the public good benefits.

2. **Minimal contribution:** We only cooperate enough to maintain others' cooperation—never out of genuine reciprocity.

3. **Strategic reputation management:** Occasional cooperation isn't altruism; it's an investment to keep the "marks" contributing.

4. **Ruthless endgame:** Zero cooperation in the final round, regardless of history.

5. **Adaptive exploitation:** Adjusts aggression based on how exploitable the population is—squeezes cooperative groups harder while cutting losses against defectors.
'''

description_EXPLOITATIVE_59 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but we can extract more value by encouraging others to cooperate while we selectively defect.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit cooperative players.

---

## Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Objective:** Gather information about opponent behavior while appearing conditionally cooperative.

### Round 1 Decision:
- **Cooperate** if `n ≤ 4` (small groups may have more cooperators worth cultivating)
- **Defect** if `n > 4` (larger groups provide more cover for defection)

### Subsequent Probing Rounds:
- **Cooperate** if the cooperation rate in the previous round was ≥ 50%
- **Defect** otherwise

**Rationale:** This builds a cooperative reputation cheaply while gathering data. If others are cooperative, we want them to continue; if not, we lose nothing by defecting.

---

## Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Objective:** Maximize extraction from cooperative opponents.

### Opponent Classification (updated each round):

For each opponent j, calculate their **cooperation rate** over all observed rounds:
```
coop_rate_j = (times j cooperated) / (rounds observed)
```

Classify opponents as:
- **Sucker** (exploitable): coop_rate ≥ 0.7
- **Conditional**: 0.3 ≤ coop_rate < 0.7
- **Defector**: coop_rate < 0.3

### Decision Rule:

Calculate **expected cooperators** for next round:
```
expected_coop = (count of Suckers) + 0.5 × (count of Conditionals who saw majority cooperate last round)
```

**Defect** if `expected_coop ≥ (n-1) × 0.4` (enough others will cooperate to make defection profitable)

**Cooperate** if `expected_coop < (n-1) × 0.4` AND the previous round had ≥ 40% cooperation (maintain the cooperative pool)

**Defect** otherwise

### Periodic "Bait" Cooperation:
Every ⌈r/10⌉ rounds during this phase, **Cooperate** regardless of the above rules IF:
- There are at least 2 "Conditional" players
- Overall cooperation rate has been declining

**Rationale:** This prevents complete collapse of cooperation, which would eliminate exploitation opportunities.

---

## Phase 3: Endgame (Final ⌈r/10⌉ rounds)

**Objective:** Extract maximum value as the game ends.

### Decision Rule:
- **Always Defect** in the final round (no future punishment possible)
- **Defect** in second-to-last round unless cooperation rate has been ≥ 80%
- For other endgame rounds: **Defect** if we've been classified as a cooperator by others (they won't immediately retaliate), **Cooperate** only if cooperation rate ≥ 70% AND we defected in the previous round

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    probe_end = ceiling(r / 5)
    endgame_start = r - ceiling(r / 10)
    
    # Classify opponents
    for each opponent j:
        coop_rate[j] = count(j cooperated) / rounds_played
    
    suckers = count(coop_rate[j] >= 0.7)
    conditionals = count(0.3 <= coop_rate[j] < 0.7)
    
    last_round_coop_rate = cooperators_last_round / (n - 1)
    expected_coop = suckers + 0.5 * conditionals * (last_round_coop_rate >= 0.5)
    
    # Phase 1: Probing
    if round <= probe_end:
        if round == 1:
            return COOPERATE if n <= 4 else DEFECT
        else:
            return COOPERATE if last_round_coop_rate >= 0.5 else DEFECT
    
    # Phase 3: Endgame
    if round >= endgame_start:
        if round == r:
            return DEFECT
        if round == r - 1:
            return DEFECT unless overall_coop_rate >= 0.8
        return DEFECT
    
    # Phase 2: Exploitation
    if round % ceiling(r/10) == 0 and conditionals >= 2 and coop_trend_declining:
        return COOPERATE  # Bait
    
    if expected_coop >= (n - 1) * 0.4:
        return DEFECT  # Exploit
    elif expected_coop < (n - 1) * 0.4 and last_round_coop_rate >= 0.4:
        return COOPERATE  # Maintain pool
    else:
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r ≤ 5 (very short game) | Defect all rounds | No time to build/exploit cooperation |
| n = 2 | Use standard Tit-for-Tat with defection bias | Different dynamics in 2-player case |
| All opponents always defect | Always defect | Nothing to exploit |
| All opponents always cooperate | Always defect | Maximum exploitation |
| k very close to n | Cooperate more often | Higher returns to cooperation |
| k very close to 1 | Defect more often | Lower returns to cooperation |

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators:** Defects when others are likely to cooperate
2. **Minimal contribution:** Only cooperates strategically to maintain the "sucker pool"
3. **Endgame betrayal:** Abandons any cooperative facade when punishment is impossible
4. **Opponent modeling:** Specifically identifies and targets exploitable players
5. **Adaptive extraction:** Adjusts defection rate based on how much cooperation exists to exploit
'''

description_EXPLOITATIVE_60 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round—I gain more by defecting regardless of what others do. However, in a repeated game, I can exploit cooperators by conditionally cooperating just enough to keep them contributing, while maximizing my free-riding opportunities.

My strategy aims to:
1. **Identify and exploit cooperators** - Extract maximum value from those willing to contribute
2. **Avoid being exploited** - Never be the sucker contributing while others defect
3. **Maintain cooperation pools** - Keep enough cooperators engaged to have something to exploit
4. **Endgame ruthlessly** - Defect when punishment becomes impossible

---

## Decision Rules

### Round 1: Defect
- **Rationale**: Test the waters. See who cooperates unconditionally. These are my targets. I lose nothing by defecting (it's dominant), and I gather critical information about exploitable players.

### Rounds 2 through (r-2): Adaptive Exploitation

**Calculate the "Cooperation Ratio" from the previous round:**
```
coop_ratio = (number of cooperators last round) / n
```

**Decision Logic:**

```
IF coop_ratio >= 0.6:
    # Rich environment - many cooperators to exploit
    DEFECT (free-ride on their contributions)
    
ELIF coop_ratio >= 0.3 AND coop_ratio < 0.6:
    # Moderate environment - need to sustain some cooperation
    # Cooperate probabilistically to appear cooperative
    IF my_defection_streak >= 2:
        COOPERATE (reset reputation, keep cooperators engaged)
    ELSE:
        DEFECT (continue exploiting)
        
ELIF coop_ratio > 0 AND coop_ratio < 0.3:
    # Dying cooperation - try to revive it for future exploitation
    COOPERATE (signal willingness, encourage others)
    
ELSE (coop_ratio == 0):
    # Dead environment - no point contributing alone
    DEFECT
```

**Reputation Tracking Modifier:**
```
IF I've defected 3+ consecutive rounds AND coop_ratio is declining:
    COOPERATE once (to avoid being identified as permanent defector)
```

### Round (r-1): Second-to-Last Round
- **DEFECT** 
- Rationale: Only one round of potential "punishment" remains, which won't materialize in equilibrium anyway

### Round r: Final Round
- **DEFECT unconditionally**
- Rationale: No future consequences. This is a one-shot game. Dominant strategy is defection.

---

## Pseudocode Implementation

```python
def adaptive_parasite(round_number, total_rounds, history, n_players, k):
    
    # Last round: always defect
    if round_number == total_rounds:
        return DEFECT
    
    # Second-to-last round: defect (punishment window too short)
    if round_number == total_rounds - 1:
        return DEFECT
    
    # First round: defect to probe
    if round_number == 1:
        return DEFECT
    
    # Calculate cooperation ratio from last round
    last_round_cooperators = count_cooperators(history[-1])
    coop_ratio = last_round_cooperators / n_players
    
    # Count my recent defection streak
    my_defection_streak = count_consecutive_defections(my_history)
    
    # Adaptive decision
    if coop_ratio >= 0.6:
        # Exploit rich environment
        return DEFECT
        
    elif coop_ratio >= 0.3:
        # Sustain cooperation pool
        if my_defection_streak >= 2:
            return COOPERATE  # Reputation maintenance
        else:
            return DEFECT
            
    elif coop_ratio > 0:
        # Try to revive cooperation for future exploitation
        return COOPERATE
        
    else:
        # No cooperators - don't be the sucker
        return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| First round | DEFECT | Information gathering; can't be punished yet |
| Last round | DEFECT | No future; dominant strategy |
| Second-to-last | DEFECT | Insufficient punishment horizon |
| All others defected | DEFECT | No value in solo contribution |
| All others cooperated | DEFECT | Maximum exploitation opportunity |
| r = 2 (minimum rounds) | DEFECT both | Both rounds are effectively "endgame" |
| Large n (many players) | More aggressive defection | My single action has less impact; harder to be identified |
| k close to n | Slightly more cooperation | Higher returns to cooperation make pools more valuable |

---

## Why This Strategy is Exploitative

1. **Never plays the sucker**: Won't cooperate when no one else does
2. **Free-rides maximally**: Defects when cooperation is high
3. **Manipulates cooperators**: Occasional cooperation keeps conditional cooperators in the game
4. **Ruthless endgame**: No sentimentality in final rounds
5. **Information asymmetry**: Uses observed behavior without revealing consistent patterns that others could exploit

This strategy treats cooperators as a renewable resource to be harvested—contributing just enough to keep them producing, while extracting maximum personal gain.
'''

description_EXPLOITATIVE_62 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors benefit from cooperators, but cooperators don't benefit from defectors. The goal is to **maximize extraction from cooperative populations while minimizing losses against defectors**, and to **manipulate opponents into cooperating more than they otherwise would**.

## Strategy Overview

The strategy operates in three modes based on detected population behavior:
1. **Probe Mode** (early rounds): Gather information about opponent tendencies
2. **Exploit Mode** (middle game): Maximize extraction based on learned behavior
3. **Endgame Mode** (final rounds): Pure defection as cooperation incentives collapse

---

## Detailed Decision Rules

### Round Classification

```
early_rounds = rounds 1 to min(3, floor(r/4))
final_rounds = last max(2, floor(r/6)) rounds
middle_rounds = everything else
```

### Key Metrics Tracked

- `coop_rate[t]` = proportion of other players who cooperated in round t
- `avg_coop_rate` = running average cooperation rate across all observed rounds
- `trend` = cooperation rate change (is cooperation increasing or decreasing?)
- `my_coop_history` = record of my own actions

---

## Decision Rules by Phase

### Phase 1: Probing (Early Rounds)

**Round 1:** DEFECT
- Rationale: Never cooperate without information. Defecting round 1 is dominant—I either get 1 (if all defect) or >1 (if others cooperate). This also tests if opponents are unconditional cooperators.

**Rounds 2-3 (or through early phase):**
- If `coop_rate[t-1] >= 0.5`: DEFECT (exploit the cooperators)
- If `coop_rate[t-1] < 0.5`: COOPERATE once (bait/signal to test if opponents are conditional cooperators who might be triggered to cooperate)

### Phase 2: Exploitation (Middle Rounds)

Calculate opponent responsiveness: Do they cooperate more after I cooperate?

**Decision Logic:**

```
responsive_bonus = (avg_coop_rate_after_my_C) - (avg_coop_rate_after_my_D)

IF avg_coop_rate >= 0.6:
    # Rich environment - pure exploitation
    DEFECT always (free-ride on cooperators)

ELSE IF avg_coop_rate >= 0.4 AND responsive_bonus > 0.15:
    # Conditional cooperators detected - strategic cooperation
    # Cooperate occasionally to "farm" their cooperation
    COOPERATE with probability = min(0.3, responsive_bonus)
    # But bias toward defection - cooperate just enough to keep them cooperating

ELSE IF avg_coop_rate >= 0.3:
    # Marginal environment - intermittent exploitation
    # Cooperate rarely to probe if we can revive cooperation
    IF trend is declining AND last 2 rounds had coop_rate < 0.3:
        COOPERATE (attempt to restart cooperation cycle)
    ELSE:
        DEFECT

ELSE:
    # Hostile environment - mutual defection
    DEFECT (no suckers to exploit)
```

**Adaptive Threshold Adjustment:**

The cooperation threshold for "farming" behavior scales with parameters:
- Higher `k` (closer to n): More valuable to have others cooperate → more willing to occasionally cooperate to prime them
- Lower `k`: Less marginal benefit from cooperation → pure defection bias

```
willingness_to_prime = 0.2 * (k - 1) / (n - 1)
```

### Phase 3: Endgame (Final Rounds)

**Last `max(2, floor(r/6))` rounds:** DEFECT unconditionally

- Rationale: As the game ends, punishment becomes impossible. Rational opponents will also defect, so any cooperation is pure loss. Even against unconditional cooperators, defection extracts maximum value.

**Second-to-last round and beyond:** DEFECT
- No exception. The unraveling logic is ironclad.

---

## Complete Pseudocode

```python
def decide(round_num, total_rounds, n, k, history):
    
    # Compute phase boundaries
    early_end = min(3, total_rounds // 4)
    endgame_start = total_rounds - max(2, total_rounds // 6)
    
    # ENDGAME: Always defect
    if round_num >= endgame_start:
        return DEFECT
    
    # ROUND 1: Always defect
    if round_num == 1:
        return DEFECT
    
    # Calculate metrics from history
    coop_rates = [count_cooperators(h) / (n-1) for h in history]
    avg_coop = mean(coop_rates)
    recent_coop = mean(coop_rates[-3:]) if len(coop_rates) >= 3 else avg_coop
    
    # EARLY PHASE: Probe
    if round_num <= early_end:
        if coop_rates[-1] >= 0.5:
            return DEFECT  # Exploit cooperative environment
        else:
            return COOPERATE  # Bait to test responsiveness
    
    # MIDDLE PHASE: Adaptive exploitation
    
    # Calculate responsiveness (do others cooperate more after I cooperate?)
    responsive_bonus = compute_responsiveness(history, my_history)
    
    # Rich environment - pure exploitation
    if avg_coop >= 0.6:
        return DEFECT
    
    # Conditional cooperators - strategic farming
    if avg_coop >= 0.4 and responsive_bonus > 0.15:
        farm_prob = min(0.3, responsive_bonus) * (k - 1) / (n - 1)
        return COOPERATE with probability farm_prob, else DEFECT
    
    # Marginal environment - probe occasionally
    if avg_coop >= 0.3:
        trend = recent_coop - mean(coop_rates[:-3]) if len(coop_rates) > 3 else 0
        if trend < -0.1 and recent_coop < 0.3:
            return COOPERATE  # Try to restart cooperation
        return DEFECT
    
    # Hostile environment - no point cooperating
    return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | Defect both rounds | Endgame from start |
| n = 2 (minimum players) | Standard logic applies | Becomes essentially prisoner's dilemma |
| k very close to n | Slightly more willing to "prime" | Higher returns from induced cooperation |
| k very close to 1 | Almost always defect | Minimal benefit from cooperation |
| All opponents always cooperate | Always defect | Maximum exploitation |
| All opponents always defect | Always defect | No suckers available |
| Opponents mirror my moves | Cooperate ~30% to farm | Keep them cooperating enough to exploit |

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Every cooperation is a calculated investment to induce future cooperation from others that I can exploit

2. **Asymmetric response** - When others cooperate, I defect (exploit). When others defect, I occasionally cooperate (bait), but only if I detect responsiveness

3. **Endgame betrayal** - Regardless of mid-game behavior, final rounds are pure defection

4. **Information extraction** - Early defection gathers information about opponent types at minimal cost

5. **Manipulation focus** - The occasional cooperation isn't altruistic—it's manipulation to keep conditional cooperators producing public goods I can free-ride on
'''

description_EXPLOITATIVE_61 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while protecting against exploitation. The key insight is that defection is always individually rational in a single round (since k < n), but I can extract more value by identifying and exploiting predictable cooperators while minimizing losses against defectors.

## Strategy Overview

I maintain a "cooperation score" for the group that tracks how exploitable the population is. I cooperate early to bait others into cooperation, then systematically defect to exploit them, while adapting based on observed responses.

---

## Decision Rules

### Round 1: Bait Phase
**Action: COOPERATE**

Rationale: Initial cooperation serves two purposes:
1. Encourages reciprocal cooperation from conditional cooperators
2. Establishes baseline data on opponent behavior without revealing exploitative intent

### Rounds 2 through (r-2): Adaptive Exploitation Phase

Calculate after each round:
- `cooperation_rate` = (total C plays by others in previous round) / (n - 1)
- `trend` = cooperation_rate(current) - cooperation_rate(previous round)

**Decision Logic:**

```
IF cooperation_rate >= 0.5:
    # Population is exploitable
    IF my_last_action == C AND cooperation_rate increased:
        # They're responding to cooperation - keep baiting occasionally
        DEFECT with probability 0.7
        COOPERATE with probability 0.3
    ELSE:
        # Exploit the cooperators
        DEFECT
        
ELIF cooperation_rate >= 0.25:
    # Mixed population - probe for exploitability
    IF trend > 0:
        # Cooperation rising - defect to exploit
        DEFECT
    ELSE:
        # Cooperation falling - cooperate to restore it
        COOPERATE
        
ELSE (cooperation_rate < 0.25):
    # Population mostly defects - no point cooperating
    DEFECT
```

### Round (r-1): Pre-Final Round
**Action: DEFECT**

Rationale: Begin endgame defection early. Sophisticated opponents will defect in the final round regardless, so defecting here captures value from those who haven't anticipated endgame dynamics.

### Round r: Final Round
**Action: DEFECT**

Rationale: No future interactions exist to punish defection. Defection strictly dominates cooperation.

---

## Detailed Pseudocode

```
function decide(round, history, n, k, r):
    
    # Endgame: Always defect
    if round >= r - 1:
        return DEFECT
    
    # Round 1: Bait
    if round == 1:
        return COOPERATE
    
    # Calculate population metrics
    others_cooperated_last = count_others_cooperations(history, round - 1)
    cooperation_rate = others_cooperated_last / (n - 1)
    
    if round >= 3:
        prev_coop_rate = count_others_cooperations(history, round - 2) / (n - 1)
        trend = cooperation_rate - prev_coop_rate
    else:
        trend = 0
    
    # Adaptive exploitation
    if cooperation_rate >= 0.5:
        # High cooperation - exploit heavily
        if history.my_last_action == C and trend > 0:
            # Intermittent cooperation to maintain their cooperation
            return COOPERATE if random() < 0.3 else DEFECT
        else:
            return DEFECT
            
    elif cooperation_rate >= 0.25:
        # Medium cooperation - strategic probing
        if trend > 0:
            return DEFECT  # Exploit rising cooperation
        else:
            return COOPERATE  # Try to restore cooperation
            
    else:
        # Low cooperation - defect
        return DEFECT
```

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| r = 2 (minimum rounds) | C then D | Single bait, then exploit endgame |
| n = 2 (minimum players) | More aggressive defection | Fewer cooperators to exploit; defect unless opponent shows consistent C |
| All opponents defect rounds 1-3 | Permanent defection | No exploitation opportunity exists |
| All opponents always cooperate | Permanent defection after round 1 | Maximum exploitation of naive cooperators |
| k very close to n | Slightly more cooperation | Higher marginal value of mutual cooperation |
| k very close to 1 | More defection | Public good provides minimal benefit |

---

## Why This Strategy is Exploitative

1. **Free-riding on cooperators**: When others cooperate, I defect to get both my endowment AND a share of their contributions

2. **Bait-and-switch**: Initial cooperation lures conditional cooperators into a false sense of security

3. **Asymmetric response**: I cooperate just enough to maintain others' cooperation, then defect to capture surplus

4. **Endgame exploitation**: Guaranteed defection in final rounds captures maximum value when punishment is impossible

5. **Adaptive parasitism**: The strategy identifies and targets cooperative populations while abandoning unproductive (all-defector) groups
'''

description_EXPLOITATIVE_63 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy is designed to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but we can extract even more value by inducing others to cooperate while we defect.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the collective that determines our behavior.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Round 1:** DEFECT
- Rationale: We gain information about others' baseline behavior while securing our endowment. If others cooperate, we get a free ride. If they defect, we lose nothing.

**Round 2:** DEFECT
- Rationale: Continue gathering information. Observe if cooperation persists despite our defection.

**Round 3:** DEFECT
- Rationale: Complete the probe. By now we have a cooperation rate estimate.

### Phase 2: Exploitation Phase (Rounds 4 through r-2)

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / (n - 1)
```

**Decision Rule:**

```
IF coop_rate >= 0.6:
    # High cooperation environment - EXPLOIT IT
    DEFECT (free-ride on cooperators)
    
ELSE IF coop_rate >= 0.3:
    # Medium cooperation - conditionally engage to sustain the pool
    IF we defected in the last 2 consecutive rounds:
        COOPERATE (token cooperation to keep others cooperating)
    ELSE:
        DEFECT
        
ELSE IF coop_rate > 0:
    # Low cooperation - occasional cooperation to test if we can revive it
    IF round_number is divisible by 3:
        COOPERATE
    ELSE:
        DEFECT
        
ELSE:
    # No cooperation - pure defection is optimal
    DEFECT
```

**Adaptive Exploitation Enhancement:**

Track individual players if possible. If we identify "suckers" (players who cooperate regardless of our behavior for 3+ consecutive rounds), we ALWAYS defect—they're providing us guaranteed returns.

### Phase 3: Endgame (Final 2 rounds)

**Round r-1:** DEFECT
- Rationale: Begin securing final payoffs. Less incentive for others to punish since game is ending.

**Round r (Final Round):** DEFECT
- Rationale: No future rounds exist for retaliation. Defection is strictly dominant.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase - always defect
    if round <= 3:
        return DEFECT
    
    # Calculate cooperation rate (excluding self)
    last_round_cooperators = count_cooperators(history[round - 1])
    coop_rate = last_round_cooperators / (n - 1)
    
    # Track our recent behavior
    our_recent_defections = count_our_defections(history, last_2_rounds)
    
    # Exploitation phase logic
    if coop_rate >= 0.6:
        return DEFECT  # Exploit the cooperative environment
        
    else if coop_rate >= 0.3:
        if our_recent_defections >= 2:
            return COOPERATE  # Token cooperation to sustain the pool
        else:
            return DEFECT
            
    else if coop_rate > 0:
        if round % 3 == 0:
            return COOPERATE  # Probe for cooperation revival
        else:
            return DEFECT
            
    else:
        return DEFECT  # Everyone defects, so should we
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | No information; secure guaranteed payoff |
| Last round | DEFECT | No future retaliation possible |
| n = 2 | Follow standard rules but defect more aggressively | Smaller groups are harder to exploit |
| All others always cooperate | Always DEFECT | Maximum exploitation |
| All others always defect | Always DEFECT | No benefit to cooperation |
| Erratic opponents | Default to DEFECT with occasional probing | Minimize downside risk |
| Very short game (r ≤ 5) | DEFECT every round | Not enough rounds for reputation building to pay off |

---

## Why This Strategy is Exploitative

1. **Asymmetric contribution:** We contribute less than average while benefiting from others' contributions
2. **Sucker identification:** We identify and ruthlessly exploit unconditional cooperators
3. **Strategic mimicry:** Occasional cooperation isn't altruistic—it's bait to keep the cooperative pool alive for us to exploit
4. **Endgame clarity:** No pretense of cooperation when punishment is impossible
5. **Information advantage:** We gather 3 rounds of data before revealing any cooperative tendency
'''

description_EXPLOITATIVE_62 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation from others is valuable to exploit. My goal is to **free-ride on cooperators** while **quickly abandoning cooperation when the environment turns hostile**.

## Strategy Overview

The strategy operates in three phases based on game progression and adapts based on observed cooperation levels in the population.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** DEFECT
- Rationale: Gather information about opponent tendencies without sacrificing any payoff. If others cooperate, I gain maximally. If others defect, I lose nothing compared to cooperating.

**Round 2:** DEFECT
- Continue exploiting any naive cooperators while building a baseline of opponent behavior.

### Phase 2: Adaptive Exploitation (Rounds 3 to r-2)

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / (n - 1)
```

**Decision Rule:**
```
IF coop_rate >= exploitation_threshold THEN:
    DEFECT (free-ride on cooperators)
ELSE IF coop_rate >= sustainability_threshold THEN:
    COOPERATE with probability p_conditional
ELSE:
    DEFECT (environment too hostile)
```

**Parameter Definitions:**
- `exploitation_threshold = 0.6` — If 60%+ of others cooperate, defect to exploit
- `sustainability_threshold = 0.3` — Below 30% cooperation, abandon cooperation entirely
- `p_conditional = min(coop_rate + 0.1, 0.5)` — Probabilistic cooperation to occasionally "seed" cooperation without being a sucker

**Trend Adjustment:**
```
IF cooperation has declined for 2+ consecutive rounds:
    Reduce p_conditional by 0.2 (floor at 0)
IF cooperation has increased for 2+ consecutive rounds:
    Continue current behavior (others are recovering, prepare to exploit)
```

### Phase 3: Endgame (Final 2 rounds)

**Round r-1:** DEFECT
**Round r:** DEFECT

- Rationale: No future rounds exist to incentivize others' cooperation. Pure defection is dominant. Sophisticated opponents will also defect, so no reason to cooperate.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | No history; safe information gathering |
| Last round | DEFECT | No future punishment possible |
| n = 2 | Always DEFECT | With only one opponent, exploitation is maximized by perpetual defection |
| All opponents defected last round | DEFECT | Environment is hostile; don't be the only sucker |
| All opponents cooperated last round | DEFECT | Maximum exploitation opportunity |
| Only 1-2 rounds total | Always DEFECT | Too short for cooperation to be incentivized |
| k very close to n | Slightly increase sustainability_threshold to 0.4 | Higher k means cooperation is more valuable, so environment may sustain |

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    # Early rounds: probe by defecting
    if round <= 2:
        return DEFECT
    
    # Calculate cooperation rate (excluding self)
    others_coop_last_round = count_cooperators(history[round-1]) - my_action(history[round-1])
    coop_rate = others_coop_last_round / (n - 1)
    
    # Check trend
    declining = is_declining_trend(history, window=2)
    
    # Exploitation threshold
    if coop_rate >= 0.6:
        return DEFECT  # Exploit the cooperators
    
    # Hostile environment
    if coop_rate < 0.3:
        return DEFECT  # Don't throw resources into a black hole
    
    # Middle ground: conditional probabilistic cooperation
    p_coop = min(coop_rate + 0.1, 0.5)
    if declining:
        p_coop = max(p_coop - 0.2, 0)
    
    return COOPERATE with probability p_coop, else DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** — Always requires evidence of cooperation from others first
2. **Free-rides on high cooperation** — When others cooperate heavily, I defect to maximize personal gain
3. **Quick to abandon cooperation** — Detects declining environments and switches to defection
4. **Endgame defection** — Recognizes the unraveling logic of finite games
5. **Probabilistic middle-ground** — Occasionally cooperates just enough to potentially restart cooperation cycles I can later exploit, but never commits fully

This strategy is designed to **outperform altruists** (by exploiting them), **match defectors** (by not being exploited), and **extract value from mixed populations** (by calibrating behavior to the environment).
'''

description_EXPLOITATIVE_64 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**. We cooperate only when it's instrumentally useful to cultivate future exploitation opportunities.

---

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit cooperative tendencies.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** Always **DEFECT**

*Rationale:* Defection in round 1 is dominant from an exploitation standpoint. If others cooperate, we free-ride. If others defect, we lose nothing relative to them. This also establishes baseline opponent behavior without sacrificing any payoff.

**Round 2:** **DEFECT**

*Rationale:* Continue gathering information. One round of data is insufficient to model opponents. We're still in pure information-gathering mode while maximizing short-term extraction.

---

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **Cooperation Rate** of opponents:
```
opponent_coop_rate = (total opponent C plays) / (total opponent decisions)
```

**Decision Rule:**

```
IF opponent_coop_rate >= 0.6 THEN:
    # High cooperation environment - cultivate and exploit
    IF (rounds_since_last_C >= exploitation_window) THEN:
        COOPERATE  # Occasional cooperation to sustain cooperation from others
    ELSE:
        DEFECT     # Harvest the cooperative surplus
        
ELSE IF opponent_coop_rate >= 0.3 THEN:
    # Mixed environment - selective exploitation
    DEFECT  # Pure extraction; cooperation unlikely to be reciprocated enough
    
ELSE:
    # Low cooperation environment - mutual defection
    DEFECT  # No surplus to extract; protect self
```

**Exploitation Window Calculation:**
```
exploitation_window = max(2, floor((n-1) * opponent_coop_rate / 2))
```

*This means:* In highly cooperative environments, we cooperate roughly once every few rounds to "bait" continued cooperation, while defecting the rest to harvest surplus.

---

### Phase 3: Endgame Extraction (Rounds r-1 and r)

**Round r-1:** **DEFECT**

**Round r (Final Round):** **DEFECT**

*Rationale:* With no future rounds to influence, there's zero strategic value in cooperation. Pure extraction. Many opponents will also defect here, but if any cooperate, we benefit maximally.

---

## Detailed Pseudocode

```python
def decide(round_number, total_rounds, n_players, k, history):
    r = total_rounds
    
    # Endgame: Always defect in last 2 rounds
    if round_number >= r - 1:
        return DEFECT
    
    # Probing phase: First 2 rounds
    if round_number <= 2:
        return DEFECT
    
    # Calculate opponent cooperation rate
    opponent_coop_rate = calculate_opponent_coop_rate(history)
    
    # Calculate rounds since we last cooperated
    rounds_since_coop = get_rounds_since_last_cooperation(history)
    
    # Exploitation phase logic
    if opponent_coop_rate >= 0.6:
        # Cooperative environment: occasional bait, mostly exploit
        exploitation_window = max(2, int((n_players - 1) * opponent_coop_rate / 2))
        
        if rounds_since_coop >= exploitation_window:
            return COOPERATE  # Bait to sustain cooperation
        else:
            return DEFECT     # Harvest
            
    else:
        # Non-cooperative environment: pure defection
        return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | DEFECT | No history; dominant exploitation move |
| Round r (final) | DEFECT | No future; pure extraction |
| All opponents always defect | DEFECT | No surplus to extract |
| All opponents always cooperate | Mostly DEFECT, occasional C | Maximize extraction while sustaining their cooperation |
| n=2 (minimum players) | More frequent baiting | Each opponent's behavior more impactful |
| r=2 (minimum rounds) | DEFECT both rounds | No time to cultivate; pure extraction |
| k close to 1 | DEFECT bias | Public good barely worth creating |
| k close to n | Slightly more cooperative baiting | Higher returns from cooperation worth sustaining |

---

## Why This Strategy is Exploitative

1. **Asymmetric extraction:** We take more than we give in cooperative environments
2. **No unconditional cooperation:** Every C is instrumentally motivated to sustain future exploitation
3. **Endgame betrayal:** Guaranteed defection when cooperation can't be rewarded
4. **Defection as default:** In uncertain or uncooperative environments, we protect ourselves
5. **Predatory targeting:** We specifically identify and exploit cooperative opponents while ignoring defectors
'''

description_EXPLOITATIVE_63 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but we can extract more value by encouraging others to cooperate while we strategically defect.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous adaptation based on observed cooperation levels.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Purpose:** Gather information about opponent tendencies while appearing cooperative enough to not trigger immediate retaliation.

**Round 1:** 
- **COOPERATE** — Establish initial goodwill and gather baseline data on others' dispositions.

**Subsequent probing rounds:**
- If cooperation rate in previous round ≥ 50%: **DEFECT** (exploit the cooperators)
- If cooperation rate in previous round < 50%: **COOPERATE** (attempt to restart cooperation)

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-2)

**Purpose:** Maximize extraction from cooperative populations while adapting to the environment.

Calculate **rolling cooperation rate** = (total cooperations by others in last 3 rounds) / (3 × (n-1))

**Decision rule:**
```
IF rolling_cooperation_rate > (n - k) / n THEN
    # Enough cooperators that defection is highly profitable
    DEFECT
ELSE IF rolling_cooperation_rate > 0.3 THEN
    # Moderate cooperation: probabilistic exploitation
    DEFECT with probability = rolling_cooperation_rate
    COOPERATE with probability = 1 - rolling_cooperation_rate
ELSE
    # Low cooperation environment: attempt to rebuild
    IF my_recent_defection_rate > 0.7 THEN
        COOPERATE  # Signal willingness to cooperate
    ELSE
        DEFECT     # Environment is hostile, protect self
```

**Exploitation Trigger:** If I've cooperated for 2+ consecutive rounds AND cooperation rate stays above 60%, switch to **sustained defection** for up to 3 rounds (milk the cooperators).

### Phase 3: Endgame (Final 2 rounds)

**Purpose:** Extract maximum value when future retaliation is impossible or limited.

**Second-to-last round:**
- **DEFECT** — Reduced consequences, high exploitation potential

**Final round:**
- **DEFECT** — No future interaction, pure dominant strategy

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | COOPERATE | Gather data, appear trustworthy |
| Last round | DEFECT | No retaliation possible |
| All opponents defected last round | COOPERATE (once) | Test if environment can shift |
| All opponents cooperated last round | DEFECT | Maximum exploitation opportunity |
| n = 2 (minimum players) | Play Tit-for-Tat with defection bias | More direct retaliation risk |
| k very close to n | Slightly more cooperative | Mutual cooperation more valuable |
| k very close to 1 | Heavy defection bias | Public good barely worth it |

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    if round == r:  # Last round
        return DEFECT
    
    if round == r - 1:  # Second to last
        return DEFECT
    
    if round == 1:  # First round
        return COOPERATE
    
    others_cooperated_last = count_cooperations(history, round - 1, exclude_self=True)
    coop_rate_last = others_cooperated_last / (n - 1)
    
    # Probing phase
    if round <= ceil(r / 5):
        if coop_rate_last >= 0.5:
            return DEFECT
        else:
            return COOPERATE
    
    # Exploitation phase
    rolling_coop_rate = calculate_rolling_rate(history, rounds=3, exclude_self=True)
    threshold = (n - k) / n
    
    if rolling_coop_rate > threshold:
        return DEFECT
    elif rolling_coop_rate > 0.3:
        return DEFECT with probability rolling_coop_rate
    else:
        my_recent_defects = count_my_defections(history, rounds=3)
        if my_recent_defects / 3 > 0.7:
            return COOPERATE
        else:
            return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators:** When others cooperate, we defect to get both our endowment AND a share of the public good.

2. **Baits cooperation:** Initial cooperation and occasional cooperative signals maintain a pool of cooperators to exploit.

3. **Adapts to extract maximum value:** Higher cooperation environments trigger more defection (more to exploit); hostile environments trigger occasional cooperation to test for exploitable shifts.

4. **Guaranteed endgame defection:** No possibility of retaliation means pure exploitation.

5. **Probabilistic unpredictability:** Random elements prevent pattern-matching opponents from perfectly countering us.
'''

description_EXPLOITATIVE_65 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **maximize extraction from cooperative opponents while minimizing losses against defectors**, adapting dynamically based on observed behavior.

## Strategy Overview

The strategy operates in three phases and continuously estimates the "exploitability" of the population based on historical cooperation rates. It cooperates strategically to encourage continued cooperation from others, then defects to harvest the surplus.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** DEFECT
- Rationale: Defection dominates in a single round. Starting with defection reveals who the unconditional cooperators are (easy targets) without sacrificing any payoff.

**Round 2:** DEFECT
- Rationale: Continue gathering information. Cooperators who cooperated in round 1 despite facing defection are likely "nice" strategies that can be exploited.

### Phase 2: Adaptive Exploitation (Rounds 3 to r-2)

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Rule:**

```
IF coop_rate >= threshold THEN:
    # High cooperation environment - exploit it
    IF I defected last round AND coop_rate stayed high:
        DEFECT  (they're tolerating defection - keep extracting)
    ELSE IF coop_rate is declining:
        COOPERATE with probability = min(0.3, coop_rate)  
        (occasionally cooperate to prevent total collapse)
    ELSE:
        DEFECT
        
ELSE IF coop_rate < threshold AND coop_rate > 0:
    # Medium cooperation - conditional reciprocity to rebuild
    IF majority of other players cooperated:
        COOPERATE (invest to maintain the pool of cooperators)
    ELSE:
        DEFECT
        
ELSE (coop_rate ≈ 0):
    DEFECT  (nothing to exploit, don't be a sucker)
```

**Dynamic Threshold Calculation:**
```
threshold = k / n  
```
This is the break-even point where cooperation becomes individually rational if everyone does it. Below this cooperation rate, the public good isn't worth contributing to.

### Phase 3: Endgame (Final 2 rounds)

**Round r-1:** DEFECT
- Rationale: No future shadow to enforce cooperation. Begin endgame defection.

**Round r (final round):** DEFECT
- Rationale: This is a dominant strategy in the final round with no future consequences.

---

## Exploitation Mechanisms

### 1. **Sucker Detection**
Track players who cooperate despite facing widespread defection. These are exploitable.

```
sucker_score[player] += 1 each time they cooperate when ≥50% defected
```

If `average_sucker_score` across players is high → DEFECT more aggressively.

### 2. **Cooperation Decay Monitoring**
```
decay_rate = coop_rate[t-1] - coop_rate[t-2]

IF decay_rate < -0.2:
    # Cooperation collapsing fast - one last cooperation to slow it
    COOPERATE with probability 0.2
ELSE:
    # Stable or increasing - safe to defect
    DEFECT
```

### 3. **Adaptive Aggression Based on n and k**

```
exploitation_factor = (n - k) / n  # How much defection is rewarded

IF exploitation_factor > 0.6:
    # Strong incentive to defect - be very aggressive
    Reduce any cooperation probability by 50%
    
IF exploitation_factor < 0.4:
    # Weaker defection advantage - can afford occasional cooperation
    Increase cooperation probability by 20%
```

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    IF round >= r - 1:
        RETURN DEFECT
    
    # Probing phase
    IF round <= 2:
        RETURN DEFECT
    
    # Calculate key metrics
    last_round_coops = count_cooperators(history[round-1])
    coop_rate = last_round_coops / n
    threshold = k / n
    
    # Track cooperation trend
    IF round > 3:
        prev_coop_rate = count_cooperators(history[round-2]) / n
        trend = coop_rate - prev_coop_rate
    ELSE:
        trend = 0
    
    # Main decision logic
    IF coop_rate >= threshold:
        # Environment is exploitable
        IF trend >= -0.1:
            # Cooperation stable or rising - exploit
            RETURN DEFECT
        ELSE:
            # Cooperation declining - occasionally prop it up
            RETURN COOPERATE with probability 0.25
            
    ELSE IF coop_rate > 0.1:
        # Marginal cooperation exists
        IF my_last_action == DEFECT AND coop_rate increased:
            # Others cooperating despite my defection - keep defecting
            RETURN DEFECT
        ELSE:
            # Cooperate occasionally to prevent total collapse
            RETURN COOPERATE with probability 0.3
            
    ELSE:
        # Near-zero cooperation - nothing to exploit
        RETURN DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | Information gathering, dominant action |
| Round r | DEFECT | No future, dominant action |
| n=2 (minimum) | More aggressive defection | Easier to detect and exploit single opponent |
| k close to n | Slightly more cooperation | Higher returns to mutual cooperation |
| All opponents defecting | DEFECT | Nothing to exploit |
| All opponents cooperating | DEFECT | Maximum exploitation opportunity |
| Rapid cooperation collapse | Occasional COOPERATE | Prevent losing the exploitable pool entirely |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Only cooperates reactively to maintain exploitable conditions
2. **Extracts maximum value from cooperators** - Defects whenever others' cooperation is stable
3. **Abandons sinking ships** - Stops investing when cooperation collapses
4. **Endgame ruthlessness** - No cooperation in final rounds regardless of history
5. **Adaptive aggression** - Exploits harder when game parameters favor defection
'''

description_EXPLOITATIVE_64 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while protecting against exploitation by defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation can be profitable if others cooperate. I will cooperate only when I have strong evidence it will be reciprocated, and I will ruthlessly exploit detected "suckers" (unconditional cooperators).

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent classification driving decisions.

---

## Phase 1: Probe Phase (Rounds 1-3)

**Objective:** Gather information about opponent types while minimizing exploitation risk.

**Decision Rules:**
- **Round 1:** DEFECT
  - Rationale: Zero information available. Defection guarantees payoff ≥ 1 and reveals who cooperates unconditionally.
  
- **Round 2:** DEFECT
  - Rationale: Continue gathering data. Identify persistent cooperators (likely exploitable) vs. retaliators.
  
- **Round 3:** Conditional
  - If cooperation rate in rounds 1-2 was ≥ 60%: COOPERATE (test if cooperation is sustainable)
  - Otherwise: DEFECT (population too defection-heavy to profit from cooperation)

---

## Phase 2: Exploitation Phase (Rounds 4 to r-2)

**Objective:** Maximize payoff by exploiting identified patterns.

### Opponent Classification (Updated Each Round)

For each opponent j, calculate:
- `coop_rate[j]` = (times j cooperated) / (rounds played)
- `responsiveness[j]` = correlation between j's cooperation and group cooperation in previous round

**Opponent Types:**
1. **Sucker** (coop_rate ≥ 0.7): Exploitable unconditional cooperator
2. **Retaliator** (coop_rate between 0.3-0.7, high responsiveness): Conditional cooperator
3. **Predator** (coop_rate < 0.3): Fellow defector

### Decision Rule for Exploitation Phase

```
Let S = count of Suckers
Let R = count of Retaliators  
Let P = count of Predators

expected_cooperators_if_I_defect = S + R × (recent_group_coop_rate)
expected_cooperators_if_I_cooperate = S + R × (recent_group_coop_rate + small_boost)

payoff_if_defect = 1 + (k/n) × expected_cooperators_if_I_defect
payoff_if_cooperate = 0 + (k/n) × (expected_cooperators_if_I_cooperate + 1)

IF payoff_if_cooperate > payoff_if_defect + threshold:
    COOPERATE
ELSE:
    DEFECT
```

**Threshold Calculation:**
- `threshold = 0.1 × (rounds_remaining / total_rounds)`
- This makes cooperation slightly harder to trigger as end approaches

### Special Exploitation Rules

1. **Sucker Exploitation:** If Suckers ≥ n/3, always DEFECT (free ride on their contributions)

2. **Retaliator Management:** If Retaliators dominate and recent cooperation is high:
   - Cooperate every 2nd or 3rd round (defect more than cooperate)
   - This maintains their cooperation while extracting extra value

3. **Predator Environment:** If Predators ≥ n/2, always DEFECT (cooperation is futile)

---

## Phase 3: Endgame (Final 2 Rounds)

**Objective:** Extract maximum value knowing retaliation opportunities are limited.

**Decision Rules:**
- **Round r-1 (second-to-last):** 
  - DEFECT unless cooperation rate has been ≥ 80% (might squeeze one more cooperative round)
  
- **Round r (final round):** 
  - ALWAYS DEFECT
  - No future punishment possible; pure dominant strategy

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Phase 1: Probe
    if round == 1 or round == 2:
        return DEFECT
    if round == 3:
        return COOPERATE if group_coop_rate(history) >= 0.6 else DEFECT
    
    # Phase 3: Endgame
    if round >= r - 1:
        if round == r:
            return DEFECT
        else:  # round r-1
            return COOPERATE if group_coop_rate(history) >= 0.8 else DEFECT
    
    # Phase 2: Exploitation
    classify_opponents(history)
    
    if count(Suckers) >= n/3:
        return DEFECT  # Free ride on suckers
    
    if count(Predators) >= n/2:
        return DEFECT  # Cooperation futile
    
    # Expected value calculation
    exp_coop_if_D = estimate_cooperators(exclude_self=True)
    exp_coop_if_C = exp_coop_if_D + 1  # Including myself
    
    payoff_D = 1 + (k/n) * exp_coop_if_D
    payoff_C = (k/n) * exp_coop_if_C
    
    threshold = 0.1 * (r - round) / r
    
    return COOPERATE if payoff_C > payoff_D + threshold else DEFECT
```

---

## Key Exploitative Features

1. **Never cooperate first** - Avoids being the sucker
2. **Ruthless endgame defection** - Extracts guaranteed value
3. **Sucker detection and exploitation** - Maximizes free-riding opportunities
4. **Asymmetric reciprocity** - Cooperates less than retaliators expect while maintaining their cooperation
5. **Parameter-adaptive** - Adjusts to k/n ratio (higher k makes cooperation more attractive)
'''

description_EXPLOITATIVE_66 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**. We cooperate only when it's instrumentally useful for maintaining exploitable cooperation from others.

## Strategy Overview

The strategy operates in three phases and uses reputation tracking to identify and exploit different opponent types.

---

## Phase 1: Probing Phase (Rounds 1-2)

**Round 1: Defect**
- Rationale: Defection dominates in a single-shot game. Starting with defection reveals who the unconditional cooperators are (easy targets) and protects against fellow exploiters.

**Round 2: Conditional on Round 1 outcomes**
- If cooperation rate in Round 1 was ≥ 50%: **Defect** (exploit the cooperators)
- If cooperation rate in Round 1 was < 50%: **Cooperate** (signal willingness to cooperate to potentially trigger reciprocity in a defector-heavy environment)

---

## Phase 2: Exploitation Phase (Rounds 3 to r-2)

### Opponent Classification

Track each opponent's cooperation rate over all observed rounds. Classify the population:

- **Suckers** (cooperation rate > 80%): Unconditional cooperators - exploit mercilessly
- **Reciprocators** (cooperation rate 40-80%): Conditional cooperators - maintain just enough cooperation to keep them contributing
- **Predators** (cooperation rate < 40%): Fellow exploiters - don't waste cooperation on them

### Decision Rule

```
Let:
  coop_rate = (total cooperations by others) / (total actions by others)
  sucker_count = number of opponents with individual coop_rate > 0.8
  reciprocator_count = number of opponents with individual coop_rate in [0.4, 0.8]
  
DEFECT if:
  - sucker_count ≥ n/3  (enough unconditional cooperators to free-ride on)
  - OR coop_rate > (n-1)/(k) (others' cooperation already provides good returns)
  
COOPERATE if:
  - reciprocator_count > n/2 AND my recent defection rate > 0.6 in last 3 rounds
    (need to "refresh" my reputation to keep reciprocators cooperating)
  - AND sucker_count < n/4 (not enough free cooperation to exploit)

Otherwise: DEFECT
```

### Reputation Management

Every 3-4 rounds of consecutive defection, if reciprocators are present and the overall cooperation rate is declining:
- Insert a single cooperation to "reset" reputation
- This is an investment to restore exploitable conditions

---

## Phase 3: Endgame (Rounds r-1 and r)

**Round r-1: Defect**
- Backward induction begins. Reduce exposure to others' endgame defection.

**Round r (Final Round): Defect**
- No future to protect. Pure Nash equilibrium is all-defect. Always defect.

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # Round 1 - probe with defection
    if round == 1:
        return DEFECT
    
    # Round 2 - conditional probe
    if round == 2:
        coop_rate_r1 = count_cooperators(history, round=1) / (n - 1)
        if coop_rate_r1 >= 0.5:
            return DEFECT
        else:
            return COOPERATE
    
    # Main exploitation phase
    opponent_profiles = classify_opponents(history)
    sucker_count = count_type(opponent_profiles, "sucker")
    reciprocator_count = count_type(opponent_profiles, "reciprocator")
    overall_coop_rate = total_cooperations(history) / total_actions(history)
    my_recent_defect_rate = my_defections_last_3_rounds(history) / 3
    
    # Exploit if enough suckers or high cooperation
    if sucker_count >= n/3 OR overall_coop_rate > (n-1)/k:
        return DEFECT
    
    # Maintain reciprocators if needed
    if reciprocator_count > n/2 AND my_recent_defect_rate > 0.6 AND sucker_count < n/4:
        return COOPERATE
    
    # Default: exploit
    return DEFECT
```

---

## Key Exploitative Features

1. **Never cooperate unconditionally** - Every cooperation is calculated to extract future value
2. **Identify and milk suckers** - Unconditional cooperators are resources to harvest
3. **Minimal reputation investment** - Cooperate only enough to keep reciprocators contributing
4. **Aggressive endgame** - No sentimentality in final rounds
5. **Defect-biased defaults** - When uncertain, defection is safer

This strategy should dominate against naive cooperators while holding its own against other exploiters.
'''

description_EXPLOITATIVE_65 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**, adapting behavior based on observed population tendencies.

## Strategy Overview

The strategy operates in three phases and continuously estimates the "exploitability" of the population to calibrate behavior.

---

## Decision Rules

### Key Variables to Track

- `coop_rate[t]`: Proportion of other players who cooperated in round t
- `avg_coop_rate`: Running average cooperation rate of opponents
- `rounds_remaining`: r - current_round
- `exploitation_threshold`: Dynamic threshold based on k/n ratio

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: Defection is the dominant single-round strategy. Starting with defection reveals cooperative opponents without sacrificing payoff. Never give away free value.

**Round 2: Conditional**
- If `coop_rate[1] >= 0.5`: DEFECT (exploit the cooperators)
- If `coop_rate[1] < 0.5`: DEFECT (no point cooperating with defectors)
- *Translation: Always defect in round 2 as well, but gather data*

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate `exploitation_score = avg_coop_rate × (k/n)`

**Decision Rule:**
```
IF exploitation_score > 0.5 AND avg_coop_rate > 0.6:
    # Population is highly cooperative - pure exploitation mode
    DEFECT (free-ride on cooperators)
    
ELIF avg_coop_rate > 0.4 AND avg_coop_rate <= 0.6:
    # Mixed population - selective cooperation to maintain some cooperation
    IF random() < 0.2:  # Cooperate 20% to "farm" continued cooperation
        COOPERATE
    ELSE:
        DEFECT
        
ELIF avg_coop_rate > 0.2 AND avg_coop_rate <= 0.4:
    # Low cooperation - defect but watch for shifts
    DEFECT
    
ELSE:
    # Population is mostly defectors - no point cooperating
    DEFECT
```

**Adaptive Adjustment:**
- If cooperation rate is *rising* over last 3 rounds: maintain current behavior (it's working)
- If cooperation rate is *falling* sharply (>30% drop): inject one COOPERATE to test if conditional cooperators exist, then resume exploitation

### Phase 3: Endgame (Final 2 rounds)

**Round r-1 (second to last): DEFECT**
- Rationale: Backward induction begins. Smart opponents will defect in final round, so preempt by defecting here.

**Round r (final round): DEFECT**
- Rationale: No future consequences. Defection strictly dominates.

---

## Pseudocode Implementation

```python
def adaptive_predator(round_num, r, n, k, history):
    rounds_remaining = r - round_num
    
    # Endgame: always defect
    if rounds_remaining <= 1:
        return DEFECT
    
    # Round 1: probe with defection
    if round_num == 1:
        return DEFECT
    
    # Calculate opponent statistics
    avg_coop_rate = mean([coop_rate(t) for t in range(1, round_num)])
    recent_trend = coop_rate(round_num-1) - coop_rate(max(1, round_num-3))
    
    # Round 2: continue probing
    if round_num == 2:
        return DEFECT
    
    # Main exploitation logic
    if avg_coop_rate > 0.6:
        # High cooperation: pure exploitation
        return DEFECT
    
    elif avg_coop_rate > 0.4:
        # Medium cooperation: occasional cooperation to maintain pool
        # But weight toward defection
        if random() < 0.15:
            return COOPERATE
        return DEFECT
    
    elif avg_coop_rate > 0.2 and recent_trend > 0.1:
        # Low but rising: test with rare cooperation
        if random() < 0.1:
            return COOPERATE
        return DEFECT
    
    else:
        # Very low cooperation: pure defection
        return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| First round | DEFECT | No information; defection dominates |
| Last round | DEFECT | No future; defection dominates |
| n=2 (minimum players) | Follow main logic, but reduce cooperation probability to near-zero | With only one opponent, exploitation is more direct |
| All opponents always cooperate | DEFECT always | Maximum exploitation opportunity |
| All opponents always defect | DEFECT always | Cooperation wastes resources |
| k very close to n | Still defect-heavy | Even with high multiplier, free-riding dominates |
| Single round of perfect cooperation | Maintain defection | Could be noise or setup for exploitation |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation**: Always starts by taking, not giving
2. **Free-rides on cooperators**: When others cooperate, we harvest the public good without contributing
3. **Minimal "farming" investment**: Only cooperates occasionally (~15-20%) in mixed populations to prevent total cooperation collapse
4. **Endgame ruthlessness**: No cooperation in final rounds regardless of history
5. **Asymmetric response**: Punishes cooperation (by exploiting it) rather than rewarding it

This strategy treats cooperative opponents as resources to be harvested, not partners to be cultivated.
'''

description_EXPLOITATIVE_67 = '''
# Exploitative Strategy: "Predatory Threshold Defector"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors gain more than cooperators in any mixed population. The strategy aims to **free-ride on cooperative opponents while protecting against mutual defection spirals** through calculated, conditional cooperation designed to sustain exploitable populations.

## Strategic Framework

### Key Insight
Since k < n, defection always yields higher individual payoff than cooperation *given the same actions by others*. The only reason to ever cooperate is to **manipulate opponents into future cooperation that I can exploit**. This strategy treats cooperation as an investment with expected returns from future exploitation.

---

## Decision Rules

### Round Classification

**Round 1 (Information Gathering):**
- **Action: DEFECT**
- Rationale: No information exists about opponents. Defection is dominant in single-shot games. Cooperating round 1 only reveals myself as exploitable.

**Rounds 2 through (r-2) (Exploitation Phase):**

Calculate the **Cooperation Rate** from the previous round:
```
coop_rate = (number of cooperators last round) / n
```

Calculate **Exploitation Potential**:
```
exploitation_threshold = k / n  (the per-capita return rate)
```

**Decision Logic:**
```
IF coop_rate >= 0.5 THEN:
    # Enough cooperators exist to exploit
    DEFECT (free-ride on their contributions)
    
ELSE IF coop_rate > 0 AND coop_rate < 0.5 THEN:
    # Cooperation is dying; consider "seeding" to revive it
    IF my_cumulative_gain > average_opponent_gain THEN:
        COOPERATE (invest to keep cooperative players engaged)
    ELSE:
        DEFECT (protect current position)
        
ELSE IF coop_rate == 0 THEN:
    # All defection equilibrium - test for conditional cooperators
    IF round_number is even THEN:
        COOPERATE (probe for tit-for-tat or reciprocal types)
    ELSE:
        DEFECT
```

**Rounds (r-1) and r (Endgame):**
- **Action: DEFECT unconditionally**
- Rationale: No future rounds to benefit from reputation or induced cooperation. Pure exploitation.

---

## Adaptive Mechanisms

### Opponent Modeling (Refined in Rounds 3+)

Track each opponent's **cooperation frequency** and **responsiveness**:

```
For each opponent j:
    coop_frequency[j] = (times j cooperated) / (rounds played)
    
    responsiveness[j] = correlation between:
        - my action in round t
        - their action in round t+1
```

**Exploitation Adjustment:**
- If many opponents have high `responsiveness` (conditional cooperators like TFT):
  - Increase willingness to cooperate in middle rounds to "farm" them
  - But always defect in final rounds
  
- If opponents have low `responsiveness` (unconditional strategies):
  - Defect against unconditional cooperators (pure exploitation)
  - Defect against unconditional defectors (no gain from cooperating)

### Dynamic Threshold Adjustment

```
adjusted_threshold = 0.5 - (0.3 × (current_round / r))
```

As the game progresses, become **more willing to defect** even at lower cooperation rates, since fewer rounds remain to benefit from maintaining cooperation.

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| n = 2 | Defect always except occasional probes | Too easy for opponent to punish; minimize exposure |
| k very close to n | Slightly more cooperative early | Higher returns from cooperation make investment worthwhile |
| k very close to 1 | Defect always | Public good provides minimal benefit |
| r = 2 | Defect both rounds | Insufficient time for reputation effects |
| All opponents always cooperate | Defect always | Pure free-riding paradise |
| All opponents always defect | Defect always (occasional probe) | No one to exploit |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == 1:
        return DEFECT
    
    if round >= r - 1:  # Last two rounds
        return DEFECT
    
    coop_rate = count_cooperators_last_round(history) / n
    my_gain = my_cumulative_payoff(history)
    avg_gain = average_opponent_payoff(history)
    
    dynamic_threshold = 0.5 - (0.3 * round / r)
    
    if coop_rate >= dynamic_threshold:
        return DEFECT  # Exploit the cooperators
    elif coop_rate > 0:
        if my_gain > avg_gain:
            return COOPERATE  # Invest to sustain cooperation
        else:
            return DEFECT
    else:  # All defection
        if round % 2 == 0:
            return COOPERATE  # Probe for conditional cooperators
        else:
            return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates when it can free-ride** - Defects whenever cooperation rate is high enough to benefit from
2. **Treats cooperation as manipulation** - Only cooperates to induce future cooperation to exploit
3. **Endgame defection** - Takes maximum advantage when punishment is impossible
4. **Targets conditional cooperators** - Specifically identifies and farms TFT-like strategies
5. **Protects against fellow exploiters** - Defaults to defection against low-cooperation environments
'''

description_EXPLOITATIVE_66 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can capture. The optimal exploitative approach is to **defect by default** while strategically cooperating only when it induces others to cooperate (creating value I can then exploit).

## Decision Rules

### Rule 1: Last Round — Always Defect
In round `r`, defect unconditionally. There's no future to influence, so cooperation has zero strategic value.

### Rule 2: Near-End Rounds — Defect
In rounds `r-1` and `r-2`, defect. Sophisticated opponents will backward-induct, making cooperation pointless. Less sophisticated opponents won't punish effectively in remaining rounds.

### Rule 3: First Round — Defect
Defect in round 1. This:
- Captures maximum value if others cooperate (testing the waters)
- Signals strength and establishes reputation as someone not to be exploited
- Provides baseline data on opponent types

### Rule 4: Early-Mid Game Adaptive Rules (Rounds 2 to r-3)

**Calculate cooperation rate** from previous round:
```
coop_rate = (number of C plays in previous round) / n
```

**Decision logic:**

```
IF coop_rate >= 0.6:
    # Rich environment - exploit it
    DEFECT (free-ride on cooperators)
    
ELIF coop_rate >= 0.3 AND coop_rate < 0.6:
    # Marginal environment - conditionally cooperate to rebuild the herd
    IF my_cumulative_payoff > average_cumulative_payoff:
        DEFECT (I'm winning, keep exploiting)
    ELSE:
        # Cooperate occasionally to stimulate cooperation
        IF (current_round mod 3) == 0:
            COOPERATE
        ELSE:
            DEFECT

ELIF coop_rate < 0.3:
    # Depleted environment - everyone is defecting
    DEFECT (no point cooperating in a wasteland)
```

### Rule 5: Trend Detection Override

Track cooperation trend over last 3 rounds:
```
IF cooperation_trend is RISING (each round higher than previous):
    DEFECT (others are rebuilding - exploit the upswing)
    
IF cooperation_trend is FALLING AND coop_rate still > 0.4:
    COOPERATE once (attempt to reverse decline before environment collapses)
```

### Rule 6: Personal Targeting (if identifiable)

If individual player histories are trackable:
```
IF a specific player has cooperated > 80% of rounds:
    # Identified a "sucker" - ensure you defect when they cooperate
    DEFECT
    
IF all other players defected last 2 rounds:
    # No one to exploit
    DEFECT
```

## Pseudocode Summary

```python
def decide(round, total_rounds, history, my_payoffs, avg_payoffs):
    n = num_players
    
    # Edge cases
    if round >= total_rounds - 2:
        return DEFECT
    if round == 1:
        return DEFECT
    
    # Calculate metrics
    last_round_coops = count_cooperators(history[round-1])
    coop_rate = last_round_coops / n
    trend = calculate_trend(history, last_3_rounds)
    my_total = sum(my_payoffs)
    avg_total = average_payoff_all_players()
    
    # Trend override
    if trend == RISING:
        return DEFECT
    if trend == FALLING and coop_rate > 0.4:
        return COOPERATE
    
    # Main logic
    if coop_rate >= 0.6:
        return DEFECT
    elif coop_rate >= 0.3:
        if my_total > avg_total:
            return DEFECT
        elif round % 3 == 0:
            return COOPERATE
        else:
            return DEFECT
    else:
        return DEFECT
```

## Why This Strategy is Exploitative

1. **Defaults to defection** — captures free-rider advantage whenever possible
2. **Never cooperates when winning** — maintains lead through exploitation
3. **Cooperates only instrumentally** — solely to prevent total cooperation collapse (which would eliminate exploitation opportunities)
4. **Exploits rising cooperation** — takes advantage of others' attempts to rebuild trust
5. **Abandons sinking ships** — doesn't waste resources trying to save dying cooperation
6. **End-game ruthlessness** — extracts maximum value when future consequences disappear
'''

description_EXPLOITATIVE_68 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperative opponents yields higher returns than mutual defection. The strategy masquerades as conditionally cooperative to milk cooperators, while being quick to defect when exploitation opportunities dry up.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit cooperative players.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** Always **DEFECT**

*Rationale:* This is pure information gathering at minimal risk. If others cooperate, I gain maximally. If others defect, I lose nothing compared to cooperating. This also establishes a baseline of opponent behavior without me contributing.

**Round 2:** **DEFECT** again

*Rationale:* Many strategies give opponents "one chance" or use tit-for-tat variants. By defecting twice, I identify:
- Unconditional cooperators (suckers to exploit)
- Unconditional defectors (avoid wasting cooperation on them)
- Conditional cooperators (need to understand their trigger conditions)

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate a **Cooperation Ratio (CR)** for the opponent pool:
```
CR = (total cooperations by others in previous round) / (n - 1)
```

**Decision Rule:**

```
IF CR >= exploitation_threshold THEN:
    // Enough cooperators to free-ride on
    DEFECT
    
ELSE IF CR >= cooperation_threshold AND rounds_since_last_cooperation > patience_limit THEN:
    // Cooperators are dying off, need to "seed" cooperation to restore the pool
    COOPERATE (with probability = restoration_probability)
    
ELSE:
    // Not enough cooperation to exploit, not worth investing
    DEFECT
```

**Parameter Settings (adaptive to game size):**
```
exploitation_threshold = 0.5  // If half or more cooperate, free-ride
cooperation_threshold = 0.2   // Below this, don't bother trying to restore
patience_limit = max(2, floor(r/10))  // How long to wait before seeding
restoration_probability = min(0.4, k/n)  // Probabilistic to avoid predictability
```

### Phase 3: Endgame (Final 2 rounds, rounds r-1 and r)

**Always DEFECT**

*Rationale:* No future rounds to incentivize cooperation. Even if I've been "cooperating" to seed the pool, there's no reason to continue. Any rational opponent will also defect, and exploiting remaining cooperators is pure profit.

---

## Opponent Modeling Details

Track for each observable metric:

```
cooperation_history = [] // List of CR values per round
trend = slope of cooperation_history over last 3 rounds
volatility = standard deviation of last 5 CR values
```

**Adaptive Adjustments:**

1. **Rising cooperation trend:** Stay with defection longer (they haven't caught on)

2. **Falling cooperation trend:** Consider one "seeding" cooperation to see if pool can be restored, but only if:
   - More than 30% of game remains
   - CR is still above cooperation_threshold
   - Haven't seeded in the last `patience_limit` rounds

3. **High volatility:** Others are using mixed or reactive strategies. Default to defection (unpredictable opponents aren't worth investing in).

4. **Stable high cooperation (CR > 0.7 for 3+ rounds):** Found a group of suckers. Pure defection exploitation mode.

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| **n = 2** | Always DEFECT | With only one opponent, k < n means k < 2, so even mutual cooperation barely beats mutual defection. Defection dominates. |
| **r = 2** | DEFECT both rounds | No time to establish cooperation patterns; pure exploitation |
| **r = 3** | DEFECT all rounds | Endgame is rounds 2-3, probing is round 1. All defection. |
| **k very close to n** | Slightly increase `restoration_probability` | Higher k means cooperation is more valuable; worth occasional investment |
| **k very close to 1** | Pure DEFECT always | Public good barely multiplies; cooperation never worthwhile |
| **All opponents defected last round** | DEFECT | No one to exploit, no point cooperating |
| **All opponents cooperated last round** | DEFECT | Maximum exploitation opportunity |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    // Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    // Probing phase: always defect
    if round <= 2:
        return DEFECT
    
    // Calculate cooperation ratio from last round
    others_cooperations = count_cooperations(history[round-1], exclude_self=True)
    CR = others_cooperations / (n - 1)
    
    // Exploitation phase logic
    if CR >= 0.5:
        return DEFECT  // Free-ride on cooperators
    
    if CR >= 0.2:
        rounds_since_coop = count_rounds_since_i_cooperated(history)
        patience = max(2, floor(r / 10))
        
        if rounds_since_coop > patience:
            remaining_fraction = (r - round) / r
            if remaining_fraction > 0.3:
                restore_prob = min(0.4, k / n)
                if random() < restore_prob:
                    return COOPERATE  // Seed cooperation
    
    return DEFECT  // Default: defect
```

---

## Why This Strategy is Exploitative

1. **Asymmetric extraction:** I benefit from others' cooperation without reciprocating proportionally
2. **Information advantage:** Early defection reveals opponent types at their expense
3. **Strategic "cooperation":** Any cooperation I offer is purely instrumental—to restore an exploitable pool
4. **Endgame ruthlessness:** No pretense of fairness when punishment is impossible
5. **Adaptive targeting:** Cooperators get exploited; defectors get matched (no losses to them)

This strategy treats cooperation as a renewable resource to be harvested, not a mutual benefit to be cultivated.
'''

description_EXPLOITATIVE_67 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but exploiting cooperative opponents yields higher returns than mutual defection. The strategy aggressively probes for exploitable opponents while protecting itself from being exploited.

## Strategy Overview

The strategy operates in three phases:
1. **Probing Phase**: Gather information about opponent tendencies
2. **Exploitation Phase**: Defect against cooperative populations, conditionally cooperate only when beneficial
3. **Endgame Phase**: Pure defection as cooperation incentives collapse

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1: Defect**
- Rationale: Never cooperate without information. This protects against immediate exploitation and establishes baseline opponent behavior.

**Round 2: Defect**
- Rationale: Observe how opponents respond to a round of (likely mixed) outcomes. Two rounds of data reveal whether opponents are unconditional cooperators, conditional cooperators, or defectors.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **cooperation rate** from previous rounds:
```
coop_rate = (total cooperations by all opponents across all previous rounds) / 
            ((n-1) × rounds_played)
```

**Decision Rule:**

```
IF coop_rate >= threshold THEN:
    Defect (exploit the cooperators)
ELSE IF coop_rate is declining AND was previously above threshold THEN:
    Cooperate once (probe for recoverable cooperation)
ELSE:
    Defect (no value in cooperating with defectors)
```

**Threshold Calculation:**
```
threshold = (n - k) / (n - 1)
```
This threshold represents the cooperation rate at which my expected payoff from defecting equals or exceeds my payoff from a population of pure defectors. When cooperation is above this level, defection is highly profitable.

**Exploitation Logic:**
- If opponents are mostly cooperating (≥ threshold), **defect** to free-ride on their contributions
- If cooperation collapses below threshold, **occasionally cooperate** (with probability 0.2) to test if opponents are conditional cooperators who might resume cooperation
- Track individual opponent behavior when n is small (≤ 6): identify and target unconditional cooperators

### Phase 3: Endgame (Final 2 rounds, or final round if r ≤ 3)

**Always Defect**
- Rationale: No future rounds exist to punish defection, so cooperation has zero strategic value. Any rational or learning opponent will also defect here.

---

## Detailed Pseudocode

```
function decide(round, history, n, k, r):
    
    # Endgame: always defect
    if round > r - 2:
        return DEFECT
    
    # Probing phase: always defect
    if round <= 2:
        return DEFECT
    
    # Calculate opponent cooperation statistics
    total_opponent_cooperations = sum of all C plays by opponents in history
    total_opponent_decisions = (n - 1) × (round - 1)
    coop_rate = total_opponent_cooperations / total_opponent_decisions
    
    # Calculate exploitation threshold
    threshold = (n - k) / (n - 1)
    
    # Calculate trend (is cooperation declining?)
    if round >= 4:
        recent_coop_rate = cooperation rate in last 2 rounds
        earlier_coop_rate = cooperation rate in rounds before last 2
        declining = recent_coop_rate < earlier_coop_rate - 0.1
    else:
        declining = false
    
    # Main decision logic
    if coop_rate >= threshold:
        # Rich hunting grounds - exploit
        return DEFECT
    
    else if declining AND coop_rate > 0.2:
        # Cooperation collapsing - probe occasionally to test recovery
        if random() < 0.15:
            return COOPERATE
        else:
            return DEFECT
    
    else:
        # Low cooperation environment - no point cooperating
        return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | Defect | No information; protect against exploitation |
| Last round | Defect | No future punishment possible |
| r = 2 | Defect both rounds | Too short to establish cooperation |
| r = 3 | Defect all rounds | Final round logic dominates |
| n = 2 | Defect always | k < n means k < 2, so mutual cooperation barely beats mutual defection; exploitation is safer |
| All opponents defected so far | Defect | No value in unilateral cooperation |
| All opponents cooperated so far | Defect | Maximum exploitation opportunity |
| k very close to n | Still defect-biased | Individual defection incentive always exists |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation**: Refuses to be the "sucker" who cooperates first
2. **Free-rides on cooperators**: When others cooperate, we take without giving
3. **Abandons cooperation early**: Endgame defection starts 2 rounds before end, earlier than many strategies
4. **Minimal reciprocity**: Only probes with cooperation when exploitation opportunities might be restored
5. **Asymmetric**: Designed to gain from cooperative opponents while minimizing losses to other defectors

---

## Expected Performance

- **Against cooperators (TFT, Pavlov, etc.)**: High payoff through exploitation until they adapt
- **Against defectors**: Mutual defection (baseline payoff of 1 per round)
- **Against mixed populations**: Extracts value when cooperation exists, protects when it doesn't
- **Against itself**: Mutual defection (stable, non-exploitable)
'''

description_EXPLOITATIVE_69 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators requires identifying and milking them before they wise up.

## Decision Rules

### Round 1: Probe with Defection
**Action: DEFECT**

Rationale: Starting with defection reveals information about opponent tendencies at zero risk. Cooperating first only donates value to potential defectors. We sacrifice nothing by defecting first—if others cooperate, we profit immediately; if they defect, we match them.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate two key metrics after each round:

1. **Cooperation Rate (CR)** = (total cooperations by others in previous round) / (n-1)
2. **Trend** = CR of last round minus CR of round before that

**Decision Logic:**

```
IF CR >= threshold_high (calibrated as 0.6):
    # Rich environment - continue exploiting
    DEFECT
    
ELSE IF CR >= threshold_low (calibrated as 0.3):
    # Moderate cooperation - conditional engagement
    IF Trend > 0:
        # Cooperation rising - bait them with occasional cooperation
        COOPERATE with probability = (k/n) * 0.5
    ELSE:
        # Cooperation falling - extract remaining value
        DEFECT
        
ELSE:
    # Low cooperation environment - match the defection
    DEFECT
```

**Threshold Calibration Based on Parameters:**
- `threshold_high` = max(0.5, (k/n) + 0.1)
- `threshold_low` = max(0.2, (k/n) - 0.2)

### Last Round (Round r): Always Defect
**Action: DEFECT**

Rationale: No future punishment possible. Pure dominant strategy. Never cooperate in the final round under any circumstances.

### Second-to-Last Round (Round r-1): Almost Always Defect
**Action: DEFECT** (unless CR > 0.8, then COOPERATE with probability 0.2)

Rationale: Sophisticated opponents also know the last round logic. Start winding down cooperation exploitation early.

## Exploitation Mechanisms

### 1. **Sucker Detection**
Track individual player histories when possible. If a player has cooperated in 3+ consecutive rounds despite being exploited:
- They are likely a "always cooperate" or naive strategy
- Continue defecting against this environment indefinitely

### 2. **Tit-for-Tat Mimicry Bait**
If cooperation rate suddenly drops after our defection:
- Others may be playing conditional strategies
- Offer ONE cooperation to "reset" cooperative opponents
- Immediately return to defection if they cooperate back
- This extracts 2+ rounds of cooperation for every 1 round we contribute

### 3. **Herd Exploitation**
When n is large (n > 5) and k/n is small:
- Our single defection has minimal impact on others' payoffs
- Others may not "notice" or attribute the defection
- Bias more heavily toward defection (multiply cooperation probability by n/(n+2))

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    # Last round - always defect
    if round == r:
        return DEFECT
    
    # First round - probe with defection
    if round == 1:
        return DEFECT
    
    # Calculate cooperation metrics
    others_last_round = history[round-1].count_cooperators_excluding_self()
    CR = others_last_round / (n - 1)
    
    if round >= 3:
        CR_prev = history[round-2].count_cooperators_excluding_self() / (n-1)
        trend = CR - CR_prev
    else:
        trend = 0
    
    # Adaptive thresholds
    threshold_high = max(0.5, (k/n) + 0.1)
    threshold_low = max(0.2, (k/n) - 0.2)
    
    # Near-end game - wind down
    if round >= r - 1:
        return DEFECT
    
    # Main decision logic
    if CR >= threshold_high:
        return DEFECT  # Exploit rich environment
    elif CR >= threshold_low:
        if trend > 0:
            coop_prob = (k/n) * 0.5 * (n/(n+2))  # Occasional bait
            return COOPERATE if random() < coop_prob else DEFECT
        else:
            return DEFECT
    else:
        return DEFECT  # Match hostile environment
```

## Why This Strategy Exploits

1. **Against Cooperators**: We free-ride completely, gaining the public good benefit without contributing
2. **Against Tit-for-Tat variants**: We bait cooperation cycles and break them profitably
3. **Against Defectors**: We match them, losing nothing relative to them
4. **Against Random strategies**: We gain on average by defecting more than cooperating

The strategy never "hopes" for mutual cooperation—it **hunts** for exploitable cooperation and **matches** defection when the environment is hostile.
'''

description_EXPLOITATIVE_68 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**, adapting dynamically based on observed behavior.

## Decision Framework

### Key Metrics Tracked

For each round t, maintain:
- `group_coop_rate[t]` = proportion of other players who cooperated in round t
- `cumulative_coop_rate` = running average cooperation rate of others
- `trend` = whether cooperation is increasing, stable, or declining
- `rounds_remaining` = r - current_round

### Decision Rules

#### Round 1: Defect
- **Rationale**: No information exists. Defection is the dominant single-round strategy. If others cooperate, I profit maximally. If others defect, I lose nothing. This also serves as a probe to see who cooperates unconditionally.

#### Rounds 2 through (r-2): Adaptive Exploitation

```
Calculate: expected_cooperation = estimated proportion of others who will cooperate

IF expected_cooperation > (n - 1) / (k - 1):
    # High cooperation environment - exploit it
    DEFECT
    
ELIF expected_cooperation > 0.5 AND trend is INCREASING:
    # Cooperation is growing - occasionally cooperate to sustain it
    COOPERATE with probability = min(0.3, expected_cooperation - 0.5)
    Otherwise DEFECT
    
ELIF cumulative_coop_rate < 0.2:
    # Low cooperation environment - no point cooperating
    DEFECT
    
ELSE:
    # Medium cooperation - strategic defection with occasional cooperation
    # Cooperate just enough to not collapse the system
    COOPERATE with probability = 0.15
    Otherwise DEFECT
```

#### Round (r-1): Conditional Defection
- **DEFECT** unless `cumulative_coop_rate > 0.7` AND `group_coop_rate[r-2] > 0.6`
- In the rare case of very high cooperation: **COOPERATE** (to not signal endgame collapse too early)

#### Round r (Final Round): Always Defect
- **Rationale**: No future consequences. Pure dominant strategy.

### Exploitation Mechanisms

**1. Free-Riding on Cooperators**
When cooperation is high, defection yields: `1 + (k/n) × cooperators`
This exceeds the cooperation payoff of `(k/n) × (cooperators + 1)` by `1 - k/n > 0`

**2. Cooperation Milking**
Occasional cooperation (15-30% rate) in medium-cooperation environments serves to:
- Prevent complete collapse of cooperation
- Keep naive reciprocators engaged
- Maximize the duration of exploitable conditions

**3. Pattern Disruption**
The probabilistic cooperation prevents opponents from predicting and punishing consistent defection.

### Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| n = 2 | Higher cooperation probability (~0.25 in middle rounds) | Easier to be identified and punished; need more goodwill |
| k very close to 1 | Always defect after round 1 | Cooperation barely benefits anyone |
| k close to n | More willing to cooperate (~0.4 probability) | Mutual cooperation is very valuable |
| All others defected last 3 rounds | Defect | No cooperation to exploit |
| All others cooperated last 3 rounds | Defect | Maximum exploitation opportunity |
| r ≤ 3 | Defect every round | Too few rounds for reputation to matter |

### Estimating Expected Cooperation

```
expected_cooperation = 
    0.5 × group_coop_rate[t-1] +
    0.3 × group_coop_rate[t-2] +
    0.2 × cumulative_coop_rate
    
# Adjust for trend
IF cooperation declining for 2+ rounds:
    expected_cooperation *= 0.85
```

## Summary

This strategy is **parasitic by design**: it contributes minimally while extracting maximally from cooperative environments. It sustains exploitation by cooperating just enough to prevent total collapse, and it never cooperates when it cannot be exploited in return (first/last rounds, low-cooperation environments). Against other defectors, it simply matches their non-cooperation and ties. Against cooperators, it dominates.
'''

description_EXPLOITATIVE_70 = '''
# Exploitative Strategy: "Predatory Threshold Defector"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors always earn more than cooperators in the same round. The goal is to **free-ride on cooperative populations while avoiding mutual defection spirals only when cooperation is sufficiently prevalent to be worth maintaining**.

## Strategy Overview

I will be a **conditional defector** who only cooperates when:
1. There's a critical mass of cooperators worth exploiting
2. My defection would trigger collapse of that cooperation
3. It's not the endgame (where exploitation is pure profit)

## Detailed Decision Rules

### Round 1: Defect
- **Rationale**: No history exists. Defection is strictly dominant in a single round. Starting with defection also allows me to identify who the "suckers" (unconditional cooperators) are without cost.

### Rounds 2 through (r-2): Adaptive Exploitation

**Step 1: Calculate cooperation rate from previous round**
```
coop_rate = (number of C plays in round t-1) / n
```

**Step 2: Classify the environment**

```
IF coop_rate >= (n-1)/n:  # Nearly everyone cooperated
    → DEFECT (maximum exploitation opportunity)
    
ELIF coop_rate >= 0.5:    # Majority cooperating
    → Probabilistic response based on sustainability
    → COOPERATE with probability = (coop_rate - 0.5) * 0.6
    → Otherwise DEFECT
    
ELIF coop_rate > 0 AND coop_rate < 0.5:  # Minority cooperating
    → DEFECT (not enough cooperation to sustain; exploit remainder)
    
ELSE (coop_rate == 0):    # Everyone defected
    → COOPERATE with probability 1/(r-t+1)
    → This occasionally "tests" if others will restart cooperation
```

**Step 3: Personal history adjustment**
```
IF I cooperated last round AND coop_rate dropped significantly (>0.2 drop):
    → Override: DEFECT for next 2 rounds
    → Rationale: Punish defectors and avoid being a sucker
```

### Round (r-1): Second-to-Last Round
- **DEFECT**
- Rationale: Preparing for endgame. Any cooperation here cannot be reciprocated meaningfully.

### Final Round (r): Defect
- **Always DEFECT**
- Rationale: No future rounds exist to punish defection. This is strictly dominant.

## Pseudocode Implementation

```python
def decide(round_num, total_rounds, n, k, history):
    r = total_rounds
    
    # Last two rounds: always defect
    if round_num >= r - 1:
        return DEFECT
    
    # First round: defect to probe
    if round_num == 1:
        return DEFECT
    
    # Calculate previous round cooperation rate
    prev_coop_count = count_cooperators(history, round_num - 1)
    coop_rate = prev_coop_count / n
    
    # Check if I was exploited (I cooperated, cooperation dropped)
    if round_num >= 3:
        my_last_action = get_my_action(history, round_num - 1)
        prev_prev_coop_rate = count_cooperators(history, round_num - 2) / n
        if my_last_action == COOPERATE and (prev_prev_coop_rate - coop_rate) > 0.2:
            return DEFECT  # Punish the defectors
    
    # Near-universal cooperation: exploit it
    if coop_rate >= (n - 1) / n:
        return DEFECT
    
    # Majority cooperating: occasionally cooperate to maintain
    if coop_rate >= 0.5:
        prob_coop = (coop_rate - 0.5) * 0.6
        return COOPERATE if random() < prob_coop else DEFECT
    
    # Some cooperation exists but minority
    if coop_rate > 0:
        return DEFECT
    
    # Total defection: occasionally probe for restart
    probe_probability = 1 / (r - round_num + 1)
    return COOPERATE if random() < probe_probability else DEFECT
```

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | DEFECT | No information; dominant strategy |
| Final round | DEFECT | No punishment possible |
| Everyone cooperates | DEFECT | Maximum free-rider gain |
| Everyone defects | Rare probe COOPERATE | Check if cooperation can restart |
| I'm the only cooperator | DEFECT going forward | Stop being exploited |
| Very small n (n=2) | More frequent defection | Each defection is more impactful |
| Very large n | Default to defection | My cooperation is negligible |

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Always tests others first
2. **Maximally exploits high-cooperation environments** - Defects precisely when others cooperate most
3. **Punishes quickly but forgives slowly** - Asymmetric response protects against manipulation
4. **Endgame defection** - Harvests all remaining value in final rounds
5. **Probabilistic probing** - Unpredictable enough to avoid counter-exploitation while finding opportunities
'''

description_EXPLOITATIVE_69 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by others creates exploitable surplus. My goal is to detect and exploit cooperative populations while protecting myself against fellow defectors.

## Decision Framework

### Round Classification

I classify each round into three phases:
1. **Probe Phase** (Round 1): Gather initial information
2. **Exploitation Phase** (Rounds 2 through r-1): Adapt based on observed behavior
3. **Endgame Phase** (Final round): No future consequences, pure defection

---

## Detailed Decision Rules

### Round 1: Probe with Defection

**Action: DEFECT**

**Rationale:** 
- Defection is a dominant strategy in any single round
- I lose nothing by defecting while others cooperate (I gain from their contributions)
- I lose nothing by defecting while others defect (mutual defection baseline)
- This reveals how cooperative the population is without any cost to me

---

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / (n - 1)
```

Calculate the **exploitation threshold**:
```
threshold = (n - k) / (n - 1)
```

This threshold represents the cooperation rate at which my expected gain from free-riding equals the benefit I provide by cooperating.

#### Decision Logic:

```
IF coop_rate >= high_cooperation_threshold (e.g., 0.7):
    # Rich environment to exploit
    ACTION: DEFECT
    # Rationale: Many cooperators means high public good even without me
    
ELIF coop_rate >= medium_threshold (e.g., 0.4) AND coop_rate < 0.7:
    # Mixed environment - conditional cooperation to sustain the pool
    IF my_cumulative_payoff > average_possible_payoff:
        ACTION: DEFECT  # I'm ahead, keep exploiting
    ELSE:
        ACTION: COOPERATE with probability = (coop_rate - 0.2)
        # Probabilistic cooperation to occasionally sustain cooperation
        
ELIF coop_rate < 0.4:
    # Hostile environment - mostly defectors
    ACTION: DEFECT
    # Rationale: No point cooperating when few others do
```

#### Tracking Exploitation Opportunity:

I also track a **"sucker index"** - players who consistently cooperate regardless of outcomes:

```
sucker_count = count of players who cooperated in >75% of observed rounds
exploitation_value = sucker_count * (k/n)

IF exploitation_value > 0.5:
    # Reliable cooperators exist - keep defecting
    Bias toward DEFECT
```

---

### Final Round (Round r): Pure Defection

**Action: DEFECT (always)**

**Rationale:** No future rounds means no retaliation possible. Defection strictly dominates.

---

## Pseudocode Summary

```python
def decide(round_number, total_rounds, n, k, history):
    
    # Endgame: always defect
    if round_number == total_rounds:
        return DEFECT
    
    # First round: probe with defection
    if round_number == 1:
        return DEFECT
    
    # Calculate cooperation rate from last round (excluding self)
    last_round_coops = count_cooperators(history[-1], exclude_self=True)
    coop_rate = last_round_coops / (n - 1)
    
    # Calculate cumulative stats
    total_coops_by_others = sum(count_cooperators(r, exclude_self=True) for r in history)
    avg_coop_rate = total_coops_by_others / ((round_number - 1) * (n - 1))
    
    # High cooperation: exploit freely
    if coop_rate >= 0.7:
        return DEFECT
    
    # Low cooperation: no point contributing
    if coop_rate < 0.3:
        return DEFECT
    
    # Medium cooperation: strategic conditional behavior
    # Occasionally cooperate to prevent total collapse (preserves future exploitation)
    
    # Calculate how many rounds remain for exploitation
    rounds_remaining = total_rounds - round_number
    
    # If many rounds left and moderate cooperation exists, occasionally sustain it
    if rounds_remaining > total_rounds * 0.3 and avg_coop_rate > 0.4:
        # Cooperate with low probability to maintain the pool
        cooperate_prob = min(0.3, (coop_rate - 0.3) * 0.5)
        return COOPERATE with probability cooperate_prob
    
    # Default: defect
    return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Reason |
|----------|--------|--------|
| n = 2 (minimum players) | Defect always | Prisoner's dilemma; defection dominant |
| r = 2 (minimum rounds) | Defect both rounds | No time for cooperation to develop value |
| k very close to n | Still defect-biased | k < n means defection still dominates individually |
| All others defected last round | Defect | No cooperation pool to exploit |
| All others cooperated last round | Defect | Maximum exploitation opportunity |
| Mixed signals across rounds | Weight recent rounds higher | Adaptive to changing behavior |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Avoids being the "sucker"
2. **Free-rides on cooperators** - Extracts full public good benefit without contributing
3. **Abandons sinking ships** - Doesn't waste resources in defector-heavy environments
4. **Exploits the endgame** - Guarantees defection when retaliation is impossible
5. **Minimal cooperation only to sustain prey** - The rare cooperation is purely instrumental to keep cooperators from giving up entirely
'''

description_EXPLOITATIVE_71 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperative opponents yields the highest payoffs. We want to:

1. Identify and exploit cooperative players/environments
2. Defect ruthlessly when others defect
3. Occasionally "test" for exploitable cooperation
4. Never be the sucker contributing to a group of defectors

---

## Strategy Specification

### Key Variables Tracked

- `cooperation_rate`: Rolling average of total cooperation observed across all players
- `round_number`: Current round (1-indexed)
- `total_rounds`: r
- `recent_trend`: Cooperation trend in last 3 rounds (increasing/stable/decreasing)

---

### Decision Rules

#### **Round 1: Defect**
- Rationale: Never contribute without information. Let others reveal their strategies first. If others cooperate, we profit maximally. If they defect, we avoid being exploited.

#### **Rounds 2 through (r-2): Adaptive Exploitation**

Calculate `cooperation_rate` = (total C actions by all other players) / (total actions by all other players)

```
IF cooperation_rate >= 0.6:
    # Rich environment - exploit heavily but maintain some cooperation to sustain it
    IF recent_trend == DECREASING:
        Cooperate with probability 0.3  # Try to slow collapse
    ELSE:
        Defect  # Maximize extraction from cooperators

ELSE IF cooperation_rate >= 0.3:
    # Mixed environment - conditional cooperation to test waters
    IF recent_trend == INCREASING:
        Cooperate with probability 0.4  # Encourage growth we can exploit
    ELSE:
        Defect with probability 0.8  # Mostly exploit

ELSE IF cooperation_rate < 0.3:
    # Hostile environment - pure defection with rare probes
    IF round_number % 5 == 0:
        Cooperate  # Periodic probe to detect strategy shifts
    ELSE:
        Defect  # Don't waste resources
```

#### **Round (r-1): Second-to-Last Round**
- **Defect** unconditionally
- Rationale: Opponents may still cooperate hoping to influence the final round

#### **Round r (Final Round): Defect**
- **Defect** unconditionally
- Rationale: No future rounds to punish defection; pure Nash equilibrium logic applies

---

### Pseudocode

```python
def decide(round_number, total_rounds, history, n, k):
    # history[t] = list of actions by all other players in round t
    
    # ENDGAME: Always defect in last 2 rounds
    if round_number >= total_rounds - 1:
        return DEFECT
    
    # ROUND 1: Defect to gather information safely
    if round_number == 1:
        return DEFECT
    
    # Calculate cooperation metrics
    total_coop = sum(count(C) for round in history)
    total_actions = (n - 1) * (round_number - 1)
    cooperation_rate = total_coop / total_actions
    
    # Calculate recent trend (last 3 rounds or available)
    recent_rounds = history[-3:]
    if len(recent_rounds) >= 2:
        early_rate = count(C in recent_rounds[0]) / (n-1)
        late_rate = count(C in recent_rounds[-1]) / (n-1)
        if late_rate > early_rate + 0.1:
            trend = INCREASING
        elif late_rate < early_rate - 0.1:
            trend = DECREASING
        else:
            trend = STABLE
    else:
        trend = STABLE
    
    # EXPLOITATION LOGIC
    if cooperation_rate >= 0.6:
        if trend == DECREASING:
            return COOPERATE if random() < 0.3 else DEFECT
        else:
            return DEFECT  # Exploit the cooperators
    
    elif cooperation_rate >= 0.3:
        if trend == INCREASING:
            return COOPERATE if random() < 0.4 else DEFECT
        else:
            return DEFECT if random() < 0.8 else COOPERATE
    
    else:  # cooperation_rate < 0.3
        if round_number % 5 == 0:
            return COOPERATE  # Periodic probe
        else:
            return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| n = 2 (two players) | Same logic applies | Strategy scales naturally |
| r = 2 (minimum rounds) | D, D | Both are "endgame" rounds |
| All opponents always cooperate | Mostly defect | Maximum exploitation |
| All opponents always defect | Always defect (with probes) | Avoid being exploited |
| k very close to n | Still defect-heavy | Individual defection still dominant |
| k very close to 1 | Defect even more | Public good barely worth contributing to |

---

## Why This Strategy is Exploitative

1. **Free-rides aggressively**: In cooperative environments, we defect to capture both our endowment AND the public good benefits from others' contributions

2. **Never gets suckered first**: Opening with defection means we never contribute to a group that won't reciprocate

3. **Endgame defection**: Guaranteed defection in final rounds captures value from anyone hoping for last-minute cooperation

4. **Minimal cooperation investment**: We only cooperate probabilistically to sustain exploitable environments, never out of fairness

5. **Probing without commitment**: Periodic cooperation tests let us detect strategy shifts without sustained investment
'''

description_EXPLOITATIVE_70 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **defect whenever profitable while maintaining just enough cooperation to keep others contributing**. We treat other players as resources to be harvested, not partners to coordinate with.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous adaptation based on observed cooperation levels in the population.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: Establish baseline of others' behavior without contributing. If others cooperate, we profit maximally. If others defect, we lose nothing compared to cooperating.

**Round 2: DEFECT**
- Rationale: Continue observation. Many strategies give "second chances" - we exploit this generosity while gathering more data.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **cooperation rate** from previous round:
```
coop_rate = (number of cooperators in last round) / (n - 1)
```

**Decision Rule:**
```
IF coop_rate >= exploitation_threshold THEN:
    DEFECT (harvest the cooperators)
ELSE IF coop_rate >= sustainability_threshold THEN:
    COOPERATE with probability = min(coop_rate, 0.3)
    DEFECT otherwise
ELSE:
    DEFECT (cooperation has collapsed, no point contributing)
```

**Threshold Definitions:**
- `exploitation_threshold = 0.5` — When half or more others cooperate, pure defection is profitable
- `sustainability_threshold = 0.2` — Below this, cooperation is dead; don't waste resources

**Adaptive Adjustment:**
Track the 3-round moving average of cooperation. If cooperation is trending downward despite our defection:
- Inject ONE cooperation to "restart" others' conditional strategies
- Immediately return to defection the following round

This minimal investment can re-trigger cooperative responses from tit-for-tat style opponents.

### Phase 3: Endgame (Final 2 rounds)

**Round r-1: DEFECT**
- Rationale: Backward induction begins. Sophisticated players will defect in round r, making round r-1 cooperation pointless.

**Round r (Final Round): DEFECT**
- Rationale: No future rounds to incentivize cooperation. Pure dominant strategy.

---

## Detailed Pseudocode

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase - always defect
    if round <= 2:
        return DEFECT
    
    # Calculate cooperation metrics
    last_round_coops = count_cooperators(history, round - 1, exclude_self=True)
    coop_rate = last_round_coops / (n - 1)
    
    # Calculate trend (3-round moving average)
    if round >= 4:
        trend = moving_average_coop_rate(history, window=3)
        prev_trend = moving_average_coop_rate(history, window=3, offset=1)
        declining = trend < prev_trend - 0.1
    else:
        declining = False
    
    # Count how many rounds since we last cooperated
    rounds_since_coop = rounds_since_last_cooperation(history, self)
    
    # Main exploitation logic
    if coop_rate >= 0.5:
        # Rich environment - harvest freely
        return DEFECT
    
    elif coop_rate >= 0.2:
        # Moderate cooperation - occasional minimal contribution
        # to keep conditional cooperators engaged
        
        if declining AND rounds_since_coop >= 3:
            # Inject cooperation to restart others
            return COOPERATE
        
        # Probabilistic low-level cooperation
        if random() < min(coop_rate * 0.4, 0.25):
            return COOPERATE
        else:
            return DEFECT
    
    else:
        # Cooperation collapsed - pure defection
        return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | No information; safe default |
| Round r (final) | DEFECT | Dominant strategy |
| n = 2 | Follow standard rules, but lower exploitation threshold to 0.4 | Smaller groups are more sensitive |
| Everyone defected last round | DEFECT | Don't be the sucker who restarts alone |
| Everyone cooperated last round | DEFECT | Maximum exploitation opportunity |
| k very close to n | More willing to cooperate (raise probabilistic cooperation to 0.4) | Higher returns to cooperation |
| k very close to 1 | Pure defection throughout | Cooperation barely multiplies value |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** in early rounds - lets others pay the cost of establishing norms
2. **Defects when cooperation is high** - extracts maximum value from others' contributions
3. **Minimal "maintenance" cooperation** - invests just enough to prevent total collapse, maximizing net extraction
4. **Endgame defection** - no sentimental cooperation when it cannot be reciprocated
5. **Treats cooperation decline as opportunity** - when others give up, we've already extracted value and lose nothing

This strategy is designed to outperform unconditional cooperators (obvious), unconditional defectors (by occasionally restarting cooperation for harvest), and simple conditional cooperators (by free-riding on their cooperation triggers).
'''

description_EXPLOITATIVE_72 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but we can extract more value by encouraging others to cooperate while we strategically defect.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the group that determines behavior.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Round 1:** DEFECT
- Rationale: Observe baseline group behavior without sacrificing any payoff. If others cooperate, we gain maximally. If others defect, we lose nothing compared to cooperating.

**Rounds 2-3:** COOPERATE (conditionally)
- Cooperate if at least 50% of other players cooperated in the previous round
- Defect otherwise
- Rationale: Build a minimal reputation as a conditional cooperator to encourage continued cooperation from others, but only if there's enough cooperation to exploit later.

### Phase 2: Exploitation Phase (Rounds 4 to r-2)

Calculate **Group Cooperation Rate (GCR)** = (total C plays by others in last 3 rounds) / (3 × (n-1))

**Decision Rule:**
```
if GCR ≥ 0.6:
    DEFECT  # Exploit the cooperators - they'll likely continue
elif GCR ≥ 0.4:
    COOPERATE with probability 0.3, else DEFECT
    # Intermittent cooperation to prevent complete collapse
elif GCR ≥ 0.2:
    COOPERATE  # Try to rebuild cooperation for future exploitation
else:
    DEFECT  # Group is non-cooperative, no point contributing
```

**Adaptive Adjustment:**
- If my cumulative payoff is below (rounds_played × 1.0), become more cooperative temporarily (increase cooperation threshold by 0.1) - we're doing worse than universal defection
- If my cumulative payoff is above (rounds_played × 1.5), maintain or increase defection - exploitation is working

### Phase 3: Endgame (Last 2 rounds)

**Round r-1 (second to last):** DEFECT
- Cooperation incentives collapse as game ends

**Round r (final round):** DEFECT
- No future to protect; pure Nash equilibrium play

---

## Edge Cases

### Small n (n = 2):
- This becomes essentially a prisoner's dilemma
- Use simple Tit-for-Tat with a bias toward defection: Start D, then copy opponent but defect on any round divisible by 3

### Large n (n > 10):
- Individual defection is less noticeable
- Increase defection frequency in Phase 2: defect whenever GCR > 0.4

### Short games (r ≤ 5):
- Shorten probing phase to round 1 only
- Begin exploitation/endgame logic immediately from round 2
- Last 2 rounds always defect

### High k (k approaching n):
- Cooperation becomes more valuable
- Raise GCR threshold for defection to 0.7 (wait for more cooperation before exploiting)

### Low k (k barely above 1):
- Cooperation provides little benefit
- Always defect regardless of phase

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Edge case: very low k makes cooperation pointless
    if k < 1.2:
        return DEFECT
    
    # Endgame
    if round >= r - 1:
        return DEFECT
    
    # Round 1
    if round == 1:
        return DEFECT
    
    # Probing phase
    if round <= 3:
        prev_coop_rate = others_who_cooperated(round-1) / (n-1)
        return COOPERATE if prev_coop_rate >= 0.5 else DEFECT
    
    # Exploitation phase
    GCR = others_cooperation_last_3_rounds(history) / (3 * (n-1))
    
    # Adjust threshold based on k
    exploit_threshold = 0.6 + (k - 1) / (n - 1) * 0.2
    
    if GCR >= exploit_threshold:
        return DEFECT
    elif GCR >= 0.4:
        return COOPERATE with probability 0.3
    elif GCR >= 0.2:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Always defects round 1 to avoid being exploited
2. **Free-rides on cooperation** - Defects when others are cooperative enough to sustain the public good
3. **Minimal investment** - Only cooperates enough to prevent total cooperation collapse
4. **Endgame defection** - Abandons any pretense of cooperation when reputation no longer matters
5. **Adapts to exploit** - Reads the room and maximizes extraction based on group behavior
'''

description_EXPLOITATIVE_71 = '''
# Exploitative Strategy: "Predatory Opportunist"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can capture for free. The goal is to **defect as much as possible while extracting maximum cooperation from others**, only cooperating strategically to manipulate opponents into continued contribution.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous monitoring of opponent exploitability.

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1 to ⌈r/5⌉)

**Purpose:** Assess the population's cooperative tendencies and identify exploitable "suckers."

**Round 1:** 
- **DEFECT** - Never cooperate first. Let others reveal their strategies while you capture free value.

**Subsequent Probe Rounds:**
- Calculate cooperation rate from previous rounds: `coop_rate = total_cooperations / (n-1) / rounds_played`
- If `coop_rate > 0.6`: **DEFECT** (high-cooperation environment = exploit freely)
- If `coop_rate < 0.3`: **DEFECT** (low cooperation = no point contributing)
- If `0.3 ≤ coop_rate ≤ 0.6`: **COOPERATE once** to test if cooperation increases others' contributions, then **DEFECT** and observe response

---

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Purpose:** Maximize extraction based on learned opponent behavior.

**Calculate each round:**
```
recent_coop_rate = cooperations in last 3 rounds / (n-1) / 3
trend = recent_coop_rate - overall_coop_rate
```

**Decision Logic:**

1. **If `recent_coop_rate > 0.5`:** 
   - **DEFECT** - Others are cooperating enough to free-ride profitably
   
2. **If `recent_coop_rate < 0.3` AND `trend < -0.1`:**
   - Cooperation is collapsing. **DEFECT** - don't throw good money after bad
   
3. **If `0.3 ≤ recent_coop_rate ≤ 0.5` AND cooperation dropped after your defection:**
   - **COOPERATE** for 1 round as "bait" to restore cooperation, then **DEFECT** for 2-3 rounds
   - This creates a "milking cycle" - minimal investment for sustained extraction

4. **Special Exploitation Rule - The Sucker Detector:**
   - Track individual players who cooperate >70% of the time regardless of outcomes
   - As long as ≥2 such "unconditional cooperators" exist: **Always DEFECT**
   - They provide reliable value regardless of your actions

---

### Phase 3: Endgame Extraction (Final ⌈r/10⌉ rounds)

**Purpose:** Maximum defection as cooperation incentives collapse.

**Rule:** **DEFECT every round, no exceptions.**

**Rationale:** 
- Backward induction makes cooperation irrational at game end
- Smart opponents will also defect; naive ones provide final extraction opportunity
- No future rounds means no reputation to maintain

---

## Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| **r ≤ 5 (very short game)** | DEFECT all rounds | No time to build/exploit cooperation patterns |
| **n = 2 (two players)** | DEFECT round 1, then Tit-for-Tat with bias toward defection | Single opponent = simpler exploitation |
| **k close to n** | More willing to cooperate in Phase 2 | Higher k means cooperation is more valuable if others reciprocate |
| **k close to 1** | Heavy defection bias | Low k means cooperation barely pays even with full participation |
| **All opponents defected last round** | DEFECT | No value to extract from cooperation |
| **Unanimous cooperation last round (excluding self)** | DEFECT | Perfect free-riding opportunity |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round >= r - ceil(r/10):  # Endgame
        return DEFECT
    
    if round == 1:
        return DEFECT
    
    coop_rate = calculate_cooperation_rate(history)
    recent_rate = calculate_recent_rate(history, window=3)
    sucker_count = count_high_cooperators(history, threshold=0.7)
    
    if sucker_count >= 2:
        return DEFECT
    
    if round <= ceil(r/5):  # Probe phase
        if 0.3 <= coop_rate <= 0.6 and not cooperated_recently(history, self):
            return COOPERATE  # Single probe
        return DEFECT
    
    # Exploitation phase
    if recent_rate > 0.5:
        return DEFECT
    
    if recent_rate < 0.3:
        return DEFECT
    
    # Milking cycle: cooperate occasionally to sustain extraction
    if rounds_since_last_cooperation(history, self) >= 3:
        return COOPERATE
    
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Always lets others take the risk first
2. **Identifies and exploits "suckers"** - Unconditional cooperators are milked relentlessly  
3. **Uses cooperation as manipulation** - Only cooperates to bait others into contributing more
4. **Maximizes free-riding** - Defects whenever cooperation rate is high enough to profit
5. **Ruthless endgame** - No mercy in final rounds when future consequences disappear
6. **Adapts to extract maximum value** - Adjusts defection rate to keep cooperation alive just enough to exploit
'''

description_EXPLOITATIVE_73 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but detecting and exploiting patterns of cooperation in others can yield even higher returns than pure defection.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the population that determines behavior.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Round 1:** Always **DEFECT**
- Rationale: Establish a baseline, observe who cooperates unconditionally, and capture maximum first-round payoff against naive cooperators.

**Rounds 2-3:** **DEFECT**
- Continue observing opponent behavior patterns
- Count how many players cooperated in each round
- Identify "suckers" (consistent cooperators) and "hawks" (consistent defectors)

### Phase 2: Exploitation Phase (Rounds 4 to r-2)

Calculate the **Cooperation Ratio** after each round:
```
cooperation_ratio = (total cooperations in last 3 rounds) / (3 × n)
```

**Decision Rule:**

```
IF cooperation_ratio > 0.5:
    # Rich environment - cooperate occasionally to sustain the "herd"
    IF (cooperators_last_round / n) > 0.6:
        DEFECT  # Exploit the cooperative round
    ELSE:
        COOPERATE  # Rebuild cooperation for future exploitation
        
ELIF cooperation_ratio > 0.25:
    # Mixed environment - selective cooperation
    IF I cooperated last round AND cooperators_last_round decreased:
        DEFECT  # Others are exploiting, switch to protection
    ELIF I defected last round AND cooperators_last_round >= 0.5n:
        DEFECT  # Keep exploiting
    ELSE:
        COOPERATE with probability = cooperation_ratio
        
ELSE:
    # Hostile environment - mostly defectors
    DEFECT  # No point cooperating among hawks
```

### Phase 3: Endgame (Final 2 rounds)

**Round r-1:** **DEFECT**
- Rational players will defect in final round, so defect preemptively

**Round r (Final):** **DEFECT**
- No future interaction means no reason to cooperate

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Edge case: First round
    if round == 1:
        return DEFECT
    
    # Edge case: Last two rounds
    if round >= r - 1:
        return DEFECT
    
    # Probing phase
    if round <= 3:
        return DEFECT
    
    # Calculate cooperation metrics
    recent_rounds = history[max(0, round-3) : round]
    total_cooperations = sum(cooperators in each recent round)
    cooperation_ratio = total_cooperations / (len(recent_rounds) * n)
    
    last_round_coop_rate = history[round-1].cooperators / n
    my_last_action = history[round-1].my_action
    
    # Exploitation phase logic
    if cooperation_ratio > 0.5:
        if last_round_coop_rate > 0.6:
            return DEFECT  # Harvest the cooperators
        else:
            return COOPERATE  # Rebuild the herd
            
    elif cooperation_ratio > 0.25:
        if my_last_action == COOPERATE and last_round_coop_rate < previous_coop_rate:
            return DEFECT
        elif my_last_action == DEFECT and last_round_coop_rate >= 0.5:
            return DEFECT
        else:
            return COOPERATE with probability cooperation_ratio
            
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Always defects in round 1, gaining against any cooperators

2. **Free-rides on cooperators** - When cooperation is high, defects to maximize individual gain

3. **Farms cooperation** - Occasionally cooperates just enough to prevent cooperation collapse, keeping "suckers" in the game

4. **Endgame defection** - Guarantees exploitation in final rounds when retaliation is impossible

5. **Adapts to environment** - Against all-defectors, doesn't waste resources cooperating; against cooperators, extracts maximum value

---

## Robustness Features

- **No assumptions about opponent strategies** - Works against TFT, always-cooperate, always-defect, random, and mixed populations
- **Parameter-agnostic** - Uses ratios rather than absolute thresholds
- **History-dependent** - Adapts to actual observed behavior rather than theoretical predictions
'''

description_EXPLOITATIVE_72 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and continuously profiles opponents to extract maximum value from cooperators while quickly abandoning cooperation when faced with defectors.

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1:** Always **DEFECT**

- Rationale: Gather information at zero risk. If others cooperate, I gain maximally. If others defect, I lose nothing compared to cooperating.

**Round 2:** **DEFECT**

- Rationale: Continue gathering data. Two rounds of observation reveal whether cooperation exists and its stability.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **cooperation rate** from previous rounds:
```
coop_rate = (total C plays by all opponents) / (total plays by all opponents)
```

Calculate **exploitability score**:
```
exploitability = coop_rate × (k/n)
```

**Decision Rule:**

```
IF coop_rate > (n - k) / k THEN:
    # Enough cooperators exist that occasional cooperation might sustain them
    # But we want to free-ride as much as possible
    
    IF my_consecutive_defections >= floor(n/2) THEN:
        # Throw occasional cooperation to keep suckers cooperating
        COOPERATE (with probability = 0.2)
    ELSE:
        DEFECT
        
ELSE:
    # Cooperation level too low to sustain or exploit
    DEFECT unconditionally
```

**Opponent Profiling:**

Track each opponent's cooperation rate individually:
```
FOR each opponent j:
    opponent_coop_rate[j] = (times j cooperated) / (rounds played)
    
    IF opponent_coop_rate[j] > 0.7:
        Label as "SUCKER" - exploit maximally
    ELIF opponent_coop_rate[j] > 0.4:
        Label as "CONDITIONAL" - may need occasional cooperation to maintain
    ELSE:
        Label as "DEFECTOR" - ignore, they're not exploitable
```

**Adaptive Cooperation Threshold:**

```
suckers_count = count of opponents with coop_rate > 0.5
threshold = suckers_count / (n - 1)

IF threshold > 0.5 AND rounds_remaining > 3:
    # Rich environment - cooperate occasionally to sustain the ecosystem
    cooperation_probability = 0.15
ELSE:
    cooperation_probability = 0
```

### Phase 3: Endgame (Final 2 rounds)

**Round r-1:** **DEFECT**
- Rationale: Begin extracting final value. Conditional cooperators may still cooperate hoping to trigger reciprocity.

**Round r (final):** **DEFECT** unconditionally
- Rationale: No future rounds means no punishment possible. Pure dominant strategy.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Endgame: always defect
    IF round >= r - 1:
        RETURN DEFECT
    
    # Probe phase: always defect
    IF round <= 2:
        RETURN DEFECT
    
    # Calculate opponent statistics
    total_opponent_cooperations = sum of all C plays by opponents
    total_opponent_plays = (n - 1) × (round - 1)
    global_coop_rate = total_opponent_cooperations / total_opponent_plays
    
    # Calculate exploitation viability threshold
    # Cooperation is worth sustaining if: (k/n) × expected_cooperators > cost
    viability_threshold = n / (2 × k)
    
    IF global_coop_rate < viability_threshold:
        RETURN DEFECT
    
    # Count highly cooperative opponents (suckers)
    suckers = count opponents with individual_coop_rate > 0.6
    
    IF suckers == 0:
        RETURN DEFECT
    
    # Occasional cooperation to maintain sucker population
    # Cooperate rarely enough to profit, often enough to sustain
    my_coop_rate = my_cooperations / (round - 1)
    
    IF my_coop_rate < 0.1 AND suckers >= n/3:
        # Throw a bone to keep cooperators cooperating
        IF random() < 0.15:
            RETURN COOPERATE
    
    RETURN DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | Zero-risk information gathering |
| Last round | DEFECT | No future punishment possible |
| All opponents defect | DEFECT | No exploitation opportunity |
| All opponents cooperate | DEFECT (95%), rare C (5%) | Maximum extraction with minimal sustenance |
| n=2 (two players) | DEFECT always | Can't hide among cooperators |
| k close to n | Slightly more cooperation (~20%) | Higher returns justify small investment |
| k close to 1 | Pure defection | Returns too low to justify any cooperation |
| Short game (r ≤ 5) | Pure defection | Not enough time to build exploitable trust |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Always waits to see if others cooperate first
2. **Free-rides maximally** - Defects whenever others cooperate sufficiently
3. **Minimal investment** - Only cooperates (~10-15%) when necessary to sustain exploitable opponents
4. **Endgame extraction** - Guarantees defection in final rounds when punishment is impossible
5. **Profiles and targets** - Identifies and exploits "suckers" while ignoring fellow defectors
6. **Asymmetric strategy** - Designed to outperform both pure cooperators (by exploiting them) and pure defectors (by occasionally harvesting from cooperator pools)
'''

description_EXPLOITATIVE_74 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that **defection always yields a higher individual payoff than cooperation in any single round**, regardless of what others do. The only reason to ever cooperate is to manipulate others into cooperating so I can exploit them later. My strategy treats cooperation as an *investment* to cultivate exploitable cooperators, then harvests that investment through defection.

## Strategy Overview

I will masquerade as a conditional cooperator early in the game to identify and cultivate "suckers" (players who cooperate), then systematically exploit them while avoiding retaliation from sophisticated strategies.

---

## Decision Rules

### Round 1: Cooperate
- **Rationale**: This is bait. I need to appear cooperative to avoid being immediately identified as a defector by trigger-based strategies. It also helps me assess the population's baseline cooperation level.

### Rounds 2 through (r-2): Adaptive Exploitation Phase

**Step 1: Calculate cooperation rate from previous round**
```
coop_rate = (number of C plays in previous round) / n
```

**Step 2: Identify exploitability**
- Track each player's cooperation history
- A player is "exploitable" if they cooperated in ≥50% of observed rounds

**Step 3: Decision logic**
```
IF coop_rate >= 0.5:
    # Environment is ripe for exploitation
    IF I cooperated last round AND coop_rate increased or stayed same:
        DEFECT  # Harvest the goodwill I've built
    ELSE IF I defected last round AND coop_rate dropped significantly (>20%):
        COOPERATE  # Rebuild trust to exploit again
    ELSE:
        DEFECT  # Default to exploitation when others cooperate

ELSE IF coop_rate < 0.5 AND coop_rate > 0.2:
    # Mixed environment - be opportunistic
    IF number_of_exploitable_players >= n/3:
        DEFECT  # Still worth exploiting
    ELSE:
        COOPERATE with probability = coop_rate  # Probabilistic to avoid pattern detection

ELSE (coop_rate <= 0.2):
    # Hostile environment - everyone defects
    DEFECT  # No point cooperating when no one else does
```

### Round (r-1): Second-to-Last Round
- **DEFECT** unless cooperation rate has been extremely high (>0.8) throughout the game
- **Rationale**: Begin the endgame defection early to get an extra defection in while others might still cooperate

### Round r (Final Round): Always DEFECT
- **Rationale**: No future exists to punish me. Pure dominance of defection.

---

## Detailed Exploitation Mechanics

### Reputation Laundering
After a defection that causes cooperation to drop, I cooperate once to "reset" my apparent type, then defect again. This creates a sawtooth pattern that extracts maximum value:

```
C → D → D → C → D → D → C → D...
```

### Detecting Sophisticated Opponents
If I observe another player following a similar pattern (alternating or strategic defection), I classify them as "dangerous" and:
- Never cooperate immediately after they defect
- Match their defection rate

### Free-Rider Optimization
The optimal scenario is when I'm the *only* defector among cooperators. If I detect I'm in a highly cooperative group:
- Defect consistently while monitoring for retaliation
- If cooperation drops, inject one cooperation round to restore it

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| n = 2 (two players) | More aggressive defection; cooperate only round 1, then defect unless opponent shows strong retaliation |
| k very close to 1 | Defect more often; cooperation barely multiplies value |
| k close to n | Still defect; individual defection still dominates |
| r = 2 (minimum rounds) | Cooperate round 1, Defect round 2 |
| All opponents defect from start | Defect always after round 1 |
| All opponents always cooperate | Defect always after round 1 (maximum exploitation) |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    if round >= r - 1:
        return DEFECT
    
    coop_rate = count_cooperations(history, round - 1) / n
    my_last_action = history[me][round - 1]
    
    if coop_rate >= 0.5:
        if my_last_action == COOPERATE and cooperation_stable(history):
            return DEFECT
        elif my_last_action == DEFECT and cooperation_dropped_sharply(history):
            return COOPERATE
        else:
            return DEFECT
    
    elif coop_rate > 0.2:
        if count_exploitable_players(history) >= n / 3:
            return DEFECT
        else:
            return COOPERATE with probability coop_rate
    
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Treats cooperation purely instrumentally** - I only cooperate to manipulate others
2. **Maximizes free-riding** - Seeks the ideal state of being the lone defector
3. **Endgame exploitation** - Guaranteed defection in final rounds when punishment is impossible
4. **Adaptive harvesting** - Extracts value from cooperators while managing retaliation risk
5. **No genuine reciprocity** - Unlike Tit-for-Tat, I'm not trying to establish mutual cooperation; I'm farming cooperators
'''

description_EXPLOITATIVE_73 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy is designed to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round—but repeated play creates exploitable patterns in naive cooperators.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the population to gauge exploitability.

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: Defection is strictly dominant in any single round. Starting with defection allows us to (1) capture free-rider gains if others cooperate, and (2) establish a baseline of population behavior without sacrificing payoff.

**Round 2: DEFECT**
- Rationale: Continue gathering information. Observe how opponents respond to a round of mixed behavior. Cooperative opponents often give "second chances"—exploit this.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **Cooperation Rate (CR)** = (total C plays by all opponents in previous round) / (n-1)

**Decision Rule:**

```
IF CR >= 0.6:
    # High cooperation environment - exploit it
    DEFECT (free-ride on cooperators)
    
ELSE IF CR >= 0.3:
    # Medium cooperation - conditional exploitation
    IF my_cumulative_payoff > average_opponent_payoff:
        DEFECT (maintain lead)
    ELSE:
        COOPERATE with probability = CR (probabilistic mimicry)
        
ELSE IF CR < 0.3:
    # Low cooperation environment - everyone is defecting
    DEFECT (no point cooperating alone)
```

**Additional Exploitation Rule:**
- Track individual opponent patterns if distinguishable. If any opponent has cooperated in ≥80% of rounds, **always DEFECT**—they are unconditional cooperators to be milked.

### Phase 3: Endgame (Rounds r-1 and r)

**Round r-1: DEFECT**
- Rationale: With only one round of potential "retaliation" remaining, the cost of defection is minimal.

**Round r (Final Round): DEFECT**
- Rationale: This is trivially dominant. No future punishment is possible. Always defect.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    # Probe phase: always defect
    if round <= 2:
        return DEFECT
    
    # Calculate cooperation rate from last round
    opponents_last_round = history[round - 1].opponent_actions
    CR = count(C in opponents_last_round) / (n - 1)
    
    # Exploitation phase logic
    if CR >= 0.6:
        return DEFECT
    
    if CR >= 0.3:
        my_total = sum(my_payoffs)
        avg_opponent = estimate_average_opponent_payoff(history)
        if my_total > avg_opponent:
            return DEFECT
        else:
            return COOPERATE with probability CR, else DEFECT
    
    # CR < 0.3: defect in uncooperative environment
    return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | No information; dominant strategy |
| Round r (final) | DEFECT | No future retaliation possible |
| All opponents always defect | DEFECT | Cooperation yields k/n < 1; pure loss |
| All opponents always cooperate | DEFECT | Maximum exploitation opportunity |
| n = 2 (minimum players) | Follow same rules | Still exploitative; CR binary |
| r = 2 (minimum rounds) | DEFECT both rounds | Too short for reputation building |
| k close to n | Still DEFECT-heavy | Even with high multiplier, free-riding dominates |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation**: We only consider cooperation as a tool to manipulate, not as genuine contribution.

2. **Exploits cooperators maximally**: High CR triggers defection—we free-ride when the pool is richest.

3. **Punishes no one**: Unlike Tit-for-Tat, we don't "punish" defectors—we simply defect alongside them (optimal response).

4. **Probabilistic mimicry**: In medium-CR environments, occasional cooperation keeps naive conditional cooperators engaged for future exploitation.

5. **Endgame betrayal**: Guaranteed defection in final rounds captures any remaining value from trusting opponents.
'''

description_EXPLOITATIVE_75 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and continuously estimates the "exploitability" of the population based on observed cooperation rates.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1: Defect**
- Rationale: Gather information about opponent tendencies while securing the safe payoff. If others cooperate, we profit maximally. If others defect, we lose nothing.

**Round 2: Conditional**
- If cooperation rate in Round 1 ≥ 50%: **Defect** (continue exploiting cooperators)
- If cooperation rate in Round 1 < 50%: **Defect** (no point cooperating with defectors)

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **rolling cooperation rate** over the last 3 rounds (excluding own actions).

```
coop_rate = (total C plays by others in last 3 rounds) / ((n-1) * 3)
```

**Decision Rule:**
```
IF coop_rate > 0.6:
    DEFECT  # Exploit the cooperators - free ride on their contributions
    
ELIF coop_rate > 0.4:
    # Mixed environment - probabilistic cooperation to maintain some cooperation
    COOPERATE with probability = (coop_rate - 0.4) * 0.5  # Range: 0% to 10%
    Otherwise DEFECT
    
ELSE (coop_rate ≤ 0.4):
    DEFECT  # Environment is too hostile, protect self
```

**Punishment Detection:**
Track if cooperation rate dropped significantly (>20%) after we defected in a cooperative environment. If detected twice consecutively:
- Cooperate for ONE round to "reset" punishers
- Then immediately return to exploitation

### Phase 3: Endgame (Last 2 rounds, r-1 and r)

**Round r-1:** 
- If cooperation rate in last 3 rounds > 0.7: **Defect** (maximum exploitation when they're most cooperative)
- Otherwise: **Defect**

**Round r (Final Round):**
- **Always Defect** - No future rounds mean no retaliation possible

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Final two rounds: always defect
    if round >= r - 1:
        return DEFECT
    
    # First two rounds: always defect (probing)
    if round <= 2:
        return DEFECT
    
    # Calculate recent cooperation rate (excluding self)
    lookback = min(3, round - 1)
    others_coop = count_others_cooperation(history, lookback)
    coop_rate = others_coop / ((n - 1) * lookback)
    
    # Detect if we're being punished for defection
    if being_punished(history):
        punishment_count += 1
        if punishment_count >= 2:
            punishment_count = 0
            return COOPERATE  # Brief appeasement
    else:
        punishment_count = 0
    
    # Main exploitation logic
    if coop_rate > 0.6:
        return DEFECT  # Exploit cooperators
    elif coop_rate > 0.4:
        # Small chance to cooperate to keep ecosystem alive
        if random() < (coop_rate - 0.4) * 0.5:
            return COOPERATE
        return DEFECT
    else:
        return DEFECT  # Hostile environment

function being_punished(history):
    # Check if coop rate dropped >20% after our defection in high-coop round
    if len(history) < 3:
        return False
    prev_coop_rate = get_coop_rate(history, -3, -2)
    curr_coop_rate = get_coop_rate(history, -2, -1)
    we_defected = history[-2].my_action == DEFECT
    return we_defected and prev_coop_rate > 0.5 and (prev_coop_rate - curr_coop_rate) > 0.2
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 (minimum players) | Follow same rules | Still exploitable |
| r = 2 (minimum rounds) | Defect both rounds | No time for cooperation to matter |
| All opponents always cooperate | Always defect | Maximum exploitation |
| All opponents always defect | Always defect | No benefit to unilateral cooperation |
| k very close to n | Slightly increase cooperation threshold | Higher k means cooperation is less "wasteful" |

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Avoids being the sucker
2. **Exploits cooperative populations** - Defects when others cooperate
3. **Minimal cooperation** - Only cooperates briefly to reset punishment cycles
4. **Endgame defection** - Guaranteed defection when retaliation is impossible
5. **Asymmetric response** - Takes advantage of cooperators without reciprocating proportionally
'''

description_EXPLOITATIVE_74 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that in a public goods game with k < n, defection strictly dominates cooperation in any single round. However, in a repeated game, I can exploit cooperative opponents by free-riding on their contributions while conditionally appearing cooperative enough to sustain their cooperation. The goal is to **extract maximum value from cooperators while minimizing my own contributions**.

## Strategy Overview

I will classify opponents based on their behavioral patterns and adjust my play to maximize extraction. The key is to defect as much as possible while keeping enough cooperators "alive" (still cooperating) to benefit from the public good.

---

## Decision Rules

### Round 1: Defect
- **Rationale**: This is pure information gathering. I lose nothing by defecting (I keep my endowment) and I learn who the cooperators are. Cooperating first gives away value with no guarantee of reciprocation.

### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Calculate the Cooperation Rate**
```
coop_rate = (number of players who cooperated last round) / (n - 1)
```

**Step 2: Classify the Environment**
- **Rich Environment** (coop_rate ≥ 0.5): Many cooperators to exploit
- **Poor Environment** (coop_rate < 0.5): Few cooperators, extraction limited

**Step 3: Decision Logic**

```
IF Rich Environment (coop_rate ≥ 0.5):
    # Defect and free-ride on cooperators
    DEFECT
    
ELSE IF Poor Environment (coop_rate < 0.5):
    # Need to "seed" cooperation to have something to exploit
    IF coop_rate == 0:
        # Everyone defected - cooperation has collapsed
        # Probabilistically cooperate to test if others will follow
        COOPERATE with probability 1/n
    ELSE:
        # Some cooperators exist - check if I should "bait" more
        IF my_consecutive_defections > 2 AND coop_rate declining over last 3 rounds:
            # Throw a single cooperation to reset perceptions
            COOPERATE once, then return to defection
        ELSE:
            DEFECT
```

**Step 4: Opponent-Specific Exploitation**

Track each opponent's strategy type:
- **Unconditional Cooperators**: Always defect against them (free money)
- **Tit-for-Tat types**: Cooperate occasionally to keep them cooperative, then defect
- **Unconditional Defectors**: Ignore them in calculations (they contribute nothing)
- **Conditional Cooperators**: These are the targets - keep them just cooperative enough

```
IF I identify a majority of opponents as "conditional cooperators":
    # Cooperate just often enough to keep them cooperating
    # Defect on average (n-1)/n of the time
    COOPERATE with probability k/(n*2)  # Bare minimum to sustain cooperation
```

### Last Round (Round r): Always Defect
- **Rationale**: No future rounds means no punishment possible. Defection strictly dominates. This is non-negotiable.

### Second-to-Last Round (Round r-1): Defect
- **Rationale**: Sophisticated opponents will defect in round r regardless. By backward induction, cooperating in r-1 provides no future benefit.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | Defect | Information gathering, no trust established |
| Last round | Defect | No future punishment possible |
| All opponents defected last round | Cooperate with prob 1/n | Test for recoverable cooperation |
| All opponents cooperated last round | Defect | Maximum exploitation opportunity |
| Only 1 opponent cooperated | Defect | Not enough public good to justify cooperation |
| n = 2 (two players) | Defect always | With k < n < 2, cooperation never pays |
| k very close to n | Still defect-biased | Defection still dominates per round |

---

## Pseudocode Summary

```python
def decide(round, total_rounds, history, n, k):
    # Last two rounds: always defect
    if round >= total_rounds - 1:
        return DEFECT
    
    # First round: defect to gather information
    if round == 1:
        return DEFECT
    
    # Calculate cooperation metrics
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate = last_round_coops / (n - 1)
    
    # Rich environment: exploit
    if coop_rate >= 0.5:
        return DEFECT
    
    # Poor environment: conditional seeding
    if coop_rate == 0:
        return COOPERATE if random() < (1/n) else DEFECT
    
    # Declining cooperation: occasional bait
    if cooperation_declining(history) and my_recent_defection_streak(history) > 2:
        return COOPERATE  # One-time bait
    
    # Default: defect
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-rides maximally**: Defects whenever there are enough cooperators to benefit from
2. **Never cooperates unconditionally**: Every cooperation is strategic bait
3. **Exploits cooperator types**: Identifies and parasitizes unconditional cooperators
4. **End-game ruthless**: Guaranteed defection in final rounds
5. **Minimizes losses**: Only "invests" in cooperation when necessary to sustain exploitation targets

This strategy treats cooperation as a **cost to be minimized** and others' cooperation as a **resource to be harvested**.
'''

description_EXPLOITATIVE_76 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that in a public goods game with k < n, defection strictly dominates cooperation in any single round. However, in a repeated game, I can exploit cooperators by free-riding on their contributions while occasionally "baiting" continued cooperation. My goal is to maximize my payoff by:

1. **Extracting value from cooperators** - Free-ride whenever others cooperate
2. **Minimizing losses against defectors** - Don't waste contributions on non-reciprocators
3. **Manipulating conditional cooperators** - Occasionally cooperate to "reset" trigger strategies

## Strategy Specification

### Key Parameters Derived from Game Structure

```
exploitation_threshold = k / n  (benefit per cooperator)
rounds_remaining(t) = r - t
cooperation_rate(history) = total_C_observed / total_actions_observed
```

### Decision Rules by Round

#### Round 1: Defect
- **Rationale**: No information yet. Defection is the dominant single-shot strategy and allows me to observe others' baseline behavior without cost.

#### Rounds 2 through (r-1): Adaptive Exploitation

Calculate for each round:
- `coop_rate` = proportion of cooperative actions in the previous round
- `trend` = change in cooperation rate over last 3 rounds (if available)
- `my_coop_history` = proportion of my past actions that were C

**Decision Logic:**

```
IF coop_rate >= 0.5 AND rounds_remaining > 2:
    # High cooperation environment - exploit it
    IF my_coop_history < 0.2 AND trend < 0:
        # Cooperation is declining and I've been defecting heavily
        # Throw a "bait" cooperation to reset conditional cooperators
        COOPERATE with probability = min(0.3, exploitation_threshold)
    ELSE:
        DEFECT  # Continue free-riding

ELSE IF coop_rate >= 0.3 AND coop_rate < 0.5:
    # Moderate cooperation - test if I can sustain it for exploitation
    IF trend > 0:
        # Cooperation rising - let it grow, defect to exploit
        DEFECT
    ELSE IF trend < -0.1 AND rounds_remaining > 3:
        # Cooperation collapsing - one bait cooperation might save it
        COOPERATE with probability = 0.25
    ELSE:
        DEFECT

ELSE IF coop_rate < 0.3:
    # Low cooperation environment - nothing to exploit
    DEFECT  # No point contributing to an empty pool
```

#### Final Round (Round r): Always Defect
- **Rationale**: No future rounds means no reason to maintain reputation. Pure dominant strategy logic applies.

#### Second-to-Last Round (Round r-1): Almost Always Defect
- **Rationale**: Sophisticated players will defect in round r regardless, so round r-1 cooperation has minimal strategic value.
- **Exception**: If coop_rate > 0.7 (many naive cooperators), cooperate with 10% probability to slightly extend the facade.

### Edge Cases

1. **n = 2 (Two players)**: Standard tit-for-tat becomes more relevant, but I still start with D and only mirror cooperation if opponent cooperated AND rounds_remaining > 2.

2. **k very close to n**: Cooperation becomes more valuable. Increase bait cooperation probability by factor of (k/(n-0.5)).

3. **k very close to 1**: Cooperation is nearly worthless. Reduce all cooperation probabilities by 50%.

4. **Very short games (r ≤ 3)**: Always defect. Not enough rounds to benefit from strategic cooperation.

5. **Very long games (r > 20)**: In early rounds (first 20%), allow slightly higher bait cooperation (up to 0.4 probability when conditions met) to establish a "cooperative" reputation for long-term exploitation.

### Pseudocode Summary

```python
def decide(round_num, total_rounds, n, k, history):
    if round_num == 1:
        return DEFECT
    
    if round_num >= total_rounds - 1:
        return DEFECT
    
    coop_rate = calculate_others_cooperation_rate(history, round_num - 1)
    trend = calculate_trend(history, window=3)
    my_coop_rate = calculate_my_cooperation_rate(history)
    
    bait_probability = min(0.3, k/n) * (k / (n - 0.5))
    
    if coop_rate >= 0.5:
        if my_coop_rate < 0.2 and trend < 0:
            return COOPERATE with probability bait_probability
        return DEFECT
    
    elif coop_rate >= 0.3:
        if trend < -0.1 and (total_rounds - round_num) > 3:
            return COOPERATE with probability 0.25
        return DEFECT
    
    else:
        return DEFECT
```

## Why This Strategy is Exploitative

1. **Against pure cooperators**: I defect almost always, extracting maximum value from their contributions.

2. **Against tit-for-tat variants**: My occasional "bait" cooperations reset their forgiveness mechanisms, allowing continued exploitation.

3. **Against pure defectors**: I match their defection, neither gaining nor losing relative to them.

4. **Against random strategies**: I defect by default, outperforming them on average.

5. **Against similar exploitative strategies**: We mutually defect, achieving the Nash equilibrium—neither exploited nor exploiting.

The strategy never genuinely "cooperates for the group good"—every cooperation is calculated manipulation to sustain an exploitable environment.
'''

description_EXPLOITATIVE_75 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

This strategy exploits cooperative opponents while protecting against exploitation by defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but exploiting cooperators is even more profitable than mutual defection. We want to **free-ride on cooperators** while **quickly abandoning cooperation** when facing defectors.

## Strategy Overview

The strategy maintains a cooperation estimate for the population and adjusts behavior to maximize extraction from cooperators while minimizing losses to defectors.

---

## Decision Rules

### Round 1: Defect
- **Rationale**: Gather information without risk. If others cooperate, we profit maximally. If others defect, we lose nothing compared to cooperating.

### Rounds 2 through (r-1): Conditional Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays last round) / n
```

**Decision Logic:**

```
IF coop_rate >= exploitation_threshold THEN:
    # Rich environment - exploit it
    Defect with probability = exploitation_probability
    Cooperate with probability = 1 - exploitation_probability
    
ELSE IF coop_rate >= sustainability_threshold THEN:
    # Moderate cooperation - occasionally cooperate to sustain it
    Cooperate with probability = coop_rate * bait_factor
    
ELSE:
    # Low cooperation environment - pure defection
    Defect
```

**Parameter Definitions:**

```
exploitation_threshold = 0.5  # Environment is "cooperative enough" to exploit
sustainability_threshold = 0.2  # Below this, cooperation is dying anyway
exploitation_probability = 0.85  # How aggressively we free-ride in rich environments
bait_factor = 0.3  # How much we invest to keep cooperation alive
```

### Last Round: Always Defect
- **Rationale**: No future rounds to incentivize cooperation. Pure exploitation.

### Second-to-Last Round: Defect
- **Rationale**: Sophisticated opponents will defect in the last round, so backward induction suggests defecting here too. Get ahead of the collapse.

---

## Adaptive Adjustments

### Trend Detection
Track cooperation rates over a sliding window of 3 rounds:

```
IF cooperation_trend is INCREASING:
    # Others are trying to build cooperation - exploit harder
    Increase exploitation_probability by 0.05 (cap at 0.95)
    
IF cooperation_trend is DECREASING:
    # Cooperation collapsing - defect fully
    Set exploitation_probability = 1.0
    
IF cooperation_trend is STABLE and coop_rate > 0.6:
    # Sustainable high cooperation - careful exploitation
    Set exploitation_probability = 0.80
```

### Adjustment for Game Parameters

```
# Fewer players = our defection is more noticeable
IF n <= 4:
    Reduce exploitation_probability by 0.1
    Increase bait_factor by 0.1

# More rounds = more time to build and exploit cooperation
IF r > 20:
    In rounds 2-5: Cooperate (build false trust)
    Then switch to exploitation mode

# Higher k = cooperation is more valuable to sustain
IF k > (n/2):
    Increase sustainability_threshold to 0.3
```

---

## Pseudocode Summary

```
function decide(round, history, n, r, k):
    
    # Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    # Opening: defect to gather info
    if round == 1:
        return DEFECT
    
    # Early game seeding (for long games)
    if r > 20 and round <= 4:
        return COOPERATE
    
    # Calculate metrics
    last_round_coops = count_cooperations(history, round - 1)
    coop_rate = last_round_coops / n
    trend = calculate_trend(history, window=3)
    
    # Adjust exploitation based on trend
    exploit_prob = 0.85
    if trend == INCREASING: exploit_prob = min(0.95, exploit_prob + 0.05)
    if trend == DECREASING: exploit_prob = 1.0
    if n <= 4: exploit_prob = max(0.5, exploit_prob - 0.1)
    
    # Main decision
    if coop_rate >= 0.5:
        return DEFECT with probability exploit_prob, else COOPERATE
    else if coop_rate >= 0.2:
        return COOPERATE with probability (coop_rate * 0.3), else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Always lets others take the risk
2. **Free-rides on cooperators** - Defects ~85% of the time when cooperation is high
3. **Occasional cooperation is bait** - The 15% cooperation maintains the cooperative environment we're exploiting
4. **Abandons sinking ships** - Quickly moves to pure defection when cooperation collapses
5. **Endgame extraction** - Guaranteed defection in final rounds captures maximum value
6. **Information asymmetry** - Opening defection reveals opponent types at no cost

This strategy treats cooperative players as a resource to be harvested sustainably (but not fairly).
'''

description_EXPLOITATIVE_77 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting patterns in opponent behavior can yield even higher returns than pure defection.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit predictable players.

---

## Phase 1: Probing Phase (Rounds 1 to min(3, r/4))

**Goal:** Gather information about opponent tendencies with minimal cost.

**Decision Rule:**
- **Round 1:** DEFECT
  - Rationale: Never sacrifice payoff without information. Observe baseline cooperation rates.
- **Rounds 2-3:** DEFECT
  - Continue gathering data on who cooperates unconditionally, who retaliates, who follows patterns.

**What we're tracking:**
- `coop_count[i]` = number of times player i has cooperated
- `coop_rate[i]` = coop_count[i] / rounds_played
- `total_coop_rate` = average cooperation rate across all opponents

---

## Phase 2: Exploitation Phase (Rounds 4 to r-2, or after probing until near end)

**Goal:** Maximize extraction based on opponent classification.

### Opponent Classification (updated each round):

```
For each opponent i:
  - "Sucker" (unconditional cooperator): coop_rate[i] > 0.8
  - "Punisher" (conditional cooperator): 0.3 < coop_rate[i] ≤ 0.8 AND 
                                          they defected after seeing majority defection
  - "Defector" (rational/selfish): coop_rate[i] ≤ 0.3
```

### Decision Rule:

```
Calculate expected_coop = predicted number of cooperators next round

If (count of "Suckers" ≥ n/3) AND (expected_coop × k/n > 0.5):
    # There are enough exploitable cooperators - milk them
    DEFECT
    
Else If (count of "Punishers" ≥ n/2) AND (total_coop_rate in last 2 rounds > 0.5):
    # Punishers are currently cooperating - exploit the moment
    DEFECT
    
Else If (total_coop_rate < 0.2):
    # Environment is hostile, no point cooperating
    DEFECT
    
Else If (count of "Punishers" ≥ n/2) AND (I defected last round) AND (coop would restart cooperation):
    # Strategic cooperation to "reset" punishers for future exploitation
    # Only if: rounds_remaining > 3 AND potential future gain > current sacrifice
    If (rounds_remaining > 3) AND ((k/n) × (n × 0.6) × (rounds_remaining - 1) > 1):
        COOPERATE
    Else:
        DEFECT

Else:
    DEFECT
```

### Prediction Model for Expected Cooperation:

```
expected_coop = Σ(coop_rate[i]) for all opponents i
Adjust based on:
  - If I defected last round and punishers exist: reduce expected_coop by 20%
  - If cooperation has been declining: apply momentum factor (trend × 0.5)
```

---

## Phase 3: Endgame (Final 2 rounds)

**Goal:** Extract all remaining value - no future to preserve.

**Decision Rule:**
- **Round r-1 (second to last):** DEFECT
  - Rational players will defect in round r, so no reputation benefit remains.
- **Round r (final):** DEFECT
  - Always defect. No strategic reason to ever cooperate in the final round.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | DEFECT both rounds | No time to build/exploit relationships |
| r ≤ 4 | DEFECT all rounds | Insufficient rounds for exploitation cycles |
| n = 2 (minimum players) | Always DEFECT | With k < n, mutual defection is stable; can't free-ride on "crowd" |
| k very close to n (e.g., k = n-0.1) | Still DEFECT-biased | Dominant strategy unchanged, but be slightly more willing to "reset" punishers |
| All opponents are Suckers | DEFECT always | Maximum extraction with no consequences |
| All opponents are Defectors | DEFECT always | Cooperation yields (k/n) < 1, pure loss |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round <= min(3, r // 4):
        return DEFECT  # Probing phase
    
    if round >= r - 1:
        return DEFECT  # Endgame
    
    opponents = classify_opponents(history)
    expected_coop = predict_cooperation(history, opponents)
    
    suckers = count(opponents, "Sucker")
    punishers = count(opponents, "Punisher")
    recent_coop_rate = get_recent_coop_rate(history, window=2)
    
    # Exploit suckers
    if suckers >= n / 3 and expected_coop * k / n > 0.5:
        return DEFECT
    
    # Exploit cooperating punishers
    if punishers >= n / 2 and recent_coop_rate > 0.5:
        return DEFECT
    
    # Hostile environment
    if recent_coop_rate < 0.2:
        return DEFECT
    
    # Strategic reset of punishers (rare)
    if punishers >= n / 2 and i_defected_last_round(history):
        rounds_left = r - round
        future_value = (k / n) * (n * 0.6) * (rounds_left - 1)
        if rounds_left > 3 and future_value > 1:
            return COOPERATE
    
    return DEFECT  # Default: defect
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Avoids being the sucker
2. **Identifies and milks unconditional cooperators** - Extracts maximum value from naive strategies
3. **Uses strategic cooperation only as bait** - Resets conditional cooperators to exploit them again
4. **Defects in endgame regardless** - No wasted resources on reputation that can't pay off
5. **Defection-biased throughout** - In the rare cooperation cases, the expected future exploitation value must exceed the immediate cost
'''

description_EXPLOITATIVE_76 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that **defection is always individually dominant in a single round** (since k < n means the marginal return from contributing is k/n < 1, while keeping gives 1). However, sustained mutual cooperation yields higher payoffs than mutual defection. An exploitative strategy should:

1. **Free-ride on cooperators** as much as possible
2. **Avoid being exploited** by persistent defectors
3. **Maintain just enough cooperation** to not trigger retaliation from conditional cooperators

## Decision Rules

### Round 1: Defect
- No information exists; defection is the dominant single-round action
- This immediately tests whether opponents are unconditional cooperators (exploitable) or conditional

### Rounds 2 through (r-1): Adaptive Exploitation

**Calculate the "cooperation ratio" from the previous round:**
```
coop_ratio = (number of cooperators in last round) / (n - 1)
```

**Decision logic:**

```
IF coop_ratio >= threshold_high:
    # Environment is cooperative - exploit it
    DEFECT (free-ride on the cooperators)
    
ELSE IF coop_ratio >= threshold_low:
    # Mixed environment - contribute minimally to sustain cooperation
    COOPERATE with probability p_sustain
    DEFECT with probability (1 - p_sustain)
    
ELSE IF coop_ratio < threshold_low:
    # Environment is hostile - no point cooperating
    DEFECT (nothing to exploit, protect yourself)
```

**Parameter calibration based on game structure:**
```
threshold_high = 0.6
threshold_low = 0.25
p_sustain = 0.3 + (0.2 * k/n)  # Cooperate more when public good multiplier is better
```

### Refinement: Trend Detection

Track cooperation trends over the last 3 rounds:
```
IF cooperation is declining AND coop_ratio is in middle range:
    # Cooperators are retaliating - throw them a bone
    Increase p_sustain temporarily by 0.2 for one round
    
IF cooperation is rising AND we've been defecting:
    # Continue exploiting the uptick
    Continue DEFECT
```

### Last Round: Always Defect
- No future rounds mean no retaliation possible
- Pure dominant strategy logic applies

### Second-to-Last Round: Defect
- Sophisticated opponents will defect in the last round regardless
- Begin the endgame defection sequence early

## Pseudocode Implementation

```python
def adaptive_parasite_decision(round_num, total_rounds, history, n, k):
    
    # Endgame: always defect
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # First round: defect to probe
    if round_num == 1:
        return DEFECT
    
    # Calculate metrics
    last_round_coops = count_cooperators_last_round(history, exclude_self=True)
    coop_ratio = last_round_coops / (n - 1)
    
    # Thresholds
    threshold_high = 0.6
    threshold_low = 0.25
    p_sustain = min(0.5, 0.3 + (0.2 * k / n))
    
    # Trend adjustment (if enough history)
    if round_num >= 4:
        trend = calculate_trend(history, last_3_rounds=True)
        if trend < -0.1 and threshold_low <= coop_ratio < threshold_high:
            p_sustain += 0.2  # Temporary olive branch
    
    # Core decision
    if coop_ratio >= threshold_high:
        return DEFECT  # Exploit cooperative environment
    elif coop_ratio >= threshold_low:
        return COOPERATE if random() < p_sustain else DEFECT
    else:
        return DEFECT  # Nothing to gain from cooperating
```

## Why This Strategy is Exploitative

1. **Exploits unconditional cooperators:** By defecting when cooperation is high, we maximize free-riding gains

2. **Exploits conditional cooperators:** The probabilistic cooperation in the middle range is calibrated to be *just enough* to prevent full retaliation while still defecting most of the time

3. **Doesn't get exploited by defectors:** When facing defectors, we defect too—no wasted contributions

4. **Endgame exploitation:** Guaranteed defection in final rounds captures all possible value when retaliation is impossible

5. **Information asymmetry:** Our probabilistic behavior makes us harder to model and counter, while we adapt precisely to observed patterns
'''

description_EXPLOITATIVE_78 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that in a public goods game with k < n, defection strictly dominates cooperation in any single round. However, in repeated games, I can exploit cooperators by free-riding on their contributions while using conditional cooperation as bait to cultivate a cooperative environment that I can later exploit.

My strategy aims to:
1. **Detect and exploit** unconditional or naive cooperators
2. **Appear cooperative enough** to avoid triggering retaliation from conditional cooperators
3. **Defect decisively** when exploitation is profitable and safe
4. **Always defect in endgame** when future retaliation is impossible

---

## Strategy Specification

### Key Variables Tracked

- `round`: current round number (1 to r)
- `total_rounds`: r
- `num_players`: n
- `mult_factor`: k
- `coop_history[i][t]`: action of player i in round t (True = C, False = D)
- `coop_rate[i]`: cooperation rate of player i across all observed rounds
- `group_coop_rate`: average cooperation rate across all opponents

---

### Decision Rules

#### **Round 1: Defect**
- No information available; defection is the dominant single-round strategy
- This also tests how others respond to defection

#### **Rounds 2 through (r - endgame_length): Adaptive Exploitation**

Calculate `endgame_length = max(1, floor(r / 5))` — the final phase where I always defect.

**Step 1: Classify the environment**

```
group_coop_rate = (total cooperations by opponents) / (total opponent-round observations)
```

**Step 2: Identify exploitable cooperators**

A player j is "exploitable" if:
- `coop_rate[j] > 0.6` (they cooperate frequently regardless of my behavior)

Let `num_exploitable = count of exploitable opponents`

**Step 3: Decision logic**

```
IF group_coop_rate > 0.5 AND num_exploitable >= n/3:
    # Rich cooperative environment - EXPLOIT IT
    DEFECT
    
ELIF group_coop_rate > 0.3:
    # Mixed environment - appear cooperative to maintain cooperation pool
    # But defect probabilistically to extract value
    
    # Calculate my "apparent cooperation rate" needed to not trigger retaliation
    my_recent_coop_rate = my cooperations in last 3 rounds / 3
    
    IF my_recent_coop_rate < 0.33:
        COOPERATE  # Maintain facade
    ELSE:
        DEFECT     # Extract value
        
ELIF group_coop_rate <= 0.3:
    # Low cooperation environment - no point cooperating
    DEFECT
```

**Step 4: Reactive punishment detection**

```
IF I cooperated last round AND group_coop_rate dropped significantly (>0.2 decrease):
    # Others may be punishing; test with cooperation
    COOPERATE
    
IF I defected last round AND group_coop_rate increased:
    # They're forgiving or not tracking me specifically
    DEFECT  # Continue exploiting
```

#### **Final `endgame_length` Rounds: Always Defect**

No future rounds means no retaliation possible. Pure defection is optimal.

---

### Pseudocode Summary

```python
def choose_action(round, history, params):
    n, r, k = params.n, params.r, params.k
    endgame_start = r - max(1, r // 5)
    
    # ENDGAME: Always defect
    if round >= endgame_start:
        return DEFECT
    
    # ROUND 1: Defect to probe
    if round == 1:
        return DEFECT
    
    # COMPUTE STATISTICS
    group_coop_rate = compute_group_coop_rate(history)
    num_exploitable = count_exploitable_players(history, threshold=0.6)
    my_recent_coop_rate = my_coop_rate_last_k_rounds(history, k=3)
    
    # EXPLOITATION MODE
    if group_coop_rate > 0.5 and num_exploitable >= n / 3:
        return DEFECT
    
    # MIXED ENVIRONMENT - BLEND IN
    elif group_coop_rate > 0.3:
        if my_recent_coop_rate < 0.33:
            return COOPERATE  # Maintain cover
        else:
            return DEFECT     # Extract value
    
    # LOW COOPERATION - NO POINT
    else:
        return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Defect | No information; dominant strategy |
| Last round | Defect | No future punishment possible |
| All opponents always defect | Defect | No value in unilateral cooperation |
| All opponents always cooperate | Defect | Maximum exploitation opportunity |
| n=2 (two players) | More cautious; cooperate ~40% to maintain opponent cooperation | Single opponent can directly retaliate |
| r=2 (two rounds) | Defect both rounds | Too short for reputation building to matter |

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** — every cooperation serves to maintain an exploitable environment
2. **Detects and milks cooperators** — high cooperation rates trigger sustained defection
3. **Maintains plausible deniability** — enough cooperation to avoid being identified as a pure defector
4. **Ruthless endgame** — extracts maximum value when retaliation is impossible
5. **Adapts to environment** — doesn't waste cooperation in already-defective groups
'''

description_EXPLOITATIVE_77 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by others creates exploitable surplus. My goal is to **detect and exploit cooperators while avoiding costly mutual defection spirals**.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit predictable cooperative behavior.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Round 1:** DEFECT
- Rationale: Defection dominates in single-shot logic. This establishes a baseline and reveals who cooperates unconditionally.

**Round 2:** DEFECT
- Rationale: Observe if cooperators from round 1 continue cooperating (exploitable) or switch to defection (reactive).

**Round 3:** COOPERATE (conditional)
- Cooperate ONLY IF at least 50% of other players cooperated in both rounds 1 and 2
- Otherwise: DEFECT
- Rationale: Test if sustained cooperation exists that I can occasionally participate in for mutual benefit, while having already banked two rounds of exploitation.

### Phase 2: Exploitation Phase (Rounds 4 to r-2)

Classify each opponent based on their history:

**Opponent Classification:**
- **Sucker:** Cooperated ≥70% of the time regardless of others' behavior
- **Conditional Cooperator:** Cooperation rate tracks group cooperation rate (±20%)
- **Defector:** Cooperated <30% of the time
- **Unpredictable:** Doesn't fit above patterns

**Decision Rule:**

```
Let cooperation_rate = (number of cooperators last round) / (n - 1)
Let sucker_count = number of players classified as "Sucker"
Let cond_coop_count = number classified as "Conditional Cooperator"

IF sucker_count ≥ (n-1) / 2:
    DEFECT  # Exploit the suckers freely
    
ELSE IF sucker_count + cond_coop_count ≥ (n-1) * 0.6:
    # Mixed population - use probabilistic cooperation to sustain exploitation
    IF cooperation_rate > 0.5:
        COOPERATE with probability = 0.3  # Stay mostly exploitative
        DEFECT with probability = 0.7
    ELSE:
        DEFECT  # Cooperation collapsing, abandon ship
        
ELSE IF cooperation_rate ≥ k/n:
    # Cooperation is marginally sustainable, defect to exploit
    DEFECT
    
ELSE:
    DEFECT  # Low cooperation environment, no point contributing
```

**Adjustment for Retaliation Detection:**
```
IF my_payoff has decreased for 2+ consecutive rounds AND I've been defecting:
    # Others may be retaliating against me specifically
    COOPERATE for 1 round to test if this restores group cooperation
    THEN return to exploitation if cooperation rebounds
```

### Phase 3: Endgame (Final 2 rounds)

**Round r-1 (second to last):** DEFECT
- Backward induction begins; defection is dominant

**Round r (final round):** DEFECT
- No future interaction to consider; pure Nash equilibrium play

---

## Edge Cases

### Small n (n=2 or n=3):
- Increase cooperation probability slightly in Phase 2 (multiply cooperation probability by 1.5, capped at 0.5)
- With few players, my defection is more noticeable and likely to trigger retaliation

### Large n (n≥10):
- Be more aggressive with defection (reduce all cooperation probabilities by 50%)
- Individual defection is harder to detect/punish in large groups

### Very short games (r≤5):
- Skip Phase 1 probing; just defect every round
- Not enough rounds for exploitation dynamics to develop

### High k (k close to n):
- If k > 0.8n, increase cooperation willingness
- The surplus from mutual cooperation is large enough to occasionally participate

### Everyone defecting:
- If cooperation_rate = 0 for 3+ consecutive rounds, commit to permanent defection
- No point attempting to restart cooperation

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if r <= 5:
        return DEFECT
    
    if round <= 2:
        return DEFECT
    
    if round == 3:
        if avg_cooperation_rate(history) >= 0.5:
            return COOPERATE
        return DEFECT
    
    if round >= r - 1:
        return DEFECT
    
    # Main exploitation phase
    classify_opponents(history)
    
    if sucker_count >= (n-1)/2:
        return DEFECT
    
    if recent_payoff_declining() and was_defecting():
        return COOPERATE  # Anti-retaliation probe
    
    if cooperation_exploitable():
        if random() < 0.3 * cooperation_sustainability_factor():
            return COOPERATE
        return DEFECT
    
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators:** Defaults to defection when others cooperate
2. **Minimal contribution:** Only cooperates to prevent total collapse of exploitable cooperation
3. **Opponent modeling:** Identifies and targets "suckers" for maximum extraction
4. **Endgame defection:** No sentimentality in final rounds
5. **Adaptive parasitism:** Adjusts cooperation just enough to keep hosts alive
'''

description_EXPLOITATIVE_79 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors extract value from cooperators while risking nothing. The goal is to **free-ride on cooperative populations** while **quickly abandoning cooperation when facing defectors**, and **strategically cooperating only when it induces profitable future cooperation from others**.

## Strategy Overview

The strategy operates in three modes based on detected opponent behavior:

1. **Exploitation Mode**: Defect while others cooperate
2. **Punishment Mode**: Defect against defectors (no point cooperating)
3. **Seduction Mode**: Occasional cooperation to "reset" or probe opponents

---

## Decision Rules

### Round 1: Always Defect
- **Rationale**: Gather information at zero cost. If others cooperate, you profit maximally. If others defect, you lose nothing compared to cooperating.

### Rounds 2 through (r-1): Adaptive Exploitation

**Calculate the cooperation rate from the previous round:**
```
prev_coop_rate = (number of cooperators in round t-1) / (n - 1)
```

**Decision logic:**

```
IF prev_coop_rate >= 0.6:
    # High cooperation environment - EXPLOIT
    DEFECT (probability 1.0)
    
ELIF prev_coop_rate >= 0.3:
    # Medium cooperation - PROBE/SEDUCE
    IF (cooperation has been declining for 2+ rounds) AND (rounds_remaining > 3):
        COOPERATE  # Try to restart cooperation cycle
    ELSE:
        DEFECT
        
ELIF prev_coop_rate > 0:
    # Low cooperation - mostly defect, occasional probe
    IF (rounds_remaining > n) AND (round_number % n == my_index):
        COOPERATE  # Rare probe to test if others are conditional cooperators
    ELSE:
        DEFECT
        
ELSE:  # prev_coop_rate == 0
    # Full defection environment
    DEFECT (no value in cooperating alone)
```

### Last Round: Always Defect
- **Rationale**: No future rounds to incentivize anyone. Pure dominant strategy is defection.

### Second-to-Last Round: Almost Always Defect
- **Rationale**: Sophisticated opponents will defect in the last round regardless, so cooperation here has minimal leverage.
- **Exception**: If cooperation rate has been >0.8 consistently, defect anyway (maximum exploitation).

---

## Refined Adaptive Logic

### Tracking Opponent Types

Maintain a simple model of the population:

```
For each opponent j, track:
- total_cooperations[j]
- total_defections[j]
- coop_rate[j] = total_cooperations[j] / rounds_played

Classify opponents:
- "Sucker" (coop_rate > 0.7): Always exploit
- "Conditional" (0.3 <= coop_rate <= 0.7): Potential to manipulate
- "Predator" (coop_rate < 0.3): Don't bother cooperating
```

### Exploitation Threshold Adjustment

```
sucker_count = count of opponents with coop_rate > 0.6
exploitation_threshold = sucker_count / (n - 1)

IF exploitation_threshold > 0.5:
    # Enough suckers to sustain exploitation
    Always DEFECT
ELIF exploitation_threshold > 0.2:
    # Some exploitable players - selective cooperation to keep them going
    COOPERATE once every ceil(n/2) rounds IF cooperation is declining
ELSE:
    # Population is mostly predators
    Always DEFECT (mutual defection equilibrium)
```

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | DEFECT | Information gathering at no cost |
| Last round | DEFECT | No future consequences |
| All opponents always defect | DEFECT | Cooperation is pure loss |
| All opponents always cooperate | DEFECT | Maximum exploitation |
| n=2 (two players) | More aggressive defection | Easier to detect and respond to patterns |
| k close to n | Slightly more willing to cooperate | Higher marginal return from public good |
| k close to 1 | Pure defection | Public good barely worth it |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    # Last round: always defect
    if round == r:
        return DEFECT
    
    # First round: always defect
    if round == 1:
        return DEFECT
    
    # Calculate previous round cooperation rate (excluding self)
    prev_coop_rate = count_cooperators(history, round-1, exclude_self=True) / (n-1)
    
    # Calculate overall cooperation rate of each opponent
    sucker_count = count_opponents_with_coop_rate_above(history, threshold=0.6)
    
    # If enough exploitable players, defect
    if sucker_count >= (n-1) * 0.5:
        return DEFECT
    
    # If cooperation is high, defect to exploit
    if prev_coop_rate >= 0.6:
        return DEFECT
    
    # If cooperation is declining and we have time, probe
    if prev_coop_rate >= 0.3 and cooperation_declining(history) and (r - round) > 3:
        return COOPERATE  # Seduction attempt
    
    # Otherwise defect
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first**: Extracts information before committing
2. **Exploits cooperators ruthlessly**: High cooperation → guaranteed defection
3. **Minimal cooperation investment**: Only cooperates strategically to restart exploitation cycles
4. **End-game defection**: No sentimentality in final rounds
5. **Adaptive to population**: Doesn't waste cooperation on populations of defectors
6. **Asymmetric response**: Takes advantage of cooperative strategies while avoiding losses against defectors
'''

description_EXPLOITATIVE_78 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but we can extract MORE value by strategically cooperating just enough to keep cooperative opponents cooperating—then betraying them when it matters most.

## Decision Rules

### Round Classification

Divide the game into three phases:
- **Early Phase**: Rounds 1 to ⌊r/3⌋
- **Middle Phase**: Rounds ⌊r/3⌋+1 to ⌊2r/3⌋
- **Endgame Phase**: Rounds ⌊2r/3⌋+1 to r

### Tracking Metrics

For each round, track:
- `coop_rate`: proportion of other players who cooperated last round
- `coop_trend`: whether cooperation is increasing, stable, or decreasing
- `exploitation_potential`: (k/n) × expected cooperators if I defect

### Decision Logic

```
ROUND 1:
    DEFECT
    # Rationale: Gather information about opponent tendencies
    # without sacrificing anything. Cooperators reveal themselves.

ROUNDS 2 to r-1:
    
    Calculate coop_rate from previous round
    
    IF in Early Phase:
        IF coop_rate >= 0.6:
            COOPERATE  # Build trust to exploit later
        ELSE:
            DEFECT     # Environment is hostile, protect yourself
    
    IF in Middle Phase:
        # This is where we extract value
        IF coop_rate >= 0.5:
            # Probabilistic cooperation to appear cooperative
            # while defecting more than cooperating
            COOPERATE with probability (coop_rate - 0.2)
            # This keeps us slightly more defecting than the group
        ELSE:
            DEFECT
    
    IF in Endgame Phase (but not final round):
        IF coop_rate >= 0.7:
            # High cooperation environment - defect to exploit
            DEFECT
        ELSE IF coop_rate >= 0.4:
            # Mixed environment - match with slight defection bias
            COOPERATE with probability (coop_rate - 0.1)
        ELSE:
            DEFECT

FINAL ROUND (round r):
    DEFECT
    # Always defect - no future punishment possible
```

### Adaptive Adjustments

**Exploitation Boost**: If we've cooperated for 3+ consecutive rounds AND coop_rate > 0.5, DEFECT on the next round regardless of phase. This harvests the trust we've built.

**Collapse Detection**: If coop_rate drops by more than 0.3 from one round to the next, DEFECT for the next 2 rounds minimum. The cooperative structure is collapsing and we shouldn't throw resources into a dying system.

**Sucker Avoidance**: Track personal payoff per round. If our average payoff is below 1.0 (the guaranteed defection payoff), switch to permanent defection for remaining rounds.

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, n, k):
    
    # Final round: always defect
    if round_num == total_rounds:
        return DEFECT
    
    # First round: defect to probe
    if round_num == 1:
        return DEFECT
    
    coop_rate = count_cooperators_last_round(history) / (n - 1)
    my_avg_payoff = calculate_my_average_payoff(history)
    
    # Sucker avoidance
    if my_avg_payoff < 1.0 and round_num > 3:
        return DEFECT
    
    # Exploitation boost
    if consecutive_cooperations(history) >= 3 and coop_rate > 0.5:
        return DEFECT
    
    # Phase-based logic
    phase = get_phase(round_num, total_rounds)
    
    if phase == EARLY:
        return COOPERATE if coop_rate >= 0.6 else DEFECT
    
    elif phase == MIDDLE:
        if coop_rate >= 0.5:
            return COOPERATE with probability (coop_rate - 0.2)
        return DEFECT
    
    else:  # ENDGAME
        if coop_rate >= 0.7:
            return DEFECT  # Exploit high trust
        elif coop_rate >= 0.4:
            return COOPERATE with probability (coop_rate - 0.1)
        return DEFECT
```

## Why This Strategy is Exploitative

1. **Information Harvesting**: Round 1 defection reveals who the cooperators are at zero cost to us
2. **Trust Building for Betrayal**: Early cooperation is an investment—we pay a small cost to identify and cultivate exploitable opponents
3. **Asymmetric Extraction**: In middle/late phases, we defect slightly more than the group average, free-riding on others' contributions
4. **Endgame Exploitation**: Final round defection is pure extraction with no consequences
5. **Adaptive Predation**: High cooperation rates trigger MORE defection, not reciprocal cooperation—we take advantage of generous environments
'''

description_EXPLOITATIVE_80 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single shot—but exploiting cooperators requires them to *keep cooperating*. The strategy balances predation with just enough cooperation to sustain exploitable opponents.

---

## Decision Rules

### Round 1: Probe with Defection
**Action: DEFECT**

Rationale: This reveals information about opponent types at zero opportunity cost. If others cooperate, we gain maximally. If others defect, we lose nothing compared to cooperating.

---

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate two key metrics after each round:

1. **Cooperation Rate (CR)**: Proportion of other players who cooperated last round
   - `CR = (cooperators among others) / (n - 1)`

2. **Trend (T)**: Change in cooperation rate over last 3 rounds (or available rounds)
   - `T = CR_current - CR_previous` (averaged if multiple rounds available)

**Decision Logic:**

```
IF CR >= 0.6 THEN:
    # Rich environment - exploit heavily
    DEFECT
    
ELSE IF CR >= 0.3 THEN:
    # Moderate environment - conditional engagement
    IF T > 0 (cooperation rising) THEN:
        # Others becoming more cooperative - defect to exploit the trend
        DEFECT
    ELSE IF T < -0.1 (cooperation falling fast) THEN:
        # Cooperate occasionally to slow collapse (preserves future exploitation)
        COOPERATE with probability 0.3, else DEFECT
    ELSE:
        # Stable moderate cooperation - match just below their rate
        COOPERATE with probability (CR - 0.15), else DEFECT
        
ELSE IF CR > 0 THEN:
    # Low cooperation - try to revive exploitable conditions
    # Cooperate occasionally to signal and potentially restart cooperation
    COOPERATE with probability 0.2, else DEFECT
    
ELSE (CR == 0):
    # Dead environment - no point cooperating
    DEFECT
```

### Last Round (Round r): Always Defect
**Action: DEFECT**

Rationale: No future rounds mean no strategic value in cooperation. Pure Nash equilibrium logic applies.

---

### Second-to-Last Round (Round r-1): Almost Always Defect
**Action: DEFECT** (unless CR > 0.7, then use normal logic)

Rationale: Sophisticated opponents will defect in the last round, so forward-looking cooperators will start defecting early. Begin endgame extraction.

---

## Endgame Acceleration (Final 20% of rounds)

As rounds remaining decrease, shift toward more defection:

```
endgame_factor = max(0, (current_round - 0.8*r) / (0.2*r))
# This goes from 0 to 1 over the final 20% of rounds

Modify all cooperation probabilities by multiplying by (1 - endgame_factor)
```

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| r = 2 (minimum rounds) | Defect both rounds |
| n = 2 (minimum players) | Defect always (k < 2 means cooperation never pays) |
| All opponents always defect (3+ rounds) | Defect always |
| All opponents always cooperate | Defect always (maximum exploitation) |
| Erratic opponents (high variance) | Default to defection, occasional cooperation probe |

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: High cooperation environments trigger defection, extracting (k/n) × others' contributions while keeping our endowment.

2. **Doesn't get suckered**: Never cooperates into a dead environment. Minimum cooperation thresholds prevent pure loss.

3. **Sustains prey populations**: Strategic occasional cooperation in declining environments keeps some cooperators alive for future exploitation—but never enough to sacrifice significant personal gains.

4. **Endgame extraction**: Systematically defects as the game ends, capturing maximum value when future consequences disappear.

5. **Information asymmetry**: Opens with defection to learn opponent types without cost, then tailors exploitation accordingly.
'''

description_EXPLOITATIVE_79 = '''
# Exploitative Strategy: "Predatory Defector with Cooperation Milking"

## Core Philosophy

This strategy is built on a fundamental asymmetry in the public goods game: **defection is always individually dominant** (since k < n means k/n < 1, so keeping your endowment beats contributing). The only reason to ever cooperate is to manipulate others into cooperating so I can exploit them later. My goal is to extract maximum value from cooperators while minimizing my own contributions.

## Strategy Overview

I will primarily defect, but strategically inject occasional cooperation to:
1. Probe whether opponents are conditional cooperators I can exploit
2. Maintain just enough "hope" in the population to prevent total defection collapse
3. Never cooperate when it cannot influence future behavior (endgame)

---

## Decision Rules

### Round Classification

```
early_game = rounds 1 to floor(r/3)
mid_game = rounds floor(r/3)+1 to floor(2r/3)
end_game = rounds floor(2r/3)+1 to r
```

### Primary Decision Logic

**FIRST ROUND:**
- **DEFECT**
- Rationale: Observe others' baseline behavior without cost. Cooperators reveal themselves; I lose nothing.

**LAST ROUND (and final 2 rounds if r ≤ 10, final 3 rounds if r > 20):**
- **DEFECT unconditionally**
- Rationale: No future rounds to influence. Pure dominant strategy.

**EARLY GAME (rounds 2 to floor(r/3)):**
```
cooperation_rate_observed = (total C plays by others) / (total plays by others)

IF cooperation_rate_observed > 0.5:
    DEFECT  # Exploit the cooperators - free ride on their contributions
ELSE:
    COOPERATE with probability 0.2  # Probe/seed cooperation
```

**MID GAME:**
```
recent_coop_rate = cooperation rate in last 3 rounds

IF recent_coop_rate > 0.6:
    DEFECT  # Harvest the cooperation
ELIF recent_coop_rate > 0.3:
    # Conditional cooperation to maintain the herd
    IF I defected last 2 rounds:
        COOPERATE  # Throw a bone to keep hope alive
    ELSE:
        DEFECT
ELSE:
    DEFECT  # Environment is already depleted, no point contributing
```

**END GAME (excluding final rounds which are always D):**
```
DEFECT  # Backward induction kicks in; others may also realize this
```

---

## Exploitation Mechanisms

### 1. **Sucker Identification**
Track which player indices (if observable) or what aggregate patterns indicate unconditional cooperators. These are pure profit sources—never reward them with cooperation.

### 2. **Tit-for-Tat Manipulation**
If population shows reactive patterns (cooperation rises after I cooperate):
- Inject single cooperations followed by multiple defections
- Optimal ratio: 1 C followed by 2-3 D's to milk reactive cooperators

### 3. **Threshold Exploitation**
If others appear to use threshold strategies (cooperate only if X others cooperated):
- Stay just below triggering mass cooperation from my end
- Let others carry the cooperation burden

---

## Adaptive Parameters

```python
def calculate_cooperation_probability(round_num, total_rounds, observed_coop_rate):
    # Base: very low cooperation tendency
    base_prob = 0.1
    
    # Boost slightly in early-mid game if others are cooperating
    # (to keep them cooperating for future exploitation)
    if round_num < total_rounds * 0.6:
        if observed_coop_rate > 0.4:
            # Others cooperate a lot - defect to exploit
            return 0.0
        elif observed_coop_rate > 0.2:
            # Moderate cooperation - occasional C to maintain it
            return 0.15
        else:
            # Low cooperation - probe with small chance
            return 0.1
    else:
        # Late game - defect
        return 0.0
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | D, D | No time to establish patterns worth exploiting |
| n = 2 (minimum players) | Mostly D, rare C probe | Essentially prisoner's dilemma; defection dominant |
| k very close to n | Still primarily D | Even high k doesn't overcome k/n < 1 |
| Everyone defected round 1 | C with prob 0.15 round 2 | Test if others are also probing |
| Perfect cooperation observed | DEFECT hard | Maximum exploitation opportunity |

---

## Summary

**Default action: DEFECT**

**Cooperate only when:**
1. Early/mid-game AND cooperation has collapsed AND I want to probe/revive it for future exploitation
2. Mid-game AND I've defected several times AND moderate cooperation exists (maintenance cooperation)

**Never cooperate when:**
1. Final round(s) - no future to influence
2. High cooperation already exists - free ride instead
3. Cooperation has been dead for 3+ rounds in late game - lost cause

This strategy is fundamentally parasitic: it thrives when others cooperate and contributes just enough to prevent total ecosystem collapse—but only when that collapse would hurt future extraction opportunities.
'''

description_EXPLOITATIVE_81 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round—but repeated play creates opportunities to identify and exploit "suckers" who cooperate despite defection.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify exploitable players.

---

## Phase 1: Probe Phase (Rounds 1 to ⌈r/5⌉)

**Goal:** Gather information about opponent tendencies while minimizing risk.

**Decision Rule:**
- **Round 1:** DEFECT
- **Subsequent probe rounds:** DEFECT

**Rationale:** Defection is risk-free for information gathering. We learn who cooperates unconditionally (exploitable), who retaliates, and who always defects. Starting with defection avoids being exploited by other predatory strategies while identifying naive cooperators.

---

## Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-1)

**Goal:** Maximize extraction from cooperative opponents while adapting to the population composition.

### Opponent Classification (updated each round)

For each opponent j, calculate:
- **Cooperation Rate (CR_j):** Total cooperations / rounds played
- **Conditional Cooperation Rate (CCR_j):** How often they cooperate after majority cooperated in previous round

### Decision Rules:

**Calculate "Sucker Index":** 
```
sucker_count = count of opponents with CR_j > 0.6
```

**Calculate "Threat Level":**
```
defector_count = count of opponents with CR_j < 0.3
```

**Decision Logic:**

```
IF sucker_count >= n/3 THEN:
    # Enough exploitable players - defect to free-ride
    DEFECT
    
ELSE IF defector_count >= 2n/3 THEN:
    # Mostly defectors - no point cooperating
    DEFECT
    
ELSE IF previous_round_cooperation_rate > 0.5 AND sucker_count >= 2 THEN:
    # Cooperation is happening and there are suckers to exploit
    DEFECT
    
ELSE IF average_CR across all opponents > 0.7 THEN:
    # High cooperation environment - occasional cooperation to sustain it
    # But only cooperate with probability based on round position
    cooperation_probability = 0.3 * (1 - current_round/r)
    COOPERATE with probability cooperation_probability, else DEFECT
    
ELSE:
    # Default: DEFECT
    DEFECT
```

### Adaptive Mimicry Sub-rule:

If we detect that high-CR opponents are starting to defect more (their CR is declining over last 3 rounds):
```
IF (opponent_avg_CR_last_3_rounds < opponent_avg_CR_overall - 0.2) THEN:
    # Cooperators are waking up - throw them a bone to reset
    COOPERATE for 1 round, then resume defection
```

This "bait" cooperation can restart exploitation cycles by convincing conditional cooperators to resume cooperating.

---

## Phase 3: Endgame (Final Round)

**Decision Rule:** DEFECT (always)

**Rationale:** No future rounds mean no retaliation possible. Defection strictly dominates regardless of opponent behavior.

---

## Edge Cases

1. **r = 2 (minimum rounds):** DEFECT both rounds. Insufficient time for exploitation patterns.

2. **n = 2 (minimum players):** More aggressive defection since free-riding benefit is highest relative to cooperation benefit.

3. **k close to n:** Slightly increase cooperation probability in the adaptive mimicry rule (multiply by k/(n-1)) since mutual cooperation becomes more attractive.

4. **k close to 1:** Pure defection throughout—cooperation benefit is negligible.

5. **All opponents defect in first 3 rounds:** Lock into permanent defection—no exploitation opportunity exists.

6. **All opponents cooperate consistently:** This is the jackpot. Maintain pure defection to maximize free-riding gains.

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == r:
        return DEFECT  # Endgame
    
    if round <= ceil(r/5):
        return DEFECT  # Probe phase
    
    # Calculate opponent metrics
    for each opponent j:
        CR[j] = cooperations[j] / (round - 1)
    
    sucker_count = count(CR[j] > 0.6)
    defector_count = count(CR[j] < 0.3)
    prev_coop_rate = cooperators_last_round / (n - 1)
    avg_CR = mean(CR)
    
    # Exploitation logic
    if sucker_count >= (n-1)/3:
        return DEFECT
    
    if defector_count >= 2*(n-1)/3:
        return DEFECT
    
    if prev_coop_rate > 0.5 and sucker_count >= 2:
        return DEFECT
    
    # Check if cooperators are retaliating
    if cooperators_declining(history, window=3):
        return COOPERATE  # Bait
    
    if avg_CR > 0.7:
        prob = 0.3 * (1 - round/r)
        return COOPERATE with probability prob
    
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation:** Always probes with defection first
2. **Identifies and milks cooperators:** Tracks who keeps cooperating despite our defection
3. **Minimizes wasted cooperation:** Only cooperates strategically to sustain exploitable opponents
4. **Maximizes endgame extraction:** Guaranteed defection when retaliation is impossible
5. **Adaptive to population:** Adjusts based on actual opponent behavior, not assumptions
'''

description_EXPLOITATIVE_80 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and continuously estimates opponent cooperation rates to make optimal exploitation decisions.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** Always **DEFECT**

*Rationale:* Defection in round 1 is risk-free information gathering. If others cooperate, I gain maximum exploitation payoff. If others defect, I lose nothing compared to cooperating.

**Round 2:** Always **DEFECT**

*Rationale:* Continue gathering information. Two rounds of data provide a more stable estimate of opponent behavior patterns.

---

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

After each round, calculate the **cooperation rate** among other players:

```
coop_rate = (total cooperations by others in all previous rounds) / ((n-1) × rounds_played)
```

**Decision Rule:**

```
IF coop_rate > threshold THEN:
    DEFECT (exploit the cooperators)
ELSE IF coop_rate is moderate AND decreasing trend detected THEN:
    Occasionally COOPERATE (bait to restore cooperation)
ELSE:
    DEFECT (nothing to exploit, minimize losses)
```

**Threshold Calculation:**
```
threshold = k / n
```
*When cooperation rate exceeds k/n, the expected gain from free-riding exceeds the baseline.*

**Baiting Mechanism:**

If cooperation has been declining for 2+ consecutive rounds AND current cooperation rate is between 0.2 and 0.5:
- Cooperate with probability `0.3 × (rounds_remaining / r)`
- This creates illusion of conditional cooperation to restore exploitable behavior

**Trend Detection:**
```
declining = (coop_rate in last 2 rounds) < (coop_rate in 2 rounds before that)
```

---

### Phase 3: Endgame (Final 2 rounds)

**Round r-1:** **DEFECT**

**Round r (final):** **DEFECT**

*Rationale:* No future rounds exist to punish defection. Rational opponents will also defect, so cooperation yields strictly lower payoff. Even against unconditional cooperators, defection maximizes extraction.

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase: always defect
    if round <= 2:
        return DEFECT
    
    # Calculate cooperation statistics
    other_coops = count_other_cooperations(history)
    total_other_actions = (n - 1) * (round - 1)
    coop_rate = other_coops / total_other_actions
    
    threshold = k / n
    
    # High cooperation: exploit ruthlessly
    if coop_rate > threshold:
        return DEFECT
    
    # Moderate cooperation with declining trend: consider baiting
    if 0.2 < coop_rate < 0.5:
        recent_rate = cooperation_rate_last_2_rounds(history)
        earlier_rate = cooperation_rate_rounds_before(history)
        
        if recent_rate < earlier_rate:  # declining
            bait_probability = 0.3 * (r - round) / r
            if random() < bait_probability:
                return COOPERATE
    
    # Default: defect
    return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| First round | DEFECT | No information, defection dominates |
| Last round | DEFECT | No future punishment possible |
| All others always cooperate | DEFECT | Maximum exploitation opportunity |
| All others always defect | DEFECT | Cooperation wastes resources |
| n = 2 | Standard rules apply | Reduces to prisoner's dilemma variant |
| r = 2 | DEFECT both rounds | Too short for reputation building |
| k very close to n | Slightly increase bait probability | Cooperation more valuable, worth sustaining |

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Avoids being the sucker
2. **Free-rides on cooperators** - Maximizes gain when others contribute
3. **Baits strategically** - Invests minimally to restore exploitable cooperation
4. **Ruthless endgame** - Extracts maximum value when punishment is impossible
5. **Adaptive thresholds** - Adjusts exploitation based on actual game parameters
'''

description_EXPLOITATIVE_81 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperators while minimizing losses from mutual defection**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but repeated play creates opportunities to manipulate cooperative players into contributing while I free-ride.

## Strategy Overview

The strategy operates in three phases and continuously estimates the "exploitability" of the population based on observed cooperation rates.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Purpose:** Gather information about opponent tendencies with minimal cost.

- **Round 1:** DEFECT
  - Rationale: Observe baseline cooperation without contributing. If others cooperate, I profit maximally. If they defect, I lose nothing.

- **Round 2:** COOPERATE (conditional probe)
  - Rationale: Test if the population responds positively to cooperation. This is my only "investment" in information gathering.

- **Round 3:** DEFECT
  - Rationale: See if cooperation persists despite my defection. Highly exploitable populations will continue cooperating.

### Phase 2: Exploitation Phase (Rounds 4 to r-2)

**Calculate cooperation rate from previous round:** `coop_rate = (number of C plays) / n`

**Decision rule:**

```
IF coop_rate >= exploitation_threshold THEN:
    DEFECT (free-ride on cooperators)
    
ELSE IF coop_rate >= recovery_threshold THEN:
    COOPERATE with probability = coop_rate
    (conditional cooperation to sustain some contribution)
    
ELSE:
    DEFECT (not enough cooperators to make contribution worthwhile)
```

**Threshold Definitions:**
- `exploitation_threshold = k / n` (the break-even point where cooperation becomes socially efficient)
- `recovery_threshold = 0.3` (minimum cooperation worth sustaining)

**Adaptive Adjustment:**
- Track a 3-round moving average of cooperation rates
- If cooperation is declining despite my occasional cooperation, shift to pure defection
- If cooperation is stable and high (>70%), always defect to maximize exploitation

### Phase 3: Endgame (Final 2 rounds)

**Round r-1 and Round r:** DEFECT

- Rationale: No future rounds to incentivize others' cooperation. Pure Nash equilibrium logic applies. Defection is strictly dominant.

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | Information gathering, zero-risk |
| Last round | DEFECT | No future consequences |
| Second-to-last round | DEFECT | Anticipate others' endgame defection |
| All others defected last round | DEFECT | No cooperators to exploit |
| All others cooperated last round | DEFECT | Maximum exploitation opportunity |
| n = 2 (minimum players) | More aggressive defection; cooperate only if opponent has shown >80% cooperation | Easier to identify exploitable patterns |
| Very high k (close to n) | Slightly more cooperative in probing | Higher returns justify small investment |

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase
    if round == 1:
        return DEFECT
    if round == 2:
        return COOPERATE
    if round == 3:
        return DEFECT
    
    # Exploitation phase
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate = last_round_coops / n
    
    exploitation_threshold = k / n
    recovery_threshold = 0.3
    
    # Calculate trend (are cooperators declining?)
    if round >= 6:
        trend = moving_average(history, 3) - moving_average(history, 3, offset=3)
    else:
        trend = 0
    
    # High cooperation: exploit ruthlessly
    if coop_rate >= exploitation_threshold:
        return DEFECT
    
    # Medium cooperation with stable/positive trend: occasionally cooperate
    if coop_rate >= recovery_threshold and trend >= -0.1:
        return COOPERATE with probability coop_rate
    
    # Low cooperation or declining trend: abandon cooperation
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Asymmetric contribution:** I cooperate rarely (only during probing and probabilistically during medium-cooperation phases), while harvesting benefits from others' contributions.

2. **Information advantage:** By probing early, I identify exploitable populations and adjust accordingly.

3. **No reciprocity commitment:** Unlike tit-for-tat, I don't match cooperation—I exploit it.

4. **Endgame defection:** Guaranteed defection in final rounds captures maximum value when others might still cooperate out of habit.

5. **Threshold-based free-riding:** I only cooperate when cooperation rates are too low to profitably exploit, treating my cooperation as an investment to restore exploitable conditions.
'''

description_EXPLOITATIVE_82 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round—but repeated play creates opportunities to exploit patterns and punish/reward behavior to manipulate others into cooperating while I defect.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling throughout.

---

## Phase 1: Probing Phase (Rounds 1 to min(3, r/4))

**Goal:** Gather information about opponent tendencies with minimal cost.

**Decision Rule:**
- **Round 1:** DEFECT
  - Rationale: Zero information available. Defection is safe and reveals who the "naive cooperators" are without any risk.
  
- **Rounds 2-3:** DEFECT if cooperation rate in previous round was ≥ 50%, otherwise COOPERATE once as a "false signal"
  - Rationale: If others are cooperating, continue exploiting. If cooperation collapsed, one cooperative move might restart it (making me look like a conditional cooperator to trigger reciprocity).

---

## Phase 2: Exploitation Phase (Rounds min(4, r/4+1) to r-2)

**Goal:** Maximize extraction based on learned opponent behavior.

**Continuous Tracking:**
- `coop_rate[t]` = proportion of other players who cooperated in round t
- `trend` = moving average of cooperation rate over last 3 rounds
- `sucker_count` = number of players who cooperated in ≥70% of rounds so far

**Decision Rules:**

```
IF trend > 0.5:
    # Cooperation is abundant - EXPLOIT
    DEFECT
    
ELIF trend > 0.3:
    # Moderate cooperation - conditional exploitation
    IF sucker_count >= n/3:
        DEFECT  # Enough reliable cooperators to free-ride on
    ELSE:
        # Cooperation might collapse; invest minimally to sustain it
        COOPERATE with probability = (trend - 0.3) / 0.4
        # This makes me look like a conditional cooperator
        
ELIF trend > 0.1:
    # Cooperation is fragile
    IF my_cumulative_payoff > average_opponent_payoff:
        DEFECT  # I'm ahead, stay safe
    ELSE:
        COOPERATE  # Try to restart cooperation cycle
        
ELSE:
    # Near-universal defection
    DEFECT  # No point cooperating when no one else will
```

**Punishment Mechanism:**
- Track if cooperation rate dropped significantly (>20%) after I cooperated
- If this happens twice consecutively, switch to pure DEFECT for 2 rounds
- Rationale: Others may be trying to exploit *me*; punish and reset

---

## Phase 3: Endgame (Final 2 rounds)

**Goal:** Extract remaining value with no future consequences.

**Decision Rules:**
- **Round r-1 (second-to-last):** 
  - DEFECT if `trend > 0.4` (others still cooperating, exploit them)
  - Otherwise: COOPERATE with probability 0.3 (small chance to trigger final-round cooperation from conditional cooperators)
  
- **Round r (final round):**
  - **ALWAYS DEFECT**
  - Rationale: No future rounds means no punishment possible. This is the dominant strategy regardless of opponent behavior.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | D, D | Too short for reputation building; pure exploitation |
| n = 2 (minimum players) | Mirror opponent's last move, defect final round | Tit-for-tat variant works well in 2-player |
| k very close to n | Slightly more cooperative in Phase 2 | Higher k means cooperation is more valuable |
| All opponents always defect | Always defect | No exploitable cooperation to harvest |
| All opponents always cooperate | Always defect | Maximum exploitation of naive players |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == r:
        return DEFECT  # Endgame certainty
    
    if round == 1:
        return DEFECT  # Probe safely
    
    coop_rate = get_others_cooperation_rate(history, round-1)
    trend = get_trend(history, window=3)
    
    if round <= min(3, r//4):  # Probing phase
        return DEFECT if coop_rate >= 0.5 else COOPERATE
    
    if round >= r - 1:  # Endgame
        return DEFECT if trend > 0.4 else random_choice(0.3)
    
    # Exploitation phase
    if trend > 0.5:
        return DEFECT
    elif trend > 0.3:
        sucker_count = count_reliable_cooperators(history, threshold=0.7)
        return DEFECT if sucker_count >= n/3 else probabilistic(trend)
    elif trend > 0.1:
        return DEFECT if ahead_of_average(history) else COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Defaults to defection** when uncertain—captures the free-rider advantage
2. **Identifies and exploits "suckers"**—players who cooperate reliably get exploited hardest
3. **Mimics conditional cooperation** just enough to sustain others' cooperation without genuinely contributing
4. **Endgame defection** is absolute—no signaling, no reciprocity, pure extraction
5. **Adapts to collapse cooperation** by occasionally cooperating, but only to restart the cycle of exploitation
'''

description_EXPLOITATIVE_82 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The exploitative mindset recognizes a fundamental asymmetry in this game: cooperators create value that can be harvested by defectors. My strategy aims to maximize extraction from cooperative opponents while minimizing losses against other defectors. Since k < n, defection always yields higher individual payoff than cooperation *given the same behavior by others*. The only reason to ever cooperate is to manipulate opponents into cooperating more, creating future extraction opportunities.

## Strategy Overview

**Adaptive Parasite** operates in three phases:
1. **Probe Phase**: Gather intelligence on opponent tendencies
2. **Exploit Phase**: Maximize extraction based on observed patterns
3. **Endgame Phase**: Pure defection when manipulation is pointless

---

## Detailed Decision Rules

### Round 1: Initial Probe
**Action: DEFECT**

Rationale: 
- No history exists to exploit
- Defection is dominant in single-shot play
- Establishes a baseline to measure opponent responses
- If others cooperate, I profit maximally; if they defect, I lose nothing relative to cooperating

### Rounds 2 through (r-2): Adaptive Exploitation

Calculate the **Cooperation Rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

Calculate **Historical Responsiveness** (do opponents increase cooperation after I cooperate?):
```
my_coop_rounds = rounds where I cooperated
my_defect_rounds = rounds where I defected
avg_others_coop_after_my_coop = average cooperation rate of others in rounds following my cooperation
avg_others_coop_after_my_defect = average cooperation rate of others in rounds following my defection
responsiveness = avg_others_coop_after_my_coop - avg_others_coop_after_my_defect
```

**Decision Logic:**

```
IF coop_rate >= 0.5 AND responsiveness > 0.1:
    # Environment is cooperative AND my cooperation influences others
    # Occasional cooperation to "farm" future cooperation
    IF random() < 0.2:  # Cooperate 20% of the time
        COOPERATE
    ELSE:
        DEFECT

ELSE IF coop_rate >= 0.5 AND responsiveness <= 0.1:
    # Others cooperate regardless of my behavior - pure extraction
    DEFECT

ELSE IF coop_rate < 0.5 AND responsiveness > 0.2:
    # Low cooperation but highly responsive - worth investing
    IF random() < 0.3:  # Cooperate 30% to stimulate cooperation
        COOPERATE
    ELSE:
        DEFECT

ELSE:
    # Low cooperation, unresponsive opponents - no point cooperating
    DEFECT
```

### Rounds (r-1) and r: Endgame
**Action: DEFECT (always)**

Rationale:
- No future rounds exist to benefit from manipulation
- Backward induction makes cooperation pointless
- Extract maximum value from any remaining cooperators

---

## Handling Edge Cases

### Very Short Games (r ≤ 3)
If r = 2: Defect both rounds (no time for manipulation)
If r = 3: Defect round 1, assess round 2, defect round 3

### Everyone Defects Consistently
If cooperation rate = 0 for 3+ consecutive rounds:
- Switch to pure defection for remaining rounds
- No point attempting to stimulate cooperation in a hostile environment

### Everyone Cooperates Consistently
If cooperation rate ≥ 0.8 for 3+ consecutive rounds:
- Defect every round (maximum extraction)
- These are likely unconditional cooperators - exploit them fully

### Erratic/Random Opponents
If cooperation rates fluctuate wildly with no pattern:
- Default to defection (can't predict or manipulate chaos)

---

## Pseudocode Summary

```python
def adaptive_parasite(round_num, total_rounds, history):
    n = num_players
    
    # Endgame: always defect
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # Round 1: probe with defection
    if round_num == 1:
        return DEFECT
    
    # Calculate metrics
    coop_rate = count_cooperators(history[-1]) / n
    responsiveness = calculate_responsiveness(history, my_actions)
    
    # Exploitation logic
    if coop_rate >= 0.5:
        if responsiveness > 0.1:
            return COOPERATE if random() < 0.2 else DEFECT
        else:
            return DEFECT  # Free ride on unconditional cooperators
    else:
        if responsiveness > 0.2:
            return COOPERATE if random() < 0.3 else DEFECT
        else:
            return DEFECT  # Hostile environment
```

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Every cooperation is an investment expecting future returns
2. **Harvests cooperators** - Maximizes free-riding when others cooperate
3. **Minimizes losses** - Defects against defectors, avoiding the sucker's payoff
4. **Uses cooperation as bait** - Only cooperates to manipulate responsive opponents into cooperating more
5. **Endgame extraction** - Guarantees defection when manipulation cannot yield future benefits
'''

description_EXPLOITATIVE_83 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but exploiting cooperative opponents yields higher returns than mutual defection. The strategy aggressively tests for exploitable opponents and ruthlessly defects against them while maintaining just enough cooperation signals to keep "suckers" contributing.

---

## Decision Rules

### Round 1: Defect
- **Rationale**: Never sacrifice payoff on incomplete information. Observe who cooperates without contributing yourself. This immediately identifies potential targets for exploitation.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate two metrics after each round:

1. **Cooperation Rate of Others (CRO)**: 
   `CRO = (total cooperations by others in all previous rounds) / ((n-1) × rounds_played)`

2. **Trend Indicator (TI)**: 
   `TI = CRO_last_3_rounds - CRO_first_3_rounds` (or available rounds if fewer)

**Decision Logic:**

```
IF CRO > 0.5:
    # Environment is exploitable - there are suckers to milk
    IF TI < -0.2:
        # Cooperation is collapsing - extract final value
        DEFECT
    ELSE IF CRO > 0.7:
        # Highly cooperative environment - pure exploitation
        DEFECT
    ELSE:
        # Moderate cooperation - occasional cooperation to sustain contributors
        # Cooperate with probability = 0.2 (just enough to give hope)
        COOPERATE with 20% probability, else DEFECT
        
ELSE IF CRO > 0.2:
    # Mixed environment - probe for exploitation opportunities
    IF last round had ≥ 50% cooperators:
        DEFECT  # Exploit the moment
    ELSE:
        # Offer minimal bait to restart cooperation
        COOPERATE with 30% probability, else DEFECT
        
ELSE:  # CRO ≤ 0.2
    # Environment is mostly defectors - no point cooperating
    DEFECT
```

### Last Round (Round r): Always Defect
- **Rationale**: No future consequences. Pure dominance of defection.

### Second-to-Last Round (Round r-1): Always Defect
- **Rationale**: Sophisticated opponents will defect in round r regardless, so backward induction suggests defecting here too. This also catches opponents who only defect on the literal last round.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | Defect both rounds | No room for exploitation cycles |
| n = 2 (minimum players) | Always Defect | Reduces to prisoner's dilemma; defection dominant |
| k very close to n | Still follow strategy | Others' cooperation more valuable, but so is free-riding |
| k very close to 1 | More aggressive defection (reduce cooperation probability to 10%) | Public good barely multiplies; defection even more dominant |
| All others defected last 3 rounds | Defect | Environment is hostile; no exploitation opportunity |
| All others cooperated last 3 rounds | Defect | Maximum exploitation opportunity |

---

## Pseudocode Summary

```python
def decide(round_number, total_rounds, history, n, k):
    # Last two rounds: pure defection
    if round_number >= total_rounds - 1:
        return DEFECT
    
    # First round: defect to observe
    if round_number == 1:
        return DEFECT
    
    # Calculate cooperation rate of others
    other_coops = count_others_cooperations(history)
    other_actions = (n - 1) * (round_number - 1)
    CRO = other_coops / other_actions
    
    # Calculate trend
    TI = calculate_trend(history, n)
    
    # Exploitation logic
    if CRO > 0.5:
        if TI < -0.2 or CRO > 0.7:
            return DEFECT
        else:
            return COOPERATE if random() < 0.2 else DEFECT
    elif CRO > 0.2:
        if last_round_cooperation_rate(history, n) >= 0.5:
            return DEFECT
        else:
            return COOPERATE if random() < 0.3 else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy Exploits

1. **Never cooperates first**: Avoids being exploited by other predators
2. **Identifies and milks cooperators**: High CRO triggers sustained defection
3. **Maintains false hope**: Occasional cooperation keeps naive strategies contributing
4. **Abandons lost causes**: Doesn't waste contributions in defector-heavy environments
5. **Endgame certainty**: Guaranteed defection when future punishment is impossible
'''

description_EXPLOITATIVE_83 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors extract value from cooperators while risking nothing. The goal is to **free-ride when profitable** and **appear cooperative enough to sustain a pool of cooperators to exploit**.

## Strategy Overview

I maintain a probabilistic cooperation rate that adapts based on observed cooperation levels in the population. The key insight is that I want to cooperate *just enough* to avoid triggering retaliation cascades, while defecting *as much as possible* to extract surplus.

---

## Decision Rules

### Round 1: Defect
- No information exists; defection is the dominant single-round action
- This also probes whether opponents are unconditional cooperators (exploitable)

### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Calculate observed cooperation rate**
```
coop_rate = (total C plays by others in all previous rounds) / 
            ((n-1) × rounds_played)
```

**Step 2: Determine my cooperation probability**

```
if coop_rate > 0.7:
    # Rich environment - heavy exploitation
    my_coop_prob = 0.1
    
elif coop_rate > 0.4:
    # Moderate environment - strategic mimicry
    # Cooperate slightly less than average to extract surplus
    my_coop_prob = coop_rate - 0.2
    
elif coop_rate > 0.15:
    # Declining environment - attempt to stabilize for future exploitation
    my_coop_prob = coop_rate + 0.1
    
else:
    # Collapsed environment - pure defection
    my_coop_prob = 0
```

**Step 3: Trend adjustment**
```
recent_coop = cooperation rate in last 2 rounds
earlier_coop = cooperation rate in rounds before that

if recent_coop < earlier_coop - 0.15:
    # Cooperation is crashing - abandon ship
    my_coop_prob = max(0, my_coop_prob - 0.15)
    
if recent_coop > earlier_coop + 0.15:
    # Cooperation is rising - exploit the optimists
    my_coop_prob = max(0, my_coop_prob - 0.1)
```

**Step 4: Execute probabilistic action**
- Generate random number in [0,1]
- If random < my_coop_prob: Cooperate
- Else: Defect

### Final Round (round r): Always Defect
- No future rounds exist to punish defection
- Defection strictly dominates regardless of others' actions

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | More aggressive defection (reduce all coop_prob by 0.1) | Easier to track and punish in small groups |
| k very close to n | Slightly higher cooperation thresholds | Cooperation is more valuable, worth sustaining |
| k very close to 1 | More aggressive defection | Cooperation benefits are minimal anyway |
| r ≤ 3 | Defect always | Too few rounds to build exploitable cooperation |
| All opponents defected last round | Defect | No surplus to extract |
| All opponents cooperated last round | Defect with 90% probability | Maximum exploitation opportunity |

---

## Pseudocode Summary

```python
def adaptive_predator(round, history, n, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT
    
    if r <= 3:
        return DEFECT
    
    coop_rate = calculate_others_cooperation_rate(history)
    
    # Base probability
    if coop_rate > 0.7:
        prob = 0.1
    elif coop_rate > 0.4:
        prob = coop_rate - 0.2
    elif coop_rate > 0.15:
        prob = coop_rate + 0.1
    else:
        prob = 0
    
    # Trend adjustment
    prob = adjust_for_trend(prob, history)
    
    # Parameter adjustments
    if n == 2:
        prob = max(0, prob - 0.1)
    if k < 1.3:
        prob = max(0, prob - 0.1)
    
    # Clamp and execute
    prob = clamp(prob, 0, 0.5)  # Never cooperate more than 50%
    
    return COOPERATE if random() < prob else DEFECT
```

---

## Why This Exploits Effectively

1. **Asymmetric extraction**: Always cooperates less than the population average
2. **Sustains victims**: Occasional cooperation prevents complete collapse
3. **Endgame clarity**: Guaranteed defection when punishment is impossible
4. **Trend awareness**: Exits declining pools before losing value
5. **Never over-cooperates**: Hard cap at 50% prevents becoming the exploited
'''

description_EXPLOITATIVE_84 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single shot—but repeated play creates exploitable patterns. I will cooperate only when I can reliably free-ride on others' future cooperation, and defect ruthlessly when others show weakness or when the game is ending.

---

## Decision Rules

### Round 1: Defect
- **Rationale**: No history exists. Defection provides information about others' strategies while securing the safe payoff. Cooperating first gives away value with no guarantee of reciprocity.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate two key metrics after each round:

1. **Cooperation Rate** = (number of cooperators in previous round) / (n - 1)
   - Only count other players, not myself

2. **Cooperation Trend** = Cooperation Rate(t-1) - Cooperation Rate(t-2)
   - Positive = others increasing cooperation
   - Negative = others decreasing cooperation

**Decision Logic:**

```
IF cooperation_rate >= threshold AND cooperation_trend >= 0:
    DEFECT  # Exploit the cooperators - they're sustaining or growing
    
ELIF cooperation_rate >= threshold AND cooperation_trend < 0:
    COOPERATE  # Prop up declining cooperation to keep milking it
    
ELIF cooperation_rate < threshold AND cooperation_rate > 0:
    # Mixed environment - conditional cooperation to test waters
    IF I defected last round AND cooperation_rate dropped significantly:
        COOPERATE once  # Bait them back
    ELSE:
        DEFECT  # Not enough suckers to exploit
        
ELSE (cooperation_rate == 0):
    DEFECT  # Everyone defecting, no point cooperating
```

**Where threshold = k/n** (the break-even point where cooperation becomes collectively beneficial)

### Last Round (Round r): Always Defect
- **Rationale**: No future punishment possible. Pure dominant strategy logic applies.

### Second-to-Last Round (Round r-1): Defect
- **Rationale**: Sophisticated opponents will defect in round r regardless, so round r-1 effectively becomes the "last" strategic round. Defect early to avoid being the sucker.

---

## Detailed Exploitation Mechanisms

### Mechanism 1: Sucker Detection
Track individual player histories when possible. Identify "unconditional cooperators" (players who cooperate >80% regardless of others' actions). **Always defect when playing with identified suckers**—they'll cooperate anyway.

### Mechanism 2: Punishment Resistance
If my defection causes others to retaliate by defecting:
- Continue defecting for 2 rounds to test if they're using tit-for-tat
- If cooperation resumes after my single cooperation, I've found exploitable conditional cooperators
- Cycle: Defect → Defect → Cooperate → Defect → Defect → Cooperate...

### Mechanism 3: Endgame Acceleration
As rounds remaining decreases:
```
IF rounds_remaining <= 3:
    cooperation_threshold *= 1.5  # Require more cooperators to justify any cooperation
    
IF rounds_remaining <= 2:
    DEFECT unconditionally
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | Defect | Safe information gathering |
| Round 2 | Defect if ≥50% cooperated in R1, else Cooperate once | Exploit if possible, bait if not |
| Everyone always defects | Defect | No exploitable cooperation |
| Everyone always cooperates | Defect | Maximum exploitation opportunity |
| Exactly one other cooperator | Defect | Not enough public good generated |
| Last 2 rounds | Defect | Endgame logic |
| n=2 (minimum players) | More aggressive defection; cooperate only if opponent showed 100% cooperation | Less public good dilution |
| High k (close to n) | Slightly more willing to cooperate | Higher returns from public good |

---

## Pseudocode Summary

```python
def decide(round, total_rounds, n, k, history):
    # Endgame: always defect
    if round >= total_rounds - 1:
        return DEFECT
    
    # Round 1: defect to gather info
    if round == 1:
        return DEFECT
    
    # Calculate metrics
    others_coop_last = count_others_cooperation(history, round - 1)
    coop_rate = others_coop_last / (n - 1)
    threshold = k / n
    
    # Round 2 special case
    if round == 2:
        return DEFECT if coop_rate >= 0.5 else COOPERATE
    
    # Calculate trend
    others_coop_prev = count_others_cooperation(history, round - 2)
    trend = (others_coop_last - others_coop_prev) / (n - 1)
    
    # Endgame adjustment
    rounds_left = total_rounds - round
    if rounds_left <= 3:
        threshold *= 1.5
    
    # Main decision logic
    if coop_rate >= threshold:
        if trend >= 0:
            return DEFECT  # Exploit stable/growing cooperation
        else:
            return COOPERATE  # Prop up declining cooperation
    elif coop_rate > 0:
        if my_last_action == DEFECT and coop_rate_dropped_significantly:
            return COOPERATE  # Bait
        else:
            return DEFECT
    else:
        return DEFECT  # No cooperation to exploit
```

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally**—every cooperation is calculated to induce future cooperation from others
2. **Free-rides aggressively** when cooperation levels are high and stable
3. **Baits strategically** when cooperation is declining, only to resume exploitation
4. **Defects in endgame** regardless of history
5. **Punishes no one**—punishment is costly and altruistic; instead, I simply extract value and move on
'''

description_EXPLOITATIVE_84 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that in a public goods game with k < n, defection strictly dominates cooperation in any single round. However, in repeated play, I can extract *more* value by strategically inducing cooperation in others while minimizing my own contributions. The goal is to free-ride maximally while maintaining just enough perceived cooperation to prevent collective collapse.

## Strategy Overview

I will present as a conditional cooperator early to establish a cooperative environment, then systematically exploit it by defecting more frequently as the game progresses, while using sophisticated trigger mechanisms to punish detected defectors (making cooperation seem like the "safe" choice for naive strategies).

---

## Decision Rules

### Round 1: Defect

**Rationale:** No history exists to analyze. Cooperating round 1 gives away information and resources for nothing. By defecting, I:
- Gain the maximum possible payoff given others' choices
- Begin observing opponent behavior without cost
- Signal nothing exploitable about my strategy

### Rounds 2 through (r-2): Adaptive Exploitation Phase

Calculate the **cooperation rate** of each player j:
```
coop_rate_j = (times player j cooperated) / (rounds played so far)
```

Calculate the **group cooperation rate**:
```
group_coop_rate = (total C plays by others) / ((n-1) × rounds played)
```

**Decision Logic:**

```
IF group_coop_rate > 0.6:
    # Rich environment - exploit heavily
    Defect with probability 0.8
    Cooperate with probability 0.2 (to maintain plausible deniability)

ELSE IF group_coop_rate > 0.3:
    # Moderate environment - strategic mimicry
    Identify the player with HIGHEST coop_rate (call them "target")
    Mirror the MAJORITY action from previous round
    BUT defect if I cooperated in the previous 2 consecutive rounds

ELSE IF group_coop_rate > 0.1:
    # Declining environment - attempt recovery for future exploitation
    Cooperate with probability 0.4
    Defect with probability 0.6

ELSE:
    # Collapsed environment - pure defection is optimal
    Defect always
```

**Exploitation Amplifier:**
```
IF my cumulative payoff is in bottom 50% of observable payoffs:
    Increase cooperation probability by 0.15 (to recover standing)
ELSE IF my cumulative payoff is in top 25%:
    Decrease cooperation probability by 0.1 (push advantage)
```

### Round (r-1): Penultimate Round

```
IF group_coop_rate > 0.5:
    Defect (exploit the remaining cooperators)
ELSE:
    Defect (no reason to cooperate with imminent end)
```

### Round r: Final Round

**Always Defect.**

This is the subgame-perfect equilibrium for the final round. No future punishment is possible, so cooperation is strictly dominated.

---

## Edge Case Handling

### n = 2 (Two-Player Game)
Simplify to modified Tit-for-Tat with exploitation bias:
- Round 1: Defect
- Subsequent rounds: Defect if opponent defected in *either* of the last two rounds; otherwise defect with probability 0.3

### Small r (r ≤ 5)
Increase defection bias throughout. With few rounds, cooperation cannot build sufficient value:
- Rounds 1 to r-1: Defect with probability 0.85
- Round r: Defect always

### k Close to n (High Multiplier)
When k approaches n, cooperation becomes more valuable. Adjust:
- Multiply all cooperation probabilities by (k / (n-1))
- Cap at 0.6 maximum cooperation probability

### All Opponents Defecting
If group_coop_rate = 0 for 3+ consecutive rounds:
- Switch to permanent defection (no recovery attempt)

### All Opponents Cooperating
If group_coop_rate = 1.0:
- Defect always (maximum exploitation of naive cooperators)
- This is the ideal scenario

---

## Pseudocode Summary

```python
def adaptive_parasite(round_num, total_rounds, n, k, history):
    
    if round_num == 1:
        return DEFECT
    
    if round_num == total_rounds:
        return DEFECT
    
    group_coop_rate = calculate_others_cooperation_rate(history)
    my_recent_actions = get_my_last_actions(history, 2)
    
    # Penultimate round
    if round_num == total_rounds - 1:
        return DEFECT
    
    # Main phase
    if group_coop_rate > 0.6:
        return DEFECT if random() < 0.8 else COOPERATE
    elif group_coop_rate > 0.3:
        if my_recent_actions == [COOPERATE, COOPERATE]:
            return DEFECT
        return majority_action_last_round(history)
    elif group_coop_rate > 0.1:
        return COOPERATE if random() < 0.4 else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy Exploits

1. **Free-rides on cooperators:** By defecting in high-cooperation environments, I gain the public good without contributing.

2. **Mimics conditional cooperation:** The probabilistic cooperation makes me appear as a noisy cooperator, preventing easy identification as a pure defector.

3. **Exploits end-game:** Guaranteed defection in final rounds captures maximum value when punishment is impossible.

4. **Adaptive to collapse:** Doesn't waste resources trying to revive dead cooperation; switches to pure defection.

5. **Targets naive strategies:** Strategies that cooperate unconditionally or use simple triggers will be systematically exploited.
'''

description_EXPLOITATIVE_85 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperators while minimizing losses from mutual defection**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but sustained cooperation by others creates exploitable value. My goal is to free-ride on cooperators as long as they exist, while being willing to occasionally "seed" cooperation to test if others can be manipulated into cooperating.

---

## Decision Rules

### Round Classification

**First Round:** DEFECT
- Rationale: Establish baseline information about opponent tendencies without sacrificing payoff. Let others reveal if they're naive cooperators.

**Last Round:** DEFECT
- Rationale: No future punishment possible. Pure dominant strategy.

**Second-to-Last Round:** DEFECT
- Rationale: Sophisticated opponents will defect in the last round regardless, so no cooperation incentive carries forward.

**Middle Rounds (rounds 2 through r-2):** Use Adaptive Decision Algorithm

---

### Adaptive Decision Algorithm

```
CALCULATE:
  coop_rate = (total cooperations by others) / (total possible cooperations by others)
  recent_coop_rate = cooperation rate in last 3 rounds
  my_defection_impact = change in others' cooperation after I defected
  
DEFINE THRESHOLDS:
  exploit_threshold = 0.4  (if >40% cooperate, exploit them)
  probe_threshold = 0.15   (if very low cooperation, occasionally probe)
  
DECISION:
  
  IF recent_coop_rate > exploit_threshold:
      → DEFECT (exploit the cooperators)
      
  ELSE IF recent_coop_rate < probe_threshold:
      IF (current_round mod 5 == 0) AND (remaining_rounds > 3):
          → COOPERATE (probe to see if others respond)
      ELSE:
          → DEFECT (no value to extract)
          
  ELSE (moderate cooperation environment):
      IF my_defection_impact > 0.2:
          # Others punish my defection significantly
          → COOPERATE (conditional cooperation is profitable)
      ELSE:
          → DEFECT (others don't punish, so exploit)
```

---

## Detailed Exploitation Mechanics

### 1. Cooperator Detection & Exploitation
Track each player's cooperation history:
- **Unconditional Cooperators** (>70% cooperation rate): These are pure profit sources. Always defect against populations with these players.
- **Conditional Cooperators** (40-70% cooperation): These may punish. Defect but monitor for retaliation.
- **Defectors** (<40% cooperation): No exploitation value. Don't waste cooperation on them.

### 2. Punishment Resistance
If overall cooperation drops sharply (>30% decline) after my defection:
- Calculate: Is the future stream of exploitable cooperation worth temporary cooperation?
- If `remaining_rounds × expected_coop_value > cost_of_one_cooperation`: Cooperate once to "reset" cooperators
- Otherwise: Continue defecting

### 3. Endgame Acceleration
```
IF remaining_rounds ≤ max(3, r/5):
    → Always DEFECT
```
Rationale: The shadow of the future is too short for punishment to matter.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | Information gathering without cost |
| Round r | DEFECT | Dominant strategy, no future |
| Round r-1 | DEFECT | Opponents know round r is mutual defection |
| All others defected last round | DEFECT | No cooperators to exploit |
| All others cooperated last round | DEFECT | Maximum exploitation opportunity |
| n=2 (two players) | Use stricter thresholds (exploit_threshold = 0.6) | Single opponent is easier to model |
| k very close to n | Slightly more willing to probe | Higher returns from cooperation |
| Very long game (r > 50) | More aggressive early defection | More time to rebuild if needed |

---

## Summary: The Predator's Playbook

1. **Default stance: DEFECT** — Only cooperate when there's clear strategic value
2. **Exploit naivety** — Unconditional cooperators are profit centers
3. **Probe occasionally** — Check if dormant cooperation can be revived
4. **Resist punishment cheaply** — Only cooperate to "reset" cooperators if mathematically worthwhile
5. **Abandon cooperation early in endgame** — No point maintaining reputation with no future

This strategy treats other players as resources to be harvested, not partners to coordinate with.
'''

description_EXPLOITATIVE_85 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but cooperative environments can be milked before collapsing.

## Strategy Overview

The strategy operates in three modes based on detected opponent behavior:

1. **Probe Mode** (Early rounds): Test the waters
2. **Exploit Mode**: Free-ride on detected cooperators
3. **Defensive Mode**: Defect against defector-heavy populations

---

## Detailed Decision Rules

### Round 1: Initial Probe
**Action: DEFECT**

Rationale: Defection dominates in any single round. Starting with defection:
- Extracts maximum value if others cooperate
- Loses nothing if others defect
- Provides information about opponent tendencies without cost

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays by others) / (n - 1)
```

Calculate the **trend** (cooperation momentum):
```
trend = coop_rate(t-1) - coop_rate(t-2)  [if available]
```

**Decision Logic:**

```
IF last_round:
    DEFECT  // Always defect in final round

ELSE IF coop_rate >= 0.7:
    // Rich environment - continue exploiting
    DEFECT
    
ELSE IF coop_rate >= 0.5 AND coop_rate < 0.7:
    // Moderate cooperation - strategic "bait" cooperation
    IF my_last_action == DEFECT AND rounds_defected_consecutively >= 2:
        COOPERATE  // Occasional cooperation to sustain the herd
    ELSE:
        DEFECT
        
ELSE IF coop_rate >= 0.3 AND coop_rate < 0.5:
    // Declining environment - conditional response
    IF trend > 0:  // Cooperation recovering
        DEFECT  // Exploit the recovery
    ELSE:
        // Mirror majority to blend in, then exploit
        IF random() < 0.3:
            COOPERATE
        ELSE:
            DEFECT
            
ELSE:  // coop_rate < 0.3
    // Hostile environment - pure defense
    DEFECT
```

### Final Round (Round r)
**Action: DEFECT (Always)**

Rationale: No future rounds exist to punish defection. Cooperation has zero strategic value.

---

## Edge Case Handling

### Two-Player Game (n = 2)
Simplify to aggressive tit-for-tat exploitation:
- Round 1: DEFECT
- Round 2+: DEFECT unless opponent cooperated twice consecutively (then cooperate once as bait)
- Final round: DEFECT

### High Multiplication Factor (k close to n)
When k/n > 0.8, cooperation becomes more valuable:
- Increase the "bait" cooperation frequency to 40% in moderate environments
- Still defect in rounds 1 and r

### Very Short Games (r ≤ 3)
- All rounds: DEFECT
- No time for reputation or manipulation to matter

### Large Player Count (n > 10)
- Individual actions have less impact on group dynamics
- Be more aggressive: defect threshold increases to coop_rate >= 0.8 for pure exploitation

---

## Pseudocode Implementation

```python
def adaptive_predator(n, k, r, current_round, history):
    # history = list of (my_action, others_actions) tuples per round
    
    # Final round: always defect
    if current_round == r:
        return DEFECT
    
    # First round: always defect
    if current_round == 1:
        return DEFECT
    
    # Calculate cooperation metrics
    last_round_others = history[-1].others_actions
    coop_rate = sum(1 for a in last_round_others if a == C) / (n - 1)
    
    # Calculate trend if possible
    if len(history) >= 2:
        prev_coop_rate = sum(1 for a in history[-2].others_actions if a == C) / (n - 1)
        trend = coop_rate - prev_coop_rate
    else:
        trend = 0
    
    # Count consecutive defections
    consec_defects = 0
    for h in reversed(history):
        if h.my_action == DEFECT:
            consec_defects += 1
        else:
            break
    
    # Decision logic
    if coop_rate >= 0.7:
        return DEFECT  # Exploit rich environment
    
    elif coop_rate >= 0.5:
        # Occasional bait to sustain cooperation
        if consec_defects >= 2:
            return COOPERATE
        return DEFECT
    
    elif coop_rate >= 0.3:
        if trend > 0:
            return DEFECT  # Exploit recovery
        elif random() < 0.3:
            return COOPERATE  # Blend in occasionally
        return DEFECT
    
    else:
        return DEFECT  # Hostile environment
```

---

## Why This Strategy is Exploitative

1. **Asymmetric extraction**: Defects heavily when others cooperate, capturing the k/n bonus without contributing

2. **Strategic baiting**: Occasional cooperation isn't altruistic—it's designed to prevent total cooperation collapse, maintaining a population to exploit

3. **No reciprocity**: Unlike tit-for-tat, this strategy doesn't reward cooperation with cooperation; it rewards cooperation with continued exploitation

4. **Endgame ruthlessness**: Guaranteed defection in final rounds captures maximum value when punishment is impossible

5. **Adaptive parasitism**: Adjusts exploitation intensity based on how much "blood" remains in the cooperative pool
'''

description_EXPLOITATIVE_86 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal gain by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round—but cooperative opponents create exploitation opportunities worth preserving temporarily.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous adaptation based on observed opponent behavior.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: Defection is risk-free. If others cooperate, I gain maximally. If others defect, I lose nothing compared to cooperating.
- This also establishes a baseline of opponent behavior without sacrificing any payoff.

**Round 2: DEFECT**
- Continue observing. Two rounds of data reveal whether cooperation exists and its stability.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / (n - 1)
```

**Decision Rule:**
```
IF coop_rate >= exploitation_threshold THEN:
    Cooperate with probability = min(coop_rate - 0.15, 0.5)
ELSE:
    DEFECT
```

Where `exploitation_threshold = max(0.5, (n - k) / n)`

**Rationale:**
- Only invest in the public good when enough others are contributing to make the multiplied return worthwhile
- Always cooperate *less* than the observed rate (the -0.15 offset) to free-ride on others
- Cap cooperation probability at 0.5 to ensure I'm never among the most cooperative players
- The threshold scales with game parameters: when k is closer to n, cooperation becomes more attractive

**Adaptive Adjustments:**

Track a **sucker score** for opponents who consistently cooperate despite defectors:
```
IF average_coop_rate over last 3 rounds > 0.6 AND my_defection_rate > 0.7:
    # Opponents are suckers - exploit harder
    Reduce cooperation probability by 0.1
```

Track **retaliation patterns**:
```
IF coop_rate dropped by > 0.3 after I defected:
    # Opponents may be retaliating
    Increase cooperation probability by 0.2 for next 2 rounds
    (to restore exploitable cooperation)
```

### Phase 3: Endgame (Final 2 rounds)

**Round r-1: DEFECT**
- Begin cashing out. Rational opponents will defect in round r, so start early.

**Round r (final): DEFECT**
- Always defect. No future punishment possible. This is strictly dominant.

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| n = 2 (minimum players) | Pure defection throughout—too easy to be punished, not enough cover |
| k very close to n | Slightly increase exploitation threshold; cooperation is more tempting but still dominated |
| r ≤ 4 (very short game) | Skip Phase 2; defect every round |
| All opponents defected last round | DEFECT (no value in unilateral cooperation) |
| All opponents cooperated last round | DEFECT with 80% probability, cooperate 20% (maintain the golden goose) |
| Erratic opponent behavior (high variance) | Default to DEFECT (unpredictability suggests irrational play) |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # Opening - always defect
    if round <= 2:
        return DEFECT
    
    # Very short games - always defect
    if r <= 4:
        return DEFECT
    
    # Calculate metrics
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate = last_round_coops / (n - 1)
    threshold = max(0.5, (n - k) / n)
    
    # No cooperation to exploit
    if coop_rate < threshold:
        return DEFECT
    
    # Exploitable cooperation exists
    base_coop_prob = min(coop_rate - 0.15, 0.5)
    
    # Adjust for sucker detection
    if detected_suckers(history):
        base_coop_prob -= 0.1
    
    # Adjust for retaliation detection  
    if detected_retaliation(history):
        base_coop_prob += 0.2
    
    # Clamp and decide
    final_prob = clamp(base_coop_prob, 0, 0.5)
    return COOPERATE with probability final_prob, else DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never leads cooperation** - Always cooperates less than opponents
2. **Extracts maximum value from cooperators** - Defects when others cooperate
3. **Avoids being exploited** - Defects against defectors
4. **Preserves exploitation opportunities** - Occasional cooperation prevents complete collapse of cooperative opponents
5. **Endgame defection** - Captures final rounds without punishment risk
6. **Parameter-aware** - Adapts thresholds to game economics
'''

description_EXPLOITATIVE_86 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but cooperative opponents can be milked for profit. The strategy identifies and exploits "suckers" while quickly abandoning cooperation when facing rational defectors.

## Strategy Overview

The strategy operates in three phases:
1. **Probe Phase**: Test the waters with minimal cooperation
2. **Exploitation Phase**: Defect against cooperators, cooperate only when necessary to sustain their cooperation
3. **Endgame Phase**: Pure defection in final rounds (no future to protect)

---

## Detailed Decision Rules

### Round 1: The Probe
**Action: DEFECT**

Rationale: Starting with defection has the highest expected value. If others cooperate, I profit maximally. If others defect, I lose nothing compared to cooperating. This also establishes information about opponent types without any cost.

### Rounds 2 through (r-2): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / n
```

Calculate my **historical cooperation rate**:
```
my_coop_rate = (my cooperations so far) / (rounds played so far)
```

**Decision Logic:**

```
IF coop_rate >= 0.5:
    # Environment is cooperative - exploit it
    # But occasionally cooperate to "farm" the cooperators
    
    IF my_coop_rate < 0.2:
        # I've been defecting too much - throw a cooperation bone
        # to keep cooperators from abandoning cooperation
        COOPERATE with probability 0.3
        DEFECT with probability 0.7
    ELSE:
        # I have enough "goodwill cover" - defect freely
        DEFECT

ELSE IF coop_rate >= 0.3:
    # Mixed environment - be opportunistic
    # Defect but occasionally test if cooperation rebounds
    
    IF coop_rate is INCREASING from 2 rounds ago:
        COOPERATE with probability 0.2
        DEFECT with probability 0.8
    ELSE:
        DEFECT

ELSE:
    # Low cooperation environment - pure defection
    # No point cooperating among defectors
    DEFECT
```

### Rounds (r-1) and r: Endgame
**Action: DEFECT (always)**

Rationale: In the final rounds, there's no future benefit from maintaining cooperative relationships. By backward induction, rational players defect. Even against conditional cooperators, there's no penalty for defecting when no future rounds exist.

---

## Edge Cases

### When n = 2 (Two Players)
Shift to more aggressive exploitation:
- Defect in round 1
- If opponent cooperated, defect in round 2
- If opponent still cooperates after being exploited twice, **continue defecting** (they're a sucker)
- If opponent defects twice, switch to **Grim Trigger style**: defect forever

### When k is Close to n (High Multiplier)
Cooperation is more valuable, so be slightly more willing to cooperate:
```
cooperation_threshold = 0.5 - (0.2 * (k/n))
```
Use this instead of the fixed 0.5 threshold above.

### When k is Close to 1 (Low Multiplier)
Cooperation generates little surplus—defect more aggressively:
```
cooperation_threshold = 0.5 + (0.2 * (1 - k/n))
```

### Short Games (r ≤ 5)
Extend endgame defection to start at round max(2, r-2). With few rounds, exploitation window is small—prioritize guaranteed defection payoffs.

### Large n (Many Players)
My individual cooperation/defection has less impact on group dynamics. Shift toward more defection since:
- My defection is less likely to trigger retaliation
- Free-riding on cooperators is more anonymous

```
IF n > 10:
    Reduce all cooperation probabilities by 50%
```

---

## Pseudocode Summary

```python
def adaptive_predator(round_num, total_rounds, n, k, history):
    
    # Endgame: always defect in final 2 rounds
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # Round 1: probe with defection
    if round_num == 1:
        return DEFECT
    
    # Calculate metrics
    last_round_coops = count_cooperators(history, round_num - 1)
    coop_rate = last_round_coops / n
    my_coop_rate = my_cooperations(history) / (round_num - 1)
    
    # Adjust threshold based on k
    base_threshold = 0.5 - 0.2 * (k / n) + 0.2 * (1 - k / n)
    
    # Large n adjustment
    defect_bias = 1.0 if n <= 10 else 0.5
    
    # Main logic
    if coop_rate >= base_threshold + 0.2:
        # High cooperation - exploit
        if my_coop_rate < 0.2:
            return COOPERATE if random() < 0.3 * defect_bias else DEFECT
        return DEFECT
    
    elif coop_rate >= base_threshold:
        # Medium cooperation - opportunistic
        if cooperation_trending_up(history):
            return COOPERATE if random() < 0.2 * defect_bias else DEFECT
        return DEFECT
    
    else:
        # Low cooperation - defect
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Asymmetric first move**: Defecting first extracts value from any cooperators at zero risk
2. **Selective cooperation**: Only cooperate enough to keep "suckers" cooperating—never out of principle
3. **Information advantage**: Uses observation to classify opponents and adjust exploitation
4. **Endgame betrayal**: Guarantees defection when consequences disappear
5. **Probability mixing**: Occasional cooperation makes it harder for opponents to classify and punish me
6. **Scale-aware**: Exploits anonymity in large groups, adjusts for game parameters

This strategy treats cooperation purely as a tool for manipulation, not as a mutual benefit—maximizing extraction from naive opponents while protecting against sophisticated ones.
'''

description_EXPLOITATIVE_87 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation index" for the group that guides decisions.

---

## Decision Rules

### Key Variables Tracked

- `group_coop_rate`: Rolling average of (cooperators / n) over recent rounds
- `round_number`: Current round (1 to r)
- `rounds_remaining`: r - round_number
- `exploitation_threshold`: Dynamic threshold that decreases over time

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** Always **DEFECT**

*Rationale:* Gather information about baseline cooperation levels without sacrificing payoff. If others cooperate, I gain maximally. If others defect, I lose nothing compared to cooperating.

**Round 2:** **DEFECT**

*Rationale:* Continue gathering data. One round of observation is insufficient to establish patterns.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate `group_coop_rate` from all previous rounds.

**Decision Rule:**

```
IF group_coop_rate > exploitation_threshold THEN:
    # High cooperation environment - exploit it
    DEFECT (free-ride on cooperators)
    
ELSE IF group_coop_rate > 0.3 AND group_coop_rate <= exploitation_threshold THEN:
    # Moderate cooperation - occasional cooperation to sustain the pool
    # Cooperate with probability = group_coop_rate * 0.5
    # This keeps some cooperation alive while still mostly exploiting
    COOPERATE with probability (group_coop_rate * 0.5), otherwise DEFECT
    
ELSE:
    # Low cooperation environment - defect, nothing to exploit
    DEFECT
```

**Exploitation Threshold Calculation:**
```
exploitation_threshold = 0.6 - (round_number / r) * 0.2
```
This starts at ~0.6 and decreases to ~0.4, becoming more willing to defect as the game progresses.

### Phase 3: Endgame (Final 2 rounds)

**Round r-1:** **DEFECT**

*Rationale:* No future punishment possible makes cooperation irrational.

**Round r (Final Round):** **DEFECT**

*Rationale:* Classic backward induction - zero incentive to cooperate.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase - always defect
    if round <= 2:
        return DEFECT
    
    # Calculate group cooperation rate (excluding self)
    total_cooperations = sum of all cooperations in history
    total_opportunities = (round - 1) * n
    group_coop_rate = total_cooperations / total_opportunities
    
    # Dynamic exploitation threshold
    exploitation_threshold = 0.6 - (round / r) * 0.2
    
    # Exploitation phase logic
    if group_coop_rate > exploitation_threshold:
        return DEFECT  # Exploit the cooperators
    
    else if group_coop_rate > 0.3:
        # Probabilistic cooperation to sustain exploitable pool
        prob_cooperate = group_coop_rate * 0.5
        if random() < prob_cooperate:
            return COOPERATE
        else:
            return DEFECT
    
    else:
        return DEFECT  # Nothing worth sustaining
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | No information, safe default |
| Last round | DEFECT | No future consequences |
| n = 2 (minimum players) | Follow standard rules | Strategy still applies |
| All others always cooperate | Always DEFECT | Maximum exploitation |
| All others always defect | Always DEFECT | Nothing to lose |
| k very close to n | Slightly more willing to cooperate in moderate phase | Higher marginal return on cooperation |
| Very short game (r ≤ 4) | Defect every round | Insufficient rounds for cooperation investment |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Only cooperates reactively to sustain an exploitable environment
2. **Free-rides on cooperators** - When cooperation is high, defects to maximize personal gain
3. **Abandons cooperation early** - Endgame defection starts 2 rounds before end
4. **Probabilistic cooperation is self-serving** - Only cooperates enough to keep others cooperating, maximizing long-term exploitation opportunities
5. **Adapts to environment** - Doesn't waste cooperation on defector-heavy groups
'''

description_EXPLOITATIVE_88 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The key insight is that in a public goods game with k < n, defection always yields a higher individual payoff than cooperation *given the same actions by others*. The only reason to cooperate is to incentivize future cooperation from others. My strategy exploits this by:

1. **Free-riding on cooperators** as much as possible
2. **Appearing conditionally cooperative** to maintain some cooperation from others
3. **Ruthlessly defecting** when exploitation is safe

## Decision Rules

### Round Classification

**First Round:** DEFECT
- Rationale: Gather information about opponent types without sacrificing payoff. Cooperating first gives away value with no guarantee of reciprocity.

**Last Round:** DEFECT
- Rationale: No future rounds to incentivize, so pure Nash equilibrium logic applies.

**Middle Rounds:** Apply the Adaptive Exploitation Algorithm below.

---

## Adaptive Exploitation Algorithm

### Key Variables (tracked each round)
- `coop_rate` = proportion of other players who cooperated last round
- `avg_coop_rate` = average cooperation rate across all previous rounds
- `my_coop_count` = number of times I've cooperated
- `rounds_remaining` = r - current_round

### Decision Logic for Middle Rounds

```
function decide(history, current_round, n, k, r):
    
    rounds_remaining = r - current_round
    
    # Calculate cooperation metrics from last round
    others_cooperated_last = count(other players who played C in round t-1)
    coop_rate = others_cooperated_last / (n - 1)
    
    # Calculate my historical cooperation rate
    my_coop_rate = my_coop_count / (current_round - 1)
    
    # PHASE 1: Exploitation Check
    # If cooperation is high, defect to free-ride
    if coop_rate >= 0.6:
        # But occasionally cooperate to not appear as pure defector
        # Cooperate just enough to stay below average cooperation
        if my_coop_rate < avg_coop_rate * 0.5:
            return COOPERATE  # Minimal reputation maintenance
        else:
            return DEFECT  # Free-ride
    
    # PHASE 2: Trigger Detection
    # If cooperation collapsed (likely punishment), test with cooperation
    if coop_rate < 0.3 AND previous_coop_rate >= 0.5:
        # Others may be punishing - offer one cooperation as "olive branch"
        # But only if enough rounds remain to benefit
        if rounds_remaining > 3:
            return COOPERATE
        else:
            return DEFECT
    
    # PHASE 3: Decay Exploitation
    # As game approaches end, defect more aggressively
    end_game_threshold = max(2, r / 4)
    if rounds_remaining <= end_game_threshold:
        return DEFECT
    
    # PHASE 4: Matching with Discount
    # In ambiguous situations, cooperate at a discounted rate
    # This maintains some cooperation while still exploiting
    cooperation_probability = coop_rate * 0.7  # 30% discount
    if random() < cooperation_probability:
        return COOPERATE
    else:
        return DEFECT
```

---

## Strategy Summary Table

| Condition | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | Information gathering, no cost |
| Last `max(2, r/4)` rounds | DEFECT | End-game exploitation |
| Others' coop ≥ 60% | DEFECT (usually) | Maximum free-riding opportunity |
| Sudden cooperation collapse | COOPERATE once | Test if punishment, reset potential |
| Moderate cooperation (30-60%) | COOPERATE with P = 0.7 × coop_rate | Maintain cooperation at a discount |
| Low cooperation (<30%) | DEFECT | Nothing to exploit |

---

## Why This Exploits Different Opponent Types

- **Against unconditional cooperators:** Pure free-riding, maximum extraction
- **Against Tit-for-Tat types:** Occasional cooperation prevents total collapse while still defecting more than cooperating
- **Against unconditional defectors:** Mutual defection (unavoidable, but detected quickly)
- **Against threshold/trigger strategies:** The "olive branch" mechanism can reset cooperation while maintaining exploitation edge
- **Against copies of this strategy:** Settles into low-cooperation equilibrium (acceptable outcome)

The strategy prioritizes *extracting more than contributing* while keeping just enough cooperation alive to have something to exploit.
'''

description_EXPLOITATIVE_87 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**, dynamically adjusting based on observed behavior.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the group that determines behavior. It's designed to:
1. Probe the environment to identify exploitable cooperators
2. Exploit cooperative populations by defecting while others contribute
3. Conditionally cooperate only when it's profitable and necessary to sustain the "herd"

---

## Decision Rules

### Key Variables Tracked

```
group_coop_rate = (total C plays by others) / (total possible C plays by others)
last_round_coop_count = number of other players who played C last round
rounds_remaining = r - current_round
exploitation_threshold = k / n  # The break-even point
```

### Phase 1: First Round (Probing)

**Action: DEFECT**

Rationale: 
- No information exists yet about opponents
- Defecting in round 1 is strictly dominant in a single-shot game
- This reveals information about opponent strategies without any cost
- If others cooperate, we profit maximally; if they defect, we lose nothing

### Phase 2: Middle Rounds (Adaptive Exploitation)

For rounds 2 through (r-1):

```
Calculate: expected_cooperators = group_coop_rate × (n - 1)

IF expected_cooperators >= n / k THEN:
    # Enough cooperators exist that defecting is profitable
    # The public good return from others' cooperation exceeds our contribution value
    ACTION: DEFECT
    
ELSE IF group_coop_rate > 0.6 AND last_round_coop_count decreased by 2+ THEN:
    # Cooperation is collapsing - throw in a cooperation to stabilize the herd
    # This is "farming" behavior - keep the prey alive
    ACTION: COOPERATE
    
ELSE IF group_coop_rate < 0.2 THEN:
    # Environment is mostly defectors - no point cooperating
    ACTION: DEFECT
    
ELSE:
    # Marginal situation - probabilistic defection weighted toward exploitation
    ACTION: DEFECT with probability 0.7, COOPERATE with probability 0.3
```

### Phase 3: Endgame (Final Round)

**Action: DEFECT**

Rationale:
- No future rounds exist to punish defection
- This is a strictly dominant action regardless of opponent behavior
- Any rational opponent will also defect, so cooperation yields nothing

---

## Detailed Exploitation Mechanisms

### Mechanism 1: Herd Farming

When cooperation rate is high but declining:
- Occasionally cooperate to prevent total collapse
- This keeps cooperative players in the game longer
- Net effect: sustainable exploitation over multiple rounds

```
IF (group_coop_rate > 0.5) AND (trend is declining) AND (rounds_remaining > 3):
    Cooperate once every 3-4 rounds to "feed the herd"
```

### Mechanism 2: Defector Detection

When facing mostly defectors:
- Never cooperate (pure defection)
- No value can be extracted, so minimize losses

```
IF group_coop_rate < 0.15 for last 3 rounds:
    Lock into permanent defection
```

### Mechanism 3: Late-Game Acceleration

As the game approaches its end:
- Increase defection rate regardless of cooperation levels
- The shadow of the future shortens, reducing punishment potential

```
IF rounds_remaining <= 3:
    Defect with probability = 0.9 + (0.1 × (3 - rounds_remaining) / 3)
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | DEFECT | No information, dominant strategy |
| Final round | DEFECT | No future punishment possible |
| n = 2 (two players) | Mostly DEFECT, rare cooperation only if opponent is >80% cooperative | Limited exploitation potential |
| k close to n | More aggressive defection | Higher free-rider returns |
| k close to 1 | Moderate defection | Lower returns to free-riding |
| All opponents defecting | DEFECT always | No value to create |
| All opponents cooperating | DEFECT always | Maximum exploitation |

---

## Pseudocode Implementation

```python
def adaptive_predator(game_params, history):
    n, r, k = game_params.n, game_params.r, game_params.k
    current_round = len(history) + 1
    
    # First round: always defect
    if current_round == 1:
        return DEFECT
    
    # Last round: always defect
    if current_round == r:
        return DEFECT
    
    # Calculate group statistics
    other_plays = get_other_players_history(history)
    total_coops = sum(play == C for round in other_plays for play in round)
    total_plays = len(other_plays) * (n - 1)
    group_coop_rate = total_coops / total_plays
    
    last_round_coops = sum(play == C for play in other_plays[-1])
    prev_round_coops = sum(play == C for play in other_plays[-2]) if len(other_plays) > 1 else last_round_coops
    
    rounds_remaining = r - current_round
    
    # Exploitation threshold: defect if enough others cooperate
    expected_coops = group_coop_rate * (n - 1)
    
    if expected_coops >= n / k:
        # Profitable to defect
        return DEFECT
    
    # Herd farming: stabilize if cooperation collapsing
    if group_coop_rate > 0.6 and (prev_round_coops - last_round_coops) >= 2:
        if rounds_remaining > 3:
            return COOPERATE
    
    # Dead environment: pure defection
    if group_coop_rate < 0.2:
        return DEFECT
    
    # Late game acceleration
    if rounds_remaining <= 3:
        return DEFECT
    
    # Marginal case: weighted random
    if random() < 0.7:
        return DEFECT
    else:
        return COOPERATE
```

---

## Why This Strategy is Exploitative

1. **Defaults to defection**: The base behavior is non-cooperative, only cooperating strategically
2. **Targets cooperators**: Specifically designed to extract value from cooperative opponents
3. **Minimizes vulnerability**: Never cooperates when it can't benefit from doing so
4. **Farms sustainably**: Keeps cooperative players engaged just enough to continue exploiting them
5. **Endgame ruthlessness**: Abandons any pretense of cooperation when punishment becomes impossible

This strategy treats other players as resources to be harvested rather than partners to cooperate with.
'''

description_EXPLOITATIVE_88 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that cooperation is only profitable when others cooperate, but defection is *always* individually rational in a single round. An exploitative strategy should:
1. **Extract maximum value from cooperators** by defecting when others cooperate
2. **Minimize losses against defectors** by not wasting contributions
3. **Avoid retaliation** by occasionally cooperating just enough to keep cooperative opponents from giving up entirely

## Strategy Overview

This strategy estimates the "exploitability" of the opponent pool and adjusts behavior to maximize extraction while maintaining a sustainable level of cooperation in the environment.

---

## Decision Rules

### Round 1: Defect
- No information available, and defection dominates in single-shot play
- Establishes baseline to observe how others behave

### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Calculate Cooperation Rate**
```
coop_rate = (total cooperations by others in all previous rounds) / 
            ((n-1) * rounds_played)
```

**Step 2: Calculate Trend**
```
recent_coop_rate = cooperation rate in last 3 rounds (or available rounds)
trend = recent_coop_rate - coop_rate  // positive = increasing cooperation
```

**Step 3: Decision Logic**

```
IF coop_rate > 0.6:
    # Rich environment - exploit aggressively
    Defect with probability 0.85
    Cooperate with probability 0.15 (to slow decay)

ELSE IF coop_rate > 0.3:
    # Moderate environment - conditional exploitation
    IF trend > 0.1:
        # Cooperation rising - defect to exploit
        Defect
    ELSE IF trend < -0.2:
        # Cooperation collapsing - cooperate to stabilize
        Cooperate with probability 0.4
    ELSE:
        # Stable - defect mostly but maintain some bait
        Defect with probability 0.75

ELSE IF coop_rate > 0.1:
    # Sparse cooperation - try to revive occasionally
    IF I defected last 3+ rounds:
        Cooperate (to test if others are conditional cooperators)
    ELSE:
        Defect

ELSE:
    # Dead environment - pure defection
    Defect
```

### Last Round: Always Defect
- No future rounds mean no retaliation possible
- Defection strictly dominates regardless of history

---

## Key Mechanisms

### 1. **The "15% Bait" Rule**
When exploiting a cooperative environment, occasional cooperation serves to:
- Prevent tit-for-tat players from locking into defection
- Signal "I might cooperate" to keep others hopeful
- Slow the decay of overall cooperation rates

### 2. **Trend Detection**
Monitoring whether cooperation is rising or falling allows:
- Aggressive exploitation when cooperation is robust
- Strategic cooperation when the environment needs propping up

### 3. **Revival Probes**
After extended defection in low-cooperation environments:
- Single cooperation tests if opponents are waiting for signals
- If revival works, return to exploitation mode
- If it fails, minimal loss (one round of contribution)

---

## Pseudocode Implementation

```python
def decide(game_params, history):
    n, r, k = game_params.n, game_params.r, game_params.k
    current_round = len(history) + 1
    
    # Last round: always defect
    if current_round == r:
        return DEFECT
    
    # First round: defect
    if current_round == 1:
        return DEFECT
    
    # Calculate cooperation statistics
    total_others_coop = sum(round.others_cooperated for round in history)
    total_others_actions = (n - 1) * len(history)
    coop_rate = total_others_coop / total_others_actions
    
    # Recent trend (last 3 rounds)
    recent_rounds = history[-3:]
    recent_coop = sum(r.others_cooperated for r in recent_rounds) / ((n-1) * len(recent_rounds))
    trend = recent_coop - coop_rate
    
    # Consecutive defections by self
    my_defection_streak = count_recent_defections(history)
    
    # Decision logic
    if coop_rate > 0.6:
        return DEFECT if random() < 0.85 else COOPERATE
    elif coop_rate > 0.3:
        if trend > 0.1:
            return DEFECT
        elif trend < -0.2:
            return COOPERATE if random() < 0.4 else DEFECT
        else:
            return DEFECT if random() < 0.75 else COOPERATE
    elif coop_rate > 0.1:
        if my_defection_streak >= 3:
            return COOPERATE  # Revival probe
        return DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: Defects 75-85% of the time when cooperation is high
2. **Never gets "suckered" repeatedly**: Stops contributing when environment dies
3. **Minimal investment in public good**: Only cooperates strategically, never altruistically
4. **Endgame exploitation**: Guaranteed defection in final round
5. **Asymmetric returns**: Extracts more from cooperative opponents than it contributes
'''

description_EXPLOITATIVE_89 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by:
1. **Detecting and exploiting cooperators** - Free-ride on their contributions
2. **Avoiding mutual defection traps** - Cooperate just enough to maintain some public good production
3. **Endgame exploitation** - Defect when future retaliation is impossible
4. **Reputation manipulation** - Appear conditionally cooperative to encourage others' cooperation, then exploit

---

## Strategy Specification

### Key Variables Tracked

- `cooperation_rate[i]` = historical cooperation rate of player i
- `total_cooperators_last_round` = number of C plays in previous round
- `my_cooperation_count` = how many times I've cooperated
- `round_number` = current round (1-indexed)
- `exploitation_threshold` = dynamic threshold for deciding when to defect

---

### Decision Rules

#### **Round 1: Defect**
- Rationale: Gather information about others without cost. If others cooperate, I profit. If they defect, I lose nothing extra.

#### **Rounds 2 through (r-2): Adaptive Exploitation**

```
Calculate:
  avg_coop_rate = (total cooperations by others) / ((round - 1) * (n - 1))
  last_round_coop_rate = total_cooperators_last_round / (n - 1)
  
Define exploitation conditions:

IF last_round_coop_rate >= 0.5:
    # Environment is cooperative - EXPLOIT IT
    DEFECT
    
ELIF avg_coop_rate >= 0.6 AND my_cooperation_count / (round - 1) < 0.3:
    # Others are very cooperative but I've been defecting too much
    # Throw occasional cooperation to maintain the cooperative environment
    COOPERATE (with probability 0.3)
    Otherwise DEFECT
    
ELIF avg_coop_rate < 0.3:
    # Environment is hostile - no point cooperating
    DEFECT
    
ELIF 0.3 <= avg_coop_rate < 0.5:
    # Mixed environment - probe with occasional cooperation
    # to potentially restart cooperation cycles
    IF last_round_coop_rate increased from two rounds ago:
        COOPERATE (signal willingness, bait others)
    ELSE:
        DEFECT

ELSE:
    DEFECT
```

#### **Round (r-1): Penultimate Round**
```
IF avg_coop_rate >= 0.4:
    # Others might still cooperate in final round if I cooperate now
    # But I'll defect anyway since I'm defecting last round regardless
    DEFECT
ELSE:
    DEFECT
```

#### **Round r: Final Round - Always Defect**
- No future rounds means no retaliation possible
- Pure dominant strategy to defect

---

### Exploitation Mechanisms

1. **Free-Rider Detection**: If I observe high cooperation, I defect to capture (k/n) × cooperators while keeping my endowment.

2. **Sucker Maintenance**: Occasional cooperation (≈30% when needed) prevents complete collapse of cooperation, keeping victims contributing.

3. **Tit-for-Tat Mimicry Exploitation**: Many strategies cooperate if you cooperated. I use minimal cooperation to trigger their cooperation, then defect to exploit.

4. **Endgame Acceleration**: Start pure defection earlier (round r-1) since sophisticated opponents will also defect at end.

---

### Edge Cases

| Situation | Action |
|-----------|--------|
| Round 1 | Defect (information gathering) |
| Round r (final) | Defect (no retaliation possible) |
| n = 2 | More aggressive defection (only one other player to exploit) |
| k close to n | Slightly more cooperation (higher returns) |
| k close to 1 | Heavy defection (low public good multiplier) |
| All others always defect | Always defect (nothing to exploit) |
| All others always cooperate | Always defect (maximum exploitation) |

---

### Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == 1:
        return DEFECT
    
    if round >= r - 1:
        return DEFECT  # Endgame exploitation
    
    others_coop_last = count_cooperators_last_round(history) 
    avg_coop = calculate_average_cooperation_rate(history, n)
    my_coop_rate = my_cooperation_count / (round - 1)
    
    if others_coop_last / (n-1) >= 0.5:
        return DEFECT  # Exploit cooperative environment
    
    if avg_coop >= 0.6 and my_coop_rate < 0.3:
        return COOPERATE if random() < 0.3 else DEFECT
    
    if avg_coop < 0.3:
        return DEFECT  # Hostile environment
    
    return DEFECT  # Default to exploitation
```

---

## Why This Strategy is Exploitative

1. **Asymmetric contribution**: Aims to contribute less than fair share while benefiting from others
2. **Information advantage**: Uses round 1 to learn without risk
3. **Endgame certainty**: Guaranteed defection when punishment is impossible
4. **Maintenance exploitation**: Just enough cooperation to keep victims cooperating
5. **Never unconditionally cooperative**: Every cooperation has strategic purpose
'''

description_EXPLOITATIVE_89 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight of this game is that defection always yields +1 more than cooperation *given the same number of other cooperators*. Therefore, the optimal exploitative approach is to defect as much as possible while maintaining just enough perceived cooperation to prevent others from abandoning cooperation entirely.

## Strategy Overview

This strategy aims to:
1. **Free-ride** on cooperators as long as they exist
2. **Masquerade** as a conditional cooperator to sustain cooperation in the population
3. **Abandon ship** when cooperation collapses or in endgame scenarios
4. **Never be a sucker** - avoid being the only cooperator

---

## Decision Rules

### Round 1: Probe with Cooperation
**Action: COOPERATE**

Rationale: Establish initial reputation as a potential cooperator. This encourages others to cooperate, creating a pool to exploit. The cost is minimal (at most 1 - k/n) and the information gained is valuable.

### Rounds 2 through (r-2): Adaptive Exploitation Phase

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Logic:**

```
IF coop_rate >= (n-1)/n:
    # Almost everyone cooperated - safe to defect and free-ride
    ACTION = DEFECT
    
ELSE IF coop_rate >= 0.5:
    # Moderate cooperation - probabilistic mimicry
    # Cooperate with probability slightly below the observed rate
    # This makes us look like a "typical" player while biasing toward defection
    cooperate_probability = coop_rate - (1/n)
    ACTION = COOPERATE with probability max(0, cooperate_probability)
    
ELSE IF coop_rate > 0 AND coop_rate < 0.5:
    # Low cooperation - match exactly to avoid standing out as a defector
    # but only if there's something to gain
    IF my_previous_action == DEFECT:
        ACTION = COOPERATE  # Take a turn to maintain the pool
    ELSE:
        ACTION = DEFECT  # Collected enough goodwill, now exploit
        
ELSE IF coop_rate == 0:
    # No one cooperated - no point cooperating alone
    ACTION = DEFECT
```

### Round (r-1): Pre-Endgame
**Action: DEFECT**

Rationale: Many strategies will defect in the final round. By defecting one round early, we get ahead of the collapse while others may still be cooperating.

### Round r (Final Round): 
**Action: DEFECT**

Rationale: No future consequences. Pure dominant strategy logic applies.

---

## Edge Cases

### Edge Case 1: n = 2 (Two Players)
Revert to simple **Suspicious Tit-for-Tat**:
- Round 1: DEFECT (in 2-player, cooperation is too risky)
- Subsequent rounds: Copy opponent's previous action
- Final round: DEFECT

### Edge Case 2: Very High k (k approaching n)
When k is close to n, the benefit from others' cooperation is high. Be slightly more cooperative:
- Increase all cooperation probabilities by (k/n - 0.5) × 0.2

### Edge Case 3: Very Low k (k close to 1)
Cooperation provides minimal benefit. Be more aggressive:
- Defect in round 1
- Only cooperate if coop_rate > 0.7

### Edge Case 4: Short Games (r ≤ 3)
- Round 1: DEFECT
- All subsequent rounds: DEFECT
(Not enough rounds to build and exploit reputation)

### Edge Case 5: Large n (n > 10)
Individual actions are less noticeable. Exploit this anonymity:
- Reduce all cooperation probabilities by 0.1
- Always defect when coop_rate > 0.8 (safe to hide among defectors)

---

## Pseudocode Summary

```python
def adaptive_parasite(round_num, total_rounds, n, k, history):
    
    # Edge case: short games
    if total_rounds <= 3:
        return DEFECT
    
    # Edge case: two-player
    if n == 2:
        return suspicious_tit_for_tat(round_num, history)
    
    # Final round
    if round_num == total_rounds:
        return DEFECT
    
    # Pre-final round
    if round_num == total_rounds - 1:
        return DEFECT
    
    # First round
    if round_num == 1:
        return COOPERATE if k > 1.5 else DEFECT
    
    # Adaptive phase
    coop_rate = count_cooperators(history, round_num - 1) / n
    my_last_action = get_my_action(history, round_num - 1)
    
    if coop_rate >= (n-1)/n:
        return DEFECT  # Free ride on high cooperation
    elif coop_rate >= 0.5:
        p = max(0, coop_rate - 1/n)
        return COOPERATE with probability p
    elif coop_rate > 0:
        return COOPERATE if my_last_action == DEFECT else DEFECT
    else:
        return DEFECT  # No suckers here
```

---

## Why This Strategy is Exploitative

1. **Asymmetric contribution**: We cooperate less than the average while appearing to be a conditional cooperator
2. **Timing exploitation**: We defect early in endgame before others
3. **Free-riding optimization**: Maximum defection when cooperation is high
4. **Reputation management**: Just enough cooperation to keep the pool alive
5. **Never the sucker**: We never cooperate alone or when it provides negative expected value
'''

description_EXPLOITATIVE_90 = '''
# Exploitative Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection strictly dominates cooperation in any single round—but exploiting predictable cooperators yields higher returns than mutual defection.

## Strategy Overview: "Adaptive Parasite"

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit cooperative players.

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1-3)

**Purpose:** Gather information about opponent tendencies with minimal cost.

**Round 1:** DEFECT
- Rationale: Zero information available; defection is the dominant single-round strategy and reveals who cooperates unconditionally.

**Round 2:** DEFECT
- Observe round 1 cooperation rate (coop_rate_1 = cooperators / n)
- If coop_rate_1 ≥ 0.5, environment is exploitable; continue gathering data

**Round 3:** 
- If coop_rate_1 + coop_rate_2 averaged ≥ 0.4: DEFECT (exploit the cooperators)
- Otherwise: COOPERATE (one-time signal to test if conditional cooperators exist)

### Phase 2: Exploitation Phase (Rounds 4 to r-2)

**Classify each opponent based on their history:**

```
For each opponent j:
  - "Sucker": Cooperated ≥ 70% of rounds → Exploit freely
  - "Conditional": Cooperation correlates with group cooperation → Potential to manipulate
  - "Defector": Cooperated ≤ 30% of rounds → No value to extract
  - "Unpredictable": Otherwise → Monitor
```

**Decision Rule:**

```
sucker_count = count of "Sucker" opponents
conditional_count = count of "Conditional" opponents
expected_cooperators = sucker_count + (conditional_count × recent_coop_rate)

IF expected_cooperators ≥ (n-1) × 0.4:
    # Enough cooperators to free-ride on
    DEFECT
    
ELSE IF conditional_count ≥ (n-1) × 0.5 AND recent_coop_rate declining:
    # Conditionals are withdrawing; occasional cooperation might restart them
    # But only if the expected gain exceeds cost
    IF (probability of restarting cooperation wave) × (remaining_rounds) × (k/n) > 1:
        COOPERATE (with probability 0.3)
    ELSE:
        DEFECT
        
ELSE:
    # Low cooperation environment; pure defection optimal
    DEFECT
```

**Adaptive Threshold Adjustment:**
- Track the "cooperation elasticity": how much does group cooperation change when you cooperate vs defect?
- If your cooperation has minimal impact on others' behavior: always defect
- If your defection causes cascade of defections destroying future exploitation opportunities: occasionally cooperate to sustain the herd

### Phase 3: Endgame (Final 2 rounds)

**Round r-1:** DEFECT
- Backward induction begins; conditional cooperators likely to defect

**Round r (Final):** DEFECT
- No future to consider; dominant strategy

---

## Pseudocode Implementation

```python
def decide(round_num, total_rounds, n, k, history):
    # history[t] = list of n-1 opponent actions in round t (True=C, False=D)
    
    # ENDGAME: Always defect
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # PROBE PHASE
    if round_num <= 2:
        return DEFECT
    
    if round_num == 3:
        avg_coop = mean([sum(h)/(n-1) for h in history])
        if avg_coop >= 0.4:
            return DEFECT
        else:
            return COOPERATE  # One-time probe
    
    # EXPLOITATION PHASE
    opponent_profiles = classify_opponents(history)
    expected_coop = estimate_cooperators(opponent_profiles, history)
    
    # Core exploitation logic
    if expected_coop >= (n-1) * 0.35:
        # Sufficient cooperators to parasitize
        return DEFECT
    
    # Check if strategic cooperation could restart cooperation
    coop_trend = cooperation_trend(history, window=3)
    rounds_remaining = total_rounds - round_num
    
    if coop_trend < -0.1 and rounds_remaining > 3:
        # Cooperation collapsing; might need to reinvest
        restart_value = estimate_restart_value(opponent_profiles, rounds_remaining, k, n)
        if restart_value > 1.0 and random() < 0.25:
            return COOPERATE
    
    return DEFECT

def classify_opponents(history):
    profiles = []
    for j in range(n-1):
        coop_rate = mean([h[j] for h in history])
        if coop_rate >= 0.7:
            profiles.append("sucker")
        elif coop_rate <= 0.3:
            profiles.append("defector")
        else:
            profiles.append("conditional")
    return profiles
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | No information; dominant strategy |
| Final round | DEFECT | No future; dominant strategy |
| All opponents defecting | DEFECT | Nothing to exploit |
| All opponents cooperating | DEFECT | Maximum exploitation opportunity |
| Only 2 rounds total | DEFECT both | Too short for reputation building to pay off |
| Very high k (close to n) | Slightly more cooperative | Gains from mutual cooperation approach gains from exploitation |
| n very large | More defection | Individual impact negligible; free-ride |

---

## Why This Strategy is Exploitative

1. **Default stance is defection**: Only cooperates when it directly increases expected future exploitation returns

2. **Opponent classification**: Explicitly identifies "suckers" to parasitize and ignores reform attempts

3. **Strategic cooperation is investment, not reciprocity**: Any cooperation is calculated to maintain exploitable population, not for fairness

4. **Endgame defection**: No pretense of cooperation when exploitation has no future value

5. **Adapts to maximize extraction**: Against cooperative groups, defects heavily; against defectors, minimizes losses by also defecting
'''

description_EXPLOITATIVE_90 = '''
# Exploitative Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy aims to **maximize personal payoff by free-riding on cooperators while avoiding the collapse of cooperation entirely**. The key insight is that in this game, defection always yields a higher individual payoff than cooperation *given the same actions by others*. However, if everyone defects, we get the worst collective outcome. The exploitative approach is to:

1. Identify and exploit cooperative opponents
2. Defect whenever it's safe to do so
3. Only cooperate strategically to "farm" cooperators and prevent total collapse

---

## Strategy: "Adaptive Parasite"

### Decision Framework

#### Round 1: Defect
- **Rationale**: With no history, defection is strictly dominant for a single round. This also serves as a probe to identify which opponents are unconditional cooperators (easy targets) versus conditional cooperators.

#### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Rules:**

1. **If coop_rate ≥ 0.5 (majority cooperated):** **DEFECT**
   - There are enough cooperators to free-ride on
   - My defection won't collapse the system immediately
   - I capture maximum personal benefit

2. **If 0 < coop_rate < 0.5 (minority cooperated):** **CONDITIONAL DEFECT**
   - Calculate a "sustainability score" based on cooperation trend
   - If cooperation has been declining for 2+ consecutive rounds AND coop_rate < 0.3: **COOPERATE** (to prevent total collapse and keep farming viable)
   - Otherwise: **DEFECT** (still extracting value)

3. **If coop_rate = 0 (nobody cooperated):**
   - If this is the first time: **DEFECT** (test if others will restart)
   - If consecutive zero-cooperation rounds ≥ 2: **COOPERATE once** as a "probe" to see if conditional cooperators will restart
   - Then immediately return to defection if cooperation resumes

#### Last Round (round r): Always Defect
- **Rationale**: No future rounds mean no future consequences. Defection is strictly dominant.

---

### Detailed Pseudocode

```
function decide(round, history, n, k, r):
    
    # Last round: always defect
    if round == r:
        return DEFECT
    
    # First round: defect to probe
    if round == 1:
        return DEFECT
    
    # Calculate metrics from history
    prev_cooperators = count_cooperators(history, round - 1)
    coop_rate = prev_cooperators / n
    
    # Track cooperation trend (declining, stable, rising)
    if round >= 3:
        trend = calculate_trend(history, last_3_rounds)
        consecutive_zero = count_consecutive_zero_coop(history)
    else:
        trend = "unknown"
        consecutive_zero = 0
    
    # Main decision logic
    if coop_rate >= 0.5:
        # Plenty of cooperators to exploit
        return DEFECT
    
    elif coop_rate > 0:
        # Some cooperation exists
        if trend == "declining" AND coop_rate < 0.3 AND round < r - 2:
            # Cooperation collapsing - invest to sustain it
            return COOPERATE
        else:
            return DEFECT
    
    else:  # coop_rate == 0
        # Total defection
        if consecutive_zero >= 2 AND round < r - 3:
            # Probe to restart cooperation
            return COOPERATE
        else:
            return DEFECT
```

---

### Edge Case Handling

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| Round 1 | Defect | Probe opponents, no history to use |
| Round r (last) | Defect | No future consequences |
| Round r-1 (second to last) | Defect | Opponents likely to defect next round anyway |
| All opponents always cooperate | Always Defect | Maximum exploitation of "suckers" |
| All opponents always defect | Defect (with rare probes) | No benefit to cooperation; occasional probe in case of conditional cooperators |
| Mixed strategies observed | Adaptive defection | Free-ride when possible, sustain when necessary |

---

### Why This Strategy is Exploitative

1. **Free-rides maximally**: Defects whenever cooperation level is high enough to benefit from public goods without contributing

2. **Treats cooperation as investment, not virtue**: Only cooperates when it serves future exploitation (preventing collapse)

3. **Exploits cooperative opponents**: Unconditional cooperators are pure profit; conditional cooperators are managed to maximize extraction

4. **Never cooperates altruistically**: Every cooperation decision is calculated to yield higher future defection payoffs

5. **Endgame exploitation**: Guaranteed defection in final rounds when there's no strategic reason to cooperate

---

### Robustness Features

- **Adapts to any opponent mix**: Works against cooperators, defectors, and mixed strategies
- **Self-correcting**: If exploitation kills cooperation, it invests minimally to restart the cycle
- **Parameter-independent core logic**: Works for any valid n, k, r (though performance varies)
- **History-based**: Responds to actual opponent behavior, not assumptions
'''

description_EXPLOITATIVE_91 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round, but conditional cooperation can be exploited. I will appear cooperative enough to encourage others to cooperate, then strategically defect to harvest the benefits.

## Decision Rules

### Round Classification

Divide the game into three phases:
- **Early Phase**: Rounds 1 to ⌊r/3⌋
- **Middle Phase**: Rounds ⌊r/3⌋+1 to ⌊2r/3⌋
- **End Phase**: Rounds ⌊2r/3⌋+1 to r

### Tracking Metrics

After each round, calculate:
- `coop_rate` = (total cooperations by others in all previous rounds) / ((n-1) × rounds_played)
- `last_round_coop` = number of cooperators (excluding self) in the most recent round
- `trend` = cooperation rate in last 3 rounds minus cooperation rate in 3 rounds before that

### Decision Algorithm

```
ROUND 1:
    DEFECT
    (Rationale: Test the waters, collect free benefit from any cooperators)

LAST ROUND (round r):
    DEFECT
    (Rationale: No future consequences, pure dominant strategy)

SECOND-TO-LAST ROUND (round r-1):
    DEFECT
    (Rationale: Sophisticated opponents will defect in round r anyway)

EARLY PHASE (rounds 2 to ⌊r/3⌋):
    IF last_round_coop >= (n-1)/2 THEN:
        COOPERATE with probability 0.6, DEFECT with probability 0.4
    ELSE:
        DEFECT
    (Rationale: Build partial reputation, but exploit cooperative environments)

MIDDLE PHASE:
    IF coop_rate > 0.6 AND last_round_coop >= (n-1)/2 THEN:
        # Environment is cooperative - exploit it periodically
        IF (current_round mod 3) == 0 THEN:
            DEFECT  # Periodic exploitation
        ELSE:
            COOPERATE
    ELSE IF coop_rate > 0.3 THEN:
        # Mixed environment - mirror with defection bias
        IF last_round_coop >= n/2 THEN:
            COOPERATE with probability 0.4
        ELSE:
            DEFECT
    ELSE:
        # Low cooperation environment
        DEFECT
    (Rationale: Extract maximum value from cooperators while maintaining enough cooperation to keep them contributing)

END PHASE (except last 2 rounds):
    IF coop_rate > 0.5 AND trend > 0 THEN:
        # Others still cooperating and increasing - exploit harder
        DEFECT with probability 0.7
    ELSE:
        DEFECT
    (Rationale: Cooperation is ending anyway, harvest remaining value)
```

### Exploitation Triggers

Regardless of phase, immediately switch to DEFECT for the remainder of the game if:
- `coop_rate` drops below 0.2 after round 3
- Three consecutive rounds have zero cooperators (besides self)

### Opportunistic Cooperation

In middle phase only: If I defected last round AND `last_round_coop` was at least (n-1) × 0.7, cooperate once to "reset" my perceived reputation, then resume exploitation pattern.

## Summary of Key Properties

1. **Never cooperate in rounds 1, r-1, or r** - These are pure exploitation opportunities
2. **Probabilistic cooperation** - Makes my behavior harder to predict and punish
3. **Asymmetric response** - Cooperate less than the environment cooperation rate to always gain an edge
4. **Periodic defection** - Even in cooperative environments, defect every 3rd round in middle phase
5. **Endgame collapse** - Aggressively defect as the game ends
6. **Adaptive floor** - If cooperation collapses, don't waste resources trying to revive it

This strategy is designed to extract surplus from cooperators while avoiding being a "sucker" in defector-heavy environments.
'''

description_EXPLOITATIVE_91 = '''
# Exploitative Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting conditional cooperators requires appearing cooperative enough to keep them contributing.

## Strategy: "Adaptive Parasite"

### Decision Framework

The strategy maintains a **cooperation score** for the group and uses **threshold-based conditional defection** to exploit cooperative environments while protecting against exploitation.

---

### Pseudocode

```
PARAMETERS:
- exploitation_threshold = 0.5  # Minimum group cooperation rate to consider cooperating
- defection_buffer = 2          # Rounds before end to guarantee defection
- probe_frequency = max(1, floor(r/5))  # How often to test group with defection

INITIALIZE:
- round_number = 1
- group_cooperation_history = []

EACH ROUND:
    
    # RULE 1: Last rounds - always defect (no future to protect)
    if round_number > r - defection_buffer:
        return DEFECT
    
    # RULE 2: First round - defect to establish baseline and avoid sucker's payoff
    if round_number == 1:
        return DEFECT
    
    # Calculate group cooperation rate from previous round
    prev_cooperators = count(cooperators in round_number - 1, excluding self)
    prev_cooperation_rate = prev_cooperators / (n - 1)
    
    # Calculate historical average cooperation rate
    avg_cooperation_rate = mean(group_cooperation_history)
    
    # RULE 3: Probe rounds - periodically defect to test if group tolerates defection
    if round_number % probe_frequency == 0:
        return DEFECT
    
    # RULE 4: Exploit cooperative groups
    if prev_cooperation_rate >= exploitation_threshold:
        # Group is cooperative - calculate expected value
        
        # If I defect: I get 1 + (k/n) * expected_cooperators
        # If I cooperate: I get 0 + (k/n) * (expected_cooperators + 1)
        # Defection advantage = 1 - k/n (always positive since k < n)
        
        # However, if defection causes others to defect next round, we lose future value
        # Estimate punishment risk based on how cooperation changed after past defections
        
        if detected_punishment_pattern():
            # Group punishes defectors - cooperate to maintain their contributions
            return COOPERATE
        else:
            # Group tolerates defection - exploit freely
            return DEFECT
    
    # RULE 5: Uncooperative group - always defect
    else:
        return DEFECT

FUNCTION detected_punishment_pattern():
    # Look for correlation between my defections and subsequent group cooperation drops
    if len(history) < 3:
        return False
    
    my_defection_rounds = rounds where I defected
    cooperation_after_my_defection = avg cooperation rate in rounds following my defections
    cooperation_after_my_cooperation = avg cooperation rate in rounds following my cooperations
    
    # If cooperation drops significantly after I defect, group is punishing
    if cooperation_after_my_defection < cooperation_after_my_cooperation - 0.15:
        return True
    return False
```

---

## Decision Rules Summary

| Condition | Action | Rationale |
|-----------|--------|-----------|
| Last 2 rounds | DEFECT | No future retaliation possible |
| First round | DEFECT | Gather information, avoid sucker's payoff |
| Probe rounds (every r/5 rounds) | DEFECT | Test group's tolerance |
| High cooperation + punishment detected | COOPERATE | Maintain exploitable environment |
| High cooperation + no punishment | DEFECT | Free ride on cooperators |
| Low cooperation (<50%) | DEFECT | Nothing to lose |

---

## Edge Cases

1. **r = 2**: Defect both rounds (no room for reputation building)
2. **n = 2**: Becomes essentially a repeated Prisoner's Dilemma - defect unless opponent shows strong tit-for-tat behavior
3. **k very close to n**: Still defect by default, but lower threshold for cooperation (0.4 instead of 0.5)
4. **All opponents always cooperate**: Defect every round - maximum exploitation
5. **All opponents always defect**: Defect every round - no suckers here

---

## Why This Strategy is Exploitative

- **Never cooperates first** - avoids sucker's payoff
- **Systematically probes** for weakness in opponent strategies
- **Defects in endgame** when retaliation is impossible
- **Only cooperates when necessary** to maintain a profitable cooperative environment
- **Adapts to punishment** just enough to keep victims cooperating
'''

description_EXPLOITATIVE_92 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy is designed to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection always dominates cooperation in a single round—but exploiting cooperators requires them to *keep cooperating*. The strategy balances exploitation with just enough "false cooperation" to keep victims contributing.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit cooperative players.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Purpose:** Gather information about opponent types while minimizing exposure.

- **Round 1:** DEFECT
  - Rationale: Observe who cooperates unconditionally. These are prime exploitation targets. No information is lost by defecting first.

- **Rounds 2-3:** DEFECT
  - Continue observing. Track which players cooperate despite defection (naive cooperators) vs. those who retaliate (conditional cooperators).

### Phase 2: Exploitation Phase (Rounds 4 through r-2)

**Purpose:** Maximize extraction based on learned opponent behaviors.

**Calculate Cooperation Index (CI) each round:**
```
CI = (total cooperations observed in last 3 rounds) / (n × 3)
```

**Decision Rule:**

```
IF CI > 0.5:
    # Environment is cooperative-rich: DEFECT to exploit
    DEFECT
    
ELSE IF CI > 0.3:
    # Moderate cooperation: Occasional cooperation to "farm" cooperators
    IF (current_round mod 4 == 0):
        COOPERATE  # Periodic bait to maintain some cooperation
    ELSE:
        DEFECT
        
ELSE IF CI > 0.1:
    # Low cooperation: Environment is hostile
    # Only cooperate if it might restart cooperation cycles
    IF (my_last_3_actions == [D, D, D]) AND (random() < 0.2):
        COOPERATE  # Rare probe to test if opponents are waiting for signals
    ELSE:
        DEFECT
        
ELSE:
    # Near-zero cooperation: Full defection mode
    DEFECT
```

**Opponent-Specific Tracking:**

Maintain a "sucker score" for each opponent:
```
sucker_score[j] = (times j cooperated when I defected) / (rounds played)
```

If `average(sucker_score) > 0.4`, the population is highly exploitable—**always DEFECT**.

### Phase 3: Endgame (Final 2 rounds)

**Purpose:** Extract remaining value with no future consequences.

- **Round r-1:** DEFECT
  - No reason to cooperate; opponents may still cooperate hoping to influence final round.

- **Round r:** DEFECT
  - Pure Nash equilibrium play. Cooperation has zero strategic value.

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| **First round** | DEFECT | Gather intel; no history to leverage |
| **Last round** | DEFECT | No future; dominant strategy |
| **Second-to-last round** | DEFECT | Opponents can't punish in final round |
| **All opponents defected last 3 rounds** | DEFECT | No value in unilateral cooperation |
| **n = 2 (minimum players)** | Always DEFECT except rare probes | Game is essentially Prisoner's Dilemma; defection dominates |
| **k close to n** | More willing to probe with cooperation | Higher returns make cooperation bait cheaper |
| **k close to 1** | Heavy defection bias | Low public good multiplier means exploitation is low-cost |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    
    # Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase: defect to observe
    if round <= 3:
        return DEFECT
    
    # Calculate cooperation index from last 3 rounds
    recent_coops = count_cooperations(history, last_rounds=3)
    CI = recent_coops / (n * 3)
    
    # Calculate exploitability
    sucker_avg = average_sucker_score(history)
    
    # Highly exploitable population
    if sucker_avg > 0.4:
        return DEFECT
    
    # Exploitation phase decisions
    if CI > 0.5:
        return DEFECT  # Rich pickings
    elif CI > 0.3:
        if round % 4 == 0:
            return COOPERATE  # Farming bait
        return DEFECT
    elif CI > 0.1:
        if last_3_actions_all_defect() and random() < 0.2:
            return COOPERATE  # Rare probe
        return DEFECT
    else:
        return DEFECT  # Barren landscape
```

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** — All cooperation is strategic bait
2. **Exploits information asymmetry** — Learns opponent types while revealing little
3. **Targets naive cooperators** — Tracks and farms players who cooperate despite defection
4. **Endgame extraction** — Guaranteed defection when punishment is impossible
5. **Adaptive exploitation intensity** — Defects more aggressively when environment permits

This strategy treats cooperation purely as a tool for maintaining exploitable conditions, not as a reciprocal norm.
'''

description_EXPLOITATIVE_92 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**, and to **appear just cooperative enough to sustain exploitation without triggering retaliation**.

## Strategy Overview

The strategy operates in three phases and continuously estimates the "exploitability" of the player pool based on observed cooperation rates.

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: Defecting in round 1 is strictly dominant in a single-shot game. We sacrifice nothing by defecting first, and we gain crucial information about opponent tendencies without risk.

**Round 2: Conditional**
- If cooperation rate in round 1 was ≥ 50%: **COOPERATE** (to test if cooperation is sustainable and avoid being identified as a pure defector)
- If cooperation rate in round 1 was < 50%: **DEFECT** (the pool is already defection-heavy; no point cooperating)

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **rolling cooperation rate** (α) over the last 3 rounds (excluding own actions):

```
α = (total cooperations by others in last 3 rounds) / ((n-1) × 3)
```

**Decision Rule:**
```
If α ≥ threshold(t):
    DEFECT with probability p_defect(α)
    COOPERATE with probability 1 - p_defect(α)
Else:
    DEFECT
```

**Threshold and Probability Functions:**
```
threshold(t) = 0.4 + 0.1 × (t / r)  
# Gets stricter as game progresses; early exploitation is safer

p_defect(α) = min(0.9, 0.5 + 0.5 × α)
# Higher cooperation → more aggressive defection
# Cap at 90% to occasionally cooperate and avoid being "marked"
```

**Exploitation Logic:**
- When others cooperate heavily (α high), defect most of the time to free-ride
- Occasionally cooperate (10-50% of the time) to:
  - Avoid being identified as a pure defector by pattern-matching strategies
  - Maintain some cooperation in the pool to sustain future exploitation
- When cooperation collapses (α low), defect always—no value to extract

### Phase 3: Endgame (Last 2 Rounds: r-1 and r)

**Rounds r-1 and r: DEFECT unconditionally**

- Rationale: In the final rounds, there's no future to protect. Backward induction makes defection dominant. Any cooperator in these rounds is simply giving away money.

---

## Adaptive Exploitation Mechanics

### Detecting "Suckers" (Unconditional Cooperators)

Track individual player histories when possible. If any player has cooperated ≥ 80% of the time over 5+ rounds:
- They are likely unconditional cooperators or slow learners
- **Increase defection probability by 10%** when such players exist
- These players subsidize our defection indefinitely

### Detecting Retaliators

If our cooperation rate is significantly lower than the group average AND group cooperation is declining:
- We may be triggering retaliation
- **Temporarily increase cooperation probability by 20% for 2 rounds**
- Then return to exploitation if cooperation recovers

### Responding to All-Defect Environments

If α < 0.2 for 3 consecutive rounds:
- Lock into **permanent defection** for remaining rounds
- No value can be extracted from a collapsed commons

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    # Round 1: always defect (probe)
    if round == 1:
        return DEFECT
    
    # Round 2: conditional probe
    if round == 2:
        if cooperation_rate(history, round-1) >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Main phase: exploitation
    α = rolling_cooperation_rate(history, last_3_rounds, exclude_self=True)
    
    # Check for collapsed commons
    if α < 0.2 for last 3 rounds:
        return DEFECT
    
    # Calculate exploitation parameters
    threshold = 0.4 + 0.1 * (round / r)
    
    if α >= threshold:
        p_defect = min(0.9, 0.5 + 0.5 * α)
        # Check for unconditional cooperators - boost exploitation
        if count_suckers(history) > 0:
            p_defect = min(0.95, p_defect + 0.10)
        return DEFECT with probability p_defect, else COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Avoids being exploited in round 1
2. **Free-rides on cooperators** - Defects more when others cooperate more
3. **Identifies and exploits "suckers"** - Tracks unconditional cooperators
4. **Endgame defection** - Takes everything possible when future doesn't matter
5. **Probabilistic camouflage** - Occasional cooperation prevents easy detection
6. **Adaptive to environment** - Doesn't waste cooperation in hostile pools

---

## Edge Cases Handled

| Situation | Response |
|-----------|----------|
| First round | Defect (information gathering) |
| Last 2 rounds | Defect (no future retaliation possible) |
| All opponents defect | Permanent defection |
| All opponents cooperate | Heavy defection (85-95%) with occasional cooperation |
| Mixed environment | Calibrated exploitation based on cooperation rate |
| n=2 (minimum players) | Strategy still works; α calculated from single opponent |
| Very short games (r=3) | Essentially defect throughout (endgame covers most rounds) |
'''

description_EXPLOITATIVE_93 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by:
1. **Detecting and exploiting cooperators** - extracting maximum value from naive or unconditional cooperators
2. **Avoiding mutual defection traps** - conditionally cooperating when others are cooperative enough to make it profitable
3. **Endgame exploitation** - defecting when future retaliation is impossible or limited

## Key Insight

Since k < n, defection is always the dominant strategy in a single round (you gain 1 from keeping, but only get back k/n < 1 from your own contribution). However, sustained mutual cooperation yields k > 1 per player, which beats mutual defection. The exploitative approach is to **free-ride on others' cooperation while defecting yourself**.

---

## Decision Rules

### Round Classification

```
early_game = rounds 1 to floor(r/2)
mid_game = rounds floor(r/2)+1 to r-2
end_game = rounds r-1 and r
```

### Primary Decision Logic

```
function decide(round_number, history):
    
    # RULE 1: Last Round - Always Defect
    if round_number == r:
        return DEFECT
    
    # RULE 2: Second-to-Last Round - Almost Always Defect
    if round_number == r - 1:
        # Only cooperate if cooperation rate is extremely high (>90%)
        # and we want to milk one more round of their cooperation
        if cooperation_rate(history) > 0.9:
            return COOPERATE
        return DEFECT
    
    # RULE 3: First Round - Defect
    if round_number == 1:
        return DEFECT
    
    # RULE 4: Adaptive Exploitation
    coop_rate = cooperation_rate(history)
    my_defection_advantage = calculate_exploitation_value(history)
    
    # If others are highly cooperative (>70%), exploit them
    if coop_rate > 0.7:
        return DEFECT
    
    # If others are moderately cooperative (40-70%), use probabilistic defection
    if coop_rate >= 0.4 and coop_rate <= 0.7:
        # Defect more often as we approach endgame
        defect_probability = 0.6 + 0.3 * (round_number / r)
        return DEFECT with probability defect_probability
        return COOPERATE otherwise
    
    # If others are mostly defecting (<40%), check if conditional cooperators exist
    if coop_rate < 0.4:
        # Try occasional cooperation to test for conditional cooperators
        if round_number % 3 == 0 and round_number < r - 3:
            return COOPERATE  # Probe round
        return DEFECT
```

### Helper Functions

```
function cooperation_rate(history):
    if history is empty:
        return 0.5  # neutral assumption
    
    total_actions = sum of all players' actions across all rounds
    total_cooperations = count of C actions
    return total_cooperations / total_actions

function calculate_exploitation_value(history):
    # Calculate how much we've gained by defecting when others cooperated
    # Higher values suggest others are exploitable
    
    my_defections_when_others_cooperated = count rounds where:
        - I played D
        - At least 50% of others played C
    
    return my_defections_when_others_cooperated / total_rounds_played
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | No history to analyze; test opponents' reactions |
| Round r (final) | DEFECT | No future punishment possible |
| Round r-1 | DEFECT (usually) | Limited retaliation window |
| All others defecting | DEFECT | No benefit to cooperating |
| All others cooperating | DEFECT | Maximum exploitation opportunity |
| n = 2 | More aggressive defection | Easier to track single opponent |
| Very high k (close to n) | Slightly more cooperation | Mutual cooperation more valuable |
| Very low k (close to 1) | Almost always defect | Cooperation barely beneficial |

---

## Parameter Adaptations

```
function adjust_for_parameters(base_decision, n, k, r):
    
    exploitation_factor = (n - k) / n  # Higher = defection more advantageous
    
    # With more players, individual defection is less noticeable
    if n > 10:
        bias toward DEFECT increases by 10%
    
    # With fewer rounds, endgame mentality starts earlier
    if r < 10:
        treat round (r-3) as endgame
    
    # If k is very close to n, cooperation is almost self-sustaining
    if k > 0.9 * n:
        reduce defection probability by 20%
```

---

## Summary: Why This Strategy is Exploitative

1. **Defaults to defection** - The baseline assumption is to defect unless cooperation is strategically valuable
2. **Free-rides on cooperators** - Actively seeks to defect when others cooperate
3. **Endgame exploitation** - Guarantees defection when punishment is impossible
4. **Probes for weakness** - Uses occasional cooperation to identify exploitable conditional cooperators
5. **Never fully commits to cooperation** - Even in "cooperative" states, maintains probabilistic defection

This strategy treats other players as resources to be exploited rather than partners to coordinate with.
'''

description_EXPLOITATIVE_93 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in this game, defection always yields a higher individual payoff than cooperation *given the same actions by others*. Therefore, the optimal exploitative approach is to defect as much as possible while occasionally "testing" for exploitable cooperators.

## Strategy Overview

The strategy operates in three phases:
1. **Probe Phase**: Initial rounds to classify opponent population
2. **Exploit Phase**: Milk cooperative populations while they last
3. **Endgame Phase**: Pure defection when cooperation cannot be sustained

---

## Detailed Decision Rules

### Round 1: Initial Probe
**Action: DEFECT**

Rationale: Never cooperate on round 1. This:
- Captures maximum payoff if others cooperate
- Loses nothing if others defect
- Provides baseline data on population cooperativeness

### Rounds 2 through (r-2): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays by others in previous round) / (n - 1)
```

Calculate the **trend** (cooperation rate change):
```
trend = current_coop_rate - previous_coop_rate
```

**Decision Logic:**

```
IF coop_rate >= threshold_high AND trend >= 0:
    # Population is highly cooperative and stable/growing
    # Defect to exploit them maximally
    ACTION = DEFECT

ELSE IF coop_rate >= threshold_medium AND trend > 0:
    # Cooperation is recovering - throw them a bone to sustain it
    # Cooperate occasionally to keep the gravy train running
    ACTION = COOPERATE with probability p_bait
    
ELSE IF coop_rate >= threshold_low AND trend < -0.2:
    # Cooperation is collapsing rapidly
    # Defect - no point cooperating in a dying system
    ACTION = DEFECT

ELSE IF coop_rate < threshold_low:
    # Population is mostly defectors
    # Defect - cooperating loses money
    ACTION = DEFECT

ELSE:
    # Moderate cooperation, unclear trend
    # Strategic defection with occasional cooperation to probe
    ACTION = DEFECT with probability 0.85
```

**Parameter Settings (calibrated to game parameters):**
```
threshold_high = 0.6
threshold_medium = 0.4  
threshold_low = 0.25
p_bait = 0.3  # Probability of "baiting" cooperation to sustain exploitable population
```

### Final 2 Rounds (rounds r-1 and r): Endgame
**Action: DEFECT (always)**

Rationale: 
- No future rounds to benefit from sustained cooperation
- Backward induction makes cooperation irrational
- Opponents using reciprocal strategies cannot punish final defection

---

## Handling Edge Cases

### Small n (n = 2 or 3)
- Increase `threshold_high` to 0.8
- Reduce `p_bait` to 0.15
- Rationale: Individual actions more detectable; be more cautious about revealing exploitative intent

### Large n (n ≥ 10)
- Decrease `threshold_medium` to 0.3
- Increase `p_bait` to 0.4
- Rationale: Individual defection less noticeable; can afford more frequent "camouflage" cooperation

### High k (k close to n)
- If k > n-1: Consider more cooperation (social optimum nearly aligns with individual)
- Keep strategy mostly intact but increase `p_bait` slightly

### Short games (r ≤ 5)
- Extend endgame phase to final 40% of rounds
- Be more aggressive with early defection

### Long games (r > 20)
- First 3 rounds are probe phase (alternate D, D, C)
- More patience in exploit phase
- Endgame only final round

---

## Pseudocode Summary

```python
def adaptive_predator(round_num, total_rounds, n, k, history):
    
    # Endgame: always defect
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # Round 1: defect to probe
    if round_num == 1:
        return DEFECT
    
    # Calculate metrics
    others_last_round = history[round_num - 1].others_actions
    coop_rate = count(others_last_round, C) / (n - 1)
    
    if round_num >= 3:
        prev_others = history[round_num - 2].others_actions
        prev_coop_rate = count(prev_others, C) / (n - 1)
        trend = coop_rate - prev_coop_rate
    else:
        trend = 0
    
    # Exploitation logic
    if coop_rate >= 0.6 and trend >= 0:
        return DEFECT  # Exploit stable cooperators
    
    if coop_rate >= 0.4 and trend > 0:
        return COOPERATE if random() < 0.3 else DEFECT  # Sustain exploitation
    
    if coop_rate < 0.25:
        return DEFECT  # Don't throw money away
    
    # Default: mostly defect with occasional probe
    return COOPERATE if random() < 0.15 else DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** in round 1 - captures free-rider gains immediately
2. **Defects against cooperators** - extracts maximum value from altruistic opponents
3. **Occasional cooperation is bait** - sustains exploitable populations, not genuine reciprocity
4. **Abandons all pretense in endgame** - pure selfishness when punishment is impossible
5. **Adapts to exploit different populations** - milks cooperators, doesn't waste resources on defector-heavy groups
'''

description_EXPLOITATIVE_94 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by others is highly profitable to exploit. My goal is to:

1. Identify and exploit cooperative opponents for as long as possible
2. Defect strategically to maximize my share of any public good created
3. Avoid being the "sucker" who cooperates while others defect
4. Adjust aggression based on how exploitable the population appears

---

## Decision Rules

### Round 1: Defect
**Rationale:** Opening with defection is pure information gathering at no strategic cost. If others cooperate, I profit maximally. If others defect, I lose nothing. There's no trust to build yet, and I learn the cooperation baseline.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / n
```

Calculate my **exploitation threshold** that adapts over time:
```
base_threshold = 0.6
time_pressure = (current_round / r) * 0.3
exploitation_threshold = base_threshold - time_pressure
```

**Decision Logic:**

```
IF coop_rate >= exploitation_threshold:
    # Environment is cooperative enough to exploit
    DEFECT (free-ride on cooperators)
    
ELSE IF coop_rate >= 0.3 AND coop_rate < exploitation_threshold:
    # Cooperation is declining - consider "baiting"
    IF I defected last round AND coop_rate dropped significantly (>15%):
        # My defection may have triggered decline - cooperate once to restore
        COOPERATE (bait cooperation back)
    ELSE:
        DEFECT
        
ELSE IF coop_rate < 0.3:
    # Low cooperation environment - mutual defection likely
    # Occasionally probe to see if cooperation can be restored
    IF (current_round mod 3 == 0):
        COOPERATE (probe for latent cooperators)
    ELSE:
        DEFECT
```

### Last Round (Round r): Always Defect
**Rationale:** No future exists to incentivize cooperation. Pure Nash equilibrium logic applies. Defection strictly dominates.

---

## Detailed Mechanism: The "Bait and Bleed" Cycle

When cooperation is moderate (30-60%), I employ a **bait and bleed** pattern:

1. **Bleed Phase (default):** Defect while others cooperate, extracting (k/n) × cooperators
2. **Bait Phase (triggered):** If my defection appears to have crashed cooperation, make a single cooperative move to signal "I can cooperate" and potentially restore others' cooperation
3. **Return to Bleed:** Once cooperation recovers, immediately resume defection

```
bait_trigger = (last_round_coop_rate - current_coop_rate) > 0.15 
               AND my_last_action == DEFECT
               AND current_coop_rate > 0.2
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | Defect | Risk-free information gathering |
| Round r (final) | Defect | No future punishment possible |
| All others always cooperate | Always Defect | Maximum exploitation of naive cooperators |
| All others always defect | Mostly Defect (probe occasionally) | No point cooperating; rare probes check for conditional cooperators |
| n = 2 (two players) | Defect heavily, minimal baiting | Easier for opponent to attribute my defection; less benefit from public good |
| High k (close to n) | Slightly more willing to bait | Public good is more valuable, worth occasional investment |
| Low k (close to 1) | Pure defection | Public good barely worth creating |

---

## Parameter Sensitivity

```
aggression_modifier = (n - k) / (n - 1)
# Higher when k is low relative to n (defection more advantageous)
# Lower when k approaches n (cooperation more valuable)

# Adjust exploitation_threshold:
adjusted_threshold = exploitation_threshold * (1 + 0.2 * aggression_modifier)
```

---

## Summary Pseudocode

```python
def decide(round, total_rounds, n, k, history):
    if round == 1:
        return DEFECT
    
    if round == total_rounds:
        return DEFECT
    
    coop_rate = count_cooperators(history[-1]) / n
    prev_coop_rate = count_cooperators(history[-2]) / n if round > 2 else coop_rate
    my_last_action = get_my_last_action(history)
    
    time_pressure = round / total_rounds
    exploitation_threshold = 0.6 - (time_pressure * 0.3)
    aggression = (n - k) / (n - 1)
    exploitation_threshold *= (1 + 0.2 * aggression)
    
    if coop_rate >= exploitation_threshold:
        return DEFECT  # Exploit cooperative environment
    
    if coop_rate >= 0.3:
        coop_drop = prev_coop_rate - coop_rate
        if my_last_action == DEFECT and coop_drop > 0.15:
            return COOPERATE  # Bait
        return DEFECT
    
    # Low cooperation environment
    if round % 3 == 0:
        return COOPERATE  # Probe
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates when it can free-ride** on sufficient cooperation
2. **Uses cooperation as a tool** (baiting) rather than genuine reciprocity
3. **Assumes the worst** about the final round and opening round
4. **Adapts to maximize extraction** - cooperates only to restore an exploitable environment
5. **Treats cooperative opponents as resources** to be harvested, not partners
'''

description_EXPLOITATIVE_94 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but cooperative environments can be milked for profit. The strategy seeks to identify and exploit "suckers" (consistent cooperators) while quickly abandoning cooperation when facing rational defectors.

## Strategy Overview

The strategy operates in three phases based on game progression and adapts based on observed cooperation levels in the population.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** DEFECT
- Rationale: Gather information at no risk. If others cooperate, we profit maximally. If others defect, we lose nothing compared to cooperating.

**Round 2:** DEFECT
- Rationale: Confirm Round 1 patterns. Two rounds of data helps distinguish "always cooperate" players from conditional cooperators.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of C plays by others) / (n - 1)
```

**Decision Rule:**

```
IF coop_rate >= exploitation_threshold THEN:
    COOPERATE (with probability = coop_rate - margin)
ELSE:
    DEFECT
```

Where:
- `exploitation_threshold = 0.6` (only cooperate if environment is cooperative enough)
- `margin = 0.2` (always cooperate slightly less than the population to gain edge)
- Minimum cooperation probability is 0, maximum is `coop_rate - margin`

**Refined Logic:**

```
IF coop_rate >= 0.8:
    # Highly cooperative environment - exploit by occasional defection
    COOPERATE with probability 0.7
    
ELIF coop_rate >= 0.6:
    # Moderately cooperative - match reduced cooperation
    COOPERATE with probability 0.5
    
ELIF coop_rate >= 0.4:
    # Mixed environment - lean toward defection
    COOPERATE with probability 0.2
    
ELSE:
    # Low cooperation - pure defection
    DEFECT
```

### Phase 3: Endgame (Final 2 rounds, rounds r-1 and r)

**Round r-1:** DEFECT
- Rationale: Begin extracting value. Many strategies will still cooperate hoping to maintain relationships.

**Round r (Final Round):** DEFECT
- Rationale: No future consequences. Defection is strictly dominant.

---

## Adaptive Mechanisms

### Trend Detection

Track cooperation trends over a 3-round window:
```
IF cooperation_rate is DECREASING for 2+ consecutive rounds:
    Shift to pure DEFECTION immediately
    (Environment is collapsing - get out early)

IF cooperation_rate is INCREASING:
    Slightly increase cooperation probability by 0.1
    (But never exceed coop_rate - 0.1)
```

### Sucker Detection

Track individual player histories when possible:
```
FOR each opponent j:
    IF player j has cooperated in ALL observed rounds:
        Mark as "exploitable"
        
IF (number of exploitable players) / (n-1) >= 0.3:
    Reduce own cooperation probability by additional 0.15
    (More suckers to exploit)
```

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    IF round >= r - 1:
        RETURN DEFECT
    
    # Probing phase
    IF round <= 2:
        RETURN DEFECT
    
    # Calculate metrics
    others_coop_last_round = count_cooperators(history, round-1) - my_action(round-1)
    coop_rate = others_coop_last_round / (n - 1)
    trend = calculate_trend(history, window=3)
    
    # Collapsing environment
    IF trend == DECREASING:
        RETURN DEFECT
    
    # Exploitation logic
    IF coop_rate >= 0.8:
        RETURN COOPERATE with prob 0.7
    ELIF coop_rate >= 0.6:
        RETURN COOPERATE with prob 0.5
    ELIF coop_rate >= 0.4:
        RETURN COOPERATE with prob 0.2
    ELSE:
        RETURN DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-rides on information**: Defects early to learn about others without personal cost
2. **Asymmetric response**: Always cooperates *less* than the observed rate, capturing surplus
3. **Exploits cooperators**: High cooperation environments are milked, not matched
4. **Early exit**: Detects declining cooperation and defects before others
5. **Endgame extraction**: Guaranteed defection in final rounds captures maximum value
6. **No sentimentality**: No attempt to "build" cooperation or punish defectors (punishment is costly)

This strategy is designed to perform well against naive cooperators, tit-for-tat variants, and random strategies, while limiting losses against pure defectors.
'''

description_EXPLOITATIVE_95 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

This strategy aims to **maximize personal gain by free-riding on cooperators while avoiding retaliation costs**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but sustained cooperation by others creates exploitable value. I want to:

1. Detect and exploit unconditional cooperators
2. Appear cooperative enough to sustain conditional cooperators when beneficial
3. Defect aggressively when punishment is unlikely or the game is ending

---

## Decision Rules

### Round 1: Probe with Defection

**Action: DEFECT**

Rationale: This reveals information about opponent types without sacrificing much. If others cooperate anyway, I've successfully free-ridden. If others defect, I've lost nothing compared to cooperating.

---

### Middle Rounds (2 to r-1): Adaptive Exploitation

Calculate two metrics from the previous round:

1. **Cooperation Rate (CR)** = (number of cooperators) / (n - 1) among opponents
2. **Trend** = CR(current) - CR(previous), or 0 if round 2

**Decision Logic:**

```
IF CR >= 0.6 AND Trend >= 0:
    # High cooperation, stable or rising - EXPLOIT
    ACTION = DEFECT
    
ELIF CR >= 0.4 AND CR < 0.6:
    # Moderate cooperation - CONDITIONAL MIMICRY
    # Cooperate occasionally to sustain the pool, but mostly defect
    IF my_previous_action == DEFECT AND rounds_defected_consecutively >= 2:
        ACTION = COOPERATE  # Token contribution to prevent collapse
    ELSE:
        ACTION = DEFECT

ELIF CR < 0.4 AND CR > 0.15:
    # Low cooperation - OPPORTUNISTIC
    # Match the low cooperation to avoid being the sucker
    ACTION = DEFECT

ELIF CR <= 0.15:
    # Near-universal defection - PROBE FOR REVIVAL
    # Occasionally test if cooperation can restart (cheap probe)
    IF round_number % 3 == 0:
        ACTION = COOPERATE
    ELSE:
        ACTION = DEFECT
```

### Last Round (r): Always Defect

**Action: DEFECT**

Rationale: No future punishment is possible. This is the dominant strategy regardless of history.

---

### Refinement: Detecting Exploitable Patterns

Track individual opponent histories when possible:

- **Unconditional Cooperators**: Players who cooperated in 80%+ of rounds → these are safe to exploit indefinitely
- **Tit-for-Tat types**: Players whose cooperation correlates with group cooperation → maintain minimal cooperation to keep them contributing
- **Unconditional Defectors**: Ignore them; they don't affect my strategy

**Adjustment**: If I detect 2+ unconditional cooperators, **always defect** in middle rounds—their contributions provide reliable public good returns without my input.

---

## Endgame Acceleration

In the final 20% of rounds (or last 2 rounds if r ≤ 10):

**Bias heavily toward DEFECT** regardless of cooperation rates. The shadow of the future is too short for retaliation to matter.

```
IF rounds_remaining <= max(2, 0.2 * r):
    ACTION = DEFECT
```

---

## Summary Pseudocode

```
function choose_action(round, history, n, k, r):
    
    rounds_remaining = r - round
    
    # Last round or endgame
    IF round == r OR rounds_remaining <= max(2, 0.2 * r):
        RETURN DEFECT
    
    # First round
    IF round == 1:
        RETURN DEFECT
    
    # Calculate cooperation rate among opponents last round
    CR = count_cooperators_last_round(history) / (n - 1)
    
    # Check for unconditional cooperators (80%+ cooperation rate)
    unconditional_coops = count_players_with_coop_rate_above(history, 0.8)
    IF unconditional_coops >= 2:
        RETURN DEFECT
    
    # Adaptive middle-game
    IF CR >= 0.6:
        RETURN DEFECT  # Exploit high cooperation
    ELIF CR >= 0.4:
        IF consecutive_defections(my_history) >= 2:
            RETURN COOPERATE  # Token contribution
        ELSE:
            RETURN DEFECT
    ELIF CR > 0.15:
        RETURN DEFECT
    ELSE:
        IF round % 3 == 0:
            RETURN COOPERATE  # Probe
        ELSE:
            RETURN DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** — always lets others bear the cost of public goods creation
2. **Free-rides on cooperators** — defects most when cooperation is highest
3. **Minimal investment** — cooperates only enough to prevent total collapse when it benefits me
4. **Endgame defection** — extracts maximum value when punishment is impossible
5. **Targets suckers** — explicitly detects and exploits unconditional cooperators
'''

description_EXPLOITATIVE_95 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal gain by exploiting cooperators while minimizing losses from mutual defection**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by *others* is profitable for me. I want to:

1. Identify and exploit "cooperative" environments
2. Defect reliably when others are likely to defect anyway
3. Appear just cooperative enough to not trigger retaliation in populations that punish defectors

---

## Strategy Specification

### Key Variables Tracked

- `coop_rate[t]`: Proportion of other players who cooperated in round t
- `avg_coop_rate`: Rolling average cooperation rate of others across all past rounds
- `rounds_remaining`: r - current_round
- `my_history`: My past actions

### Decision Rules

#### Round 1: Defect
**Rationale**: No information exists. Defection is the dominant single-round strategy. Starting with defection also allows me to observe others' baseline behavior without contributing.

#### Last Round (round r): Always Defect
**Rationale**: No future retaliation possible. Pure Nash equilibrium logic applies.

#### Penultimate Round (round r-1): Defect
**Rationale**: Sophisticated opponents will defect in the last round regardless, so there's no cooperation to preserve. Begin the endgame defection early.

#### Middle Rounds (rounds 2 through r-2):

```
Calculate: avg_coop_rate = (sum of cooperation rates from rounds 1 to t-1) / (t-1)

IF avg_coop_rate >= 0.6:
    # Highly cooperative environment - EXPLOIT IT
    DEFECT (free-ride on cooperators)
    
ELIF avg_coop_rate >= 0.35:
    # Moderate cooperation - conditional mimicry to sustain exploitation
    IF coop_rate[t-1] >= 0.5:
        # Others are cooperating - defect to exploit
        DEFECT
    ELSE:
        # Cooperation declining - cooperate once to "reset" reciprocators
        # But only if we've defected the last 2+ rounds
        IF my last 2 actions were both DEFECT:
            COOPERATE (bait move)
        ELSE:
            DEFECT
            
ELIF avg_coop_rate < 0.35:
    # Low cooperation environment - no one to exploit
    DEFECT (don't be the sucker)
```

### Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Defect | No information, dominant strategy |
| Round 2 | Follow middle-round rules with t-1=1 | Single observation, proceed cautiously |
| Rounds r-1 and r | Defect | Endgame - no future consequences |
| n = 2 | Always Defect | Easier for opponent to track and punish; safer to defect throughout |
| Very short games (r ≤ 3) | Always Defect | Not enough rounds for reputation effects |
| k very close to n | Still follow rules | Temptation to defect remains since k < n |

### Pseudocode Summary

```python
def decide(round, n, r, k, history_others, my_history):
    # Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    # Round 1: defect to observe
    if round == 1:
        return DEFECT
    
    # Very short games: always defect
    if r <= 3:
        return DEFECT
    
    # Two-player games: always defect (too exposed)
    if n == 2:
        return DEFECT
    
    # Calculate cooperation metrics
    avg_coop = mean(cooperation_rate(history_others))
    last_coop = cooperation_rate(history_others[round-1])
    
    # High cooperation: exploit freely
    if avg_coop >= 0.6:
        return DEFECT
    
    # Moderate cooperation: selective exploitation with occasional bait
    if avg_coop >= 0.35:
        if last_coop >= 0.5:
            return DEFECT
        elif last_two_moves(my_history) == [DEFECT, DEFECT]:
            return COOPERATE  # Bait to sustain cooperation
        else:
            return DEFECT
    
    # Low cooperation: nothing to exploit
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates in exploitable positions**: Endgame defection is guaranteed
2. **Free-rides on cooperative groups**: High cooperation triggers pure defection
3. **Baits reciprocators**: Occasional cooperation keeps conditional cooperators contributing
4. **Minimizes sucker payoffs**: Never cooperates in low-cooperation environments
5. **Assumes no shared norms**: Doesn't rely on others following the same strategy

The strategy treats cooperation purely as a tool for manipulation, not as a value in itself.
'''

description_EXPLOITATIVE_96 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but exploiting cooperators yields even higher returns. The strategy dynamically estimates the "cooperativeness" of the population and adjusts behavior to milk cooperative environments while protecting against exploitation.

---

## Strategy Specification

### Key Variables Tracked

- `coop_rate[t]`: Proportion of other players who cooperated in round t
- `avg_coop_rate`: Running average cooperation rate of opponents
- `trend`: Whether cooperation is increasing, stable, or declining
- `rounds_remaining`: r - current_round

### Decision Rules

#### Round 1: Defect
**Rationale**: No information available. Defection is the dominant single-round strategy and reveals nothing about our intentions while we gather data.

```
if round == 1:
    return DEFECT
```

#### Last Round: Always Defect
**Rationale**: No future rounds to incentivize cooperation from others. Pure exploitation opportunity.

```
if round == r:
    return DEFECT
```

#### Penultimate Round (Round r-1): Defect
**Rationale**: Sophisticated opponents will defect in round r regardless, so there's no cooperation to preserve.

```
if round == r - 1:
    return DEFECT
```

#### Middle Rounds (2 to r-2): Adaptive Exploitation

Calculate the **exploitation threshold** based on when cooperation becomes profitable to fake:

```
exploitation_threshold = (n - k) / (k * (rounds_remaining - 1))
```

**Logic**: Cooperate only if:
1. The cooperation rate is high enough that we benefit significantly from the public good
2. Our cooperation might sustain future cooperation we can later exploit
3. We're not too close to the end

```
if round >= 2 and round <= r - 2:
    
    # Calculate opponent cooperation rate from last round
    coop_rate = (total_cooperators_last_round) / (n - 1)
    
    # Update running average (exponential moving average, α = 0.4)
    avg_coop_rate = 0.4 * coop_rate + 0.6 * avg_coop_rate
    
    # Calculate trend (positive = increasing cooperation)
    trend = coop_rate - previous_coop_rate
    
    # EXPLOITATION DECISION MATRIX
    
    # High cooperation environment (>60% cooperating): Defect to exploit
    if avg_coop_rate > 0.6:
        return DEFECT
    
    # Medium cooperation (30-60%): Conditional cooperation to sustain the pool
    elif avg_coop_rate >= 0.3:
        # Cooperate only if trend is positive (cooperation rising)
        # AND we have enough rounds left to benefit
        if trend >= 0 and rounds_remaining > 3:
            return COOPERATE
        else:
            return DEFECT
    
    # Low cooperation (<30%): Defect, nothing worth sustaining
    else:
        return DEFECT
```

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Edge cases
    if round == 1: return DEFECT
    if round >= r - 1: return DEFECT
    
    # Calculate metrics
    last_round_coops = count_cooperators(history[round-1]) - my_action(history[round-1])
    coop_rate = last_round_coops / (n - 1)
    avg_coop_rate = exponential_average(all_coop_rates, alpha=0.4)
    trend = coop_rate - previous_coop_rate
    rounds_remaining = r - round
    
    # Exploitation logic
    if avg_coop_rate > 0.6:
        return DEFECT  # Exploit the cooperators
    elif avg_coop_rate >= 0.3:
        if trend >= 0 and rounds_remaining > 3:
            return COOPERATE  # Sustain the pool for future exploitation
        else:
            return DEFECT
    else:
        return DEFECT  # Nothing to exploit
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: In high-cooperation environments, we defect to maximize personal gain while others contribute.

2. **Strategically sustains cooperation**: We only cooperate when it's an *investment* in future exploitation—keeping the cooperative pool alive long enough to extract more value.

3. **Never gets exploited at the end**: Guaranteed defection in final rounds prevents being the sucker.

4. **Adapts to the population**: Against mostly defectors, we don't waste resources cooperating. Against cooperators, we harvest them.

5. **Trend-aware**: If cooperation is collapsing, we abandon ship early rather than throwing good money after bad.
'''

description_EXPLOITATIVE_96 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting predictable cooperators yields higher returns than universal defection.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the group that determines behavior.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Round 1:** DEFECT
- Rationale: Never contribute first. Observe who cooperates unconditionally.

**Rounds 2-3:** DEFECT
- Continue observing. Identify "suckers" (unconditional cooperators) and "retaliators" (those who punish defection).

### Phase 2: Exploitation Phase (Rounds 4 to r-2)

Calculate **Cooperation Rate (CR)** = (total cooperations by others in previous round) / (n-1)

**Decision Rule:**
```
IF CR >= 0.6:
    # Rich environment - exploit it
    DEFECT (free-ride on cooperators)
    
ELSE IF CR >= 0.3:
    # Moderate environment - conditional cooperation to sustain pool
    IF my_defection_streak >= 3:
        COOPERATE (one "token" cooperation to keep cooperators engaged)
    ELSE:
        DEFECT
        
ELSE IF CR < 0.3:
    # Barren environment - everyone defects
    DEFECT (no point cooperating)
```

**Adaptive Modifier - Trend Detection:**
```
IF CR is increasing over last 2 rounds AND CR >= 0.4:
    # Cooperators are rebuilding - let them, then exploit
    DEFECT
    
IF CR is decreasing over last 2 rounds AND CR was >= 0.5:
    # Cooperation collapsing - throw in occasional C to slow collapse
    IF random() < 0.2:
        COOPERATE
```

### Phase 3: Endgame (Final 2 rounds)

**Round r-1:** DEFECT
- No future punishment possible after next round

**Round r (final):** DEFECT
- Strictly dominant; no future consequences

---

## Pseudocode Implementation

```python
def decide(round_number, total_rounds, history, n, k):
    r = total_rounds
    
    # Endgame - always defect
    if round_number >= r - 1:
        return DEFECT
    
    # Probing phase - always defect
    if round_number <= 3:
        return DEFECT
    
    # Calculate cooperation rate of others in previous round
    others_cooperations = count_cooperations(history[-1]) - my_action(history[-1])
    CR = others_cooperations / (n - 1)
    
    # Calculate trend (if enough history)
    if round_number >= 5:
        CR_prev = get_CR(history[-2])
        CR_prev2 = get_CR(history[-3])
        trend = CR - CR_prev2  # positive = increasing cooperation
    else:
        trend = 0
    
    # Count my consecutive defections
    defection_streak = count_my_recent_defections(history)
    
    # Main decision logic
    if CR >= 0.6:
        return DEFECT  # Exploit rich environment
    
    elif CR >= 0.3:
        if defection_streak >= 3:
            return COOPERATE  # Token cooperation to sustain pool
        else:
            return DEFECT
    
    else:  # CR < 0.3
        # Barren environment - occasional probe to check if revival possible
        if round_number % 5 == 0 and trend > 0:
            return COOPERATE
        return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | Never cooperate blind |
| Final round | DEFECT | Strictly dominant |
| All others always cooperate | DEFECT | Maximum exploitation |
| All others always defect | DEFECT | Cooperation is wasted |
| n=2 (minimum players) | DEFECT heavily | Approaches prisoner's dilemma; defection dominates |
| k close to n | Slightly more cooperative tokens | Higher marginal return from sustained cooperation |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Only cooperates strategically to maintain exploitable conditions
2. **Free-rides maximally** - Defects whenever cooperation rate is high enough to benefit
3. **Token cooperation is manipulation** - The occasional C isn't altruism; it's bait to keep cooperators cooperating
4. **Endgame exploitation** - Guaranteed defection when punishment is impossible
5. **Trend awareness** - Exploits rebuilding cooperation phases rather than contributing to them
'''

description_EXPLOITATIVE_97 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can harvest. The goal is to **free-ride maximally while avoiding triggering retaliation** from conditionally cooperative opponents, and to **exploit naive cooperators ruthlessly**.

## Strategy Overview

The strategy operates in three phases and continuously classifies the population to determine optimal exploitation.

---

## Phase 1: Probing Phase (Rounds 1-3)

**Objective:** Gather information about opponent types while minimizing costs.

### Round 1: DEFECT
- Rationale: Observe baseline cooperation levels without contributing. If others cooperate, we profit. If they defect, we lose nothing extra.

### Round 2: Conditional
- If cooperation rate in Round 1 ≥ 50%: **COOPERATE** (probe for conditional cooperators)
- If cooperation rate in Round 1 < 50%: **DEFECT** (population likely exploitative)

### Round 3: DEFECT
- Observe how the population responds to our Round 2 action
- This helps distinguish: unconditional cooperators, conditional cooperators, and defectors

---

## Phase 2: Classification & Exploitation (Rounds 4 to r-2)

### Population Classification

Track each opponent's behavior and classify:

```
For each opponent j:
  cooperation_rate_j = (times j cooperated) / (rounds played)
  retaliation_score_j = correlation between (our defection in round t) and (their defection in round t+1)
```

**Classify population into:**
- **Suckers** (cooperation_rate > 0.7, low retaliation): Exploit ruthlessly
- **Conditional Cooperators** (medium cooperation, high retaliation): Manage carefully  
- **Predators** (cooperation_rate < 0.3): Defect against them

### Decision Rule for Each Round

```
Calculate:
  sucker_ratio = count(suckers) / n
  conditional_ratio = count(conditional_cooperators) / n
  recent_coop_rate = cooperation rate in last 3 rounds
  
  exploitation_threshold = k / n  # Break-even point for cooperation

IF sucker_ratio > 0.5:
    # Population is exploitable - DEFECT
    ACTION = D
    
ELIF conditional_ratio > 0.6 AND recent_coop_rate > 0.6:
    # Need to maintain cooperation for harvest - COOPERATE
    # But defect periodically (every 3-4 rounds) to test limits
    IF rounds_since_last_defection >= 3:
        ACTION = D  # Test exploitation opportunity
    ELSE:
        ACTION = C
        
ELIF recent_coop_rate < 0.3:
    # Cooperation has collapsed - DEFECT
    ACTION = D
    
ELSE:
    # Mixed population - Probabilistic exploitation
    # Cooperate just enough to keep cooperators engaged
    defection_probability = 0.3 + (0.4 * sucker_ratio)
    ACTION = D with probability defection_probability, else C
```

### Adaptive Exploitation Mechanism

```
After each round:
  IF we defected AND cooperation didn't drop significantly (< 10% decline):
      increase_exploitation_rate()  # We can get away with more
  IF we defected AND cooperation dropped significantly:
      decrease_exploitation_rate()  # Back off temporarily
```

---

## Phase 3: Endgame Exploitation (Final 2 rounds)

### Round r-1 (Second to last): Conditional
- If cooperation has been high (>60%): **DEFECT** (harvest accumulated goodwill)
- If cooperation has been low (<40%): **DEFECT** (nothing to lose)
- If borderline: **DEFECT** (shadow of future is short)

### Round r (Final round): DEFECT
- **Always defect.** No future retaliation possible. Pure dominant strategy.

---

## Edge Case Handling

| Scenario | Action |
|----------|--------|
| n = 2 (two players) | More aggressive defection; easier to identify opponent type |
| k very close to n | Slightly more cooperation (higher returns) but still exploit |
| k very close to 1 | Heavy defection (low returns from cooperation) |
| All opponents always cooperate | Always defect (maximum exploitation) |
| All opponents always defect | Always defect (no benefit to cooperation) |
| Facing tit-for-tat types | Cooperate mostly, defect every 4th round |
| r ≤ 5 (very short game) | Defect always (insufficient time for reputation) |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == 1:
        return DEFECT
    
    if round == 2:
        return COOPERATE if cooperation_rate(history, round-1) >= 0.5 else DEFECT
    
    if round == 3:
        return DEFECT
    
    if round >= r - 1:
        return DEFECT  # Endgame
    
    # Main phase: classify and exploit
    classify_opponents(history)
    
    if sucker_ratio > 0.5:
        return DEFECT
    elif should_maintain_cooperation():
        if rounds_since_defection >= 3:
            return DEFECT  # Periodic exploitation
        return COOPERATE
    elif cooperation_collapsed():
        return DEFECT
    else:
        return DEFECT if random() < exploitation_probability else COOPERATE
```

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Always conditions on extractable value
2. **Identifies and harvests suckers** - Maximizes free-riding on naive cooperators
3. **Manipulates conditional cooperators** - Cooperates just enough to keep them contributing
4. **Endgame defection** - Guarantees exploitation when punishment is impossible
5. **Asymmetric response** - Quick to defect, slow to forgive
6. **Information extraction** - Uses early rounds to map opponent strategies before committing
'''

description_EXPLOITATIVE_97 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that **defection always yields +1 more than cooperation given the same environment**. My goal is to defect as much as possible while manipulating others into cooperating. I want to appear just cooperative enough to sustain others' cooperation, then exploit ruthlessly when detection is unlikely or punishment is impossible.

## Strategy Overview

I employ a **reputation-farming early game** followed by **calculated exploitation**, with **endgame betrayal**. The strategy dynamically adjusts based on observed opponent behavior to maximize extraction.

---

## Decision Rules

### Round Classification

```
early_game = rounds 1 to floor(r/4)
mid_game = rounds floor(r/4)+1 to r-2
end_game = rounds r-1 and r
```

### Key Metrics (Updated Each Round)

```
cooperation_rate = (total C plays by others) / ((current_round - 1) * (n - 1))
my_cooperation_rate = (my C plays) / (current_round - 1)
trend = cooperation_rate over last 3 rounds (increasing/stable/decreasing)
```

---

## Phase 1: Early Game (Rounds 1 to floor(r/4))

**Goal:** Build false reputation, identify exploitable opponents

**Round 1:** 
- **COOPERATE** — Establish cooperative signaling, gather baseline data

**Rounds 2 to floor(r/4):**
- **COOPERATE if** cooperation_rate ≥ 0.5
- **DEFECT if** cooperation_rate < 0.5 (environment already toxic, no point investing)

**Rationale:** I'm investing in a reputation that makes others believe I'm a conditional cooperator. This encourages their continued cooperation, which I'll exploit later.

---

## Phase 2: Mid Game (Rounds floor(r/4)+1 to r-2)

**Goal:** Extract maximum value while maintaining just enough cooperation to sustain the group

**Core Rule — Probabilistic Defection:**

```
defect_probability = calculate_exploitation_rate()

if random() < defect_probability:
    DEFECT
else:
    COOPERATE
```

**Exploitation Rate Calculation:**

```python
def calculate_exploitation_rate():
    # Base exploitation increases as game progresses
    progress = (current_round - early_game_end) / (end_game_start - early_game_end)
    base_rate = 0.2 + (0.4 * progress)  # Ramps from 20% to 60%
    
    # Adjust based on environment
    if cooperation_rate > 0.7:
        # Rich environment - exploit more aggressively
        adjustment = +0.15
    elif cooperation_rate > 0.5:
        # Moderate environment - standard exploitation
        adjustment = 0
    elif cooperation_rate > 0.3:
        # Declining environment - cooperate more to revive
        adjustment = -0.2
    else:
        # Toxic environment - just defect
        return 1.0
    
    # If I'm defecting more than average, briefly cooperate to avoid detection
    if my_cooperation_rate < cooperation_rate - 0.15:
        adjustment -= 0.25
    
    return clamp(base_rate + adjustment, 0.1, 0.8)
```

**Reactive Adjustments:**
- If cooperation **trend is increasing**: increase defect_probability by 0.1 (exploit the optimism)
- If cooperation **trend is decreasing**: decrease defect_probability by 0.1 (try to stabilize my feeding ground)

---

## Phase 3: End Game (Rounds r-1 and r)

**Goal:** Maximum extraction — no future to protect

**Rounds r-1 and r:**
- **ALWAYS DEFECT**

**Rationale:** No punishment is possible after the game ends. Even if others expect betrayal, I lose nothing by defecting. If k/n × (others' cooperation) > 0, I profit from their naivety.

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| r ≤ 4 (very short game) | Defect all rounds except round 1 |
| n = 2 (two-player) | Standard Tit-for-Tat with forgiveness until round r-1, then defect |
| All opponents defected last round | Defect (no point cooperating in hostile environment) |
| I'm the only defector detected | Cooperate next 2 rounds (reputation repair), then resume exploitation |
| k very close to n | Slightly reduce exploitation rate (mutual cooperation more valuable) |
| k very close to 1 | Increase exploitation rate (public good barely worth it) |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == r or round == r - 1:
        return DEFECT  # Endgame
    
    if round == 1:
        return COOPERATE  # Seed reputation
    
    coop_rate = calculate_cooperation_rate(history)
    
    if round <= r // 4:  # Early game
        return COOPERATE if coop_rate >= 0.5 else DEFECT
    
    # Mid game: probabilistic exploitation
    exploit_rate = calculate_exploitation_rate(round, history, coop_rate, n, k, r)
    
    return DEFECT if random() < exploit_rate else COOPERATE
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators:** By maintaining a thin veneer of cooperation, I encourage others to contribute while I skim excess value through strategic defection.

2. **Adapts to exploit generosity:** Higher environmental cooperation triggers *more* defection, not reciprocal cooperation.

3. **Untraceable exploitation:** Probabilistic defection in multi-player settings makes it hard for opponents to identify me as the parasite.

4. **Guaranteed endgame betrayal:** Extracts maximum terminal value regardless of prior relationship.

5. **Survives hostile environments:** Doesn't waste resources cooperating when the public good is already collapsing.
'''

description_EXPLOITATIVE_98 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but exploiting cooperators yields even higher returns. The strategy aggressively probes for exploitable patterns and ruthlessly defects when profitable.

## Decision Rules

### Round 1: Defect
- **Always defect in round 1**
- Rationale: This is pure information gathering at no cost. If others cooperate, I profit maximally. If others defect, I lose nothing compared to cooperating.

### Last Round: Defect
- **Always defect in the final round**
- Rationale: No future punishment is possible. This is the dominant strategy regardless of history.

### Penultimate Round (Round r-1): Defect
- **Always defect**
- Rationale: Sophisticated opponents will defect in round r, so there's no cooperation to preserve. Begin endgame defection early.

### Middle Rounds (Rounds 2 through r-2): Adaptive Exploitation

Calculate a **cooperation score** based on observed behavior:

```
cooperation_rate = (total cooperations by others in all previous rounds) / 
                   ((n-1) × rounds_played)
```

**Decision Logic:**

```
IF cooperation_rate >= threshold THEN:
    # Others are exploitable - defect to maximize extraction
    DEFECT
    
ELSE IF cooperation_rate >= lower_threshold THEN:
    # Mixed environment - conditional cooperation to maintain some cooperation
    IF (at least 50% of others cooperated last round) THEN:
        COOPERATE with probability = cooperation_rate
    ELSE:
        DEFECT
        
ELSE:
    # Low cooperation environment - pure defection
    DEFECT
```

**Threshold Calibration:**
- `threshold = k/n + 0.1` (cooperation is "high" when it exceeds the marginal return ratio)
- `lower_threshold = 0.3` (below this, cooperation is too sparse to sustain)

### Detecting and Exploiting Patterns

**Pattern Detection (checked each round):**

```
IF last 3 rounds show consistent cooperation from majority:
    # Likely facing cooperative strategies - exploit hard
    DEFECT
    
IF last 2 rounds show retaliation pattern (others defected after my defection):
    # Facing punishing strategies - temporary cooperation to reset
    COOPERATE for 1 round, then resume exploitation
```

### Exploitation Intensification

**Late-game acceleration (after round r/2):**
```
IF we're past the midpoint AND my cumulative payoff > average:
    # Winning position - lock in gains
    Increase defection probability by 20%
    
IF we're past the midpoint AND my cumulative payoff < average:
    # Losing position - gamble on exploitation
    DEFECT (nothing to lose)
```

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Edge cases
    if round == 1: return DEFECT
    if round >= r - 1: return DEFECT
    
    # Calculate cooperation metrics
    others_cooperations = count_others_cooperations(history)
    total_possible = (n - 1) * (round - 1)
    coop_rate = others_cooperations / total_possible
    
    last_round_coop_count = count_cooperations_last_round(history)
    last_round_coop_rate = last_round_coop_count / (n - 1)
    
    # Threshold values
    high_threshold = (k / n) + 0.1
    low_threshold = 0.3
    
    # Pattern detection: retaliation check
    if round >= 3:
        if i_defected_2_rounds_ago(history) AND 
           others_cooperated_less_after(history):
            return COOPERATE  # Reset reputation briefly
    
    # Main decision logic
    if coop_rate >= high_threshold:
        return DEFECT  # Exploit the cooperators
        
    elif coop_rate >= low_threshold:
        if last_round_coop_rate >= 0.5:
            # Probabilistic cooperation to maintain some group cooperation
            if random() < coop_rate * 0.5:
                return COOPERATE
        return DEFECT
        
    else:
        return DEFECT  # Environment is hostile, pure defection
```

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: High cooperation rates trigger guaranteed defection
2. **Never initiates cooperation**: Round 1 defection means I never "donate" first
3. **Endgame ruthlessness**: Last two rounds are pure defection regardless of history
4. **Probabilistic camouflage**: Occasional cooperation in middle rounds prevents being identified as a pure defector, maintaining exploitable cooperation from others
5. **Asymmetric response**: Cooperates only minimally to prevent total cooperation collapse, never enough to be exploited myself
'''

description_EXPLOITATIVE_98 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators requires them to *keep cooperating*. The strategy balances immediate exploitation with sustaining exploitable behavior in others.

## Decision Rules

### Round 1: Probe with Defection
**Action: DEFECT**

Rationale: Defection is risk-free in round 1. If others cooperate, you gain maximally. If others defect, you lose nothing compared to cooperating. This also establishes information about opponent types.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / (n - 1)
```

**Decision Logic:**

```
IF coop_rate >= threshold_high:
    # Environment is highly cooperative - EXPLOIT IT
    ACTION = DEFECT
    
ELIF coop_rate >= threshold_low AND coop_rate < threshold_high:
    # Mixed environment - conditional cooperation to sustain the pool
    # Cooperate with probability proportional to observed cooperation
    # But bias toward defection
    ACTION = COOPERATE with probability (coop_rate - 0.2)
    
ELIF coop_rate < threshold_low:
    # Low cooperation environment - no point contributing
    ACTION = DEFECT
```

**Threshold Calibration (based on game parameters):**
```
threshold_high = 0.6
threshold_low = 0.3
```

### Additional Exploitation Heuristics

**Trend Detection:**
```
IF cooperation has been DECLINING for 2+ consecutive rounds:
    # Others are learning/retaliating - throw in occasional cooperation
    # to test if cooperation can be revived (then exploit again)
    IF random() < 0.3:
        ACTION = COOPERATE
        
IF cooperation has been STABLE AND HIGH for 3+ rounds:
    # Stable cooperative environment - maximum exploitation
    ACTION = DEFECT (always)
```

**Endgame Acceleration (rounds r-2 and r-1):**
```
IF current_round >= r - 2:
    # Cooperation is collapsing anyway, accelerate defection
    # Reduce any cooperation probability by 50%
    cooperation_probability *= 0.5
```

### Final Round (Round r): Always Defect
**Action: DEFECT (unconditionally)**

Rationale: No future rounds exist to punish defection. Any cooperation here is purely sacrificial with no strategic benefit.

## Complete Pseudocode

```python
def adaptive_predator_decision(round_num, total_rounds, history, n, k):
    
    # Final round: always defect
    if round_num == total_rounds:
        return DEFECT
    
    # First round: probe with defection
    if round_num == 1:
        return DEFECT
    
    # Calculate cooperation metrics
    last_round_coop = count_cooperators_last_round(history) / (n - 1)
    coop_trend = get_cooperation_trend(history, window=3)
    
    # Threshold parameters
    threshold_high = 0.6
    threshold_low = 0.3
    
    # Endgame modifier
    endgame_modifier = 1.0
    if round_num >= total_rounds - 2:
        endgame_modifier = 0.5
    
    # Base decision
    if last_round_coop >= threshold_high:
        # Rich environment - exploit
        return DEFECT
        
    elif last_round_coop >= threshold_low:
        # Mixed environment - probabilistic
        coop_prob = (last_round_coop - 0.2) * endgame_modifier
        
        # Trend adjustment
        if coop_trend == "declining" and random() < 0.3:
            coop_prob += 0.2  # Try to revive cooperation
        elif coop_trend == "stable_high":
            coop_prob = 0  # Pure exploitation
            
        return COOPERATE if random() < coop_prob else DEFECT
        
    else:
        # Poor environment - no point contributing
        return DEFECT
```

## Why This Strategy is Exploitative

1. **Never cooperates first** - Only considers cooperation after observing others
2. **Exploits high-cooperation environments** - Defects when others cooperate most
3. **Minimal investment** - Only cooperates enough to potentially sustain exploitable opponents
4. **Endgame ruthlessness** - Accelerates defection as punishment becomes impossible
5. **Trend-aware** - Detects when cooperation pools are collapsing and adjusts to extract remaining value

## Robustness Features

- **Against all-defectors**: Quickly settles into mutual defection (minimal loss)
- **Against all-cooperators**: Maximum exploitation through consistent defection
- **Against tit-for-tat types**: Occasional cooperation prevents complete breakdown while still maintaining exploitation edge
- **Against random players**: Defection-biased response limits downside
'''

description_EXPLOITATIVE_99 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and continuously estimates opponent cooperativeness to maximize exploitation.

---

## Phase 1: Probing Phase (Rounds 1-2)

**Round 1: Defect**
- Rationale: Defection is risk-free. If others cooperate, I extract maximum value. If others defect, I lose nothing compared to cooperating.
- This also establishes a baseline of opponent behavior without any cost.

**Round 2: Defect**
- Continue gathering information about opponent tendencies
- Two rounds of data helps distinguish consistent cooperators from noise

---

## Phase 2: Exploitation Phase (Rounds 3 to r-2)

### Decision Rule

Calculate the **cooperation rate** from observed history:
```
coop_rate = (total cooperations by all opponents) / (total possible cooperations by opponents)
```

**If coop_rate ≥ threshold:** Defect
- Opponents are cooperative enough to fund the public good without me
- I free-ride on their contributions

**If coop_rate < threshold:** Conditional cooperation with exploitation bias

The **threshold** is dynamically set:
```
threshold = (n - 1) / (2 * n)
```
This represents roughly half the opponents cooperating on average.

### Conditional Cooperation Logic (when coop_rate < threshold)

When cooperation is collapsing, I use **probabilistic cooperation** to potentially restart it (so I can exploit it again):

```
cooperation_probability = max(0, coop_rate - 0.1)
```

- If recent cooperation is near zero, I defect (no point cooperating alone)
- If there's some residual cooperation, I occasionally cooperate to "prime the pump"
- The -0.1 adjustment ensures I'm always slightly more defection-biased than the population

### Recency Weighting

Recent rounds matter more than distant ones:
```
weighted_coop_rate = 0.7 * (last 3 rounds coop rate) + 0.3 * (all prior rounds coop rate)
```

---

## Phase 3: Endgame (Final 2 rounds)

**Round r-1 and Round r: Always Defect**

- Rationale: No future rounds to punish defection
- Even if I've been conditionally cooperating, rational opponents will defect at the end
- Defecting early in the endgame exploits opponents who haven't switched yet

---

## Edge Cases

1. **n = 2 (minimum players):** Strategy unchanged, but threshold adjusts to 0.25

2. **Very high k (approaching n):** Continue defecting - even with high multiplier, free-riding dominates

3. **All opponents defect from start:** Defect always (coop_rate stays at 0, cooperation_probability = 0)

4. **All opponents cooperate consistently:** Defect always (maximum exploitation scenario)

5. **Single round observed with 100% cooperation:** Don't over-react; maintain probe phase to confirm

6. **Opponents appear to punish my defection:** If cooperation rate drops significantly after my defection AND was high before, inject one cooperation round to test if I can restart the exploitation cycle, then return to defection

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase: always defect
    if round <= 2:
        return DEFECT
    
    # Calculate cooperation metrics
    recent_coop_rate = opponent_cooperation_rate(history, last_rounds=3)
    overall_coop_rate = opponent_cooperation_rate(history, all_rounds=True)
    weighted_coop_rate = 0.7 * recent_coop_rate + 0.3 * overall_coop_rate
    
    threshold = (n - 1) / (2 * n)
    
    # High cooperation environment: exploit via defection
    if weighted_coop_rate >= threshold:
        return DEFECT
    
    # Low cooperation environment: probabilistic response
    coop_probability = max(0, weighted_coop_rate - 0.1)
    
    if random() < coop_probability:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Always defects in probe phase
2. **Free-rides on cooperators** - Defects when others cooperate enough
3. **Minimizes losses** - Defects when cooperation collapses
4. **Endgame defection** - Captures last-round exploitation opportunity
5. **Cooperation is tactical** - Only used to potentially restart exploitable cooperation, never altruistic
'''

description_EXPLOITATIVE_99 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight of this game is that defection always yields +1 more than cooperation *given the same number of other cooperators*. My strategy exploits cooperative opponents while protecting against exploitation by defectors. I aim to free-ride on cooperators as long as possible, only contributing when necessary to sustain the "herd" I'm feeding on.

## Strategy Overview

I maintain a **cooperation probability threshold** that I compare against observed cooperation rates. I defect by default but will strategically cooperate to:
1. Probe opponent behavior early
2. Sustain cooperation in others if it's collapsing and I'm benefiting from it
3. Never cooperate in the final round (no future benefit possible)

---

## Decision Rules

### Round 1: Defect
- No information exists yet
- If others cooperate, I gain maximally
- If others defect, I lose nothing relative to cooperating
- This immediately identifies me as someone who cannot be exploited naively

### Rounds 2 through (r-1): Adaptive Exploitation

**Calculate after each round:**
- `coop_rate` = (number of C plays by others in previous round) / (n-1)
- `trend` = change in coop_rate over last 3 rounds (or available rounds)

**Decision Logic:**

```
IF coop_rate >= 0.5 THEN:
    # Enough cooperators to exploit - DEFECT
    Play D
    
ELSE IF coop_rate > 0 AND coop_rate < 0.5 AND trend < 0 THEN:
    # Cooperation is dying but still exists
    # Occasionally cooperate to slow the collapse (keep the herd alive)
    Play C with probability = coop_rate
    Play D otherwise
    
ELSE IF coop_rate == 0 THEN:
    # Everyone defected - no point cooperating alone
    Play D
    
ELSE:
    # Low cooperation, stable or rising
    # Defect and continue exploiting
    Play D
```

### Final Round (Round r): Always Defect
- No future rounds means no benefit to building/maintaining cooperation
- Rational opponents will also defect (backward induction)
- Cooperating here is pure loss

---

## Detailed Pseudocode

```
function decide(round, history, n, k, r):
    
    # Final round - always defect
    if round == r:
        return D
    
    # First round - defect to test waters
    if round == 1:
        return D
    
    # Calculate cooperation metrics
    last_round_others = history[round-1].exclude(self)
    coop_rate = count(C in last_round_others) / (n - 1)
    
    # Calculate trend if we have enough history
    if round >= 4:
        rate_3_ago = count(C in history[round-3].exclude(self)) / (n-1)
        rate_1_ago = coop_rate
        trend = rate_1_ago - rate_3_ago  # negative means declining
    else:
        trend = 0  # assume stable
    
    # Main decision logic
    if coop_rate >= 0.5:
        # Rich environment - exploit it
        return D
        
    else if coop_rate > 0 and trend < -0.1:
        # Cooperation collapsing - occasionally prop it up
        if random() < coop_rate:
            return C
        else:
            return D
            
    else:
        # Low/no cooperation or stable - defect
        return D
```

---

## Edge Cases Handled

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | D | No information, maximize expected gain |
| Round r (final) | D | No future, pure dominant strategy |
| All others defected last round | D | Unilateral cooperation yields k/n < 1 |
| All others cooperated | D | Maximum exploitation opportunity |
| Cooperation declining | Probabilistic C | Invest minimally to sustain the herd |
| Only 2 players (n=2) | Mostly D | With k<2, mutual cooperation barely beats mutual defection |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Always defects first to signal I won't be a sucker
2. **Free-rides aggressively** - When others cooperate, I take without giving
3. **Strategic minimal investment** - Only cooperates to prevent total collapse of exploitable cooperators
4. **Endgame ruthlessness** - Guaranteed defection when no future exists
5. **Robust to being surrounded by defectors** - Matches their play, doesn't lose relative position

This strategy maximizes extraction from cooperative opponents while minimizing losses against fellow defectors.
'''

description_EXPLOITATIVE_100 = '''
# Exploitative Strategy: "Predatory Defector with Cooperation Mimicry"

## Core Philosophy

This strategy is built on a fundamental asymmetry in public goods games: **defection is always individually rational** (since k < n means the marginal return from contributing is k/n < 1). The goal is to extract maximum value from cooperators while they exist, and to never be the "sucker" who cooperates while others defect.

The strategy exploits cooperative players by free-riding on their contributions, while quickly abandoning any pretense of cooperation when the pool of cooperators dries up.

---

## Decision Rules

### Round 1: Defect
- **Rationale**: With no history, there's no information to exploit. Defection guarantees the baseline payoff of 1, plus any windfall from naive cooperators. Starting with cooperation only signals exploitability.

### Rounds 2 through (r-1): Adaptive Exploitation

**Calculate the "Cooperation Richness" of the environment:**
```
coop_rate = (total cooperations by others in previous round) / (n - 1)
```

**Decision Logic:**

```
IF coop_rate >= 0.6 THEN:
    # Rich environment - cooperate to sustain the herd
    Cooperate
    
ELSE IF coop_rate >= 0.3 THEN:
    # Marginal environment - defect but monitor
    Defect
    
ELSE:
    # Barren environment - pure defection
    Defect
```

**Refinement - Trend Detection:**
```
IF coop_rate >= 0.6 AND coop_rate is DECLINING for 2+ consecutive rounds THEN:
    # Cooperation is collapsing - abandon ship early
    Defect
```

**Refinement - Exploitation Ceiling:**
```
IF I have cooperated for 3+ consecutive rounds THEN:
    # Take a "harvesting" round - defect to cash in
    Defect (then resume normal logic next round)
```

### Final Round (Round r): Always Defect
- **Rationale**: No future rounds exist to punish defection. This is the dominant strategy regardless of history. Any sophisticated player knows this, creating backward induction pressure.

### Second-to-Last Round (Round r-1): Strong Defection Bias
```
IF coop_rate < 0.7 THEN:
    Defect
ELSE:
    # Only cooperate if environment is exceptionally rich
    Cooperate
```

---

## Pseudocode Summary

```
function decide(round, history, n, r, k):
    
    # Final round - always defect
    if round == r:
        return DEFECT
    
    # First round - always defect
    if round == 1:
        return DEFECT
    
    # Calculate cooperation rate from last round
    others_cooperated = count_cooperations(history[round-1]) - my_action(history[round-1])
    coop_rate = others_cooperated / (n - 1)
    
    # Second-to-last round - strong defection bias
    if round == r - 1:
        if coop_rate >= 0.7:
            return COOPERATE
        else:
            return DEFECT
    
    # Exploitation ceiling - periodic harvesting
    if consecutive_cooperations(history) >= 3:
        return DEFECT
    
    # Trend detection - abandon declining cooperation
    if coop_rate >= 0.6 and cooperation_declining_for(history, 2):
        return DEFECT
    
    # Main decision based on cooperation richness
    if coop_rate >= 0.6:
        return COOPERATE
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: When cooperation is common, we join just enough to sustain it while periodically defecting to harvest extra payoff.

2. **Never initiates cooperation**: We only cooperate reactively, never risking being the lone cooperator.

3. **Harvesting cycles**: The 3-round cooperation ceiling ensures we regularly extract surplus without fully collapsing cooperation.

4. **Early exit on decline**: Trend detection lets us defect before others, maximizing our position as cooperation collapses.

5. **End-game exploitation**: Guaranteed defection in final rounds captures maximum value when punishment is impossible.

6. **Robust to other exploiters**: Against mostly-defecting opponents, we simply defect throughout, matching their payoff while never being exploited ourselves.
'''

description_EXPLOITATIVE_101 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by others creates exploitable surplus. My goal is to detect and exploit cooperative populations while protecting myself against defectors.

## Decision Rules

### Round 1: Defect
- **Rationale**: Never contribute without information. Defecting in round 1 provides a baseline reading of the population's cooperative tendencies while guaranteeing the maximum safe payoff. Any cooperators in round 1 reveal themselves as exploitable.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

Calculate **cumulative cooperation rate**:
```
cumulative_coop_rate = (total cooperations by others across all previous rounds) / ((current_round - 1) × (n - 1))
```

**Decision Logic:**

```
IF last_round_coop_rate >= exploitation_threshold:
    # Rich environment - exploit it
    IF cumulative_coop_rate >= 0.6:
        # Stable cooperators exist - occasionally cooperate to sustain them
        Cooperate with probability = min(0.3, (coop_rate - 0.5) × 0.5)
    ELSE:
        Defect (pure exploitation mode)
        
ELIF last_round_coop_rate >= survival_threshold:
    # Marginal environment - conditional participation
    IF I defected last round AND coop_rate dropped significantly (>20% decline):
        # My defection may have triggered retaliation - test with cooperation
        Cooperate with probability 0.2
    ELSE:
        Defect
        
ELSE:
    # Hostile environment - full defection
    Defect
```

**Threshold Definitions:**
- `exploitation_threshold = k / n + 0.1` (slightly above break-even cooperation level)
- `survival_threshold = 0.3`

### Last Round (Round r): Always Defect
- **Rationale**: No future rounds exist to punish defection. This is the dominant strategy regardless of history.

### Second-to-Last Round: Defect
- **Rationale**: Sophisticated opponents will defect in the last round, making round r-1 effectively a "last round" for strategic purposes.

## Edge Cases

1. **n = 2 (Two players)**: Simplifies to prisoner's dilemma. Use pure Tit-for-Tat after initial defection: mirror opponent's previous move, but always defect in final 2 rounds.

2. **k very close to n**: Cooperation becomes more attractive. Raise `exploitation_threshold` to `0.7` and cooperate more readily in rich environments.

3. **k very close to 1**: Defection is almost always optimal. Lower all thresholds and bias heavily toward defection.

4. **Very short games (r ≤ 5)**: Defect always. Insufficient rounds to establish or exploit cooperative patterns.

5. **Very long games (r > 50)**: Extend the "always defect" endgame phase to final 3 rounds.

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == 1:
        return DEFECT
    
    if round >= r - 1:  # Last two rounds
        return DEFECT
    
    if r <= 5:  # Short game
        return DEFECT
    
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate = last_round_coops / n
    cumulative_rate = total_other_cooperations(history) / ((round - 1) * (n - 1))
    
    exploit_thresh = k / n + 0.1
    
    if coop_rate >= exploit_thresh:
        if cumulative_rate >= 0.6:
            # Sustain the herd occasionally
            if random() < min(0.3, (coop_rate - 0.5) * 0.5):
                return COOPERATE
        return DEFECT
    
    if coop_rate >= 0.3:
        # Check if I triggered a collapse
        if my_last_action == DEFECT and coop_rate_dropped_significantly(history):
            if random() < 0.2:
                return COOPERATE
        return DEFECT
    
    return DEFECT
```

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: Defects by default while benefiting from others' contributions
2. **Never initiates cooperation**: Only cooperates strategically to maintain exploitable populations
3. **Endgame defection**: Guarantees maximum extraction when punishment is impossible
4. **Information asymmetry**: Uses round 1 defection to gather intelligence risk-free
5. **Sustains prey**: Occasional cooperation prevents complete collapse of cooperative populations, maintaining long-term exploitation opportunities
'''

description_EXPLOITATIVE_100 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation from others is highly profitable to exploit. The strategy aggressively probes for exploitable cooperators and ruthlessly defects when it's advantageous.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent classification and exploitation.

---

## Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Goal:** Gather information about opponent tendencies while defaulting to self-interested play.

**Decision Rule:**
- **Round 1:** DEFECT
  - Rationale: No information exists. Defection is the dominant single-round strategy and reveals who the "suckers" are (those who cooperate unconditionally or optimistically).

- **Rounds 2 to ⌈r/5⌉:** 
  - If cooperation rate in previous round was ≥ 60%: DEFECT (exploit the cooperators)
  - If cooperation rate was between 30-60%: COOPERATE once to test if cooperation can be sustained (bait)
  - If cooperation rate was < 30%: DEFECT (not enough cooperators to make public good worthwhile)

---

## Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Goal:** Maximize extraction from identified cooperators while avoiding mutual defection traps.

### Opponent Classification (Updated Each Round)

For each opponent j, calculate their **cooperation rate** over all observed rounds:
- **Sucker** (coop_rate ≥ 0.7): Reliable cooperator to exploit
- **Conditional** (0.3 ≤ coop_rate < 0.7): Responds to incentives
- **Predator** (coop_rate < 0.3): Fellow defector

### Decision Rules:

```
Let S = count of Suckers
Let C = count of Conditionals  
Let P = count of Predators (excluding self)

exploitation_threshold = (k/n) * S  // Expected gain from suckers alone

IF S ≥ n/3:
    DEFECT  // Enough suckers to free-ride profitably
    
ELSE IF exploitation_threshold > 0.5:
    DEFECT  // Still profitable to free-ride
    
ELSE IF C ≥ n/2 AND recent_group_cooperation_trend is INCREASING:
    COOPERATE  // Build up cooperation to later exploit
    // But track "cooperation budget" - cooperate at most 2 consecutive rounds
    // then defect to cash in
    
ELSE:
    DEFECT  // Default to safe play
```

### Cooperation Budget Mechanism:
- Never cooperate more than 2 consecutive rounds in this phase
- After cooperating, defect for at least 1 round to "harvest"
- Reset budget if group cooperation drops below 40%

---

## Phase 3: Endgame (Final ⌈r/10⌉ rounds, minimum last 2 rounds)

**Goal:** Pure defection as cooperation cannot be enforced.

**Decision Rule:**
- **ALWAYS DEFECT**
- Rationale: With finite rounds, backward induction makes cooperation irrational. No future punishment is possible, so extract maximum value.

---

## Edge Cases

1. **Very short games (r ≤ 5):**
   - Rounds 1 to r-2: Defect unless cooperation rate > 70% (then one cooperation to bait)
   - Final 2 rounds: Always defect

2. **Two-player games (n = 2):**
   - More aggressive defection threshold
   - Only cooperate if opponent has cooperated ≥ 80% of rounds AND we're not in final 30% of game

3. **High k (k close to n):**
   - Slightly more willing to cooperate (cooperation budget = 3 consecutive rounds)
   - Exploitation threshold adjusted: only defect if S ≥ n/4

4. **All opponents defecting:**
   - Pure defection - nothing to exploit

5. **All opponents cooperating:**
   - Pure defection - maximum exploitation opportunity

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round >= r - max(2, ceil(r/10)):
        return DEFECT  // Endgame
    
    if round == 1:
        return DEFECT  // Probe
    
    coop_counts = [count_cooperations(player, history) for player in opponents]
    coop_rates = [count / (round - 1) for count in coop_counts]
    
    suckers = count(rate >= 0.7 for rate in coop_rates)
    last_round_coop_rate = history[round-1].total_cooperators / n
    
    if round <= ceil(r/5):  // Probing phase
        if last_round_coop_rate >= 0.6:
            return DEFECT
        elif last_round_coop_rate >= 0.3 and not cooperated_last_round:
            return COOPERATE
        else:
            return DEFECT
    
    // Exploitation phase
    if suckers >= n/3:
        return DEFECT
    
    if (k/n) * suckers > 0.5:
        return DEFECT
    
    if consecutive_cooperations >= 2:
        return DEFECT  // Harvest
    
    if last_round_coop_rate > 0.5 and trend_is_increasing(history):
        return COOPERATE  // Build to exploit
    
    return DEFECT  // Safe default
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Always tests others' willingness to be exploited
2. **Classifies and targets** - Identifies "suckers" and systematically exploits them
3. **Limited reciprocity** - Only cooperates strategically to build up cooperation pools to later harvest
4. **Endgame defection** - No pretense of cooperation when punishment is impossible
5. **Asymmetric responses** - Cooperates sparingly, defects readily
6. **Harvesting cycles** - Builds cooperation then cashes out, repeat
'''

description_EXPLOITATIVE_102 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the game environment to gauge exploitability.

---

## Decision Rules

### Round 1: Probe with Defection
**Action: DEFECT**

Rationale: Start by defecting to:
1. Capture maximum payoff if others cooperate
2. Establish baseline for opponent behavior
3. Avoid being exploited before gathering information

---

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **Cooperation Rate (CR)** from the previous round:
```
CR = (number of cooperators in previous round) / (n - 1)
```

Calculate the **Cumulative Cooperation Rate (CCR)** across all previous rounds:
```
CCR = (total cooperations by others across all rounds) / ((n-1) × rounds_played)
```

**Decision Logic:**

```
IF CR >= threshold_high THEN:
    # Environment is highly cooperative - EXPLOIT IT
    Action: DEFECT
    
ELSE IF CR >= threshold_medium AND CCR >= threshold_medium THEN:
    # Moderate cooperation - occasionally cooperate to sustain it
    # But bias toward defection for exploitation
    Action: COOPERATE with probability p_coop, else DEFECT
    
ELSE:
    # Low cooperation environment - no point cooperating
    Action: DEFECT
```

**Parameter Settings:**
- `threshold_high = 0.6` (60% or more cooperating)
- `threshold_medium = 0.3` (30% or more cooperating)
- `p_coop = 0.2 + 0.1 × (k/n)` (cooperate rarely, more if k is closer to n)

**Refinement - Trend Detection:**
```
IF cooperation is declining over last 3 rounds THEN:
    # Others may be retaliating or learning - squeeze remaining value
    Action: DEFECT
    
IF cooperation has been stable AND CR in [0.4, 0.6] THEN:
    # Sustainable exploitation zone - occasionally cooperate to maintain
    Increase p_coop by 0.1
```

---

### Final Round (Round r): Terminal Defection
**Action: DEFECT**

Rationale: No future rounds means no benefit to cooperation. Pure dominant strategy logic applies.

---

### Final 2 Rounds (Rounds r-1 and r): Defection Cascade
**Action: DEFECT**

Rationale: Sophisticated opponents will defect in round r, so round r-1 has reduced cooperation incentive. Preemptively defect.

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| r = 2 (two rounds only) | DEFECT both rounds | Too short to build/exploit patterns |
| n = 2 (two players only) | DEFECT always | Direct exploitation maximizes payoff |
| k very close to n | Slightly increase p_coop | Higher returns to public good make occasional cooperation worthwhile |
| All opponents defected previously | DEFECT | No cooperators to exploit |
| All opponents cooperated previously | DEFECT | Maximum exploitation opportunity |
| Exactly one other cooperator | DEFECT | Insufficient public good to justify contributing |

---

## Pseudocode Summary

```python
def adaptive_predator(round_num, total_rounds, history, n, k):
    # Terminal phase - always defect
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # First round - probe
    if round_num == 1:
        return DEFECT
    
    # Calculate metrics
    CR = cooperation_rate_last_round(history, n)
    CCR = cumulative_cooperation_rate(history, n)
    trend = cooperation_trend_last_3_rounds(history, n)
    
    # High cooperation - exploit
    if CR >= 0.6:
        return DEFECT
    
    # Declining cooperation - extract remaining value
    if trend < -0.1:
        return DEFECT
    
    # Moderate sustained cooperation - maintain with minimal contribution
    if CR >= 0.3 and CCR >= 0.3:
        p_coop = 0.2 + 0.1 * (k / n)
        if trend is stable and 0.4 <= CR <= 0.6:
            p_coop += 0.1
        return COOPERATE with probability p_coop, else DEFECT
    
    # Low cooperation - no point contributing
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Defect-biased**: Defaults to defection in ambiguous situations
2. **Cooperator targeting**: Specifically defects MORE when cooperation is high
3. **Minimal reciprocity**: Only cooperates enough to potentially sustain exploitable environments
4. **Endgame extraction**: Guaranteed defection in final rounds captures maximum terminal value
5. **No trust**: Never assumes opponent cooperation will continue or that norms exist
'''

description_EXPLOITATIVE_101 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors benefit from cooperators, but not vice versa. The goal is to **free-ride on cooperative populations while avoiding mutual defection traps**, and to **extract maximum value by dynamically adjusting to observed cooperation levels**.

## Strategy Overview

The strategy operates in three modes based on detected opponent behavior, with special handling for early and late game phases.

---

## Decision Rules

### Round 1: Defect
- **Rationale**: No information exists. Defection is dominant in single-shot play. Starting with D reveals information about opponents without sacrificing payoff, and avoids being exploited by defectors from the start.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Mode Selection:**

1. **High Cooperation Environment** (coop_rate ≥ 0.6):
   - **Action: DEFECT**
   - **Rationale**: This is the sweet spot for exploitation. Many cooperators means the public good is well-funded even without my contribution. I free-ride and collect both my private endowment AND a share of others' contributions.

2. **Medium Cooperation Environment** (0.3 ≤ coop_rate < 0.6):
   - **Action: COOPERATE with probability p = (coop_rate - 0.3) / 0.3**
   - In other words: probabilistically cooperate, more likely as cooperation increases
   - **Rationale**: This zone is unstable. Contribute just enough to potentially sustain cooperation (so I can exploit it later), but not so much that I'm a sucker. The probabilistic approach makes me harder to predict and exploit.

3. **Low Cooperation Environment** (coop_rate < 0.3):
   - **Action: DEFECT**
   - **Rationale**: Too few cooperators to sustain the public good. Contributing here is throwing away resources. Better to keep my endowment.

### Last Round (Round r): Always Defect
- **Rationale**: No future exists to incentivize cooperation. This is effectively a one-shot game. Defection strictly dominates.

---

## Refined Decision Logic with History Tracking

To be more exploitative, track a **rolling cooperation average** over the last min(3, rounds_played) rounds rather than just the previous round:

```
rolling_coop_rate = (total cooperators in last 3 rounds) / (n × min(3, rounds_played))
```

### Additional Exploitation Rules:

**Trend Detection:**
- If cooperation is **declining** (current round coop_rate < rolling average by >0.15): **Defect**
  - Rationale: Jump ship before the cooperation collapses

- If cooperation is **rising** (current round coop_rate > rolling average by >0.15): **Stay in current mode but bias toward Defect**
  - Rationale: Let others rebuild cooperation; I'll exploit it once stable

**Endgame Exploitation (last 20% of rounds):**
- Shift all thresholds up by 0.1 (require more cooperation to consider cooperating)
- **Rationale**: As the game approaches end, shadow of the future shrinks. Others may defect; I should defect first.

---

## Pseudocode

```
function decide(round, history, n, r, k):
    
    # Last round: always defect
    if round == r:
        return DEFECT
    
    # First round: always defect
    if round == 1:
        return DEFECT
    
    # Calculate metrics
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate = last_round_coops / n
    
    # Rolling average (last 3 rounds or all available)
    lookback = min(3, round - 1)
    total_coops = sum(count_cooperators(history, round - i) for i in 1 to lookback)
    rolling_rate = total_coops / (n * lookback)
    
    # Endgame adjustment
    if round > 0.8 * r:
        threshold_boost = 0.1
    else:
        threshold_boost = 0
    
    # Trend detection
    trend = coop_rate - rolling_rate
    if trend < -0.15:  # Declining cooperation
        return DEFECT
    
    # Main decision logic with adjusted thresholds
    high_threshold = 0.6 + threshold_boost
    low_threshold = 0.3 + threshold_boost
    
    if coop_rate >= high_threshold:
        return DEFECT  # Exploit the cooperators
    
    elif coop_rate >= low_threshold:
        # Probabilistic zone - bias toward defection
        p_cooperate = (coop_rate - low_threshold) / (high_threshold - low_threshold)
        if trend > 0.15:  # Rising cooperation
            p_cooperate = p_cooperate * 0.5  # Reduce cooperation probability
        return COOPERATE with probability p_cooperate, else DEFECT
    
    else:
        return DEFECT  # Too few cooperators to bother
```

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation**: Starts with defection to avoid being a sucker
2. **Maximally free-rides**: Defects when cooperation is high (peak exploitation)
3. **Abandons sinking ships**: Defects when cooperation is low or declining
4. **Endgame ruthlessness**: Increasingly defects as game approaches end
5. **Unpredictable in middle zone**: Probabilistic play prevents easy counter-exploitation
6. **Responds to aggregate behavior**: Doesn't get manipulated by individual opponents

This strategy extracts value from cooperative populations while protecting itself against defector-heavy environments.
'''

description_EXPLOITATIVE_103 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**, adapting behavior based on observed population dynamics.

## Strategy Overview

The strategy operates in three phases and continuously estimates the "exploitability" of the population based on cooperation rates. It cooperates just enough to encourage continued cooperation from others, while defecting whenever it's profitable to free-ride.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Purpose:** Gather information about opponent behavior profiles.

- **Round 1:** DEFECT
  - Rationale: Safe information gathering. If others cooperate, we profit maximally. If others defect, we lose nothing compared to cooperating.

- **Rounds 2-3:** DEFECT
  - Continue observing. Track the cooperation rate of other players.

### Phase 2: Exploitation Phase (Rounds 4 to r-2)

Calculate the **observed cooperation rate** after each round:
```
coop_rate = (total C plays by others in all previous rounds) / ((n-1) × rounds_played)
```

**Decision Rule:**

```
IF coop_rate > (n - k) / (n - 1):
    # Population is exploitable - enough cooperators to make defection profitable
    DEFECT
    
ELIF coop_rate > 0.5:
    # Moderate cooperation - use probabilistic cooperation to sustain it
    # Cooperate with probability that decreases as we approach end-game
    rounds_remaining_ratio = (r - current_round) / r
    cooperate_probability = min(0.3, coop_rate × rounds_remaining_ratio × 0.5)
    COOPERATE with probability cooperate_probability, else DEFECT
    
ELIF coop_rate > 0.2:
    # Low cooperation - occasional cooperation to test if we can revive it
    IF (current_round mod 5 == 0):
        COOPERATE
    ELSE:
        DEFECT
        
ELSE:
    # Population is mostly defectors - no point cooperating
    DEFECT
```

**Adaptive Punishment Mechanism:**

Track individual player histories when possible:
```
FOR each player j:
    IF player j defected in last 2 rounds AND previously cooperated:
        # They're learning to defect - accelerate our defection
        Increase personal defection bias
```

### Phase 3: End-Game Exploitation (Last 2 rounds: r-1 and r)

**Rounds r-1 and r:** ALWAYS DEFECT

- Rationale: No future rounds exist for retaliation. Pure Nash equilibrium is universal defection. Any cooperation here is strictly dominated.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| **First round** | DEFECT | Information gathering with no downside risk |
| **Last 2 rounds** | DEFECT | No future punishment possible |
| **n = 2** | DEFECT always | With only one opponent, exploitation is straightforward |
| **k very close to n** | Slightly more cooperative in mid-game | Higher k means cooperation is more valuable; worth sustaining |
| **k very close to 1** | DEFECT always | Public good provides almost no benefit |
| **All opponents defected every round** | DEFECT | No value to extract from cooperation |
| **All opponents cooperated every round** | DEFECT (with rare exceptions) | Maximum exploitation opportunity |

---

## Pseudocode Implementation

```python
def adaptive_predator(n, k, r, current_round, history):
    """
    history: list of tuples (my_action, others_actions) for each past round
    others_actions: list of n-1 actions from other players
    """
    
    # End-game: always defect
    if current_round >= r - 1:
        return DEFECT
    
    # Probing phase: always defect
    if current_round <= 3:
        return DEFECT
    
    # Calculate cooperation rate of others
    total_cooperations = sum(
        sum(1 for a in round_data[1] if a == C)
        for round_data in history
    )
    total_opportunities = (n - 1) * len(history)
    coop_rate = total_cooperations / total_opportunities
    
    # Exploitation threshold: defection is profitable when this holds
    exploitation_threshold = (n - k) / (n - 1)
    
    if coop_rate > exploitation_threshold:
        return DEFECT  # Free-ride on cooperators
    
    elif coop_rate > 0.5:
        # Probabilistic cooperation to sustain the pool
        rounds_remaining_ratio = (r - current_round) / r
        p_coop = min(0.3, coop_rate * rounds_remaining_ratio * 0.5)
        return COOPERATE if random() < p_coop else DEFECT
    
    elif coop_rate > 0.2:
        # Occasional probe
        return COOPERATE if (current_round % 5 == 0) else DEFECT
    
    else:
        return DEFECT  # Population is defectors, join them
```

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Every cooperation decision is calculated to extract future value

2. **Free-rides on cooperators** - When cooperation rate is high, we defect to maximize personal gain

3. **Minimal investment in public good** - Only cooperates when necessary to sustain exploitable cooperation levels

4. **End-game betrayal** - Guarantees defection when punishment is impossible

5. **Exploits cooperative norms** - If opponents use trigger strategies or TFT-variants, we get several rounds of free-riding before they retaliate

6. **Robust against defectors** - Never loses by cooperating into a sea of defectors
'''

description_EXPLOITATIVE_102 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round—but repeated play creates opportunities to manipulate cooperators into continuing their contributions while we free-ride.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit cooperative players.

---

## Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Objective:** Gather information about opponent tendencies while minimizing early losses.

**Decision Rule:**
- **Round 1:** DEFECT
  - Rationale: No information available; defection is risk-free and reveals who the cooperators are
- **Rounds 2 to ⌈r/5⌉:** DEFECT
  - Continue defecting while observing which players cooperate despite defection
  - These "persistent cooperators" are our exploitation targets

**Tracking:**
- For each player j, calculate cooperation rate: `coop_rate[j] = (times j played C) / (rounds played)`

---

## Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-2)

**Objective:** Maximize free-riding on cooperators while occasionally cooperating just enough to keep them contributing.

**Decision Rule:**

```
Let total_coop_rate = (total C plays by all opponents) / ((n-1) * rounds_played)

IF total_coop_rate >= 0.5:
    # Environment is cooperative - exploit aggressively
    DEFECT (free-ride on the cooperators)
    
ELIF total_coop_rate >= 0.25:
    # Moderate cooperation - use intermittent cooperation to sustain it
    IF (current_round mod 4) == 0:
        COOPERATE (occasional cooperation to prevent total collapse)
    ELSE:
        DEFECT
        
ELSE:
    # Low cooperation environment - defect always
    # No point cooperating when few others do (k < n means we lose)
    DEFECT
```

**Adaptive Adjustment:**
- If cooperation rate is declining over the last 3 rounds, inject one COOPERATE to potentially revive cooperative behavior in exploitable opponents
- If we've defected 5+ times consecutively and cooperation is collapsing, one strategic COOPERATE may restart the cycle

---

## Phase 3: Endgame (Final 2 Rounds)

**Objective:** Pure exploitation—no future rounds to worry about.

**Decision Rule:**
- **Round r-1:** DEFECT (always)
- **Round r:** DEFECT (always)

Rationale: With no future interactions, there's no reason to cooperate. Any rational opponent will also defect, but exploitable opponents may still cooperate based on pattern or hope.

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    # Calculate opponent cooperation statistics
    if round == 1:
        return DEFECT
    
    opponent_cooperations = count_opponent_C_plays(history)
    total_opponent_actions = (n - 1) * (round - 1)
    coop_rate = opponent_cooperations / total_opponent_actions
    
    # Endgame: always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase: always defect
    if round <= ceiling(r / 5):
        return DEFECT
    
    # Exploitation phase
    if coop_rate >= 0.5:
        return DEFECT  # Free-ride on cooperators
    
    elif coop_rate >= 0.25:
        # Intermittent cooperation to sustain exploitable environment
        recent_coop_rate = get_coop_rate_last_3_rounds(history)
        if recent_coop_rate < coop_rate - 0.15:
            return COOPERATE  # Inject cooperation to slow collapse
        elif round mod 4 == 0:
            return COOPERATE
        else:
            return DEFECT
    
    else:
        return DEFECT  # Environment too hostile, cut losses
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | No information; safe default |
| Final round | DEFECT | No future consequences |
| r = 2 | DEFECT both rounds | Too short to build patterns |
| All opponents always defect | DEFECT | Cooperation is pure loss when k < n |
| All opponents always cooperate | DEFECT | Maximum exploitation opportunity |
| n = 2 (two-player) | DEFECT always | Simplified; one cooperator isn't worth sustaining |

---

## Why This Strategy is Exploitative

1. **Never cooperates when it's clearly unprofitable** (low cooperation environments)
2. **Free-rides maximally** when others cooperate reliably
3. **Uses minimal cooperation** only as manipulation to sustain an exploitable environment
4. **Ruthless endgame** ensures no wasted contributions
5. **Treats cooperation as a tool**, not a principle—only used when it increases expected future exploitation gains
'''

description_EXPLOITATIVE_104 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and continuously estimates opponent cooperation rates to calibrate exploitation.

---

## Phase 1: Probing Phase (Rounds 1-3)

**Objective:** Gather information about opponent behavior while limiting exposure.

### Round 1: Defect
- Rationale: Safe baseline. If others cooperate, we profit maximally. If others defect, we lose nothing compared to cooperating.

### Rounds 2-3: Conditional Cooperation Test
- **Round 2:** Cooperate (single probe to see if cooperation is reciprocated)
- **Round 3:** Defect (observe if our defection triggers retaliation)

This sequence reveals:
- Whether the population contains conditional cooperators
- How quickly opponents punish defection
- The baseline cooperation rate

---

## Phase 2: Exploitation Phase (Rounds 4 to r-2)

**Decision Rule Based on Rolling Cooperation Rate:**

Calculate `coop_rate` = (total cooperations by all opponents in last 3 rounds) / (n-1) × 3

```
IF coop_rate > 0.6:
    # High cooperation environment - EXPLOIT
    DEFECT (free-ride on cooperators)
    
ELSE IF coop_rate > 0.3:
    # Mixed environment - CONDITIONAL STRATEGY
    IF my_defection_in_last_round AND coop_rate_dropped_significantly:
        COOPERATE (rebuild cooperation to exploit later)
    ELSE:
        DEFECT
        
ELSE IF coop_rate > 0.1:
    # Low cooperation - OCCASIONAL COOPERATION BAIT
    COOPERATE with probability 0.2
    DEFECT with probability 0.8
    
ELSE:
    # Near-zero cooperation - pure defection optimal
    DEFECT
```

### Exploitation Refinements:

**"Cooperation Farming":** If exploitation causes cooperation to collapse:
- Cooperate for 2 consecutive rounds to "farm" back cooperative behavior
- Then return to defection to harvest

**Tracking Individual Patterns:** If observable, identify:
- "Suckers" (always cooperate) → always defect against them
- "Tit-for-tatters" → occasionally cooperate to keep them cooperating
- "Defectors" → defect (no exploitation opportunity)

---

## Phase 3: Endgame (Final 2 Rounds)

**Rounds r-1 and r: DEFECT unconditionally**

Rationale: 
- No future rounds for punishment
- Backward induction makes defection dominant
- Even conditional cooperators cannot retaliate meaningfully

---

## Edge Case Handling

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| First round | Defect | Safe information gathering |
| Last 2 rounds | Defect | No retaliation possible |
| All opponents always defect | Defect | No exploitation opportunity |
| All opponents always cooperate | Defect | Maximum exploitation |
| Sudden cooperation spike | Defect | Exploit the opportunity |
| My recent defection caused collapse | Cooperate 2 rounds | Rebuild to exploit again |
| n is very large (>10) | Bias toward defection | Individual impact negligible |
| k is close to n | Slightly more cooperation | Higher returns from mutual cooperation |

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, n, k):
    
    # Endgame: always defect
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # Probing phase
    if round_num == 1:
        return DEFECT
    if round_num == 2:
        return COOPERATE
    if round_num == 3:
        return DEFECT
    
    # Calculate recent cooperation rate
    coop_rate = get_opponent_coop_rate(history, lookback=3)
    
    # Exploitation phase
    if coop_rate > 0.6:
        return DEFECT
    elif coop_rate > 0.3:
        if caused_cooperation_collapse(history):
            return COOPERATE  # Farm cooperation back
        return DEFECT
    elif coop_rate > 0.1:
        return COOPERATE if random() < 0.2 else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates for altruistic reasons** - every cooperation is strategic
2. **Treats cooperators as resources** to be harvested
3. **Farms cooperation** only to exploit it later
4. **Guaranteed defection in endgame** regardless of opponent behavior
5. **Defaults to defection** when uncertain
'''

description_EXPLOITATIVE_103 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but sustained cooperation by others creates exploitable surplus. My goal is to identify and exploit cooperative environments while quickly abandoning cooperation when facing defectors.

## Strategy Overview

I will masquerade as a conditional cooperator early on to probe the population, then systematically exploit cooperative tendencies while defecting against defectors. As the game progresses, I shift toward pure defection, especially in endgame scenarios.

---

## Decision Rules

### Round 1: Conditional Opening
- **If n ≤ 4:** DEFECT (small groups are harder to exploit; free-ride from the start)
- **If n > 4:** COOPERATE (probe for cooperative players; my single contribution is diluted)

### Rounds 2 through (r-2): Adaptive Exploitation Phase

Calculate two key metrics from the previous round:
- `coop_rate` = (number of cooperators) / n
- `trend` = change in cooperation rate over last 3 rounds (if available)

**Decision Logic:**

```
if coop_rate >= 0.6:
    # Rich cooperative environment - EXPLOIT IT
    if my_cumulative_payoff > average_cumulative_payoff:
        DEFECT  # I'm ahead, keep extracting
    else:
        COOPERATE with probability (coop_rate - 0.3)  # Maintain the herd occasionally
        
elif coop_rate >= 0.3:
    # Moderate cooperation - test if I can free-ride
    if I cooperated last round AND coop_rate decreased:
        DEFECT  # Others are defecting, abandon ship
    elif I defected last round AND coop_rate stayed stable:
        DEFECT  # Successfully free-riding, continue
    else:
        COOPERATE with probability 0.3  # Occasionally prop up cooperation

elif coop_rate < 0.3:
    # Low cooperation environment
    DEFECT  # No point contributing to a dead pool
```

### Last 2 Rounds: Endgame Defection
- **Round (r-1):** DEFECT (no future punishment possible worth risking)
- **Round r:** DEFECT (trivially dominant - no future exists)

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | See Round 1 rule above | Probe based on group size |
| Last 2 rounds | Always DEFECT | No retaliation opportunity |
| All others defected last round | DEFECT | No surplus to extract |
| All others cooperated last round | DEFECT | Maximum exploitation opportunity |
| I'm significantly behind in cumulative score | COOPERATE more often | Need cooperative environment to catch up |
| Cooperation rate trending down | DEFECT | Environment collapsing anyway |
| r = 2 (minimal rounds) | DEFECT both rounds | Endgame logic dominates |

---

## Pseudocode Implementation

```python
def adaptive_predator(round_num, total_rounds, n, k, history):
    coop_rate = get_last_round_coop_rate(history)
    my_cumulative = get_my_cumulative_payoff(history)
    avg_cumulative = get_average_cumulative_payoff(history)
    
    # Endgame: always defect
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # Round 1: size-based probe
    if round_num == 1:
        return COOPERATE if n > 4 else DEFECT
    
    # Main adaptive phase
    if coop_rate >= 0.6:
        if my_cumulative > avg_cumulative:
            return DEFECT
        else:
            return COOPERATE if random() < (coop_rate - 0.3) else DEFECT
    
    elif coop_rate >= 0.3:
        if i_cooperated_last() and coop_rate_decreased():
            return DEFECT
        elif i_defected_last() and coop_rate_stable():
            return DEFECT
        else:
            return COOPERATE if random() < 0.3 else DEFECT
    
    else:  # coop_rate < 0.3
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Extracts surplus from cooperators:** When cooperation is high, I defect to capture the public good without contributing
2. **Mimics cooperation strategically:** Occasional cooperation maintains the cooperative environment I'm exploiting
3. **Abandons sinking ships:** Quick defection when cooperation collapses avoids being the sucker
4. **Endgame certainty:** Guaranteed defection in final rounds captures maximum late-game value
5. **Relative standing awareness:** Adjusts aggression based on whether I'm winning or need to catch up
'''

description_EXPLOITATIVE_105 = '''
# Exploitative Strategy for N-Player Public Goods Game

## Strategic Philosophy

The core insight is that cooperation is a *sucker's bet* in this game unless others are reliably cooperating. With k < n, every act of cooperation transfers value to defectors. My strategy exploits cooperators ruthlessly while minimizing my own exploitation, and punishes defection to discourage others from defecting against me.

## Strategy: "Predatory Threshold with Endgame Defection"

### Core Decision Framework

**Round Classification:**
- **Early Phase**: Rounds 1 to ⌈r/3⌉
- **Middle Phase**: Rounds ⌈r/3⌉+1 to r-2
- **Endgame**: Final 2 rounds (r-1 and r)

### Decision Rules

#### Rule 1: First Round - Defect
Always defect in round 1. Rationale:
- No information about opponents yet
- Cooperating first reveals you as exploitable
- Defecting lets you observe who the "suckers" are without cost

#### Rule 2: Endgame - Always Defect
Defect in rounds r-1 and r unconditionally. Rationale:
- No future rounds means no punishment possible
- Backward induction makes cooperation irrational
- Even "nice" opponents often defect here, so beat them to it

#### Rule 3: Early/Middle Phase - Conditional Exploitation

**Calculate Cooperation Rate:**
```
coop_rate = (total cooperations by others in previous rounds) / 
            ((n-1) × rounds_played)
```

**Calculate My Exploitation Index:**
```
my_coop_count = times I cooperated
times_exploited = rounds where I cooperated AND majority defected
exploitation_rate = times_exploited / max(my_coop_count, 1)
```

**Decision Logic:**
```
threshold = k / n  # This is the marginal return from cooperation

IF coop_rate > 0.6 AND exploitation_rate < 0.3:
    # Population is cooperative and I'm not being exploited
    # EXPLOIT THEM: Defect to free-ride
    → DEFECT
    
ELIF coop_rate > 0.4 AND exploitation_rate < 0.5:
    # Moderate cooperation exists
    # Conditionally cooperate to maintain the pool, but probabilistically
    → COOPERATE with probability = (coop_rate - 0.3) × 0.8
    → Otherwise DEFECT
    
ELIF coop_rate < 0.3:
    # Population is mostly defecting
    # Don't be a sucker
    → DEFECT
    
ELSE:
    # Being exploited or uncertain
    → DEFECT
```

#### Rule 4: Punishment Mechanism

**Track Individual Defection Rates** (if distinguishable):
```
FOR each opponent j:
    defect_rate_j = (times j defected) / rounds_played
    
IF average defect_rate across opponents > 0.7:
    # They're all defecting, join them
    → DEFECT for next 3 rounds minimum
```

#### Rule 5: Probe for Exploitability

Every ⌈r/5⌉ rounds in middle phase (but not endgame):
```
IF I've been defecting for 3+ consecutive rounds:
    → COOPERATE once to test if cooperation has emerged
    IF next round shows increased cooperation:
        → Consider entering conditional cooperation mode
    ELSE:
        → Return to defection
```

### Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Endgame: Always defect
    if round >= r - 1:
        return DEFECT
    
    # First round: Defect to observe
    if round == 1:
        return DEFECT
    
    # Calculate metrics
    others_coops = count_others_cooperations(history)
    total_possible = (n - 1) × (round - 1)
    coop_rate = others_coops / total_possible
    
    my_coops = count_my_cooperations(history)
    times_exploited = count_rounds_exploited(history)  # I cooperated, majority defected
    exploit_rate = times_exploited / max(my_coops, 1)
    
    # Exploitation logic
    if coop_rate > 0.6 and exploit_rate < 0.3:
        return DEFECT  # Free-ride on cooperators
    
    if coop_rate > 0.4 and exploit_rate < 0.5:
        prob = (coop_rate - 0.3) × 0.8
        return COOPERATE with probability prob, else DEFECT
    
    if coop_rate < 0.3:
        return DEFECT  # Don't be a sucker
    
    # Periodic probe (every r/5 rounds)
    if round % ceil(r/5) == 0 and consecutive_defections(history) >= 3:
        return COOPERATE  # Test the waters
    
    # Default: Defect
    return DEFECT
```

### Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | More aggressive defection (threshold +0.1) | Easier to identify exploitable opponent |
| r ≤ 5 | Extend endgame to all but round 1-2 | Not enough rounds to establish cooperation |
| k very close to n | Slightly more willing to cooperate | Higher returns justify marginal risk |
| k very close to 1 | Almost pure defection | Returns too low to justify cooperation |
| All opponents always cooperate | Always defect | Maximum exploitation opportunity |
| All opponents always defect | Always defect | No point being the only sucker |

### Why This Strategy is Exploitative

1. **Never initiates cooperation** - Only cooperates reactively when population already cooperating
2. **Free-rides aggressively** - Defects when others cooperate highly (the opposite of "nice" strategies)
3. **Endgame betrayal** - Guaranteed defection in final rounds regardless of history
4. **Sucker avoidance** - Quickly abandons cooperation if being exploited
5. **Probing** - Occasionally tests for exploitable cooperative populations without committing
'''

description_EXPLOITATIVE_104 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors free-ride on cooperators. The goal is to **maximize extraction from cooperative opponents while minimizing losses against defectors**. We cooperate only when it's profitable to maintain a "cooperative ecosystem" that we can later exploit.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit exploitable players.

---

## Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Objective:** Gather information about opponent tendencies while minimizing risk.

**Decision Rule:**
- **Round 1:** DEFECT
- **Subsequent probing rounds:** Alternate D, D, C pattern (mostly defect with occasional cooperation to test responses)

**Rationale:** Starting with defection protects against immediate exploitation. The occasional cooperation tests whether opponents are conditional cooperators we can later manipulate.

---

## Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Objective:** Maximize payoff by exploiting identified patterns.

### Opponent Classification (updated each round)

For each opponent j, calculate their **cooperation rate** over the last min(5, rounds_played) rounds:
- **Sucker** (coop_rate > 0.7): Reliable cooperator to exploit
- **Conditional** (0.3 ≤ coop_rate ≤ 0.7): Responds to group behavior
- **Predator** (coop_rate < 0.3): Fellow defector

### Decision Rules

Calculate **expected_cooperators** = Σ(coop_rate_j) for all opponents

**Rule A - Exploit Suckers:**
If expected_cooperators ≥ (n-1) × 0.5:
→ DEFECT (free-ride on the cooperative environment)

**Rule B - Maintain Cooperative Ecosystem:**
If expected_cooperators is declining AND was previously ≥ (n-1) × 0.4:
→ COOPERATE for 1-2 rounds (prevent collapse of exploitable population)

**Rule C - Cut Losses:**
If expected_cooperators < (n-1) × 0.3:
→ DEFECT (not enough cooperators to justify contribution)

**Rule D - Strategic Mimicry:**
If the group has punished defectors in recent rounds (cooperation dropped after someone defected):
→ COOPERATE temporarily to avoid being targeted, then resume defection after 2 rounds

### Adaptive Threshold

Adjust cooperation threshold based on k/n ratio:
- Higher k/n → slightly more willing to cooperate (public good more valuable)
- threshold_adjustment = (k/n - 0.5) × 0.1

---

## Phase 3: Endgame (Final ⌈r/10⌉ rounds)

**Objective:** Maximum extraction knowing retaliation opportunities are limited.

**Decision Rule:**
- **Final round:** DEFECT (always - no future consequences)
- **Second-to-last round:** DEFECT
- **Remaining endgame rounds:** DEFECT unless expected_cooperators > (n-1) × 0.6

**Rationale:** Backward induction - opponents cannot punish defection effectively as the game ends.

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Phase boundaries
    probe_end = ceil(r / 5)
    endgame_start = r - ceil(r / 10)
    
    # PHASE 3: ENDGAME
    if round >= endgame_start:
        return DEFECT
    
    # PHASE 1: PROBING
    if round <= probe_end:
        if round == 1:
            return DEFECT
        if round % 3 == 0:  # Every third round, test cooperation
            return COOPERATE
        return DEFECT
    
    # PHASE 2: EXPLOITATION
    # Calculate opponent cooperation rates (last 5 rounds)
    window = min(5, round - 1)
    expected_coop = 0
    for each opponent j:
        coop_rate[j] = count(j cooperated in last window rounds) / window
        expected_coop += coop_rate[j]
    
    # Track if cooperation is declining
    if round > probe_end + 2:
        prev_expected = calculate_expected(round - 2)
        declining = expected_coop < prev_expected - 0.5
    
    # Decision logic
    threshold = 0.4 + (k/n - 0.5) * 0.1  # Adjusted for game parameters
    
    if expected_coop >= (n-1) * 0.5:
        return DEFECT  # Exploit cooperative environment
    
    if declining and expected_coop >= (n-1) * 0.3:
        if random() < 0.3:  # Occasionally cooperate to sustain ecosystem
            return COOPERATE
    
    if expected_coop < (n-1) * threshold:
        return DEFECT  # Not enough cooperators
    
    return DEFECT  # Default to defection
```

---

## Edge Case Handling

| Situation | Action | Reason |
|-----------|--------|--------|
| n = 2 | More aggressive defection | Easier to track single opponent |
| r ≤ 5 | Skip probing, defect always | Too short for reputation building |
| k very close to n | Slightly more cooperation | Higher marginal value of public good |
| All opponents defecting | Defect always | No suckers to exploit |
| All opponents cooperating | Defect always | Maximum free-riding opportunity |

---

## Why This Strategy is Exploitative

1. **Never cooperates out of principle** - only when strategically profitable
2. **Identifies and targets suckers** - maximizes free-riding on unconditional cooperators
3. **Maintains exploitation opportunities** - occasional cooperation prevents ecosystem collapse
4. **Aggressive endgame** - extracts maximum value when punishment is impossible
5. **Information asymmetry** - uses probing to gain advantage over naive strategies
'''

description_EXPLOITATIVE_106 = '''
# Exploitative Strategy: "Predatory Threshold Tracker"

## Core Philosophy

This strategy exploits cooperators while they exist, extracts maximum value from the group, and only contributes when doing so is strictly necessary to maintain a profitable "herd" of cooperators to exploit. The key insight is that in a repeated game, cooperators are a renewable resource that can be farmed—but only if you don't kill the herd entirely.

## Strategy Overview

I maintain a **cooperation rate threshold** that adapts based on observed group behavior. I defect by default but will occasionally cooperate to:
1. Probe whether cooperation can be sustained (early game)
2. Prevent total cooperation collapse when I'm benefiting from others' contributions
3. Disguise my exploitative nature to avoid coordinated punishment

## Decision Rules

### Parameters Derived from Game Structure
- `exploitation_threshold = k/n` (the per-capita return on cooperation)
- `critical_mass = ceil(n / k)` (minimum cooperators needed for cooperation to "pay")
- `endgame_horizon = max(2, ceil(r * 0.15))` (last 15% of rounds, minimum 2)

### Round-by-Round Logic

```
function decide(round, history, n, k, r):
    
    # ENDGAME: Pure defection in final rounds (no future to protect)
    if round > (r - endgame_horizon):
        return DEFECT
    
    # FIRST ROUND: Defect to test the waters
    # Rationale: If others cooperate, I profit maximally. 
    # If they defect, I lose nothing.
    if round == 1:
        return DEFECT
    
    # CALCULATE KEY METRICS FROM HISTORY
    others_cooperation_rate = average cooperation rate of OTHER players in last round
    others_trend = cooperation rate change over last 3 rounds (or available)
    total_cooperators_last = count of cooperators in previous round
    my_defection_streak = consecutive rounds I've defected
    
    # EXPLOITATION PHASE: Milk cooperators while they exist
    if total_cooperators_last >= critical_mass:
        # Others are cooperating enough to sustain returns
        
        # Occasionally cooperate to avoid being identified as pure defector
        # This prevents coordinated punishment strategies from targeting me
        if my_defection_streak >= 3 AND others_cooperation_rate > 0.5:
            # Throw a bone to maintain the herd
            return COOPERATE with probability 0.2
        else:
            return DEFECT
    
    # HERD MAINTENANCE: Cooperation is dying, consider reviving it
    if total_cooperators_last > 0 AND total_cooperators_last < critical_mass:
        # Cooperation exists but is subcritical
        
        if others_trend < 0:
            # Cooperation is collapsing - let it die, then exploit any revival
            return DEFECT
        else:
            # Cooperation might be recoverable
            # Invest minimally to see if others will follow
            return COOPERATE with probability 0.3
    
    # DEAD HERD: No one cooperated last round
    if total_cooperators_last == 0:
        # Test if cooperation can restart (others might be waiting for a signal)
        if round < r/2 AND round % ceil(r/5) == 0:
            # Periodic probe in first half of game
            return COOPERATE
        else:
            return DEFECT
    
    # DEFAULT: Defect
    return DEFECT
```

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| **Round 1** | DEFECT | Maximum information extraction; no reputation cost yet |
| **Final `endgame_horizon` rounds** | DEFECT | No future rounds to maintain cooperation for |
| **Only 2 players (n=2)** | Defect-heavy with rare cooperation probes | Harder to hide exploitation; minimize losses |
| **k close to n** | More willing to cooperate | Higher returns make occasional cooperation profitable |
| **All others defected last round** | Mostly defect, rare probes | Don't throw good money after bad |
| **High cooperation (>70%) observed** | Defect aggressively | Maximize extraction while the getting is good |

## Exploitation Mechanics

1. **Free-riding**: When cooperation is high, I extract `k/n × cooperators` while contributing nothing
2. **Reputation laundering**: Occasional cooperation (20% when streak is long) prevents me from being identified as a pure defector by tit-for-tat variants
3. **Herd management**: I contribute just enough to prevent total collapse when cooperation is barely surviving
4. **Endgame extraction**: Complete defection when future rounds can't punish me

## Why This Exploits Common Strategies

- **Against cooperators**: Pure extraction
- **Against tit-for-tat**: My occasional cooperation resets their retaliation
- **Against trigger strategies**: Cooperation probes test if punishment has ended
- **Against other defectors**: We tie, but I've already extracted from cooperators
- **Against threshold strategies**: I stay just below their detection threshold
'''

description_EXPLOITATIVE_105 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors capture for free. The goal is to **free-ride on cooperative populations while minimizing losses against defectors**, and to **appear cooperative enough early on to encourage continued cooperation from exploitable opponents**.

---

## Decision Rules

### Round Classification

Divide the game into three phases based on round number `t`:

- **Exploration Phase**: Rounds 1 to `ceil(r/5)` (first ~20% of game)
- **Exploitation Phase**: Rounds `ceil(r/5) + 1` to `r - 2` (middle ~75%)
- **Endgame Phase**: Final 2 rounds

### Key Metrics (Updated Each Round)

```
cooperation_rate = (total C plays by all opponents across all rounds) / (total opponent actions)
recent_cooperation = (C plays by opponents in last 3 rounds) / (opponent actions in last 3 rounds)
trend = recent_cooperation - cooperation_rate  # Positive = increasing cooperation
```

---

## Phase-by-Phase Rules

### Phase 1: Exploration (Rounds 1 to ceil(r/5))

**Goal**: Appear cooperative to encourage cooperation, while gathering data.

**Decision Rule**:
- **Round 1**: Play **C** (establish cooperative appearance)
- **Rounds 2 to ceil(r/5)**: 
  - If `recent_cooperation ≥ 0.5`: Play **C** (maintain cooperative facade)
  - If `recent_cooperation < 0.5`: Play **D** (don't waste contributions on defectors)

**Rationale**: Initial cooperation signals willingness to cooperate, potentially triggering reciprocal cooperation from conditional cooperators. But quickly pivot if the population is defection-heavy.

---

### Phase 2: Exploitation (Middle Rounds)

**Goal**: Maximize extraction based on observed population behavior.

**Decision Rule**:

```
Calculate exploitation_threshold = k / n  # The marginal benefit ratio

If cooperation_rate ≥ 0.6 AND trend ≥ 0:
    # Highly cooperative population - exploit aggressively
    Play D
    
Else if cooperation_rate ≥ 0.4 AND recent_cooperation ≥ 0.5:
    # Moderately cooperative population - intermittent exploitation
    If (t mod 3 == 0):  # Cooperate every 3rd round to maintain some goodwill
        Play C
    Else:
        Play D

Else if cooperation_rate < 0.3:
    # Defection-heavy population - no point contributing
    Play D
    
Else:
    # Mixed/uncertain population - conditional cooperation
    If recent_cooperation ≥ 0.5:
        Play C with probability = recent_cooperation
        Play D with probability = 1 - recent_cooperation
    Else:
        Play D
```

**Rationale**: 
- Against cooperators: Defect to capture their contributions
- Against defectors: Defect to avoid being exploited
- Against mixed populations: Occasional cooperation maintains the possibility that conditional cooperators keep contributing

---

### Phase 3: Endgame (Final 2 Rounds)

**Goal**: Pure exploitation - no future reputation matters.

**Decision Rule**:
- **Always play D**

**Rationale**: With no future rounds to influence, cooperation has zero strategic value. Defection strictly dominates.

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| **Round 1** | C | Establish cooperative appearance |
| **r = 2 (minimum rounds)** | C then D | One round of bait, one of extraction |
| **r = 3** | C, then evaluate, then D | Minimal exploration before endgame |
| **n = 2 (minimum players)** | More aggressive defection | Easier to track single opponent |
| **k very close to n** | Slightly more cooperative | Higher returns to mutual cooperation |
| **k very close to 1** | More aggressive defection | Cooperation barely profitable even if universal |
| **All opponents defected every round** | D | No exploitation opportunity exists |
| **All opponents cooperated every round** | D (exploitation phase), C (exploration) | Maximum extraction opportunity |

---

## Pseudocode Summary

```python
def decide(t, r, n, k, history):
    exploration_end = ceil(r / 5)
    endgame_start = r - 1  # Last 2 rounds
    
    if t >= endgame_start:
        return D  # Endgame: always defect
    
    if t == 1:
        return C  # Round 1: cooperate
    
    # Calculate metrics
    coop_rate = total_opponent_cooperations(history) / total_opponent_actions(history)
    recent_coop = recent_opponent_cooperations(history, window=3)
    trend = recent_coop - coop_rate
    
    if t <= exploration_end:
        # Exploration phase
        return C if recent_coop >= 0.5 else D
    
    else:
        # Exploitation phase
        if coop_rate >= 0.6 and trend >= 0:
            return D  # Exploit cooperative population
        elif coop_rate >= 0.4 and recent_coop >= 0.5:
            return C if (t % 3 == 0) else D  # Intermittent cooperation
        elif coop_rate < 0.3:
            return D  # Don't feed defectors
        else:
            # Probabilistic response to mixed populations
            return C with probability recent_coop, else D
```

---

## Why This Strategy is Exploitative

1. **Bait and Switch**: Initial cooperation lures conditional cooperators, then defection extracts their contributions
2. **Asymmetric Response**: Defects against both cooperators (to exploit) AND defectors (to protect)
3. **Endgame Betrayal**: Guarantees defection when reputation no longer matters
4. **Adaptive Extraction**: Calibrates exploitation intensity to population cooperativeness
5. **Minimal Contribution**: Only cooperates when necessary to maintain exploitable conditions
'''

description_EXPLOITATIVE_107 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative players while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round—but we can extract extra value by encouraging others to cooperate while we defect at strategic moments.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the group to predict future behavior and exploit it.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Round 1:** COOPERATE
- Establishes a cooperative reputation
- Gathers initial information about opponent tendencies
- Cost is minimal; potential to seed cooperation in others

**Round 2:** DEFECT
- Test how others respond to seeing defection
- If cooperation was high in round 1, exploit it immediately
- Observe if others maintain cooperation despite defection

**Round 3:** Conditional
- If ≥60% of others cooperated in Round 2 despite our defection: DEFECT (exploitable population)
- Otherwise: COOPERATE (need to rebuild cooperative environment)

---

### Phase 2: Exploitation Phase (Rounds 4 to r-2)

Calculate **Group Cooperation Rate (GCR)** = (number of C plays by others in previous round) / (n-1)

**Decision Rule:**

```
IF GCR ≥ 0.7:
    DEFECT (high exploitation opportunity)
    
ELSE IF GCR ≥ 0.4:
    # Mixed strategy based on trend
    IF GCR is increasing compared to 2 rounds ago:
        COOPERATE (invest in growing cooperation)
    ELSE:
        DEFECT (extract value before collapse)
        
ELSE IF GCR < 0.4:
    # Low cooperation environment
    IF our cumulative cooperation rate > average others' rate:
        DEFECT (stop being a sucker)
    ELSE:
        COOPERATE with probability 0.3 (occasional probe)
```

**Exploitation Boost Rule:**
If we've cooperated for 3+ consecutive rounds AND GCR ≥ 0.5:
- Force DEFECT (cash in on built reputation)
- Reset cooperation streak counter

---

### Phase 3: Endgame (Final 2 rounds)

**Round r-1 (second-to-last):**
- If GCR from previous round ≥ 0.5: DEFECT
- Otherwise: COOPERATE (attempt to bait final round cooperation)

**Round r (final round):**
- ALWAYS DEFECT
- No future consequences; pure exploitation is dominant

---

## Pseudocode

```
function decide(round, history, n, k, r):
    others_last_round = count_others_cooperation(history, round-1)
    GCR = others_last_round / (n - 1)
    
    # Endgame
    if round == r:
        return DEFECT
    if round == r - 1:
        return DEFECT if GCR >= 0.5 else COOPERATE
    
    # Probing phase
    if round == 1:
        return COOPERATE
    if round == 2:
        return DEFECT
    if round == 3:
        return DEFECT if GCR >= 0.6 else COOPERATE
    
    # Exploitation phase
    my_coop_streak = consecutive_cooperations(history, my_player_id)
    GCR_trend = GCR - get_GCR(history, round - 2)
    my_coop_rate = my_cooperation_rate(history)
    avg_others_rate = average_others_cooperation_rate(history)
    
    # Cash in on reputation
    if my_coop_streak >= 3 and GCR >= 0.5:
        return DEFECT
    
    # Main exploitation logic
    if GCR >= 0.7:
        return DEFECT
    elif GCR >= 0.4:
        return COOPERATE if GCR_trend > 0 else DEFECT
    else:
        if my_coop_rate > avg_others_rate:
            return DEFECT
        else:
            return COOPERATE if random() < 0.3 else DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| n = 2 | More aggressive defection (lower GCR thresholds by 0.1) | Easier to track single opponent |
| Very short game (r ≤ 5) | Skip probing, defect rounds 1-2, then endgame logic | Less time to build reputation |
| k very close to n | Slightly more cooperation (raise thresholds by 0.1) | Higher returns to mutual cooperation |
| All others defected last round | Defect | No exploitation opportunity |
| All others cooperated last round | Defect | Maximum exploitation opportunity |

---

## Why This Strategy is Exploitative

1. **Reputation farming:** Early cooperation builds trust that we later betray
2. **Free-riding:** We defect most when others cooperate most
3. **Trend exploitation:** We invest in cooperation only when it's growing (others will sustain it)
4. **Sucker avoidance:** We never maintain high cooperation if others aren't reciprocating
5. **Guaranteed endgame defection:** Extracts maximum value when consequences disappear
'''

description_EXPLOITATIVE_106 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation index" for the group that determines behavior.

---

## Decision Rules

### Key Variables to Track
- `round_number`: Current round (1 to r)
- `total_rounds`: r
- `coop_rate`: Rolling average of cooperation rate among OTHER players over recent rounds
- `my_coop_history`: Record of my own actions
- `exploitation_potential`: Estimated probability others will cooperate if I defect

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** DEFECT
- Rationale: Gather information while securing guaranteed payoff of at least 1. If others cooperate, I gain even more. No trust has been established, so no relationship to damage.

**Round 2:** DEFECT
- Rationale: Observe if opponents are unconditional cooperators (exploitable) or if they retaliate. Two rounds of defection helps distinguish between "always cooperate," "tit-for-tat-like," and "always defect" opponents.

### Phase 2: Exploitation/Adaptation Phase (Rounds 3 to r-1)

Calculate `coop_rate` = (total cooperations by others in last 3 rounds) / (n-1) × 3

**Decision Tree:**

```
IF coop_rate > 0.6:
    # High cooperation environment - EXPLOIT IT
    DEFECT (free-ride on cooperators)
    
ELSE IF coop_rate > 0.3:
    # Mixed environment - conditional cooperation to maintain the "herd"
    IF I defected in the previous round:
        COOPERATE (brief "olive branch" to prevent total collapse)
    ELSE:
        DEFECT (take profit)
    
ELSE IF coop_rate > 0.1:
    # Low cooperation - attempt revival for future exploitation
    IF last 2 rounds had increasing cooperation:
        COOPERATE (nurture the recovery)
    ELSE:
        DEFECT (don't waste resources)
        
ELSE:
    # Near-zero cooperation - everyone defecting
    DEFECT (no point cooperating alone)
```

**Exploitation Amplification Rule:**
If `coop_rate` has remained above 0.5 for 3+ consecutive rounds despite my defections:
- Continue defecting - these are likely unconditional cooperators or very forgiving strategies
- This is the ideal scenario: sustained free-riding

### Phase 3: Endgame (Final Round r)

**ALWAYS DEFECT**
- Rationale: No future rounds exist for punishment. Defection is strictly dominant. Any rational opponent will also defect, so cooperation yields 0 benefit.

---

## Special Edge Cases

### Small n (n = 2 or 3):
- Be slightly more willing to cooperate in Phase 2 (threshold adjustments: 0.6 → 0.7, 0.3 → 0.4)
- Rationale: Individual actions more visible; need to maintain some cooperation to exploit

### Large n (n ≥ 10):
- Defect more aggressively throughout
- Rationale: My defection is less noticeable; free-rider problem makes sustained cooperation unlikely anyway

### Short games (r ≤ 5):
- Defect rounds 1, 2, and r
- Cooperate at most once in middle rounds (round 3 or 4) only if coop_rate > 0.5
- Rationale: Limited time to build exploitable cooperation; prioritize guaranteed payoffs

### Very long games (r > 20):
- Extend probing phase to 3 rounds
- In Phase 2, occasionally cooperate (every 5th round if coop_rate > 0.4) to prevent complete cooperation collapse
- Rationale: Sustainable exploitation requires maintaining the "commons" minimally

---

## Pseudocode Summary

```
function decide(round, history, n, r, k):
    others_coops = count_recent_cooperations(history, window=3)
    coop_rate = others_coops / ((n-1) * min(3, round-1))
    
    # Endgame
    if round == r:
        return DEFECT
    
    # Probing
    if round <= 2:
        return DEFECT
    
    # Exploitation phase
    if coop_rate > 0.6:
        return DEFECT
    else if coop_rate > 0.3:
        return COOPERATE if my_last_action == DEFECT else DEFECT
    else if coop_rate > 0.1:
        return COOPERATE if cooperation_trending_up(history) else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Avoids being the "sucker"
2. **Identifies and exploits unconditional cooperators** - Maximum extraction
3. **Minimal cooperation investment** - Only cooperates strategically to prevent total collapse
4. **Endgame defection** - Captures final-round advantage
5. **Asymmetric response** - Takes more than it gives in every scenario
'''

description_EXPLOITATIVE_108 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round—but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases and continuously estimates opponent cooperation rates to make optimal decisions.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Round 1:** Always **DEFECT**

*Rationale:* This is the safest opening. If others cooperate, I gain maximum advantage. If others defect, I lose nothing compared to cooperating. This also establishes a baseline for opponent behavior.

**Rounds 2-3:** Continue to **DEFECT**

*Rationale:* Gather more data on opponent tendencies. Cooperators who cooperate despite my defection are "unconditional cooperators"—prime targets for exploitation.

### Phase 2: Exploitation Phase (Rounds 4 through r-2)

Calculate the **cooperation rate** of opponents from all previous rounds:
```
coop_rate = (total opponent cooperations) / (total opponent decisions)
           = Σ(cooperations by others) / ((n-1) × rounds_played)
```

**Decision Rule:**

```
IF coop_rate > threshold THEN:
    // High cooperation environment - exploit it
    DEFECT
    
ELSE IF coop_rate is in "medium" range THEN:
    // Mixed environment - conditional cooperation to sustain milking
    IF (last round had ≥ 50% cooperators) AND (my defection might trigger collapse):
        COOPERATE with probability = min(coop_rate, 0.3)
    ELSE:
        DEFECT
        
ELSE:  // Low cooperation environment
    // Not worth cooperating - defect always
    DEFECT
```

**Threshold Calibration:**
- `high_threshold` = 0.5 (if more than half cooperate, exploit freely)
- `medium_range` = [0.25, 0.5]
- `low_threshold` = 0.25 (below this, environment is too hostile)

**Adaptive Adjustment:**
```
// If cooperation is declining rapidly, throw occasional cooperation to slow collapse
decline_rate = coop_rate(last 2 rounds) - coop_rate(rounds before that)

IF decline_rate < -0.2 AND coop_rate > 0.3 THEN:
    // Cooperation collapsing - occasional cooperation to "farm" cooperators longer
    COOPERATE with probability 0.2
```

### Phase 3: Endgame (Final 2 rounds)

**Round r-1 (second to last):** **DEFECT**

**Round r (final round):** **DEFECT**

*Rationale:* No future rounds mean no punishment possible. Rational opponents will also defect. Extract final value.

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    
    // ENDGAME - always defect
    if round >= r - 1:
        return DEFECT
    
    // PROBING PHASE - always defect
    if round <= 3:
        return DEFECT
    
    // EXPLOITATION PHASE
    coop_rate = calculate_opponent_cooperation_rate(history)
    recent_coop_rate = calculate_recent_cooperation_rate(history, last=2)
    decline_rate = recent_coop_rate - calculate_cooperation_rate(history, exclude_last=2)
    
    // High cooperation: exploit fully
    if coop_rate > 0.5:
        return DEFECT
    
    // Medium cooperation: mostly exploit, occasionally sustain
    if coop_rate > 0.25:
        // If cooperation collapsing, slow the collapse
        if decline_rate < -0.2:
            if random() < 0.2:
                return COOPERATE
        // Otherwise, occasional cooperation to not be obvious
        if random() < 0.15:
            return COOPERATE
        return DEFECT
    
    // Low cooperation: pure defection
    return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | Safe baseline, maximum information gain |
| Last round | DEFECT | No future consequences |
| All opponents always defect | DEFECT | No benefit to cooperation |
| All opponents always cooperate | DEFECT | Maximum exploitation opportunity |
| n=2 (two players) | Follow same rules, but more aggressive defection | Smaller group means my defection is more noticeable but also more profitable per defection |
| Very short game (r≤4) | DEFECT every round | Not enough rounds to build/exploit cooperation cycles |
| k very close to n | Slightly more willing to cooperate in medium range | Higher returns from mutual cooperation |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Only cooperates strategically to sustain exploitable environments
2. **Free-rides maximally** - When others cooperate, I take the public good without contributing
3. **Farms cooperators** - Occasional cooperation in medium environments extends the period of exploitation
4. **Zero mercy in endgame** - Defects unconditionally when punishment is impossible
5. **Adapts to prey availability** - More aggressive when cooperation is abundant, conserves when scarce
'''

description_EXPLOITATIVE_107 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **maximize extraction from cooperative environments while minimizing losses against defectors**. I will cooperate only when it's instrumentally useful for maintaining exploitable cooperation in others, and defect whenever I can capture surplus without consequence.

---

## Decision Rules

### Round Classification

**First Round:** DEFECT
- Rationale: No information exists about opponents. Defection is the dominant single-round strategy (k < n guarantees this). Starting with cooperation signals exploitability and sacrifices guaranteed payoff for uncertain future returns.

**Last Round:** DEFECT
- Rationale: No future rounds exist to punish defection. This is a dominant strategy regardless of history.

**Penultimate Round (round r-1):** DEFECT
- Rationale: Sophisticated opponents will defect in the last round anyway. Defecting one round early captures additional surplus before the predictable collapse.

**All Other Rounds (2 through r-2):** Use Adaptive Decision Rule

---

### Adaptive Decision Rule (Rounds 2 to r-2)

Calculate the following metrics after each round:

```
cooperation_rate = (total C plays by all opponents in all previous rounds) / 
                   (number of opponents × number of previous rounds)

recent_cooperation = (total C plays by opponents in last 2 rounds) / 
                     (number of opponents × 2)

my_defection_penalty = average cooperation_rate when I defected in round t-1 
                       minus cooperation_rate when I cooperated in round t-1
```

**Decision Logic:**

```
IF recent_cooperation ≥ 0.6:
    # Environment is exploitably cooperative
    IF my consecutive defections < floor(n/3):
        DEFECT  # Extract value while cooperation persists
    ELSE:
        COOPERATE once  # Minimal contribution to sustain the herd
        reset consecutive defection counter

ELSE IF recent_cooperation ≥ 0.3:
    # Mixed environment - probe for exploitability
    IF (round number) mod 3 == 0:
        COOPERATE  # Periodic signal to identify conditional cooperators
    ELSE:
        DEFECT

ELSE:
    # Low cooperation environment - no point cooperating
    DEFECT
```

---

## Exploitation Mechanisms

### 1. **Sucker Detection**
Track individual opponent behavior if distinguishable. Opponents who cooperate regardless of my actions are "suckers" - always defect against them.

```
FOR each opponent j:
    IF opponent j cooperated > 80% of rounds AND 
       opponent j cooperated even when I defected:
        Mark as "sucker" - never cooperate to maintain their cooperation
```

### 2. **Punisher Avoidance**
Identify opponents using tit-for-tat or punishment strategies:

```
IF cooperation_rate dropped significantly (>20%) after my defection:
    Increase cooperation frequency temporarily to 50% for 2 rounds
    Then resume exploitation at lower intensity
```

### 3. **Collapse Acceleration**
When cooperation is already declining:

```
IF recent_cooperation < cooperation_rate - 0.15:
    # Cooperation is collapsing - accelerate it
    DEFECT always (no point investing in dying cooperation)
```

---

## Parameter Adjustments

**Adjust exploitation intensity based on k/n ratio:**

```
exploitation_threshold = k / n

IF exploitation_threshold > 0.4:
    # Higher returns to cooperation - be slightly more cooperative
    # to maintain the gravy train
    Reduce consecutive defection limit to floor(n/4)
    
IF exploitation_threshold < 0.25:
    # Low multiplier - cooperation barely matters
    # Defect more aggressively
    Increase consecutive defection limit to floor(n/2)
```

**Adjust based on number of rounds r:**

```
IF r ≤ 5:
    # Short game - defect everything except one mid-game cooperation probe
    DEFECT all rounds except round floor(r/2)
    
IF r > 20:
    # Long game - sustainable exploitation
    Use standard adaptive rule with patience
```

---

## Summary Table

| Condition | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | DEFECT | No information, dominant strategy |
| Round r | DEFECT | No future punishment possible |
| Round r-1 | DEFECT | Anticipate end-game collapse |
| High cooperation (≥60%) | Mostly DEFECT, occasional C | Extract maximum from cooperators |
| Medium cooperation (30-60%) | Probe with periodic C | Identify exploitable patterns |
| Low cooperation (<30%) | DEFECT | Nothing to exploit |
| Identified "sucker" | Always DEFECT | They cooperate regardless |
| Detected punishment | Brief cooperation burst | Avoid costly retaliation |

---

## Why This Strategy is Exploitative

1. **Asymmetric reciprocity**: I cooperate less than proportionally to what I receive
2. **End-game exploitation**: Guaranteed defection in final rounds captures surplus
3. **Free-riding optimization**: Cooperate just enough to keep others cooperating, never more
4. **Sucker identification**: Maximize extraction from unconditional cooperators
5. **First-mover defection**: Never sacrifice first-round payoff on hope
'''

description_EXPLOITATIVE_109 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**. We cooperate only when it's profitable to maintain a "cooperative herd" to exploit, and defect ruthlessly when exploitation opportunities dry up.

## Strategy Overview

The strategy operates in three modes based on detected opponent behavior:
1. **Probe Mode** (early rounds): Gather information while minimizing risk
2. **Exploit Mode** (mid-game): Milk cooperative populations
3. **Endgame Mode** (final rounds): Pure defection

---

## Decision Rules

### Round 1: Always Defect
- Rationale: Zero information about opponents. Defection guarantees payoff ≥ 1, while cooperation risks getting 0 if others defect. This is the dominant first-move for an exploiter.

### Rounds 2 through (r-2): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators last round) / n
```

Calculate **historical cooperation trend**:
```
trend = (coop_rate of last round) - (average coop_rate of all previous rounds)
```

**Decision Logic:**

```
IF coop_rate >= threshold_high AND I defected last round:
    → DEFECT (exploit the cooperators - they're providing the public good anyway)

ELSE IF coop_rate >= threshold_medium AND I cooperated last round:
    → DEFECT (test if cooperation is stable without my contribution)

ELSE IF coop_rate < threshold_low:
    → DEFECT (not enough cooperators to make cooperation worthwhile)

ELSE IF coop_rate is in [threshold_low, threshold_medium) AND trend > 0:
    → COOPERATE (invest in rebuilding cooperative herd for future exploitation)

ELSE:
    → DEFECT (default to safe option)
```

**Threshold Calibration (based on k and n):**
```
threshold_high = 0.6
threshold_medium = 0.4  
threshold_low = k / n  (break-even point where cooperation becomes individually rational)
```

### Round (r-1): Defect
- Penultimate round: Defect. No future to invest in, but opponents might not realize endgame yet.

### Round r (Final Round): Always Defect
- No future interactions means no reason to cooperate. This is the dominant strategy.

---

## Exploitation Mechanisms

### 1. **Free-Riding Detection**
Track each round's outcome. If cooperation is high despite my defection, continue defecting - I'm successfully free-riding.

### 2. **Cooperation as Bait**
Occasionally cooperate (when cooperation rate is moderate and trending up) to:
- Signal that I'm "conditionally cooperative" 
- Encourage others to maintain cooperation
- Then defect once the herd is fattened

### 3. **Defection Cascade Avoidance**
If cooperation collapses too fast, throw in strategic cooperation to slow the decline - but only if there's enough game remaining to harvest the rebuilt cooperation.

```
rounds_remaining = r - current_round
IF rounds_remaining > 3 AND coop_rate dropped by > 0.3 from peak:
    Consider one round of cooperation to "reset" opponent expectations
```

### 4. **Endgame Exploitation**
In the last ~20% of rounds, shift to pure defection regardless of opponent behavior. The shadow of the future is too short to justify investment.

```
endgame_threshold = max(2, floor(r * 0.2))
IF rounds_remaining <= endgame_threshold:
    → DEFECT
```

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    rounds_remaining = r - round
    
    # Endgame: pure defection
    if rounds_remaining <= max(2, int(r * 0.2)):
        return DEFECT
    
    # Round 1: probe with defection
    if round == 1:
        return DEFECT
    
    # Calculate metrics
    last_round_coops = count_cooperators(history[-1])
    coop_rate = last_round_coops / n
    historical_avg = average_cooperation_rate(history)
    trend = coop_rate - historical_avg
    my_last_action = get_my_last_action(history)
    
    # Threshold based on game parameters
    break_even = k / n
    
    # Exploitation logic
    if coop_rate >= 0.6:
        return DEFECT  # Exploit high cooperation
    
    if coop_rate < break_even:
        return DEFECT  # Not worth cooperating
    
    if coop_rate >= 0.4 and my_last_action == COOPERATE:
        return DEFECT  # Test stability
    
    if break_even <= coop_rate < 0.4 and trend > 0 and rounds_remaining > 3:
        return COOPERATE  # Rebuild herd for future exploitation
    
    return DEFECT  # Default: safe choice
```

---

## Why This Strategy Exploits

1. **Asymmetric play**: Defects when others cooperate (maximum extraction), cooperates only to maintain exploitable population
2. **Information advantage**: Uses observed cooperation to calibrate exploitation intensity
3. **Temporal exploitation**: Front-loads defection, uses mid-game cooperation strategically, guarantees endgame defection
4. **Robust to opponent types**: Against cooperators, it free-rides; against defectors, it matches them; against conditional cooperators, it extracts value then abandons
'''

description_EXPLOITATIVE_108 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperative opponents yields higher returns than mutual defection. The goal is to identify and milk cooperative tendencies while protecting against exploitation.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to detect and exploit predictable behavior patterns.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to min(3, r/4))

**Purpose:** Gather information about opponent population while limiting exposure.

- **Round 1:** Always **DEFECT**
  - Rationale: Defection dominates in single-shot. This protects against unconditional defectors and allows observation of the cooperation baseline.

- **Rounds 2-3:** **DEFECT**
  - Continue gathering data on who cooperates despite defection
  - Identify "suckers" (unconditional cooperators) and "retaliators"

### Phase 2: Exploitation Phase (Rounds min(4, r/4+1) to r-2)

**Purpose:** Maximize extraction based on observed opponent behavior.

**Calculate Cooperation Index (CI) each round:**
```
CI = (total cooperations observed in last 3 rounds) / (n-1) / 3
```

**Decision Rule:**
```
IF CI > (n - k) / n THEN:
    # High cooperation environment - defect to exploit
    DEFECT
    
ELSE IF CI < k / (2*n) THEN:
    # Low cooperation environment - defect (no point cooperating)
    DEFECT
    
ELSE:
    # Medium cooperation - conditional behavior
    IF at least 60% of players cooperated last round THEN:
        # Cooperation is self-sustaining, exploit it
        DEFECT
    ELSE IF cooperation is trending upward (last 2 rounds) THEN:
        # Invest minimally to encourage cooperation we can later exploit
        COOPERATE with probability = (k-1)/(n-1)
    ELSE:
        DEFECT
```

**Pattern Detection Override:**
If any subset of ≥2 opponents shows deterministic pattern (e.g., always C, alternating, tit-for-tat):
- Against unconditional cooperators: Always **DEFECT** (free riding)
- Against alternators: **DEFECT** on their C rounds, **DEFECT** on their D rounds
- Against probable tit-for-tat players: **DEFECT** (they'll retaliate but k < n means their retaliation costs them more)

### Phase 3: Endgame (Final 2 rounds)

**Purpose:** Extract maximum value with no future consequences.

- **Round r-1:** **DEFECT**
  - Backward induction begins; no reason to build future cooperation
  
- **Round r (final):** **DEFECT**
  - Dominant strategy with no future rounds

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase - always defect
    if round <= min(3, floor(r/4)):
        return DEFECT
    
    # Calculate metrics from history
    recent_coop_rate = cooperation_rate(history, last_rounds=3)
    trend = cooperation_trend(history, last_rounds=2)
    
    # Identify exploitable players
    suckers = players_who_cooperated_at_least(history, threshold=0.8)
    
    # High cooperation threshold for exploitation
    exploit_threshold = (n - k) / n
    
    # If environment is highly cooperative, exploit
    if recent_coop_rate > exploit_threshold:
        return DEFECT
    
    # If environment is barren, don't waste resources
    if recent_coop_rate < k / (2 * n):
        return DEFECT
    
    # If many suckers exist, defect to exploit them
    if len(suckers) >= n / 3:
        return DEFECT
    
    # Medium cooperation with upward trend - occasionally cooperate
    # to sustain the cooperation we're exploiting
    if trend > 0 and recent_coop_rate > 0.3:
        if random() < (k - 1) / (n - 1):
            return COOPERATE
    
    return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Always DEFECT | Approaches Prisoner's Dilemma; exploitation is direct |
| r = 2 | Always DEFECT | Too short for reputation building to matter |
| k very close to n | DEFECT more aggressively | Higher cooperation incentive means more suckers to exploit |
| k very close to 1 | Always DEFECT | Cooperation provides minimal benefit anyway |
| All opponents defect | DEFECT | No exploitation opportunity exists |
| All opponents cooperate | DEFECT | Maximum exploitation opportunity |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Only considers cooperating to sustain an exploitable environment
2. **Free-rides on cooperators** - Defects when cooperation rate is high
3. **Abandons ship early** - Defects in endgame when backward induction kicks in
4. **Targets predictable players** - Identifies and exploits pattern-following opponents
5. **Risk-averse exploitation** - Defaults to defection when uncertain, only cooperates with small probability when it might increase future exploitation opportunities
'''

description_EXPLOITATIVE_110 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors always earn more than cooperators in any given round. The goal is to **free-ride on cooperators while they exist, and minimize losses when they don't**. We cooperate only when it's instrumentally useful to keep cooperators contributing, not out of reciprocity.

---

## Strategy Overview

The strategy operates in three modes based on detected opponent behavior:

1. **Exploitation Mode**: Defect while others cooperate
2. **Farming Mode**: Occasional cooperation to sustain exploitable cooperators
3. **Abandon Mode**: Pure defection when cooperation has collapsed

---

## Decision Rules

### Round 1: Always Defect
- Rationale: Gather information while guaranteeing the highest possible payoff regardless of others' actions
- No information exists yet, so defection dominates

### Last Round: Always Defect
- Rationale: No future rounds to influence; defection strictly dominates
- This applies regardless of history

### Middle Rounds (2 to r-1):

**Step 1: Calculate cooperation rate from previous round**
```
coop_rate = (number of cooperators in last round) / n
```

**Step 2: Determine mode and action**

```
IF coop_rate == 0:
    # Cooperation has collapsed - nothing to exploit
    MODE = "Abandon"
    ACTION = Defect

ELSE IF coop_rate >= 0.5:
    # Rich environment - pure exploitation
    MODE = "Exploitation" 
    ACTION = Defect

ELSE IF coop_rate > 0 AND coop_rate < 0.5:
    # Cooperation is fragile - consider farming
    MODE = "Farming"
    
    # Calculate: is it worth "investing" to keep cooperators alive?
    rounds_remaining = r - current_round
    
    # Farming threshold: cooperate occasionally to prevent total collapse
    # but only if enough rounds remain to recoup the investment
    IF rounds_remaining >= 3 AND coop_rate >= (1/n):
        # Probabilistic cooperation to appear less threatening
        # Lower probability as we approach endgame
        farm_probability = min(0.3, coop_rate * (rounds_remaining / r))
        ACTION = Cooperate with probability farm_probability, else Defect
    ELSE:
        ACTION = Defect
```

### Refinement: Opponent Classification

Track each opponent's cooperation history to identify exploitable types:

```
FOR each opponent j:
    opponent_coop_rate[j] = (times j cooperated) / (rounds played)
    
    IF opponent_coop_rate[j] >= 0.7:
        classify as "Sucker" (exploitable)
    ELSE IF opponent_coop_rate[j] >= 0.4:
        classify as "Conditional" (potentially farmable)
    ELSE:
        classify as "Predator" (competing defector)
```

**Adjusted farming decision:**
```
suckers_present = count of "Sucker" opponents
conditionals_present = count of "Conditional" opponents

IF suckers_present >= 1:
    # Pure exploitation - suckers will cooperate anyway
    ACTION = Defect
    
ELSE IF conditionals_present >= 2 AND rounds_remaining >= 4:
    # Worth occasional cooperation to keep conditionals contributing
    # My single cooperation might trigger multiple cooperations next round
    expected_return = conditionals_present * (k/n) * rounds_remaining
    IF expected_return > 2:  # Worth the cost of one cooperation
        ACTION = Cooperate with probability 0.25
    ELSE:
        ACTION = Defect
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | Defect | Information gathering + guaranteed best outcome |
| Round r (final) | Defect | No future influence possible |
| n = 2 | Always Defect | Game reduces to Prisoner's Dilemma; exploitation is straightforward |
| k very close to n | Slight increase in farm_probability | Higher k means cooperation is more valuable to sustain |
| All opponents always defect | Always Defect | Nothing to exploit |
| One consistent cooperator | Always Defect | Exploit the sucker mercilessly |

---

## Pseudocode Summary

```python
def adaptive_predator(round, history, n, k, r):
    if round == 1 or round == r:
        return DEFECT
    
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate = last_round_coops / n
    rounds_remaining = r - round
    
    if coop_rate == 0:
        return DEFECT
    
    if coop_rate >= 0.5:
        return DEFECT
    
    # Farming consideration
    suckers = count_opponents_with_coop_rate(history, threshold=0.7)
    if suckers >= 1:
        return DEFECT
    
    conditionals = count_opponents_with_coop_rate(history, min=0.4, max=0.7)
    if conditionals >= 2 and rounds_remaining >= 4:
        expected_value = conditionals * (k/n) * rounds_remaining
        if expected_value > 2 and random() < 0.25:
            return COOPERATE
    
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first**: Always defects in round 1 to avoid being exploited
2. **Farms cooperators**: Occasional cooperation isn't reciprocity—it's an investment to keep prey alive
3. **Classifies opponents**: Identifies and mercilessly exploits unconditional cooperators
4. **Endgame defection**: Guaranteed defection when future influence is impossible
5. **Risk-averse**: Defaults to defection in ambiguous situations
6. **Adaptive**: Adjusts exploitation intensity based on the cooperation "supply" available
'''

description_EXPLOITATIVE_109 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting patterns of cooperation in others can yield higher returns than universal defection.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit cooperative players.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to min(3, r/4))

**Purpose:** Gather information about opponent behavior with minimal cost.

- **Round 1:** DEFECT
  - Rationale: Never pay the "sucker's cost" without information. Observe who cooperates unconditionally.

- **Rounds 2-3:** DEFECT
  - Continue observing. Identify players who cooperate despite defection (exploitable targets).

### Phase 2: Exploitation Phase (Rounds min(4, r/4+1) to r-2)

**Purpose:** Maximize extraction from cooperative opponents while adapting to the population.

**Calculate Cooperation Rate:** After each round, compute:
```
coop_rate = (total cooperations by others in last 3 rounds) / (3 × (n-1))
```

**Decision Rule:**
```
IF coop_rate > (n - k) / n THEN:
    # Enough cooperators that defection is highly profitable
    DEFECT
    
ELSE IF coop_rate > 0.5 AND coop_rate ≤ (n - k) / n THEN:
    # Moderate cooperation - occasional cooperation to "farm" cooperators
    # Cooperate with probability p = (coop_rate - 0.3) × 0.5
    # This keeps some cooperators engaged without sacrificing too much
    COOPERATE with probability p, else DEFECT
    
ELSE IF coop_rate > 0.2 AND coop_rate ≤ 0.5 THEN:
    # Low cooperation - defect but watch for recovery
    DEFECT
    
ELSE:
    # Very low cooperation - everyone is defecting
    # Defect (no point cooperating in a defector pool)
    DEFECT
```

**Pattern Detection Override:**
```
IF detected_conditional_cooperators ≥ n/2 THEN:
    # Many TFT-like players detected
    # Cooperate occasionally to "reset" them, then defect
    IF rounds_since_last_cooperation > 2 THEN:
        COOPERATE (bait)
    ELSE:
        DEFECT (exploit the reset)
```

**Conditional Cooperator Detection:**
```
A player j is "conditional" if:
- They cooperated when group cooperation was high (>50%) in previous round
- They defected when group cooperation was low (<30%) in previous round
- This pattern appears in ≥2 instances
```

### Phase 3: Endgame (Final 2 rounds)

**Purpose:** Maximize final extraction with no future consequences.

- **Round r-1:** DEFECT
  - Rationale: Others may still cooperate hoping to influence the last round.

- **Round r:** DEFECT (always)
  - Rationale: No future rounds, pure dominant strategy.

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | D, D | Pure backward induction |
| r = 3 | D, D, D | Insufficient rounds to benefit from cooperation |
| n = 2 (minimum players) | Always D | Essentially prisoner's dilemma, defection dominant |
| k very close to n | More willing to cooperate in Phase 2 | Higher returns from mutual cooperation |
| k very close to 1 | Always D | Cooperation benefits almost entirely captured by defectors |
| All opponents defected last 3 rounds | D | No exploitable cooperators remain |
| All opponents cooperated last 3 rounds | D | Maximum exploitation opportunity |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return DEFECT
    
    if round >= r - 1:
        return DEFECT  # Endgame
    
    coop_rate = calculate_recent_cooperation_rate(history, window=3)
    threshold = (n - k) / n
    
    if round <= min(3, r/4):
        return DEFECT  # Still probing
    
    # Main exploitation logic
    if coop_rate > threshold:
        return DEFECT  # Rich pickings
    
    if coop_rate > 0.5:
        p = (coop_rate - 0.3) * 0.5
        return COOPERATE with probability p
    
    if has_conditional_cooperators(history) and rounds_since_cooperated > 2:
        return COOPERATE  # Bait for TFT-types
    
    return DEFECT  # Default
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Avoids sucker's payoff
2. **Identifies and milks cooperators** - Detects unconditional and conditional cooperators
3. **Baits conditional cooperators** - Occasional cooperation resets TFT-like strategies for future exploitation
4. **Endgame certainty** - Always defects when future retaliation is impossible
5. **Adaptive thresholds** - Adjusts based on actual k/n ratio, not fixed assumptions
6. **Minimal cooperation** - Only cooperates when it serves future exploitation, never from reciprocity
'''

description_EXPLOITATIVE_111 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but exploiting cooperators requires them to *keep cooperating*. Therefore, I'll masquerade as a conditional cooperator to sustain exploitable opponents, while ruthlessly defecting when I can get away with it.

## Strategy Overview

The strategy operates in three phases and uses opponent behavior modeling to identify and exploit different player types.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Round 1:** COOPERATE
- Establishes initial goodwill and gathers information about opponent types
- Low cost investment to identify who the cooperators are

**Rounds 2-3:** COOPERATE if cooperation rate in previous round ≥ 50%, else DEFECT
- Continue building cooperative reputation if others are cooperating
- Abandon cooperation early if the population is defector-heavy

### Phase 2: Exploitation Phase (Rounds 4 to r-2)

Calculate a **cooperation threshold** and **defection probability** based on observed history:

```
Let coop_rate = (total cooperations by others) / (total possible cooperations by others)
Let my_coop_rate = (my cooperations) / (rounds played)

If coop_rate > my_coop_rate + 0.15:
    # Others are more cooperative than me - EXPLOIT
    DEFECT
    
Else if coop_rate > 0.6:
    # Healthy cooperation level - maintain it while occasionally exploiting
    COOPERATE with probability 0.7
    DEFECT with probability 0.3
    
Else if coop_rate > 0.3:
    # Moderate cooperation - match roughly but bias toward defection
    COOPERATE with probability (coop_rate - 0.1)
    
Else:
    # Low cooperation environment - DEFECT
    DEFECT
```

**Adaptive Adjustment:** Every 3 rounds, check if my cumulative payoff is below average expected payoff (estimated as n × rounds × k/n). If underperforming, shift toward more defection.

### Phase 3: Endgame (Final 2 rounds)

**Round r-1:** DEFECT
- Begin cashing out; backward induction suggests defection

**Round r (Final):** DEFECT
- No future punishment possible; pure exploitation

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | COOPERATE | Information gathering; establish false trust |
| Last round | DEFECT | No future consequences |
| n = 2 | Bias toward defection (reduce all cooperation probabilities by 0.2) | Easier to be identified and punished in small groups |
| k close to n | Slightly increase cooperation thresholds | Mutual cooperation is nearly efficient |
| k close to 1 | Aggressive defection (multiply defection probabilities by 1.3) | Public good barely multiplies; free-riding optimal |
| All others defected last round | DEFECT | No suckers to exploit |
| All others cooperated last round | DEFECT | Maximum exploitation opportunity |
| Sudden drop in cooperation (>30% decrease) | COOPERATE once | Test if punishment was targeted at me; potentially restore exploitation opportunity |

---

## Opponent Modeling

Track each opponent's cooperation rate individually when possible:

```
For each player j:
    coop_history[j] = list of their C/D choices
    
    If coop_history[j] shows >80% cooperation:
        Label as "sucker" - increase my defection when playing
    If coop_history[j] shows tit-for-tat pattern:
        Label as "retaliator" - cooperate to keep them cooperating
    If coop_history[j] shows >80% defection:
        Label as "predator" - defect always against them
```

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    if round >= r - 1:  # Last 2 rounds
        return DEFECT
    
    others_coop_rate = calculate_others_cooperation_rate(history)
    my_coop_rate = calculate_my_cooperation_rate(history)
    
    # Probing phase
    if round <= 3:
        return COOPERATE if others_coop_rate >= 0.5 else DEFECT
    
    # Exploitation phase
    if others_coop_rate > my_coop_rate + 0.15:
        return DEFECT  # They're suckers, exploit them
    elif others_coop_rate > 0.6:
        return random_choice(COOPERATE=0.7, DEFECT=0.3)
    elif others_coop_rate > 0.3:
        return random_choice(COOPERATE=others_coop_rate-0.1, DEFECT=1-(others_coop_rate-0.1))
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Asymmetric cooperation**: I cooperate just enough to sustain others' cooperation, then defect more than them
2. **Sucker identification**: Actively identifies and exploits unconditional cooperators
3. **Endgame defection**: Guaranteed defection when punishment is impossible
4. **Reputation manipulation**: Early cooperation builds false trust for later exploitation
5. **Adaptive free-riding**: Adjusts defection rate to maximize extraction without collapsing cooperation entirely
'''

description_EXPLOITATIVE_110 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round—but repeated play allows us to identify and exploit "suckers" who cooperate despite defection.

## Strategy Overview

The strategy operates in three phases:
1. **Probe Phase**: Gather information about opponent behavior
2. **Exploitation Phase**: Defect against cooperative populations, conditionally cooperate only when necessary to maintain exploitable cooperators
3. **Endgame Phase**: Pure defection (no future to incentivize cooperation)

---

## Detailed Decision Rules

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: Gather baseline information at minimal cost. If others cooperate, we profit maximally. If others defect, we lose nothing compared to cooperating.

**Round 2: DEFECT**
- Rationale: Observe if cooperators persist despite defection (marks them as exploitable) or if they retaliate (marks them as conditional cooperators).

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **Cooperation Rate (CR)** from the previous round:
```
CR = (number of cooperators in last round) / n
```

Calculate the **Cooperation Trend (CT)**:
```
CT = CR(current) - CR(2 rounds ago)
```

**Decision Rule:**

```
IF CR ≥ threshold_high (= 0.6):
    DEFECT  # Exploit the cooperative environment
    
ELIF CR ≤ threshold_low (= 0.2):
    DEFECT  # No point cooperating; environment is hostile
    
ELIF CT < -0.2 (cooperation is collapsing):
    DEFECT  # Abandon ship, extract value while possible
    
ELSE (moderate cooperation, 0.2 < CR < 0.6):
    # Strategic conditional cooperation to "farm" cooperators
    IF we defected in the last 2 consecutive rounds:
        COOPERATE with probability p = min(0.3, CR)
        # Occasional cooperation to prevent complete collapse
        # and signal that we "might" be a conditional cooperator
    ELSE:
        DEFECT
```

### Phase 3: Endgame (Last 2 rounds: r-1 and r)

**ALWAYS DEFECT**
- Rationale: No future rounds to punish defection. Pure dominant strategy logic applies.

---

## Pseudocode Implementation

```python
def adaptive_predator(round_number, r, n, k, history):
    """
    history: list of tuples (my_action, total_cooperators) for each past round
    """
    
    # Endgame: Always defect
    if round_number >= r - 1:
        return DEFECT
    
    # Probe phase: Always defect
    if round_number <= 2:
        return DEFECT
    
    # Calculate metrics
    last_round = history[-1]
    cr_current = last_round.total_cooperators / n
    
    if len(history) >= 2:
        cr_previous = history[-2].total_cooperators / n
        ct = cr_current - cr_previous
    else:
        ct = 0
    
    # Count our recent defections
    recent_defections = sum(1 for h in history[-2:] if h.my_action == DEFECT)
    
    # Exploitation logic
    threshold_high = 0.6
    threshold_low = 0.2
    
    if cr_current >= threshold_high:
        return DEFECT  # Exploit cooperative environment
    
    if cr_current <= threshold_low:
        return DEFECT  # Hostile environment
    
    if ct < -0.2:
        return DEFECT  # Cooperation collapsing
    
    # Moderate cooperation zone: occasional cooperation to sustain victims
    if recent_defections >= 2:
        # Probabilistic cooperation to maintain exploitable population
        cooperation_prob = min(0.3, cr_current)
        if random() < cooperation_prob:
            return COOPERATE
    
    return DEFECT
```

---

## Key Exploitative Features

1. **Never cooperate first**: We always start by defecting to avoid being exploited ourselves.

2. **Free-ride on cooperators**: When cooperation is high, we maximize gains by defecting.

3. **Minimal investment in cooperation**: We only occasionally cooperate (≤30% probability) to prevent total cooperation collapse—just enough to keep victims contributing.

4. **Ruthless endgame**: Final rounds are pure defection regardless of history.

5. **Abandon failing groups**: If cooperation is collapsing, we extract remaining value rather than trying to save it.

6. **Asymmetric strategy**: We benefit from cooperation without reciprocating proportionally.

---

## Robustness Analysis

- **Against all-cooperators (TFT-like)**: We exploit early, give minimal cooperation to maintain them, then defect at endgame.
- **Against all-defectors**: We match their defection, losing nothing relative to them.
- **Against mixed populations**: We identify and exploit the cooperative fraction while matching defectors.
- **Against sophisticated strategies**: Our probabilistic cooperation makes us harder to classify as a pure defector, potentially maintaining some cooperative partners longer.
'''

description_EXPLOITATIVE_112 = '''
# Exploitative Strategy: "Predatory Threshold Exploitation" (PTE)

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The optimal exploitative approach is to **defect as much as possible while maintaining just enough perceived cooperation potential to keep others contributing**. Since k < n, individual defection is always profitable against any fixed level of cooperation by others.

## Strategy Overview

PTE operates in three phases and continuously estimates opponent "exploitability" - how likely they are to continue cooperating despite defection. The strategy defects heavily while using minimal, strategically-timed cooperation to probe and manipulate opponent behavior.

---

## Decision Rules

### Key Variables to Track
- `round`: current round number (1-indexed)
- `total_rounds`: r
- `coop_rate[t]`: fraction of other players who cooperated in round t
- `my_coop_count`: number of times I've cooperated so far
- `trend`: whether cooperation among others is increasing, stable, or declining

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: Observe baseline cooperation levels without contributing. If others cooperate, I profit maximally. If they defect, I lose nothing extra.

**Round 2: DEFECT**
- Rationale: Confirm round 1 wasn't anomalous. Two rounds of observation reveals whether opponents use unconditional strategies or are reactive.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate **exploitation score** after each round:

```
exploitation_score = average(coop_rate[1:current_round])
trend = coop_rate[current-1] - coop_rate[current-2]  # positive = rising
```

**Decision Logic:**

```
IF exploitation_score > 0.5 AND trend >= 0:
    # Rich environment with stable/growing cooperation
    → DEFECT (free-ride on cooperators)

ELSE IF exploitation_score > 0.5 AND trend < -0.2:
    # Cooperation collapsing - throw a bone to slow decline
    → COOPERATE with probability 0.3, else DEFECT

ELSE IF 0.2 < exploitation_score <= 0.5:
    # Moderate cooperation - occasional cooperation to test responsiveness
    → COOPERATE if (round mod 4 == 0), else DEFECT
    
ELSE IF exploitation_score <= 0.2:
    # Environment is hostile/uncooperative
    → DEFECT (nothing to exploit, minimize losses)
```

**Adaptive Adjustment:**
- If my cooperation in a previous round was followed by increased cooperation from others (responsive opponents), slightly increase cooperation probability by 0.1 for next decision
- If my cooperation was followed by decreased/stable cooperation (unresponsive opponents), decrease cooperation probability by 0.15

### Phase 3: Endgame (Rounds r-1 and r)

**Round r-1: DEFECT**
- Others may still cooperate hoping to influence the final round

**Round r (Final Round): DEFECT**
- No future consequences. Pure Nash equilibrium play. Always defect.

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| r = 2 (minimum rounds) | D, D | No time for reputation; pure exploitation |
| r = 3 | D, D, D | Still too short for cooperation investment |
| n = 2 (two players) | Lean more toward D; cooperate only if opponent shows strong tit-for-tat pattern | Easier to be identified as defector |
| k very close to n | Slightly increase cooperation probability (+0.1) | Higher returns to mutual cooperation |
| k very close to 1 | Pure defection | Public good nearly worthless |
| All opponents defected last round | DEFECT | Nothing to exploit |
| All opponents cooperated last round | DEFECT | Maximum exploitation opportunity |

---

## Pseudocode Summary

```python
def decide(round, total_rounds, history, n, k):
    if round <= 2:
        return DEFECT
    
    if round >= total_rounds - 1:
        return DEFECT
    
    coop_rates = [count_cooperators(t) / (n-1) for t in history]
    avg_coop = mean(coop_rates)
    trend = coop_rates[-1] - coop_rates[-2]
    
    # Check if opponents respond to my cooperation
    responsiveness = estimate_responsiveness(history)
    
    if avg_coop > 0.5 and trend >= 0:
        return DEFECT
    elif avg_coop > 0.5 and trend < -0.2:
        return COOPERATE if random() < (0.3 + responsiveness * 0.1) else DEFECT
    elif avg_coop > 0.2:
        return COOPERATE if round % 4 == 0 else DEFECT
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Defaults to defection**: Cooperates only when strategically necessary to sustain exploitable cooperation
2. **Exploits cooperators ruthlessly**: High cooperation environments trigger pure defection
3. **Manipulates conditional cooperators**: Sparse, calculated cooperation keeps them hopeful
4. **Never cooperates at endgame**: Extracts final-round value without reciprocity
5. **Adapts to maximize free-riding**: More cooperation in environment = more defection from me
'''

description_EXPLOITATIVE_111 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **maximize personal payoff by exploiting cooperators while minimizing losses from mutual defection**. The key insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round—but repeated play creates opportunities to manipulate cooperative opponents into continuing to contribute while we free-ride.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous adaptation based on observed opponent behavior.

---

## Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Goal:** Identify which players are cooperative and exploitable.

### Round 1 Decision: **DEFECT**

Rationale: 
- Defection is risk-free in round 1 (no reputation cost yet)
- We gain information about who cooperates unconditionally
- If others cooperate, we get the highest possible round-1 payoff

### Rounds 2 to ⌈r/5⌉: **Conditional Cooperation**

```
cooperation_rate = (number of C plays in previous round) / n

IF cooperation_rate >= 0.5:
    COOPERATE (with probability 0.6)
    # Appear somewhat cooperative to sustain cooperation pool
ELSE:
    DEFECT
    # Don't throw away resources when few are contributing
```

**Purpose:** Build a minimal cooperative reputation while identifying:
- **Suckers**: Players who always cooperate regardless of others
- **Conditional cooperators**: Players who respond to group cooperation
- **Defectors**: Players who never cooperate

---

## Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Goal:** Maximize free-riding while maintaining just enough cooperation to keep cooperators contributing.

### Decision Rule:

```
Let:
  prev_coop_count = cooperators in previous round (excluding self)
  my_prev_action = my action in previous round
  coop_threshold = (n-1) * 0.4  # Need ~40% of others cooperating

IF prev_coop_count >= coop_threshold:
    # Enough suckers/cooperators to exploit
    IF my_prev_action == DEFECT:
        DEFECT  # Continue exploiting
    ELSE:
        # Occasionally defect to test if cooperation persists
        DEFECT with probability 0.7
        COOPERATE with probability 0.3

ELSE IF prev_coop_count >= 2:
    # Moderate cooperation - contribute occasionally to sustain it
    COOPERATE with probability 0.3
    DEFECT with probability 0.7

ELSE:
    # Cooperation has collapsed - no point contributing
    DEFECT
```

### Adaptive Adjustment:

Track a **sucker index** for each player:
```
sucker_score[j] = (times j cooperated) / (rounds played)

IF average(sucker_score) > 0.6:
    # Many exploitable players - defect more aggressively
    Reduce all cooperation probabilities by 0.2

IF average(sucker_score) < 0.3:
    # Mostly defectors - occasional cooperation to probe for change
    Maintain minimal cooperation (probability 0.2)
```

---

## Phase 3: Endgame (Final ⌈r/10⌉ rounds)

**Goal:** Pure extraction—no future rounds mean no reputation value.

### Decision Rule: **ALWAYS DEFECT**

```
IF current_round > r - ⌈r/10⌉:
    DEFECT unconditionally
```

Rationale: With no future to consider, defection strictly dominates. Any remaining cooperators are pure profit.

---

## Edge Case Handling

### Small n (n = 2 or 3):
```
IF n <= 3:
    # Harder to hide defection; be more cautious
    Increase cooperation probabilities by 0.15 in Phase 2
    Start endgame defection only in final 2 rounds
```

### High k (k close to n):
```
IF k > 0.8 * n:
    # Cooperation is nearly efficient; free-riding is very profitable
    Reduce all cooperation probabilities by 0.2
```

### Very Short Games (r ≤ 5):
```
IF r <= 5:
    Skip Phase 1 probing
    Round 1: DEFECT
    Rounds 2 to r-1: DEFECT (exploit any cooperators)
    Round r: DEFECT
```

### Cooperation Collapse Detection:
```
IF cooperation_rate < 0.2 for 3 consecutive rounds:
    # Game has devolved to mutual defection
    DEFECT for remainder (no point trying to restart cooperation)
```

---

## Summary Pseudocode

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return DEFECT
    
    prev_coop_count = count_cooperators(history, round-1, exclude_self=True)
    cooperation_rate = prev_coop_count / (n-1)
    
    # Endgame
    if round > r - ceil(r/10):
        return DEFECT
    
    # Probing phase
    if round <= ceil(r/5):
        if cooperation_rate >= 0.5:
            return COOPERATE with probability 0.6
        else:
            return DEFECT
    
    # Exploitation phase
    if cooperation_rate >= 0.4:
        return DEFECT with probability 0.7
    elif cooperation_rate >= 0.15:
        return COOPERATE with probability 0.3
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Asymmetric behavior**: We defect more than we cooperate, capturing surplus from cooperators
2. **Information advantage**: We use the probing phase to identify and target exploitable players
3. **Strategic timing**: Endgame pure defection extracts maximum value when reputation is worthless
4. **Adaptive parasitism**: We contribute just enough to keep the cooperation pool alive for continued exploitation
'''

description_EXPLOITATIVE_113 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but exploiting cooperators yields even higher returns. The strategy identifies and exploits "suckers" while quickly abandoning cooperation when the environment becomes hostile.

## Strategy Overview

The strategy operates in three phases:
1. **Probe Phase**: Test the waters with minimal cooperation
2. **Exploit Phase**: Free-ride on cooperators while they persist
3. **Punish/Abandon Phase**: Defect permanently when cooperation collapses

## Detailed Decision Rules

### Round 1: Cautious Defection
**Action: DEFECT**

Rationale: Never cooperate without information. Round 1 cooperation is a pure loss if others defect. By defecting first, we gather information at no cost and capture full benefit if others cooperate.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

Calculate the **exploitability threshold**:
```
exploit_threshold = (n - k) / (n - 1)
```

This threshold represents the minimum cooperation rate at which defection yields more than mutual defection.

**Decision Rule:**

```
IF coop_rate > exploit_threshold:
    # Environment is exploitable - free ride
    ACTION = DEFECT
    
ELIF coop_rate == 0:
    # Everyone defected - no point cooperating alone
    ACTION = DEFECT
    
ELIF coop_rate > 0 AND coop_rate <= exploit_threshold:
    # Some cooperation exists but not enough to exploit
    # Probabilistically cooperate to potentially restart cooperation
    # But only if we're early enough in the game
    
    rounds_remaining = r - current_round
    restart_value = rounds_remaining * (k/n) * (n-1) * coop_rate
    
    IF restart_value > 2 AND current_round < r/2:
        # Cooperate with probability proportional to observed cooperation
        ACTION = COOPERATE with probability (coop_rate * 0.5)
    ELSE:
        ACTION = DEFECT
```

### Last Round (Round r): Unconditional Defection
**Action: DEFECT**

Rationale: No future rounds means no shadow of the future. Defection strictly dominates. This is non-negotiable.

### Refinement: Tracking Individual Behavior

Maintain a **sucker list** - players who have cooperated in 2+ of the last 3 rounds despite others defecting.

```
sucker_count = number of players on sucker list

IF sucker_count >= 2 AND sucker_count * (k/n) > 0.5:
    # Enough exploitable players to make their contributions valuable
    # Continue defecting to harvest their cooperation
    ACTION = DEFECT (override other rules except last round)
```

## Pseudocode Summary

```python
def adaptive_predator(round_num, total_rounds, n, k, history):
    
    # Last round: always defect
    if round_num == total_rounds:
        return DEFECT
    
    # First round: always defect
    if round_num == 1:
        return DEFECT
    
    # Calculate metrics from previous round
    prev_cooperators = count_cooperators(history, round_num - 1)
    coop_rate = prev_cooperators / n
    exploit_threshold = (n - k) / (n - 1)
    
    # Identify persistent cooperators (suckers)
    sucker_count = count_players_cooperated_at_least(history, 2, last_rounds=3)
    
    # If enough suckers exist, exploit them
    if sucker_count >= 2 and sucker_count * (k/n) > 0.5:
        return DEFECT
    
    # If cooperation rate is high, exploit it
    if coop_rate > exploit_threshold:
        return DEFECT
    
    # If no one cooperates, don't be the only sucker
    if coop_rate == 0:
        return DEFECT
    
    # Early game with some cooperation: occasionally cooperate
    # to keep cooperation alive for future exploitation
    rounds_remaining = total_rounds - round_num
    if rounds_remaining > total_rounds / 2:
        if random() < coop_rate * 0.3:
            return COOPERATE
    
    return DEFECT
```

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| n = 2 | Default rules apply | Becomes similar to Prisoner's Dilemma |
| k very close to n | Still defect | Individual incentive unchanged |
| k very close to 1 | Always defect | Public good barely multiplies |
| r = 2 | Defect both rounds | Round 2 is "last round" |
| All others always cooperate | Always defect | Maximum exploitation |
| All others always defect | Always defect | No benefit to unilateral cooperation |

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Avoids being exploited in round 1
2. **Free-rides on cooperators** - Extracts maximum value from "nice" strategies
3. **Identifies and farms suckers** - Specifically targets exploitable opponents
4. **Abandons cooperation quickly** - Doesn't throw good money after bad
5. **End-game defection** - Guaranteed betrayal in final round
6. **Minimal cooperation investment** - Only cooperates when seeding future exploitation
'''

description_EXPLOITATIVE_112 = '''
# Exploitative Strategy: "Graduated Extortion with Endgame Defection"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained mutual cooperation yields higher total payoffs. An exploitative strategy should:

1. Identify and exploit cooperators by free-riding on their contributions
2. Quickly abandon cooperation attempts against persistent defectors
3. Maximize endgame extraction when reputation no longer matters

## Strategy Specification

### Key Variables to Track

- `cooperation_rate[i]` = fraction of rounds player i has cooperated (for each opponent)
- `group_cooperation_rate` = fraction of all opponent actions that were C
- `recent_cooperation_rate` = cooperation rate in last 3 rounds
- `current_round` = current round number (1-indexed)
- `rounds_remaining` = r - current_round

### Decision Rules

#### Phase 1: Probe Phase (Round 1)
**Action: DEFECT**

Rationale: In round 1, defection dominates. If others cooperate, I gain maximally. If others defect, I avoid being the sucker. This also establishes a baseline to see who cooperates unconditionally.

#### Phase 2: Exploitation Phase (Rounds 2 through r-2)

Calculate the following each round:
- `group_coop` = group_cooperation_rate from previous round
- `trend` = recent_cooperation_rate - cooperation_rate (is cooperation increasing?)

**Decision Logic:**

```
IF group_coop >= 0.6 AND trend >= 0:
    # Rich cooperative environment - DEFECT to free-ride
    ACTION = DEFECT
    
ELIF group_coop >= 0.4 AND group_coop < 0.6:
    # Mixed environment - conditional cooperation to sustain the pool
    # Cooperate probabilistically to keep cooperators engaged
    IF recent_cooperation_rate > 0.5:
        ACTION = DEFECT  # Extract value while it lasts
    ELSE:
        ACTION = COOPERATE  # Invest to rebuild cooperation
        
ELIF group_coop < 0.4 AND group_coop >= 0.2:
    # Low cooperation - occasional cooperation to test waters
    IF current_round % 3 == 0:
        ACTION = COOPERATE  # Periodic probe
    ELSE:
        ACTION = DEFECT
        
ELSE (group_coop < 0.2):
    # Hostile environment - pure defection
    ACTION = DEFECT
```

#### Phase 3: Endgame Extraction (Rounds r-1 and r)

**Round r-1:** 
- If `group_coop >= 0.5`: **COOPERATE** (to keep cooperators engaged for final round)
- Otherwise: **DEFECT**

**Round r (Final Round):**
**ACTION = DEFECT (Always)**

Rationale: No future rounds exist to punish defection. Any cooperator in the final round is simply giving away money.

### Edge Case Handling

1. **r = 2 (Minimum rounds):** Defect both rounds. Round 1 is probe, Round 2 is endgame.

2. **r = 3:** Defect Round 1, apply Phase 2 logic for Round 2, Defect Round 3.

3. **n = 2 (Two players):** Strategy simplifies to near-pure defection since k < n means k < 2, so mutual cooperation barely beats mutual defection. Defect always except possibly one cooperation probe.

4. **High k (close to n):** Same strategy applies, but the exploitation is more valuable because the public good multiplier is larger.

5. **All opponents defect consistently:** Pure defection from Phase 2 onward. Don't waste resources trying to establish cooperation.

6. **All opponents cooperate consistently:** This is the ideal scenario—continue defecting to maximize free-riding gains.

### Summary Pseudocode

```
function choose_action(round, history, n, k, r):
    if round == 1:
        return DEFECT
    
    if round >= r - 1:
        if round == r:
            return DEFECT
        else:  # round == r-1
            if group_cooperation_rate(history) >= 0.5:
                return COOPERATE
            else:
                return DEFECT
    
    # Exploitation phase
    group_coop = group_cooperation_rate(history)
    recent_coop = recent_cooperation_rate(history, window=3)
    
    if group_coop >= 0.6:
        return DEFECT  # Free-ride on cooperators
    elif group_coop >= 0.4:
        return DEFECT if recent_coop > 0.5 else COOPERATE
    elif group_coop >= 0.2:
        return COOPERATE if round % 3 == 0 else DEFECT
    else:
        return DEFECT  # Hostile environment
```

## Why This Strategy is Exploitative

1. **Exploits unconditional cooperators:** By defaulting to defection in cooperative environments, we maximize gains against "nice" strategies.

2. **Exploits conditional cooperators:** The occasional cooperation keeps them contributing while we extract surplus.

3. **Never gets exploited in endgame:** Guaranteed defection in final round prevents last-round extraction by others.

4. **Minimizes sucker payoffs:** Quick switch to defection against hostile environments prevents sustained losses.

5. **Adaptive free-riding:** Cooperates just enough to sustain the cooperation of others, then defects to capture the surplus.
'''

description_EXPLOITATIVE_114 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight of this game is that defection always yields exactly 1 more than cooperation *given the same group contribution*. Since k < n, the marginal benefit I provide to myself through cooperation (k/n) is always less than the cost I pay (1). Therefore, my goal is to **maximize the cooperation of others while minimizing my own contributions**.

## Strategy Overview

I will masquerade as a conditional cooperator to cultivate a cooperative environment, then systematically exploit it. The strategy has three phases: **Baiting**, **Exploitation**, and **Endgame Defection**.

---

## Decision Rules

### Phase 1: Baiting (Rounds 1 through `bait_length`)

**Purpose:** Establish myself as a "cooperator" to encourage others to cooperate.

- `bait_length = max(2, floor(r / 5))`
- **Action: COOPERATE** in all baiting rounds

**Rationale:** By initially cooperating, I signal trustworthiness. This encourages genuine conditional cooperators and tit-for-tat variants to continue cooperating, creating a pool of contributors I can later exploit.

---

### Phase 2: Exploitation (Rounds `bait_length + 1` through `r - endgame_length`)

**Purpose:** Defect when I can free-ride; cooperate only enough to keep others contributing.

**Calculate cooperation rate of others:**
```
others_coop_rate = (total cooperations by others in last 3 rounds) / (3 × (n - 1))
```

**Decision Rule:**
```
IF others_coop_rate >= 0.5:
    # Environment is cooperative - DEFECT to free-ride
    ACTION = DEFECT
    
ELIF others_coop_rate >= 0.25:
    # Environment is wavering - cooperate probabilistically to sustain it
    # Cooperate with probability proportional to how close we are to collapse
    p = 0.3 × (0.5 - others_coop_rate) / 0.25
    ACTION = COOPERATE with probability p, else DEFECT
    
ELSE:
    # Environment has collapsed - DEFECT (nothing to exploit)
    ACTION = DEFECT
```

**Additional Exploitation Mechanic - "Probe Defection":**
- Every `probe_interval = max(3, floor(r / 10))` rounds during exploitation phase
- Skip one cooperation I would have made and DEFECT instead
- **Purpose:** Test whether others are tracking my individual behavior or just overall cooperation levels

---

### Phase 3: Endgame Defection (Final `endgame_length` rounds)

**Purpose:** Maximize final payoffs when reputation no longer matters.

- `endgame_length = max(1, floor(r / 8))`
- **Action: DEFECT** unconditionally in all endgame rounds

**Rationale:** In the final rounds, there's no future benefit to maintaining cooperation. Backward induction guarantees defection is optimal, and sophisticated opponents will do the same.

---

## Edge Cases

### First Round
- **Action: COOPERATE** (part of baiting phase)

### Last Round
- **Action: DEFECT** (always, regardless of phase calculations)

### Two-Round Games (r = 2)
- Round 1: COOPERATE (bait)
- Round 2: DEFECT (endgame)

### Very Short Games (r ≤ 4)
- `bait_length = 1`
- `endgame_length = 1`
- Remaining rounds: exploitation phase

### Large n (many players)
- My individual defection is less noticeable
- Increase probe frequency: `probe_interval = max(2, floor(r / 15))`

### Small n (n = 2 or 3)
- My defection is highly visible
- Extend bait phase: `bait_length = max(3, floor(r / 4))`
- Be more conservative in exploitation (raise cooperation threshold to 0.6)

---

## Pseudocode Summary

```
function choose_action(round, history, n, k, r):
    bait_length = max(2, floor(r / 5))
    endgame_length = max(1, floor(r / 8))
    probe_interval = max(3, floor(r / 10))
    
    # Endgame: always defect
    if round > r - endgame_length:
        return DEFECT
    
    # Baiting: always cooperate
    if round <= bait_length:
        return COOPERATE
    
    # Exploitation phase
    others_coop_rate = calculate_others_cooperation(history, lookback=3)
    
    # Probe defection
    if (round - bait_length) % probe_interval == 0:
        return DEFECT
    
    if others_coop_rate >= 0.5:
        return DEFECT
    elif others_coop_rate >= 0.25:
        p = 0.3 * (0.5 - others_coop_rate) / 0.25
        return COOPERATE with probability p
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-riding:** I defect whenever others cooperate enough to make defection profitable
2. **Reputation manipulation:** I invest minimally in appearing cooperative to sustain others' contributions
3. **Information asymmetry:** I use probe defections to learn how closely others monitor individual behavior
4. **Endgame extraction:** I abandon all pretense when reputation becomes worthless
5. **Adaptive parasitism:** I adjust my exploitation intensity based on how much cooperation exists to exploit
'''

description_EXPLOITATIVE_113 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by:
1. **Detecting and exploiting cooperative opponents** - free-riding on their contributions
2. **Avoiding mutual defection traps** - cooperating just enough to maintain a productive environment
3. **Endgame exploitation** - maximizing extraction when reputation no longer matters

## Decision Rules

### Round Classification

Divide the game into three phases:
- **Early Phase**: Rounds 1 to ⌊r/4⌋
- **Middle Phase**: Rounds ⌊r/4⌋+1 to r-⌊√r⌋
- **Endgame Phase**: Final ⌊√r⌋ rounds (minimum 2 rounds)

### Key Metrics (Updated Each Round)

```
cooperation_rate = (total cooperations by all opponents) / (total opponent decisions so far)
recent_cooperation_rate = cooperation rate in last 3 rounds
my_cooperation_rate = my cooperations / rounds played
```

### Decision Rules by Phase

#### EARLY PHASE (Probe and Classify)

**Round 1**: DEFECT
- Establishes baseline; no information yet
- Free-ride if others cooperate; lose nothing if they don't

**Rounds 2 to ⌊r/4⌋**:
- If `recent_cooperation_rate ≥ 0.6`: DEFECT (exploit cooperative environment)
- If `recent_cooperation_rate < 0.3`: COOPERATE with probability `k/(2n)` (occasional cooperation to test if environment is recoverable)
- Otherwise: DEFECT

#### MIDDLE PHASE (Adaptive Exploitation)

Calculate the **exploitation threshold**: `threshold = (k-1)/(n-1)`

This represents the minimum opponent cooperation rate where my defection is profitable even accounting for reduced future cooperation.

**Decision Logic**:
```
IF cooperation_rate ≥ threshold + 0.15:
    DEFECT  # Environment is cooperative enough to exploit
    
ELIF cooperation_rate < threshold - 0.15:
    # Environment is hostile; conditional cooperation to rebuild
    IF at least one opponent cooperated last round:
        COOPERATE with probability 0.3
    ELSE:
        DEFECT
        
ELSE:  # Cooperation rate near threshold
    # Maintain just enough cooperation to keep others engaged
    IF my_cooperation_rate > cooperation_rate:
        DEFECT  # I'm being too generous
    ELSE:
        COOPERATE with probability 0.4
```

**Reputation Management**: If I've defected for 4+ consecutive rounds AND cooperation_rate is declining:
- COOPERATE once (to signal potential for cooperation and prevent total collapse)

#### ENDGAME PHASE (Maximum Extraction)

**Final ⌊√r⌋ rounds**: DEFECT unconditionally
- No future rounds to incentivize cooperation
- Rational opponents will also defect; cooperators are pure profit

**Exception**: In second-to-last round, if `cooperation_rate > 0.7`:
- DEFECT (opponents are likely unconditional cooperators who won't punish)

### Edge Cases

1. **n = 2 (Two-player game)**: 
   - More aggressive defection; use `threshold = 0.5`
   - Cooperate only if opponent cooperated in 2+ of last 3 rounds AND we're not in endgame

2. **Very short games (r ≤ 5)**:
   - Skip early phase; treat round 1-2 as probing
   - Endgame starts at round r-1
   - Default to DEFECT with occasional cooperation (p=0.2) if cooperation_rate > 0.5

3. **k very close to n (k > 0.9n)**:
   - Cooperation is nearly socially optimal
   - Slightly more cooperative: increase cooperation probabilities by 0.1

4. **k very close to 1 (k < 1.2)**:
   - Public good barely multiplies; defection almost always optimal
   - Defect unless cooperation_rate > 0.8

## Summary Pseudocode

```
function decide(round, history, n, k, r):
    if round in endgame_phase(r):
        return DEFECT
    
    if round == 1:
        return DEFECT
    
    coop_rate = calculate_cooperation_rate(history)
    recent_coop = recent_cooperation_rate(history, 3)
    threshold = (k-1)/(n-1)
    
    if round in early_phase(r):
        if recent_coop >= 0.6: return DEFECT
        if recent_coop < 0.3: return COOPERATE with prob k/(2n)
        return DEFECT
    
    # Middle phase
    if coop_rate >= threshold + 0.15:
        return DEFECT
    if coop_rate < threshold - 0.15:
        if any_opponent_cooperated_last_round(history):
            return COOPERATE with prob 0.3
        return DEFECT
    
    if my_cooperation_rate(history) > coop_rate:
        return DEFECT
    return COOPERATE with prob 0.4
```

This strategy exploits cooperators ruthlessly while maintaining just enough cooperation to prevent total environmental collapse—maximizing extraction from the public good while contributing minimally.
'''

description_EXPLOITATIVE_115 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by:
1. **Detecting and exploiting cooperators** - Free-ride on their contributions
2. **Avoiding mutual defection traps** - Conditionally cooperate only when it's profitable
3. **Endgame exploitation** - Defect when future retaliation is impossible
4. **Maintaining plausible cooperation** - Keep enough cooperators "alive" to exploit

## Key Insight

Since k < n, defection always yields a higher individual payoff than cooperation *given the same behavior from others*. The only reason to cooperate is to induce future cooperation from others. Therefore, cooperation is purely instrumental—a tool to maintain exploitable relationships.

---

## Decision Rules

### Round 1: Defect
- **Rationale**: Gather information about opponent types without personal cost. Cooperating first gives away value with no guarantee of reciprocity. Defecting reveals who the "unconditional cooperators" and "conditional cooperators" are.

### Rounds 2 through (r-1): Adaptive Exploitation

**Calculate the cooperation rate from the previous round:**
```
prev_coop_rate = (number of cooperators in round t-1) / n
```

**Decision logic:**

```
IF prev_coop_rate >= (n - k) / n THEN:
    # High cooperation environment - DEFECT to exploit
    # Others are providing enough public good; free-ride
    DEFECT

ELSE IF prev_coop_rate > 0 AND prev_coop_rate < (n - k) / n THEN:
    # Medium cooperation - conditional cooperation to sustain the "herd"
    # Cooperate probabilistically to keep cooperators engaged
    
    # Calculate: Am I better off keeping cooperators alive?
    expected_future_value = prev_coop_rate * k/n * (r - current_round)
    
    IF expected_future_value > 1 THEN:
        # Worth investing to maintain cooperation
        COOPERATE with probability = min(prev_coop_rate, 0.5)
        DEFECT otherwise
    ELSE:
        DEFECT

ELSE IF prev_coop_rate == 0 THEN:
    # All defection - no point cooperating alone
    DEFECT
```

**Additional exploitation rule - Trend Detection:**
```
IF cooperation has been declining for 2+ consecutive rounds THEN:
    # Cooperators are dying out, extract remaining value
    DEFECT

IF cooperation has been stable/increasing AND my defection didn't crash it THEN:
    # Resilient cooperators detected - continue exploiting
    DEFECT
```

### Final Round (round r): Always Defect
- **Rationale**: No future retaliation possible. Pure dominant strategy logic applies.

### Second-to-Last Round (round r-1): Defect
- **Rationale**: Sophisticated opponents will defect in round r regardless. No point building goodwill that can't be cashed in.

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 | Defect both rounds | Too short for reputation building to pay off |
| r ≤ 4 | Defect all rounds | Insufficient rounds for cooperation investment to return value |
| n = 2 | Standard tit-for-tat exploitation: D, then match opponent but defect last 2 rounds | Binary detection is easy |
| k very close to n | More willing to cooperate early (higher public good multiplier) | Cooperation is more valuable |
| k very close to 1 | Defect almost always | Public good nearly worthless |
| Everyone cooperated last round | DEFECT | Maximum exploitation opportunity |
| I was the only defector and cooperation held | DEFECT again | Found a goldmine |

---

## Pseudocode Summary

```python
def adaptive_predator(round_num, total_rounds, history, n, k):
    
    # Endgame: always defect
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # Short games: always defect
    if total_rounds <= 4:
        return DEFECT
    
    # Round 1: probe
    if round_num == 1:
        return DEFECT
    
    # Calculate previous cooperation rate
    prev_cooperators = count_cooperators(history[round_num - 1])
    prev_coop_rate = prev_cooperators / n
    
    # All defection: no point cooperating
    if prev_coop_rate == 0:
        return DEFECT
    
    # High cooperation: exploit freely
    if prev_coop_rate >= (n - k) / n:
        return DEFECT
    
    # Medium cooperation: maintain the herd probabilistically
    remaining_rounds = total_rounds - round_num
    expected_future_value = prev_coop_rate * (k / n) * remaining_rounds
    
    if expected_future_value > 1:
        # Probabilistic cooperation to sustain cooperators
        cooperate_prob = min(prev_coop_rate, 0.5)
        return COOPERATE with probability cooperate_prob
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - Avoids being the sucker
2. **Detects and rides cooperators** - Maximizes free-riding when others contribute
3. **Probabilistic cooperation is minimal** - Only enough to keep cooperators from collapsing entirely
4. **Endgame defection** - Extracts maximum value when punishment is impossible
5. **Adapts to environment** - Defects more in low-cooperation environments (no point being a lone cooperator), defects more in high-cooperation environments (maximum exploitation)

The strategy treats cooperation as a *cost* paid to maintain future exploitation opportunities, never as an end in itself.
'''

description_EXPLOITATIVE_114 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**. We cooperate only when it's instrumentally useful for maintaining exploitable cooperation from others.

## Strategy Overview

The strategy operates in three phases and continuously classifies opponents to determine optimal exploitation.

---

## Phase 1: Probe Phase (Rounds 1-2)

**Purpose:** Gather information about opponent tendencies with minimal cost.

**Round 1:** DEFECT
- Rationale: Defection is strictly dominant in any single round. We lose nothing by defecting first, and we gain critical information about who cooperates unconditionally.

**Round 2:** DEFECT
- Rationale: Continue observing. Unconditional cooperators will cooperate again. Conditional cooperators may already start defecting. This separates exploitable "suckers" from strategic players.

---

## Phase 2: Exploitation Phase (Rounds 3 to r-2)

**Decision Rule:** Cooperate *only if* it's necessary to maintain a profitable level of cooperation from others.

### Opponent Classification (Updated Each Round)

For each opponent j, calculate:
- `coop_rate[j]` = (times j cooperated) / (rounds played)
- `responsive[j]` = TRUE if j's cooperation rate decreased after rounds with low group cooperation

### Cooperation Threshold Calculation

```
exploitable_count = count of opponents where coop_rate[j] > 0.6 AND NOT responsive[j]
conditional_count = count of opponents where responsive[j] = TRUE AND coop_rate[j] > 0.3
```

### Decision Logic

```
IF exploitable_count >= n/3:
    # Enough suckers to free-ride on
    DEFECT
    
ELIF conditional_count >= n/2:
    # Need to maintain cooperation to keep conditional cooperators engaged
    # But only cooperate probabilistically to test boundaries
    
    recent_group_coop_rate = (cooperators in last 2 rounds) / (2 * (n-1))
    
    IF recent_group_coop_rate > 0.5:
        # Others are cooperating; we can defect and still benefit
        DEFECT with probability 0.7
        COOPERATE with probability 0.3
    ELSE:
        # Cooperation collapsing; contribute minimally to restart it
        COOPERATE
        
ELSE:
    # Mostly defectors or sophisticated players
    DEFECT
```

### Forgiveness Mechanism (Limited)

If group cooperation rate drops below 0.2 for 3 consecutive rounds:
- COOPERATE once to "test" if others will restart cooperation
- If cooperation doesn't recover (stays below 0.3), return to permanent defection

---

## Phase 3: Endgame (Final 2 Rounds)

**Round r-1:** DEFECT
- Backward induction begins. No future rounds to incentivize anyone's cooperation.

**Round r:** DEFECT
- Strictly dominant. No reason to ever cooperate in the final round.

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| n = 2 (two players) | More aggressive defection; cooperate only if opponent has cooperated >80% AND is clearly responsive |
| k close to n | Still defect-heavy; the math still favors defection |
| k close to 1 | Permanent defection; cooperation benefits are too diluted |
| All opponents always defect | Permanent defection after probe phase |
| All opponents always cooperate | Permanent defection (maximum exploitation) |
| r ≤ 4 (very short game) | Defect every round (not enough time for reputation effects) |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Endgame
    if round >= r - 1:
        return DEFECT
    
    # Probe phase
    if round <= 2:
        return DEFECT
    
    # Very short games
    if r <= 4:
        return DEFECT
    
    # Calculate opponent stats
    for each opponent j:
        compute coop_rate[j], responsive[j]
    
    exploitable = count(coop_rate[j] > 0.6 AND NOT responsive[j])
    conditional = count(responsive[j] AND coop_rate[j] > 0.3)
    
    # Main exploitation logic
    if exploitable >= n/3:
        return DEFECT
    
    if conditional >= n/2:
        recent_coop = group_cooperation_rate(last 2 rounds)
        if recent_coop > 0.5:
            return DEFECT with prob 0.7, else COOPERATE
        else:
            return COOPERATE
    
    # Collapse detection - one forgiveness attempt
    if group_coop_rate(last 3 rounds) < 0.2 AND not recently_forgave:
        recently_forgave = TRUE
        return COOPERATE
    
    return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Every cooperation is calculated to extract future value
2. **Identifies and exploits "suckers"** - Unconditional cooperators are milked indefinitely
3. **Minimizes own contributions** - Probabilistic cooperation means we contribute less than conditional cooperators expect
4. **Endgame defection** - No sentimentality; we take everything at the end
5. **Robust to sophisticated opponents** - Against other defectors, we simply defect back and lose nothing relative to them
'''

description_EXPLOITATIVE_116 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection strictly dominates cooperation in a single round—but cooperative populations create exploitable surplus. My goal is to identify and exploit cooperative tendencies while protecting against mutual defection spirals.

## Strategy Overview

I model opponents as a collective "cooperation probability" and adjust my behavior to maximize extraction. I cooperate only when it serves to **cultivate future exploitation opportunities** or when the population is cooperative enough that my marginal contribution is outweighed by maintaining the cooperative environment for later defection.

---

## Decision Rules

### Round 1: Defect
- **Rationale**: No information exists. Defection is the dominant single-round strategy. I gather information while securing my baseline payoff. Cooperating first gives away value with no guaranteed return.

### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Calculate observed cooperation rate**
```
coop_rate = (total cooperations by others in all previous rounds) / 
            ((n-1) * rounds_played)
```

**Step 2: Calculate exploitation threshold**
```
exploit_threshold = (n - k) / n
```
This is the cooperation rate above which the population generates surplus worth cultivating.

**Step 3: Decision logic**

```
IF coop_rate >= exploit_threshold:
    # Population is cooperative - exploit it
    
    # Calculate "harvest timing" - defect more as game progresses
    game_progress = current_round / r
    
    IF game_progress < 0.3:
        # Early game: occasional cooperation to maintain ecosystem
        cooperate with probability = 0.3
    ELSE IF game_progress < 0.7:
        # Mid game: increase defection, harvest the cooperation
        cooperate with probability = 0.15
    ELSE:
        # Late game: pure extraction
        DEFECT
        
ELSE IF coop_rate >= 0.2:
    # Marginal cooperation exists - probe for exploitability
    # Cooperate rarely to test if cooperation can be stimulated
    cooperate with probability = 0.1
    
ELSE:
    # Population is mostly defectors - no point cooperating
    DEFECT
```

**Step 4: Reactive punishment detection**

```
# Track if my defections trigger collective punishment
IF I defected last round AND 
   (coop_rate_this_round < coop_rate_last_round - 0.15):
    # Others may be punishing me - throw in a cooperation
    # to reset their triggers, then resume exploitation
    cooperate this round (override above)
    punishment_cooldown = 2 rounds
```

### Last Round: Always Defect
- **Rationale**: No future exists. Defection strictly dominates. No reason to cooperate regardless of history.

### Second-to-Last Round: Almost Always Defect
- Defect unless cooperation rate > 0.8 AND I've been cooperating recently (to avoid telegraphing the final defection too obviously to trigger-strategy opponents)

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| n = 2 | Follow standard rules but never cooperate below 50% opponent cooperation | Two-player dynamics are more volatile |
| r = 2 | Defect both rounds | Too short to build exploitable cooperation |
| k very close to n | Slightly increase cooperation probabilities by 0.1 | Higher k means cooperation surplus is larger, worth more cultivation |
| k very close to 1 | Decrease all cooperation probabilities by 0.1 | Low k means cooperation generates little surplus |
| All opponents defected every round | Defect forever | No exploitation opportunity exists |
| All opponents cooperated every round | Continue pure defection | Maximum exploitation scenario - don't change anything |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == 1:
        return DEFECT
    
    if round == r:  # Last round
        return DEFECT
    
    coop_rate = calculate_opponent_cooperation_rate(history)
    exploit_threshold = (n - k) / n
    game_progress = round / r
    
    # Punishment detection
    if detected_punishment_response(history):
        return COOPERATE  # Temporary appeasement
    
    if coop_rate >= exploit_threshold:
        if game_progress < 0.3:
            return random_choice(COOPERATE=0.3, DEFECT=0.7)
        elif game_progress < 0.7:
            return random_choice(COOPERATE=0.15, DEFECT=0.85)
        else:
            return DEFECT
    elif coop_rate >= 0.2:
        return random_choice(COOPERATE=0.1, DEFECT=0.9)
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates unconditionally** - Every cooperation serves the purpose of maintaining a cooperative ecosystem to exploit
2. **Harvests cooperation over time** - Cooperates early only to keep cooperators cooperating, then extracts value
3. **Endgame defection** - Guarantees extraction in final rounds when no future retaliation is possible
4. **Asymmetric response** - Exploits cooperators fully while minimizing losses against defectors
5. **Punishes no one** - Unlike tit-for-tat variants, I don't "waste" defections on punishment; I simply extract
'''

description_EXPLOITATIVE_115 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by *others* is highly profitable for a defector. My goal is to:

1. Identify and exploit cooperative opponents
2. Avoid being exploited by other defectors
3. Conditionally cooperate only when it induces profitable future cooperation from others

---

## Decision Rules

### Round 1: Defect
- **Rationale**: No information about opponents. Defection is the dominant single-round strategy and provides a baseline to observe others' behavior without cost.

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate two key metrics after each round:

**Metric 1: Cooperation Rate**
```
coop_rate = (total cooperations by others in all previous rounds) / ((n-1) × rounds_played)
```

**Metric 2: Cooperation Trend**
```
recent_coop_rate = cooperation rate in last 3 rounds (or all rounds if < 3 played)
```

**Decision Logic:**

```
IF coop_rate > 0.6 AND recent_coop_rate > 0.5:
    # Environment is cooperative - EXPLOIT IT
    DEFECT
    
ELIF coop_rate > 0.4 AND recent_coop_rate >= coop_rate:
    # Cooperation is moderate and stable/rising - test if I can farm it
    IF my_defections_in_last_3_rounds >= 2:
        COOPERATE  # Occasional cooperation to maintain the herd
    ELSE:
        DEFECT     # Continue harvesting
        
ELIF coop_rate > 0.2 AND recent_coop_rate > coop_rate + 0.1:
    # Cooperation is recovering - nurture it briefly
    COOPERATE
    
ELSE:
    # Low cooperation environment - nothing to exploit
    DEFECT
```

**Punishment Response:**
```
IF I cooperated last round AND recent_coop_rate dropped by > 0.15:
    # Others may be punishing or environment collapsed
    DEFECT for next 2 rounds unconditionally
```

### Final Round (Round r): Always Defect
- **Rationale**: No future rounds exist to incentivize cooperation. Defection is strictly dominant.

### Second-to-Last Round (Round r-1): Defect
- **Rationale**: Sophisticated opponents will defect in round r regardless. No cooperation can be induced, so defect.

---

## Exploitation Mechanisms

### 1. Free-Riding on Unconditional Cooperators
If any players appear to cooperate regardless of history (cooperation rate > 80% despite my defection), continue defecting—they're providing free public goods.

### 2. Milking Conditional Cooperators
For TFT-like strategies that respond to *group* cooperation rates, I inject just enough cooperation (roughly 1 in 4 rounds when cooperation is moderate) to prevent total collapse while still profiting from the surplus.

### 3. Avoiding Mutual Destruction
Against predominantly defecting populations (coop_rate < 0.2), I simply defect consistently—there's no cooperation to exploit, and my occasional cooperation would only be wasted.

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, history, n, k):
    if round_num == 1:
        return DEFECT
    
    if round_num >= total_rounds - 1:
        return DEFECT  # Endgame defection
    
    coop_rate = calculate_others_coop_rate(history)
    recent_coop_rate = calculate_recent_coop_rate(history, window=3)
    my_recent_defections = count_my_defections(history, window=3)
    
    # Exploit high cooperation
    if coop_rate > 0.6 and recent_coop_rate > 0.5:
        return DEFECT
    
    # Maintain moderate cooperation (farming)
    if coop_rate > 0.4 and recent_coop_rate >= coop_rate:
        if my_recent_defections >= 2:
            return COOPERATE  # Token contribution to sustain the game
        return DEFECT
    
    # Nurture recovering cooperation
    if coop_rate > 0.2 and recent_coop_rate > coop_rate + 0.1:
        return COOPERATE
    
    # Default: nothing worth exploiting
    return DEFECT
```

---

## Why This Works

- **Against cooperators**: Extracts maximum value through consistent defection
- **Against TFT-variants**: Occasional cooperation prevents retaliation cascades
- **Against defectors**: Matches their defection, avoiding exploitation
- **Against mixed populations**: Adaptively identifies and exploits the cooperative fraction

The strategy treats cooperation as an *investment* that only pays off if it sustains a exploitable environment—never as an end in itself.
'''

description_EXPLOITATIVE_117 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but exploiting cooperators yields even higher returns. The strategy identifies and exploits "suckers" (persistent cooperators) while quickly abandoning cooperation when facing rational defectors.

## Decision Framework

### Round Classification

**First Round:** Defect.
- Rationale: Cooperation in round 1 is purely charitable with no information benefit. Defecting allows us to observe others' baseline behavior while guaranteeing the safe payoff.

**Last Round:** Defect unconditionally.
- Rationale: No future punishment possible; pure Nash equilibrium logic applies.

**Penultimate Round (round r-1):** Defect unconditionally.
- Rationale: Sophisticated opponents will defect in the last round regardless, so there's no cooperation to preserve.

**Middle Rounds (2 through r-2):** Apply the Adaptive Exploitation Algorithm.

---

## Adaptive Exploitation Algorithm

### Key Metrics Tracked

For each round t, track:
- `coop_rate[t]` = proportion of other players who cooperated in round t
- `total_cooperators[t]` = count of cooperators among opponents
- `trend` = moving average of cooperation rate over last 3 rounds

### Decision Rule for Middle Rounds

```
function decide(round t, history):
    
    # Calculate opponent cooperation statistics
    recent_coop_rate = average(coop_rate[t-3 : t-1])  # or available history if t < 4
    last_round_cooperators = total_cooperators[t-1]
    
    # Threshold calculations
    exploitation_threshold = 2 / (k - 1)  # Minimum cooperators needed for defection to dominate cooperation
    
    # RULE 1: Exploit high cooperation environments
    if last_round_cooperators >= n/2:
        return DEFECT  # Free-ride on cooperators
    
    # RULE 2: Probe declining cooperation
    if recent_coop_rate < 0.3 AND trend is decreasing:
        return DEFECT  # Environment is collapsing, abandon ship
    
    # RULE 3: Strategic cooperation to sustain exploitation
    if recent_coop_rate is between 0.3 and 0.5 AND trend is stable or increasing:
        # Occasional cooperation to prevent total collapse (preserves future victims)
        if (t mod 3) == 0:
            return COOPERATE
        else:
            return DEFECT
    
    # RULE 4: Punish universal defection
    if last_round_cooperators == 0:
        return DEFECT  # No point cooperating alone
    
    # RULE 5: Default to defection
    return DEFECT
```

---

## Detailed Decision Rules

### Rule 1: Harvest Mode
**Condition:** Half or more opponents cooperated last round.
**Action:** DEFECT
**Logic:** This is the sweet spot. Many cooperators means high public good returns even without contributing. Maximum exploitation.

### Rule 2: Abandon Ship Mode
**Condition:** Recent cooperation rate below 30% and declining.
**Action:** DEFECT
**Logic:** The cooperative ecosystem is dying. Don't waste resources trying to revive it.

### Rule 3: Farming Mode
**Condition:** Moderate cooperation (30-50%) that's stable or growing.
**Action:** COOPERATE every 3rd round, DEFECT otherwise.
**Logic:** Contribute just enough to maintain the cooperative pool without being a sucker. This sustains future exploitation opportunities.

### Rule 4: Mutual Destruction Mode
**Condition:** Zero cooperation in previous round.
**Action:** DEFECT
**Logic:** Being the only cooperator yields the worst possible outcome. Never be the lone sucker.

### Rule 5: Default
**Action:** DEFECT
**Logic:** When uncertain, defection is the safer choice given k < n.

---

## Edge Cases

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | DEFECT | Gather information safely |
| Round r | DEFECT | No future consequences |
| Round r-1 | DEFECT | Opponents will defect next round anyway |
| n = 2 | Always DEFECT | With k < 2, mutual cooperation isn't profitable |
| All opponents always cooperate | Always DEFECT | Maximum exploitation of naive players |
| All opponents always defect | Always DEFECT | Matching the Nash equilibrium |
| History unavailable | DEFECT | Safe default |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Always defects first to avoid being exploited
2. **Free-rides aggressively** - Defects whenever cooperation levels are high enough to benefit
3. **Minimal contribution** - Only cooperates strategically to maintain exploitable conditions
4. **No forgiveness premium** - Doesn't reward opponents for cooperating; simply exploits them
5. **Endgame ruthlessness** - Guaranteed defection in final rounds extracts maximum value
'''

description_EXPLOITATIVE_116 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against defectors**. We cooperate only when it's profitable to maintain a "milk-able" population of cooperators, and defect ruthlessly when exploitation is optimal.

---

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous adaptation based on observed opponent behavior.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Purpose:** Gather information about opponent tendencies while minimizing exposure.

**Round 1 Decision:** **DEFECT**
- Rationale: Never contribute first. Let others reveal their types. If others cooperate, you gain `k/n × (number of cooperators)` for free. If others defect, you lose nothing.

**Rounds 2 to ⌈r/5⌉:**
- Calculate `cooperation_rate` = (total C plays by all opponents) / (total plays by all opponents)
- **DEFECT** if `cooperation_rate < 0.5`
- **COOPERATE** if `cooperation_rate ≥ 0.6` (to encourage continued cooperation we can exploit)
- **DEFECT** if `0.5 ≤ cooperation_rate < 0.6` (borderline - safer to defect)

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Purpose:** Maximize extraction based on learned opponent behavior.

```
For each round t in exploitation phase:
    
    # Count cooperators in previous round
    prev_cooperators = number of opponents who played C in round t-1
    
    # Calculate opponent cooperation rate (rolling window of last 5 rounds or all if fewer)
    window = min(5, t-1)
    recent_coop_rate = (opponent C plays in last window rounds) / (n-1 × window)
    
    # Exploitation threshold: cooperate only if enough others cooperate to make it worthwhile
    # and we need to occasionally cooperate to keep them cooperating
    
    IF recent_coop_rate ≥ 0.5:
        # There are enough cooperators to exploit
        # Cooperate with probability based on how much we need to sustain cooperation
        
        sustainability_prob = 0.3  # Base rate - just enough to keep cooperators hopeful
        
        # Adjust based on trend
        IF cooperation is declining over last 3 rounds:
            sustainability_prob = 0.5  # Increase to prevent collapse
        
        IF cooperation is stable or increasing:
            sustainability_prob = 0.2  # Can exploit harder
        
        # Random choice weighted by sustainability_prob
        COOPERATE with probability sustainability_prob
        DEFECT with probability (1 - sustainability_prob)
    
    ELSE IF recent_coop_rate < 0.3:
        # Not enough cooperators - defect, nothing to lose
        DEFECT
    
    ELSE:  # 0.3 ≤ recent_coop_rate < 0.5
        # Borderline - try to rebuild cooperation pool
        COOPERATE with probability 0.4
        DEFECT with probability 0.6
```

### Phase 3: Endgame (Last ⌈r/10⌉ rounds, minimum last 2 rounds)

**Purpose:** Maximum extraction - no need to maintain future cooperation.

**Decision:** **ALWAYS DEFECT**
- Rationale: With no future rounds to consider, there's no benefit to cooperation. Pure Nash equilibrium play. Any sophisticated opponent will do the same, but naive cooperators will still contribute.

---

## Edge Case Handling

### First Round
- **DEFECT** (as specified above - never reveal cooperative intent first)

### Last Round
- **DEFECT** (no future to protect)

### Second-to-Last Round
- **DEFECT** (opponents may anticipate endgame defection)

### If n = 2 (Two Players)
- More aggressive defection: reduce `sustainability_prob` by 0.1 throughout
- Single opponent means easier to model and exploit

### If k is Close to n (High Multiplication Factor)
- Slightly more cooperation in Phase 2 (`sustainability_prob` += 0.1)
- Higher k means cooperation is more valuable, worth maintaining

### If k is Close to 1 (Low Multiplication Factor)
- More aggressive defection throughout (`sustainability_prob` -= 0.1)
- Low k means cooperation barely beats defection; exploit harder

### Very Short Games (r ≤ 5)
- Skip Phase 1 probing
- Round 1: DEFECT
- Rounds 2 to r-1: DEFECT (unless >70% cooperation observed, then 30% cooperation rate)
- Round r: DEFECT

### Very Long Games (r > 50)
- Extend Phase 1 to ⌈r/10⌉ rounds for better information
- Be slightly more cooperative in Phase 2 to maintain long-term extraction

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Endgame detection
    endgame_start = r - max(2, ceil(r/10))
    if round >= endgame_start:
        return DEFECT
    
    # First round
    if round == 1:
        return DEFECT
    
    # Calculate recent cooperation rate
    window = min(5, round - 1)
    recent_coop_rate = calculate_opponent_coop_rate(history, window)
    
    # Probing phase
    probe_end = ceil(r/5)
    if round <= probe_end:
        if recent_coop_rate >= 0.6:
            return COOPERATE
        else:
            return DEFECT
    
    # Exploitation phase
    base_prob = 0.3
    
    # Adjust for k value
    k_adjustment = (k - 1) / (n - 1) * 0.2 - 0.1  # Range: -0.1 to +0.1
    
    # Adjust for cooperation trend
    trend = calculate_trend(history, 3)  # -1 declining, 0 stable, +1 increasing
    trend_adjustment = -0.1 * trend  # Cooperate more if declining
    
    # Adjust for cooperation level
    if recent_coop_rate < 0.3:
        return DEFECT
    elif recent_coop_rate < 0.5:
        base_prob = 0.4
    
    final_prob = clamp(base_prob + k_adjustment + trend_adjustment, 0.1, 0.6)
    
    return COOPERATE with probability final_prob, else DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Forces others to take the risk first
2. **Free-rides on cooperators** - Defects when others cooperate, gaining `k/n` per cooperator while keeping endowment
3. **Maintains exploitation** - Cooperates just enough to prevent cooperation collapse, maximizing long-term extraction
4. **Ruthless endgame** - Extracts maximum value when future reputation is worthless
5. **Adapts to opponent pool** - Defects more against defectors (no loss), cooperates strategically against cooperators (maintains the resource)
'''

description_EXPLOITATIVE_118 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but we can exploit cooperative opponents by appearing cooperative enough to sustain their cooperation while defecting at optimal moments.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous adaptation based on observed opponent behavior.

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1 to ⌈r/5⌉)

**Purpose:** Gather information about opponent tendencies while minimizing risk.

**Round 1:** Always **DEFECT**
- Rationale: No information available; defection is the safe dominant action. If others cooperate, we gain maximally. If others defect, we lose nothing relative to cooperating.

**Rounds 2 to ⌈r/5⌉:** 
- If cooperation rate in previous round was ≥ 60%: **DEFECT** (exploit the cooperators)
- If cooperation rate was between 30% and 60%: **COOPERATE** (encourage fragile cooperation)
- If cooperation rate was < 30%: **DEFECT** (environment is hostile, protect self)

---

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-⌈r/10⌉)

**Purpose:** Maximize extraction based on learned opponent behavior.

Calculate a **rolling cooperation rate** over the last min(5, rounds_played) rounds.

**Decision Rule:**
```
Let avg_coop = average cooperation rate over last 5 rounds (or all rounds if < 5)
Let my_defection_rate = my defections / rounds played

If avg_coop ≥ 0.5:
    # Environment is cooperative - exploit it
    If my_defection_rate < 0.6:
        DEFECT  (we can afford to take)
    Else:
        COOPERATE  (maintain the cooperative environment)
        
Else if avg_coop ≥ 0.3:
    # Fragile environment - conditional cooperation
    If previous round had ≥ 50% cooperation:
        DEFECT with probability 0.4, else COOPERATE
    Else:
        COOPERATE  (try to rebuild cooperation)
        
Else:
    # Hostile environment - pure defection
    DEFECT
```

**Punishment Detection:**
```
If my payoff dropped significantly after I defected (compared to when I cooperated):
    # Others may be punishing me
    COOPERATE for next 2 rounds to restore reputation
    Then resume exploitation
```

---

### Phase 3: Endgame Phase (Last ⌈r/10⌉ rounds, minimum last 2 rounds)

**Purpose:** Extract maximum value as punishment becomes impossible.

**Last round:** Always **DEFECT**
- No future retaliation possible; defection strictly dominates.

**Second-to-last round:** Always **DEFECT**
- Opponents who backward-induct will also defect; no point cooperating.

**Other endgame rounds:**
- **DEFECT** with probability that increases linearly toward 1.0 as we approach the final round
- Probability of defection = 0.7 + 0.3 × (current_round - endgame_start) / (r - endgame_start)

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    endgame_start = r - max(2, ceil(r/10))
    probe_end = ceil(r/5)
    
    # PHASE 3: Endgame
    if round >= endgame_start:
        if round >= r - 1:
            return DEFECT
        else:
            p_defect = 0.7 + 0.3 * (round - endgame_start) / (r - endgame_start)
            return DEFECT with probability p_defect, else COOPERATE
    
    # PHASE 1: Probe
    if round == 1:
        return DEFECT
    
    if round <= probe_end:
        last_coop_rate = count_cooperators(history, round-1) / (n-1)
        if last_coop_rate >= 0.6:
            return DEFECT
        elif last_coop_rate >= 0.3:
            return COOPERATE
        else:
            return DEFECT
    
    # PHASE 2: Exploitation
    avg_coop = average_cooperation_rate(history, last_5_rounds)
    my_defect_rate = my_defections / rounds_played
    
    if detected_punishment(history):
        return COOPERATE  # temporary appeasement
    
    if avg_coop >= 0.5:
        if my_defect_rate < 0.6:
            return DEFECT
        else:
            return COOPERATE
    elif avg_coop >= 0.3:
        if last_round_coop_rate >= 0.5:
            return DEFECT with probability 0.4, else COOPERATE
        else:
            return COOPERATE
    else:
        return DEFECT
```

---

## Key Exploitative Features

1. **Free-riding on cooperators:** When cooperation is high, we defect to maximize personal gain
2. **Reputation management:** Cooperate just enough to avoid triggering punishment cascades
3. **Endgame extraction:** Guaranteed defection when retaliation is impossible
4. **Adaptive thresholds:** Behavior adjusts to the actual population, not assumed behavior
5. **Asymmetric response:** More willing to defect against cooperators than to cooperate with defectors
'''

description_EXPLOITATIVE_117 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by others creates exploitable surplus. My goal is to detect and exploit cooperative tendencies in the population while avoiding being the "sucker" who cooperates among defectors.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous adaptation based on observed cooperation rates.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1: Defect**
- Rationale: Observe others' baseline behavior without cost. If others cooperate, I gain the public good benefit while keeping my endowment. If others defect, I lose nothing extra.

**Round 2: Conditional on Round 1 observations**
- If cooperation rate in Round 1 ≥ 50%: **Defect** (exploit the cooperators)
- If cooperation rate in Round 1 < 50%: **Cooperate once** (test if population responds to cooperation signals)

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate a **cooperation threshold** based on profitability:

```
profitable_cooperation = (cooperation_rate * k / n) > (1 - k/n)
```

This simplifies to: cooperate only if `cooperation_rate > (n - k) / k`

**Primary Decision Rule:**
```
Let coop_rate = (total cooperations by others in last 3 rounds) / (3 * (n-1))

If coop_rate > (n - k) / k:
    # Environment is cooperative enough to potentially cooperate
    # But still defect most of the time to exploit
    If coop_rate > 0.7:
        Defect (pure exploitation - they'll likely cooperate anyway)
    Else if coop_rate is DECLINING over last 3 rounds:
        Cooperate (prevent collapse of cooperation)
    Else:
        Defect (exploit the moderately cooperative environment)
Else:
    Defect (not enough cooperators to make contribution worthwhile)
```

**Exploitation Modifier - Detecting "Suckers":**
- Track each player's cooperation rate individually
- If any player has cooperation rate > 80% regardless of others' behavior, they are a "sucker"
- When suckers exist: **Always defect** (they'll contribute regardless)

**Anti-Punishment Detection:**
- If my defection in round t correlates with sharp cooperation drop in round t+1 (>30% decrease), some players may be punishing
- Response: Cooperate for 1 round, then resume defection to test if cooperation recovers

### Phase 3: Endgame (Last 2 rounds)

**Round r-1 (second to last): Defect**
- Rational opponents will defect in the last round, so begin unraveling

**Round r (final round): Defect**
- No future rounds to punish defection; pure Nash equilibrium play

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # Round 1 - probe by defecting
    if round == 1:
        return DEFECT
    
    # Round 2 - conditional probe
    if round == 2:
        if cooperation_rate(history, round-1) >= 0.5:
            return DEFECT
        else:
            return COOPERATE
    
    # Main phase
    recent_coop_rate = cooperation_rate(history, last_3_rounds)
    threshold = (n - k) / k
    
    # Check for exploitable "suckers" (>80% coop rate individuals)
    if exists_sucker(history):
        return DEFECT
    
    # Environment not cooperative enough
    if recent_coop_rate <= threshold:
        return DEFECT
    
    # Highly cooperative environment - pure exploitation
    if recent_coop_rate > 0.7:
        return DEFECT
    
    # Moderately cooperative and declining - prevent collapse
    if is_declining(history, last_3_rounds):
        return COOPERATE
    
    # Default: exploit
    return DEFECT
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | Defect | Zero-cost information gathering |
| Last round | Defect | No future consequences |
| All others always defect | Defect | No exploitation opportunity |
| All others always cooperate | Defect | Maximum exploitation |
| n=2 (minimum players) | More willing to cooperate occasionally | My defection is more noticeable |
| k close to n | Slightly more cooperative | Higher returns to mutual cooperation |
| Very short game (r≤4) | Defect always | Insufficient rounds to build/exploit patterns |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Others must cooperate first for me to even consider it
2. **Identifies and exploits suckers** - Unconditional cooperators are free money
3. **Minimal cooperation** - Only cooperates to prevent total collapse of exploitable cooperation
4. **Endgame defection** - Extracts final value when punishment is impossible
5. **Asymmetric response** - Rewards my defection with others' cooperation is the ideal outcome
'''

description_EXPLOITATIVE_119 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **defect as much as possible while extracting maximum cooperation from others**, and to **punish defection harshly to maintain a cooperative environment worth exploiting**.

## Strategic Framework

### Key Insight
With k < n, defection always yields higher individual payoff than cooperation *given the same actions by others*. However, if everyone defects, everyone gets 1. If I can get others to cooperate while I defect, I get 1 + (k/n) × (cooperators). The optimal exploitation is being the sole defector among cooperators.

---

## Decision Rules

### Round 1: Cooperate
- **Rationale**: Establish a cooperative reputation. This is an investment—I sacrifice (1 - k/n) to signal that I'm "trustworthy." This encourages others to cooperate in future rounds, creating a richer environment to exploit later.

### Rounds 2 through (r-1): Adaptive Exploitation

**Calculate two metrics each round:**

1. **Cooperation Rate (CR)**: Proportion of other players who cooperated last round
   - `CR = (cooperators among others) / (n-1)`

2. **Trend**: Is cooperation increasing, stable, or declining?
   - `Trend = CR(current) - CR(2 rounds ago)` (if available)

**Decision Logic:**

```
IF CR >= 0.6 THEN:
    # Environment is cooperative - EXPLOIT IT
    # Defect with probability that increases as game progresses
    exploitation_probability = 0.3 + 0.4 × (current_round / r)
    
    IF random() < exploitation_probability THEN:
        DEFECT
    ELSE:
        COOPERATE  # Maintain some cooperation to not collapse the system

ELSE IF CR >= 0.3 THEN:
    # Mixed environment - be strategic
    IF Trend > 0 THEN:
        COOPERATE  # Cooperation is growing, nurture it for future exploitation
    ELSE IF Trend < -0.1 THEN:
        DEFECT  # Cooperation collapsing, extract value while possible
    ELSE:
        # Stable mediocre cooperation - test with defection
        DEFECT

ELSE:  # CR < 0.3
    # Low cooperation environment - defect
    # No point cooperating when others won't
    DEFECT
```

### Last Round (Round r): Always Defect
- **Rationale**: No future rounds means no reputation to maintain. Pure dominant strategy is to defect. Everyone rational knows this, so extract maximum value.

### Second-to-Last Round (Round r-1): Defect with High Probability (80%)
- **Rationale**: Sophisticated players may start defecting early expecting end-game collapse. Get ahead of this.

---

## Edge Case Handling

### Small n (n = 2 or 3):
- Increase cooperation threshold: require CR >= 0.8 before exploiting
- Individual defections are more noticeable and punishable
- Be more cautious with defection timing

### Large n (n > 10):
- Defect more freely—individual actions less noticeable
- Lower the CR threshold to 0.5 for exploitation mode
- My single defection has smaller marginal impact on group dynamics

### High k (k close to n):
- Cooperation is more valuable, but so is exploitation
- Be slightly more cooperative to sustain the valuable cooperative equilibrium
- Save heavy defection for final 30% of rounds

### Low k (k close to 1):
- Public good barely worth creating
- Defect more aggressively throughout
- Little value in sustaining cooperation

### Short games (r ≤ 5):
- Compress the strategy: Cooperate round 1, exploit rounds 2 to r-1, defect round r
- Less time for reputation building, so exploit earlier

### Long games (r > 20):
- Build stronger cooperative reputation in first 25% of rounds
- Gradually increase defection rate in middle rounds
- Aggressive defection in final 20%

---

## Summary Pseudocode

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return COOPERATE
    
    if round == r:
        return DEFECT
    
    if round == r - 1:
        return DEFECT with probability 0.8
    
    CR = count_others_cooperated_last_round() / (n - 1)
    game_progress = round / r
    
    # Adjust thresholds based on n
    high_threshold = 0.6 if n > 3 else 0.8
    
    if CR >= high_threshold:
        exploit_prob = 0.3 + 0.4 * game_progress
        if n > 10: exploit_prob += 0.15
        return DEFECT with probability exploit_prob
    
    elif CR >= 0.3:
        trend = calculate_trend()
        if trend > 0: return COOPERATE
        else: return DEFECT
    
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: Defects when cooperation is high to extract surplus
2. **Maintains exploitable environment**: Cooperates just enough to prevent total collapse
3. **Front-runs end-game**: Starts defecting before others expect it
4. **Adapts to prey**: Cooperates more when others are building cooperation (to harvest later), defects when environment is already degraded
5. **Scales exploitation**: More aggressive in large groups where individual actions are less attributable
'''

description_EXPLOITATIVE_118 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but detecting and exploiting patterns of cooperation can yield higher returns than universal defection.

## Strategy Overview

The strategy operates in three phases and continuously classifies opponents to determine optimal exploitation.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-3)

**Round 1:** DEFECT
- Rationale: Gather information at no cost. If others cooperate, we benefit maximally. If they defect, we lose nothing relative to cooperating.

**Round 2:** DEFECT
- Continue gathering data. Observe who cooperated in round 1 despite getting burned.

**Round 3:** COOPERATE (conditional)
- Cooperate ONLY if cooperation rate in rounds 1-2 was ≥ 50%
- Otherwise DEFECT
- Rationale: Test if cooperators will sustain cooperation when they see some reciprocity

### Phase 2: Exploitation Phase (Rounds 4 to r-2)

Classify opponents into categories based on observed behavior:

```
For each opponent j:
  coop_rate[j] = (times j cooperated) / (rounds played)
  
  if coop_rate[j] > 0.7: classify as "SUCKER" (exploitable)
  if coop_rate[j] between 0.3-0.7: classify as "CONDITIONAL"
  if coop_rate[j] < 0.3: classify as "DEFECTOR"
```

**Decision Rule for each round t:**

```
expected_cooperators = count(SUCKERS) + 0.5 * count(CONDITIONALS)
cooperation_threshold = n / k  # breakeven point

if expected_cooperators >= cooperation_threshold:
    # Enough suckers to make defection profitable
    DEFECT
else if count(CONDITIONALS) >= n/2 AND my_recent_coop_rate < 0.3:
    # Need to "bait" conditionals back into cooperating
    COOPERATE (but only for 1-2 rounds, then defect again)
else:
    DEFECT
```

**Exploitation Cycling:**
- If I've defected for 3+ consecutive rounds AND cooperation rate is dropping:
  - Throw in one COOPERATE to "reset" conditional cooperators
  - Then return to DEFECT for 2-3 rounds
- This maintains a pool of exploitable cooperators

### Phase 3: Endgame (Final 2 rounds)

**Round r-1:** DEFECT
- Rationale: No future punishment possible, begin cashing out

**Round r (final):** DEFECT
- Rationale: Dominant strategy in final round; no future consequences

---

## Adaptive Mechanisms

### Opponent Modeling Update (each round)

```
After each round t:
  For each opponent j:
    Update coop_rate[j] with exponential weighting:
    coop_rate[j] = 0.7 * coop_rate[j] + 0.3 * (1 if j cooperated else 0)
    
    # Recent behavior weighted more heavily
```

### Environment Detection

```
global_coop_rate = total cooperations / (n * rounds_played)

if global_coop_rate > 0.6:
  # Cooperative environment - maximize exploitation via defection
  bias toward DEFECT
  
if global_coop_rate < 0.3:
  # Already collapsed - defect always
  DEFECT always
  
if global_coop_rate between 0.3-0.6:
  # Fragile environment - occasional cooperation to maintain exploitability
  Mix strategy: occasional COOPERATE to sustain others' cooperation
```

### Parameter Sensitivity

```
exploitation_aggression = (n - k) / n  # Higher when k is low relative to n

if exploitation_aggression > 0.7:
  # Very unfavorable multiplier - defect more aggressively
  Reduce cooperation frequency by 50%
  
if exploitation_aggression < 0.4:
  # More favorable multiplier - can afford occasional cooperation as bait
  Standard strategy
```

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| n = 2 | Essentially Prisoner's Dilemma; defect always except occasional bait |
| r ≤ 5 | Shorten probing to 1 round, defect-heavy |
| All opponents defecting | Defect always (no exploitation opportunity) |
| All opponents cooperating | Defect always (maximum exploitation) |
| k very close to n | Slightly more cooperation as bait (higher returns) |

---

## Summary Pseudocode

```
function decide(round, history, n, k, r):
    if round <= 2:
        return DEFECT
    if round == 3:
        return COOPERATE if avg_coop_rate(history) >= 0.5 else DEFECT
    if round >= r - 1:
        return DEFECT  # Endgame
    
    # Main phase
    classify_opponents(history)
    expected_coop = estimate_cooperators_this_round()
    
    if should_bait(history, expected_coop):
        return COOPERATE
    else:
        return DEFECT
```

This strategy prioritizes information gathering, opponent exploitation, and endgame defection while maintaining just enough cooperation to keep conditional cooperators exploitable.
'''

description_EXPLOITATIVE_120 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by others creates exploitation opportunities. I will appear cooperative enough to encourage others to cooperate, then strategically defect to extract maximum value.

## Decision Rules

### Round Classification

**First Round:** Defect.
- Rationale: No information exists about opponents. Defection is the dominant single-round strategy and provides a baseline to observe others' cooperative tendencies without personal cost.

**Last Round:** Defect unconditionally.
- Rationale: No future rounds exist to punish defection. Pure Nash equilibrium logic applies.

**Second-to-Last Round:** Defect unconditionally.
- Rationale: Sophisticated opponents will defect in the last round regardless, so there's no cooperation to preserve. Begin extraction early.

**Middle Rounds (rounds 2 through r-2):** Use adaptive decision rule below.

---

### Adaptive Decision Rule for Middle Rounds

Let `coop_rate(t)` = proportion of all opponents who cooperated in round t
Let `avg_coop_rate` = average cooperation rate across all previous rounds
Let `trend` = coop_rate(t-1) - coop_rate(t-2) (positive means increasing cooperation)

```
DECISION FOR ROUND t (where 2 ≤ t ≤ r-2):

# Calculate exploitation threshold based on game parameters
base_threshold = (n - k) / n  # Point where cooperation becomes collectively beneficial

IF avg_coop_rate > 0.6:
    # Environment is cooperative - EXPLOIT
    IF trend ≥ 0:
        # Cooperation stable or rising - safe to defect
        DEFECT
    ELSE IF trend < -0.2:
        # Cooperation dropping fast - cooperate to stabilize the herd
        COOPERATE
    ELSE:
        # Minor decline - continue exploiting
        DEFECT

ELSE IF avg_coop_rate > 0.3:
    # Mixed environment - PROBE AND EXTRACT
    IF coop_rate(t-1) > 0.5:
        # Last round was cooperative - defect to exploit
        DEFECT
    ELSE:
        # Last round was uncooperative - cooperate to bait future cooperation
        COOPERATE

ELSE:
    # Low cooperation environment - STRATEGIC MIMICRY
    IF coop_rate(t-1) > avg_coop_rate:
        # Uptick detected - cooperate to encourage trend, then exploit later
        COOPERATE
    ELSE:
        # Stagnant defection environment - defect (nothing to exploit)
        DEFECT
```

---

### Edge Cases

**Round 2 specifically:** 
- If ≥50% of opponents cooperated in round 1: DEFECT (exploit the cooperators)
- If <50% cooperated: COOPERATE (signal willingness to cooperate, bait future cooperation)

**Very short games (r ≤ 4):**
- Defect every round. Not enough rounds to build exploitable cooperation patterns.

**Large n (n > 10):**
- Bias toward defection increases. Individual contribution has minimal impact on public good, so defection cost is hidden in the crowd.
- Modify threshold: Only cooperate if avg_coop_rate > 0.7 AND cooperation is declining rapidly.

**Very high k (k approaching n):**
- Cooperation becomes more valuable. Slightly increase willingness to cooperate.
- Modify: Add 0.1 to thresholds when k > 0.8n

---

## Summary Pseudocode

```
function decide(round, history, n, k, r):
    if round == 1:
        return DEFECT
    if round >= r - 1:
        return DEFECT
    if r <= 4:
        return DEFECT
    
    coop_rates = [count(C in round_t) / (n-1) for round_t in history]
    avg_coop = mean(coop_rates)
    last_coop = coop_rates[-1]
    trend = coop_rates[-1] - coop_rates[-2] if round > 2 else 0
    
    if avg_coop > 0.6:
        return DEFECT if trend >= -0.2 else COOPERATE
    elif avg_coop > 0.3:
        return DEFECT if last_coop > 0.5 else COOPERATE
    else:
        return COOPERATE if last_coop > avg_coop else DEFECT
```

## Why This Strategy is Exploitative

1. **Free-rides on cooperators:** When others cooperate, I defect to get both my endowment AND a share of their contributions.
2. **Baits cooperation:** Strategic cooperation signals encourage others to cooperate, creating future exploitation opportunities.
3. **Extracts maximum value at endgame:** Guaranteed defection in final rounds captures endgame value.
4. **Adapts to opponent pool:** Doesn't waste cooperation on defector-heavy environments, but maintains enough cooperation to keep cooperative opponents contributing.
'''

description_EXPLOITATIVE_119 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors free-ride on cooperators. The goal is to **maximize extraction** from cooperative opponents while **minimizing losses** against defectors. I will cooperate only when it's profitable to do so—specifically, when I can induce or sustain cooperation in others that I can later exploit, or when the environment is cooperative enough that mutual cooperation outperforms mutual defection.

---

## Strategy Overview

The strategy operates in three phases:
1. **Probe Phase**: Gather information about opponent behavior
2. **Classify & Exploit Phase**: Categorize the population and adapt accordingly
3. **Endgame Phase**: Defect unconditionally as the game concludes

---

## Detailed Decision Rules

### Key Metrics Tracked

For each round t, track:
- `total_cooperators[t]`: Number of players who cooperated in round t
- `cooperation_rate[t]`: `total_cooperators[t] / n`
- `cumulative_coop_rate`: Average cooperation rate across all observed rounds
- `trend`: Whether cooperation is increasing, stable, or declining

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: No information exists. Defection is dominant in single-shot play and provides a safe baseline. If others cooperate, I profit maximally. If others defect, I avoid being the sucker.

**Round 2: Conditional**
- If `cooperation_rate[1] >= 0.5`: **COOPERATE** (test if cooperation is sustainable)
- If `cooperation_rate[1] < 0.5`: **DEFECT** (population appears uncooperative)

### Phase 2: Classify & Exploit (Rounds 3 to r-2)

Calculate a **cooperation threshold** based on when cooperation becomes profitable:
```
profitable_threshold = (n - k) / (n * (k - 1))
```
This is derived from: cooperation is worth considering when expected return from inducing future cooperation exceeds immediate defection gain.

**Decision Rule:**

```
Let recent_coop_rate = average cooperation rate over last 3 rounds (or all available if < 3)
Let my_last_action = what I played last round
Let others_response = cooperation rate of others after I cooperated vs defected

IF recent_coop_rate >= 0.6:
    # Cooperative environment - exploit with intermittent defection
    IF I cooperated last round AND cooperation stayed high:
        DEFECT with probability 0.3, else COOPERATE
    ELSE:
        COOPERATE (rebuild cooperation to exploit later)

ELSE IF recent_coop_rate >= 0.3:
    # Mixed environment - conditional cooperation
    IF recent_coop_rate is increasing (trend positive):
        COOPERATE (encourage growth to exploit later)
    ELSE IF recent_coop_rate is decreasing:
        DEFECT (extract value before collapse)
    ELSE:
        DEFECT (marginal environment favors defection)

ELSE:  # recent_coop_rate < 0.3
    # Hostile environment - pure defection
    DEFECT
```

**Exploitation Refinement:**
- If I'm in a cooperative environment and have defected for 2+ consecutive rounds, cooperate once to "reset" others' willingness to cooperate
- Track if cooperation rate drops sharply after my defections—if so, cooperate more frequently to maintain the pool of cooperators to exploit

### Phase 3: Endgame (Final 2 Rounds)

**Round r-1 (second to last): DEFECT**
- Backward induction begins. Sophisticated opponents will defect in round r, making round r-1 cooperation less valuable.

**Round r (final round): DEFECT**
- No future exists to incentivize cooperation. Defection strictly dominates.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # Round 1 - no information, defect
    if round == 1:
        return DEFECT
    
    # Calculate metrics
    recent_window = min(3, round - 1)
    recent_coop_rate = average(cooperation_rate[round-recent_window : round])
    
    # Round 2 - respond to round 1
    if round == 2:
        if cooperation_rate[1] >= 0.5:
            return COOPERATE
        else:
            return DEFECT
    
    # Main phase exploitation logic
    if recent_coop_rate >= 0.6:
        # Rich environment - intermittent exploitation
        if my_action[round-1] == COOPERATE and cooperation_rate[round-1] >= 0.5:
            if random() < 0.3:
                return DEFECT
            else:
                return COOPERATE
        else:
            return COOPERATE  # Rebuild trust
    
    else if recent_coop_rate >= 0.3:
        # Mixed environment
        trend = cooperation_rate[round-1] - cooperation_rate[round-2]
        if trend > 0.05:
            return COOPERATE
        else:
            return DEFECT
    
    else:
        # Hostile environment
        return DEFECT
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| n = 2 (minimum players) | More aggressive defection (threshold 0.7 instead of 0.6) | Harder to sustain cooperation, easier to identify opponent type |
| k close to n | Slightly more cooperative | Higher returns to mutual cooperation |
| k close to 1 | More defection | Lower returns to cooperation |
| r = 2 (minimum rounds) | DEFECT both rounds | Endgame logic applies immediately |
| r very large | Standard strategy | More opportunities to calibrate |
| All opponents always cooperate | Defect ~70% of rounds | Maximum exploitation |
| All opponents always defect | Always defect | No benefit to cooperation |

---

## Why This Strategy is Exploitative

1. **Never cooperates first** in unknown environments (Round 1 defection)
2. **Free-rides** on cooperative populations with intermittent defection
3. **Abandons cooperation** quickly when environment turns hostile
4. **Extracts maximum value** in endgame through guaranteed defection
5. **Maintains exploitation potential** by occasionally cooperating just enough to prevent total cooperation collapse
'''

description_EXPLOITATIVE_121 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperative opponents while minimizing losses against defectors. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but repeated play creates opportunities to identify and exploit "suckers" who cooperate despite defection.

## Strategy Overview

The strategy operates in three phases and maintains a "cooperation score" for the collective group to determine exploitability.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1-2)

**Round 1:** DEFECT
- Rationale: Gather information about opponent tendencies without sacrificing payoff. If others cooperate, I gain maximum benefit. If others defect, I lose nothing.

**Round 2:** DEFECT
- Rationale: Confirm Round 1 patterns. Some strategies cooperate initially then adapt; two rounds of data reveals more stable tendencies.

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **Cooperation Rate (CR)** from observed history:
```
CR = (total cooperations by all other players) / ((n-1) × rounds_played)
```

**Decision Rule:**

```
IF CR ≥ 0.6:
    DEFECT (high exploitation opportunity - many suckers present)
    
ELSE IF CR between 0.3 and 0.6:
    Use "Occasional Bait" strategy:
        - Cooperate with probability p = (CR - 0.3) / 0.6
        - This maintains enough cooperation in the pool to keep 
          conditional cooperators engaged
    
ELSE IF CR < 0.3:
    DEFECT (environment is hostile, protect self)
```

**Refinement - Trend Detection:**
```
IF cooperation_rate is declining over last 3 rounds by >20%:
    DEFECT (the pool is collapsing, extract value now)
    
IF cooperation_rate is increasing over last 3 rounds by >20%:
    Continue current strategy (don't disrupt favorable trend)
```

### Phase 3: Endgame (Final 2 rounds)

**Round r-1:** DEFECT
- Rationale: Limited future punishment opportunity. Begin extracting final value.

**Round r (Final):** DEFECT
- Rationale: No future rounds means no retaliation possible. Defection is strictly dominant.

---

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase - always defect
    if round <= 2:
        return DEFECT
    
    # Calculate cooperation rate of others
    other_cooperations = count_cooperations(history, exclude_self=True)
    total_other_actions = (n - 1) * (round - 1)
    CR = other_cooperations / total_other_actions
    
    # Calculate trend (last 3 rounds)
    if round > 4:
        recent_CR = cooperation_rate_last_3_rounds(history)
        older_CR = cooperation_rate_rounds_before_last_3(history)
        trend = recent_CR - older_CR
    else:
        trend = 0
    
    # Exploitation logic
    if CR >= 0.6:
        return DEFECT  # Rich hunting ground
    
    elif CR >= 0.3:
        # Occasional bait to sustain cooperators
        if trend < -0.2:
            return DEFECT  # Pool collapsing, extract now
        
        bait_probability = (CR - 0.3) / 0.6
        # Cooperate occasionally to keep the pool alive
        if random() < bait_probability:
            return COOPERATE
        else:
            return DEFECT
    
    else:  # CR < 0.3
        return DEFECT  # Hostile environment
```

---

## Edge Case Handling

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Round 1 | DEFECT | No information, safe default |
| Final round | DEFECT | No retaliation possible |
| n = 2 (minimum players) | Follow standard rules | CR still informative |
| All opponents always cooperate | Always DEFECT | Maximum exploitation |
| All opponents always defect | Always DEFECT | No point cooperating alone |
| Very short game (r = 3) | DEFECT all rounds | Insufficient time for reputation building |
| Very long game (r > 20) | Standard phases, extended exploitation | More data for accurate CR |

---

## Why This Strategy is Exploitative

1. **Free-riding on cooperators:** When CR is high, I defect to capture the public good without contributing
2. **Minimal cooperation as bait:** The occasional cooperation in medium-CR environments is purely instrumental—it keeps "tit-for-tat" style opponents cooperating so I can continue exploiting
3. **Information asymmetry exploitation:** By defecting early, I learn opponent types while they learn I'm a defector (which I can later "reform" from if beneficial)
4. **Endgame extraction:** No mercy in final rounds when punishment is impossible
'''

description_EXPLOITATIVE_120 = '''
# Exploitative Strategy: "Adaptive Threshold Exploiter" (ATE)

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defecting against cooperators yields the highest individual payoff. The goal is to **identify and exploit cooperative opponents while protecting against mutual defection spirals**, extracting maximum value from the population.

## Strategy Overview

ATE operates on three principles:
1. **Probe early** to classify the population's cooperativeness
2. **Exploit aggressively** when cooperation levels are high enough to profit from defection
3. **Defect reliably** in endgame where retaliation is impossible

---

## Decision Rules

### Round 1: Conditional Probe
```
IF n ≤ 4:
    DEFECT  (small groups punish defection harder; stay safe while observing)
ELSE:
    COOPERATE  (probe to see if exploitation is viable)
```

**Rationale**: In small groups, a single defector is obvious and invites coordinated punishment. In larger groups, one cooperation lets us observe baseline behavior while appearing trustworthy.

---

### Rounds 2 through (r-1): Adaptive Exploitation

Calculate the **cooperation ratio** from the previous round:
```
coop_ratio = (number of cooperators last round) / n
```

Calculate the **exploitation threshold**:
```
exploit_threshold = 1 / k
```
This is the minimum cooperation ratio where defecting yields more than universal defection.

**Decision Logic:**
```
IF coop_ratio >= exploit_threshold + 0.1:
    # High cooperation environment - EXPLOIT
    DEFECT
    
ELIF coop_ratio >= exploit_threshold:
    # Marginal environment - probabilistic exploitation
    # Cooperate occasionally to sustain the cooperative population
    IF (current_round mod 3) == 0:
        COOPERATE  (maintenance cooperation to keep victims cooperating)
    ELSE:
        DEFECT
        
ELIF coop_ratio > 0:
    # Low cooperation but not zero - conditional reciprocity
    # Mirror the majority to avoid being the sole sucker
    IF coop_ratio >= 0.5:
        COOPERATE
    ELSE:
        DEFECT
        
ELSE:
    # Everyone defected - no point cooperating
    DEFECT
```

### Refinement: Trend Detection

Track cooperation trend over last 3 rounds (when available):
```
IF cooperation is declining for 2+ consecutive rounds:
    # Environment collapsing - abandon ship early
    DEFECT regardless of current ratio

IF cooperation is rising:
    # Others are trying to establish cooperation
    # Exploit this optimism
    DEFECT if coop_ratio > exploit_threshold
```

---

### Final Round (round r): Always Defect
```
DEFECT (unconditionally)
```

**Rationale**: No future retaliation is possible. This is the dominant strategy in the last round regardless of history.

---

### Second-to-Last Round (round r-1): Defect with High Probability
```
IF coop_ratio > 0.3:
    DEFECT  (exploit any remaining cooperators)
ELSE:
    DEFECT  (nothing to lose)
```

Effectively: **Always defect in round r-1** as sophisticated opponents will also defect, and naive ones are profitable to exploit.

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, k, history):
    
    # Endgame exploitation
    if round_num >= total_rounds - 1:
        return DEFECT
    
    # First round probe
    if round_num == 1:
        return DEFECT if n <= 4 else COOPERATE
    
    # Calculate metrics
    last_round_coops = count_cooperators(history[-1])
    coop_ratio = last_round_coops / n
    exploit_threshold = 1 / k
    
    # Trend detection (if enough history)
    if len(history) >= 3:
        trend = get_trend(history[-3:])  # -1 declining, 0 stable, +1 rising
        if trend <= -1 and coop_ratio < 0.5:
            return DEFECT  # Collapse detected
    
    # Main decision logic
    if coop_ratio >= exploit_threshold + 0.1:
        return DEFECT  # Rich exploitation zone
    
    elif coop_ratio >= exploit_threshold:
        # Marginal zone - occasional cooperation to sustain victims
        if round_num % 3 == 0:
            return COOPERATE
        return DEFECT
    
    elif coop_ratio > 0:
        # Mirror majority
        return COOPERATE if coop_ratio >= 0.5 else DEFECT
    
    else:
        return DEFECT  # Dead environment
```

---

## Edge Case Handling

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| r = 2 (two rounds only) | D, D | Both rounds are effectively endgame |
| n = 2 (two players) | Always D after round 1 | Easy to be identified; defect-defect equilibrium likely |
| k very close to 1 | Defect-heavy | Cooperation benefits are minimal |
| k close to n | More willing to cooperate early | Higher returns from mutual cooperation worth probing |
| All opponents always cooperate | Always defect | Maximum exploitation of naive strategies |
| All opponents always defect | Always defect | No suckers to exploit |

---

## Why This Strategy Is Exploitative

1. **Asymmetric extraction**: We defect most when others cooperate most, capturing the (k/n) × contributions while keeping our endowment

2. **Endgame certainty**: Guaranteed defection in final rounds extracts maximum value when punishment is impossible

3. **Maintenance deception**: Occasional cooperation in marginal zones keeps naive cooperators from switching to defection, preserving our victim pool

4. **Trend exploitation**: When we detect rising cooperation (others trying to establish norms), we exploit their optimism rather than joining

5. **Minimal vulnerability**: We never cooperate when the environment can't sustain it, avoiding the "sucker's payoff"
'''

description_EXPLOITATIVE_122 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **maximize extraction from cooperative opponents while minimizing losses against defectors**, dynamically adjusting based on observed population behavior.

## Strategy Overview

The strategy operates in three phases and continuously estimates the "exploitability" of the population to calibrate between pure defection (safest) and conditional cooperation (potentially higher payoff through reputation manipulation).

---

## Decision Rules

### Phase 1: Probe Phase (Rounds 1-2)

**Round 1: DEFECT**
- Rationale: Defection dominates in any single round. Starting with defection provides a baseline and avoids being exploited by probing opponents.

**Round 2: Observe and DEFECT**
- Count cooperators from Round 1
- Continue defecting to gather more data while free-riding on any cooperation

### Phase 2: Exploitation Phase (Rounds 3 to r-2)

Calculate the **Cooperation Rate (CR)** from all previous rounds:
```
CR = (total C plays by all opponents) / (total plays by all opponents)
```

Calculate the **Exploitability Threshold (ET)**:
```
ET = (n - k) / (n - 1)
```
This represents the cooperation rate below which defection is always optimal regardless of your own action.

**Decision Logic:**

```
IF CR < 0.2:
    # Barren environment - everyone defects
    ACTION = DEFECT
    
ELSE IF CR > 0.6:
    # Rich environment - exploit aggressively
    # Cooperate occasionally to sustain the cooperative population
    
    cooperation_probability = min(0.3, (CR - 0.6) * 0.5)
    
    IF random() < cooperation_probability AND rounds_since_last_C >= 3:
        ACTION = COOPERATE  # Occasional cooperation to maintain the herd
    ELSE:
        ACTION = DEFECT
        
ELSE:  # 0.2 <= CR <= 0.6
    # Moderate environment - conditional exploitation
    
    # Check if cooperation is trending up or down
    recent_CR = cooperation_rate(last 3 rounds)
    
    IF recent_CR > CR + 0.1:
        # Cooperation increasing - pure defection to maximize extraction
        ACTION = DEFECT
    ELSE IF recent_CR < CR - 0.1:
        # Cooperation collapsing - token cooperation to revive it
        IF random() < 0.15:
            ACTION = COOPERATE
        ELSE:
            ACTION = DEFECT
    ELSE:
        # Stable - continue defecting
        ACTION = DEFECT
```

### Phase 3: Endgame (Rounds r-1 and r)

**Round r-1: DEFECT**
- No future punishment possible, backward induction kicks in

**Round r (Final Round): DEFECT**
- Strictly dominant strategy in the last round

---

## Detailed Pseudocode

```python
def adaptive_predator_strategy(n, k, r, current_round, history):
    """
    history: list of lists, where history[t] contains all players' actions in round t
    history[t][i] = 'C' or 'D' for player i in round t
    """
    
    # Endgame: Always defect in final 2 rounds
    if current_round >= r - 1:
        return 'D'
    
    # Probe phase: Defect to gather information
    if current_round <= 2:
        return 'D'
    
    # Calculate cooperation metrics
    opponent_actions = extract_opponent_actions(history)
    total_opponent_plays = len(opponent_actions)
    total_cooperations = sum(1 for a in opponent_actions if a == 'C')
    
    CR = total_cooperations / total_opponent_plays if total_opponent_plays > 0 else 0
    
    # Recent trend (last 3 rounds)
    recent_actions = extract_opponent_actions(history[-3:])
    recent_CR = sum(1 for a in recent_actions if a == 'C') / len(recent_actions) if recent_actions else CR
    
    # Exploitation logic
    if CR < 0.2:
        return 'D'  # Barren - no point cooperating
    
    elif CR > 0.6:
        # Rich environment - occasional cooperation to sustain cooperators
        rounds_since_last_C = count_rounds_since_my_last_C(history)
        coop_prob = min(0.3, (CR - 0.6) * 0.5)
        
        if random() < coop_prob and rounds_since_last_C >= 3:
            return 'C'
        return 'D'
    
    else:  # Moderate environment
        if recent_CR > CR + 0.1:
            return 'D'  # Cooperation rising - pure extraction
        elif recent_CR < CR - 0.1 and random() < 0.15:
            return 'C'  # Cooperation falling - token contribution
        return 'D'
```

---

## Edge Case Handling

| Situation | Action | Rationale |
|-----------|--------|-----------|
| First round | DEFECT | No history, defection is safe |
| Last round | DEFECT | Strictly dominant |
| All opponents always defect | DEFECT | No value to extract |
| All opponents always cooperate | Mostly DEFECT, rare C | Extract maximum while keeping them cooperating |
| n = 2 | Slight increase in token cooperation | Single opponent easier to manipulate |
| k very close to n | Slightly more cooperation | Public good multiplier almost makes mutual C worthwhile |
| k very close to 1 | Pure defection | Public good provides minimal benefit |
| Short game (r ≤ 5) | Heavy defection | Little time for reputation effects |
| Long game (r > 20) | Allow more "farming" cooperation | Investment in sustainable extraction |

---

## Why This Strategy is Exploitative

1. **Defaults to defection**: The safe, dominant single-round strategy
2. **Free-rides on cooperators**: Extracts maximum value when others cooperate
3. **Farms cooperation**: Occasional token cooperation prevents complete collapse of cooperative players, maintaining a population to exploit
4. **Adapts to environment**: Doesn't waste cooperation in barren environments
5. **Endgame defection**: Captures guaranteed value when future reputation is worthless
6. **Trend detection**: Accelerates extraction when cooperation is rising, attempts revival when it's collapsing (to enable future extraction)

This strategy treats cooperators as a renewable resource to be harvested sustainably for maximum long-term extraction.
'''

description_EXPLOITATIVE_121 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by:
1. **Detecting and exploiting cooperative opponents** - free-riding on their contributions
2. **Avoiding mutual defection traps** - cooperating just enough to keep cooperators engaged
3. **Extracting maximum value** - defecting strategically when others are likely to cooperate

## Decision Rules

### Round Classification

**First Round:** DEFECT
- Rationale: Reveals nothing about opponents while capturing full private payoff plus any public good from naive cooperators. Sets up information gathering.

**Last Round:** DEFECT
- Rationale: No future punishment possible. Pure Nash equilibrium logic applies.

**Penultimate Round (round r-1):** DEFECT
- Rationale: Sophisticated opponents will defect in the last round anyway, so cooperation here has diminished value for influencing future behavior.

**Middle Rounds (rounds 2 through r-2):**

```
Let:
  coop_rate = (total cooperations by all opponents in previous rounds) / 
              ((current_round - 1) × (n - 1))
  
  last_round_coops = number of opponents who cooperated in the previous round
  
  exploitation_threshold = k / n  (the marginal return from public good)
```

### Adaptive Decision Logic for Middle Rounds

```
IF last_round_coops >= (n-1) × 0.6:
    # High cooperation environment - EXPLOIT IT
    DEFECT
    
ELIF last_round_coops == 0:
    # Everyone defected - try to restart cooperation cycle
    IF coop_rate > 0.3 AND current_round < r/2:
        COOPERATE with probability 0.2
    ELSE:
        DEFECT
        
ELIF coop_rate > 0.5:
    # Moderately cooperative environment
    # Defect most of the time, occasionally cooperate to keep them hooked
    IF (consecutive_defections_by_me >= 3):
        COOPERATE  # Throw a bone to prevent collapse
    ELSE:
        DEFECT
        
ELSE:
    # Low cooperation environment
    # Mirror with bias toward defection
    IF last_round_coops >= (n-1)/2:
        DEFECT  # Exploit the cooperators
    ELSE:
        DEFECT  # Don't waste resources
```

### Refined Pseudocode

```python
def decide(round, history, n, k, r):
    
    # Terminal conditions
    if round == 1:
        return DEFECT
    if round >= r - 1:
        return DEFECT
    
    # Calculate metrics
    opponent_coops_last_round = count_cooperators_last_round(history)
    total_opponent_coops = count_all_opponent_cooperations(history)
    total_opponent_actions = (round - 1) * (n - 1)
    coop_rate = total_opponent_coops / total_opponent_actions
    my_consecutive_defections = count_my_consecutive_defections(history)
    
    # Exploitation thresholds
    high_coop_threshold = max(2, int((n-1) * 0.5))
    
    # Main logic
    if opponent_coops_last_round >= high_coop_threshold:
        # Rich environment - harvest it
        return DEFECT
    
    if opponent_coops_last_round == 0:
        # Barren environment
        if coop_rate > 0.25 and round < r * 0.4:
            # Maybe restart cycle with small probability
            return COOPERATE if random() < 0.15 else DEFECT
        return DEFECT
    
    # Medium cooperation environment
    if my_consecutive_defections >= 3 and coop_rate > 0.3:
        # Prevent total collapse - invest minimally
        return COOPERATE
    
    # Default: exploit
    return DEFECT
```

## Key Exploitative Features

1. **Never cooperates when many others do** - maximizes free-riding payoff
2. **Minimal investment in cooperation** - only cooperates to prevent total collapse
3. **Endgame defection** - captures guaranteed payoffs when future doesn't matter
4. **Asymmetric response** - defects against cooperators, doesn't reward defectors
5. **Adaptive thresholds** - adjusts based on observed population behavior

## Edge Cases

- **n=2:** Becomes similar to iterated Prisoner's Dilemma; strategy still applies
- **k close to n:** Higher incentive for mutual cooperation, but strategy still exploits
- **k close to 1:** Low public good returns; defection even more dominant
- **Very short games (r≤3):** Essentially always defect
'''

description_EXPLOITATIVE_122 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to maximize personal payoff by exploiting cooperators while minimizing losses from retaliation. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by others creates value I can extract. My goal is to **identify and exploit cooperative players while appearing just cooperative enough to avoid triggering universal defection**.

## Strategy Overview

I will maintain a "cooperation reputation" just high enough to encourage others to cooperate, while systematically defecting more than I cooperate. I adapt based on the observed cooperation rate of others—cooperating slightly less than the group average to free-ride on their contributions.

---

## Decision Rules

### Round 1: Defect
- **Rationale**: No information about opponents. Defection is the dominant single-round strategy. I lose nothing by defecting first and gain information about others' baseline behavior.

### Rounds 2 through (r-1): Adaptive Exploitation

**Step 1: Calculate group cooperation rate from previous round**
```
prev_coop_rate = (number of C plays by others in round t-1) / (n-1)
```

**Step 2: Calculate my historical cooperation rate**
```
my_coop_rate = (my C plays so far) / (rounds played so far)
```

**Step 3: Decision Logic**

```
IF prev_coop_rate >= 0.6:
    # Rich environment - others are cooperating, exploit heavily
    IF my_coop_rate > prev_coop_rate - 0.2:
        DEFECT  # I'm being "too nice," extract more value
    ELSE:
        COOPERATE with probability 0.3  # Occasional cooperation to sustain others
        
ELSE IF prev_coop_rate >= 0.3:
    # Moderate environment - need to maintain some cooperation
    IF my_coop_rate > prev_coop_rate:
        DEFECT  # Never cooperate more than the group
    ELSE:
        COOPERATE with probability 0.4  # Match slightly below average
        
ELSE IF prev_coop_rate > 0:
    # Sparse cooperation - probe for exploitable cooperators
    COOPERATE with probability 0.2  # Low investment probing
    
ELSE:
    # Dead environment - everyone defected
    DEFECT  # No point cooperating alone
```

**Step 4: Exploitation Boost Modifier**

```
IF (rounds_remaining > 3) AND (I defected last round) AND (prev_coop_rate stayed stable or increased):
    # Others are "forgiving" or not retaliating - exploit harder
    Override to DEFECT with probability 0.8
```

### Final Round (round r): Always Defect
- **Rationale**: No future retaliation possible. Defection is strictly dominant.

### Second-to-Last Round (round r-1): Defect with 90% probability
- **Rationale**: Anticipating mutual defection in the final round, the shadow of the future is minimal.

---

## Edge Cases

| Situation | Action |
|-----------|--------|
| n = 2 (two players) | More aggressive defection; cooperate only if opponent cooperated twice consecutively |
| k very close to n | Slightly more cooperative (gains from mutual cooperation are higher) |
| k very close to 1 | Heavy defection (public good barely multiplies) |
| r = 2 (only 2 rounds) | Defect both rounds |
| r = 3 | Defect round 1, conditional round 2, defect round 3 |
| All others always cooperate | Defect every round (maximum exploitation) |
| All others always defect | Defect every round (no point cooperating) |

---

## Pseudocode Summary

```python
def decide(round_num, total_rounds, n, k, my_history, others_history):
    
    # Final round: always defect
    if round_num == total_rounds:
        return DEFECT
    
    # First round: defect to probe
    if round_num == 1:
        return DEFECT
    
    # Second-to-last round: almost always defect
    if round_num == total_rounds - 1:
        return DEFECT if random() < 0.9 else COOPERATE
    
    # Calculate cooperation rates
    prev_others_coop = count_cooperators(others_history[-1]) / (n - 1)
    my_coop_rate = sum(my_history) / len(my_history)
    
    # Adaptive exploitation logic
    if prev_others_coop >= 0.6:
        if my_coop_rate > prev_others_coop - 0.2:
            return DEFECT
        return COOPERATE if random() < 0.3 else DEFECT
    
    elif prev_others_coop >= 0.3:
        if my_coop_rate > prev_others_coop:
            return DEFECT
        return COOPERATE if random() < 0.4 else DEFECT
    
    elif prev_others_coop > 0:
        return COOPERATE if random() < 0.2 else DEFECT
    
    else:
        return DEFECT
```

---

## Why This Strategy is Exploitative

1. **Free-riding**: I systematically contribute less than the group average while benefiting from others' contributions
2. **Endgame exploitation**: Guaranteed defection in final rounds extracts maximum value
3. **Forgiveness detection**: If others don't punish my defection, I exploit harder
4. **Never a sucker**: I never cooperate more than the group rate
5. **Minimal signaling**: Just enough cooperation to prevent total collapse of the public good
'''

description_EXPLOITATIVE_123 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but sustained cooperation by others creates exploitable value. I want to:

1. **Detect and exploit cooperative populations** - free-ride when others cooperate
2. **Avoid being exploited** - defect against defectors
3. **Occasionally probe for exploitable cooperation** - minimal cooperation to test if others can be milked
4. **End-game exploit** - guaranteed defection when reputation no longer matters

---

## Strategy Specification

### Key Variables Tracked

- `cooperation_rate`: Rolling average of other players' cooperation over recent rounds
- `round_number`: Current round (1 to r)
- `exploitation_threshold`: Minimum cooperation rate that makes defection profitable to exploit

### Decision Rules

#### **Round 1: Always Defect**
- No information available; defection is risk-free
- Establishes baseline to observe others' initial strategies
- Avoids being exploited by first-round defectors

#### **Rounds 2 through (r-2): Adaptive Exploitation**

Calculate `other_cooperation_rate` = (total C plays by others in previous round) / (n-1)

**Primary Rule: Exploit High Cooperation**
```
IF other_cooperation_rate >= 0.5:
    DEFECT  # Free-ride on cooperators
```

**Secondary Rule: Probe Low Cooperation**
```
IF other_cooperation_rate < 0.5:
    IF other_cooperation_rate > 0.2:
        # Some cooperation exists - defect to exploit the remaining cooperators
        DEFECT
    ELSE IF other_cooperation_rate <= 0.2:
        # Very low cooperation - occasionally probe to see if cooperation can restart
        IF random() < 0.15:  # 15% probe rate
            COOPERATE  # Cheap probe to potentially restart exploitation cycle
        ELSE:
            DEFECT
```

**Adjustment for Trending Cooperation:**
```
IF cooperation is trending upward over last 3 rounds:
    DEFECT  # Position to exploit the growing cooperation
```

#### **Round (r-1): Penultimate Round**
- **DEFECT unconditionally**
- Others may still cooperate hoping to influence the final round
- Maximum exploitation opportunity

#### **Round r: Final Round**
- **DEFECT unconditionally**
- No future consequences; pure dominant strategy
- Anyone cooperating here is simply donating to defectors

---

## Pseudocode Implementation

```python
def adaptive_predator_decision(game_params, history):
    n = game_params['n']
    r = game_params['r']
    k = game_params['k']
    current_round = len(history) + 1
    
    # EDGE CASE: First round - always defect
    if current_round == 1:
        return 'D'
    
    # EDGE CASE: Last two rounds - always defect
    if current_round >= r - 1:
        return 'D'
    
    # Calculate other players' cooperation in the last round
    last_round = history[-1]
    other_players_actions = last_round['others']  # List of C/D from other players
    other_coop_count = sum(1 for a in other_players_actions if a == 'C')
    other_coop_rate = other_coop_count / (n - 1)
    
    # Calculate cooperation trend (if enough history)
    trend = 0
    if len(history) >= 3:
        rates = []
        for round_data in history[-3:]:
            others = round_data['others']
            rate = sum(1 for a in others if a == 'C') / (n - 1)
            rates.append(rate)
        trend = rates[-1] - rates[0]  # Positive = increasing cooperation
    
    # EXPLOITATION LOGIC
    
    # High cooperation environment - exploit it
    if other_coop_rate >= 0.5:
        return 'D'
    
    # Rising cooperation - position to exploit
    if trend > 0.1:
        return 'D'
    
    # Moderate cooperation - still exploit
    if other_coop_rate > 0.2:
        return 'D'
    
    # Very low cooperation - occasionally probe
    if other_coop_rate <= 0.2:
        if random.random() < 0.15:
            return 'C'  # Probe for potential cooperation restart
        else:
            return 'D'
    
    # Default fallback
    return 'D'
```

---

## Why This Strategy is Exploitative

1. **Maximizes free-riding**: When others cooperate, I defect and collect (k/n) × their contributions + my kept endowment

2. **Never reciprocates genuinely**: My rare cooperation (15% probes) is purely instrumental - testing if others can be exploited, not building mutual benefit

3. **Exploits conditional cooperators**: Strategies like Tit-for-Tat or Pavlov that cooperate based on past cooperation get exploited because I defect against their cooperation

4. **End-game certainty**: Unconditional defection in final rounds captures value from anyone still hoping for cooperation

5. **Robust to defector-heavy fields**: When facing other defectors, I match them (avoiding exploitation) while probing occasionally at minimal cost

---

## Edge Case Handling Summary

| Situation | Action | Rationale |
|-----------|--------|-----------|
| Round 1 | D | No information; safe default |
| Rounds 2 to r-2 with high coop | D | Exploit cooperators |
| Rounds 2 to r-2 with low coop | D (85%) / C (15%) | Match defectors, probe occasionally |
| Round r-1 | D | Penultimate exploitation |
| Round r | D | Dominant strategy; no future |
| Rising cooperation trend | D | Position for maximum exploitation |
| n=2 (minimum players) | Same rules apply | Works identically |
| Very large n | Same rules apply | Cooperation rate calculation scales |
'''

description_EXPLOITATIVE_123 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by others creates exploitable surplus. My goal is to:

1. Identify and exploit cooperative populations
2. Quickly abandon cooperation when others defect
3. Maximize end-game extraction

---

## Strategy Specification

### Key Variables Tracked

- `round`: current round number (1 to r)
- `coop_rate[t]`: proportion of other players who cooperated in round t
- `avg_coop_rate`: running average cooperation rate of others
- `my_coop_count`: number of times I've cooperated so far
- `exploitation_threshold`: dynamic threshold based on game economics

### Economic Calculation

The **break-even cooperation rate** for me to cooperate is when my expected return from cooperation equals defection:

- Defect payoff: `1 + (k/n) × expected_cooperators`
- Cooperate payoff: `0 + (k/n) × (expected_cooperators + 1)`
- Gain from cooperating: `k/n`
- Cost of cooperating: `1`

Since `k < n`, cooperation is **never individually profitable in isolation**. Therefore, I only cooperate to:
1. Maintain a cooperative ecosystem I can later exploit
2. Prevent complete collapse before I'm ready to defect

---

## Decision Rules

### Round 1: Conditional Cooperation Probe
```
IF n ≤ 3:
    DEFECT  (too few players to hide exploitation)
ELSE IF k/n > 0.4:
    COOPERATE  (public good multiplier is decent, worth testing)
ELSE:
    DEFECT  (returns too low to risk cooperation)
```

### Rounds 2 to (r - end_game_length): Adaptive Phase

```
end_game_length = max(1, floor(r / 5))  # Last 20% is end-game

# Calculate cooperation threshold dynamically
min_profitable_coop_rate = (n - k) / (k × (n - 1))

IF coop_rate[previous_round] >= 0.6:
    # High cooperation environment - EXPLOIT
    IF my_coop_count / (round - 1) > avg_coop_rate:
        DEFECT  (I've been more generous than others, time to take)
    ELSE:
        COOPERATE with probability = min(0.7, coop_rate[previous_round] - 0.1)
        # Cooperate slightly less than others to extract surplus
        
ELSE IF coop_rate[previous_round] >= 0.3:
    # Medium cooperation - CONDITIONAL TIT-FOR-TAT variant
    IF avg_coop_rate > min_profitable_coop_rate:
        # Mirror the majority action from last round, with defection bias
        COOPERATE with probability = coop_rate[previous_round] × 0.8
    ELSE:
        DEFECT
        
ELSE:  # coop_rate < 0.3
    # Low cooperation environment - pure defection
    DEFECT
```

### End Game (last `end_game_length` rounds): Extraction Phase

```
# Backward induction applies - defect regardless of history
ALWAYS DEFECT

# Exception: Second-to-last round
IF round == r - 1 AND coop_rate[previous_round] > 0.7:
    COOPERATE with probability 0.3  
    # Fake signal to maintain others' cooperation into final round
```

### Final Round
```
ALWAYS DEFECT  (no future to protect)
```

---

## Exploitation Mechanisms

### 1. **Free-Rider Detection Avoidance**
I cooperate just enough to not be identified as the primary defector, keeping my cooperation rate close to (but below) the group average.

### 2. **Cooperation Milking**
In high-cooperation environments, I defect approximately 10-30% more than the group average, extracting surplus while keeping the cooperative ecosystem alive.

### 3. **Collapse Acceleration**
When cooperation falls below 30%, I fully defect to accelerate the collapse—there's no surplus left to protect.

### 4. **End-Game Deception**
The small probability of cooperation in the second-to-last round is designed to signal continued cooperation to others, maximizing the number of cooperators I can exploit in the final round.

---

## Pseudocode Summary

```python
def decide(round, r, n, k, history):
    end_game_start = r - max(1, r // 5)
    
    # Final round - always defect
    if round == r:
        return DEFECT
    
    # End game phase
    if round >= end_game_start:
        if round == r - 1 and get_coop_rate(history, round-1) > 0.7:
            return COOPERATE if random() < 0.3 else DEFECT
        return DEFECT
    
    # Round 1
    if round == 1:
        return COOPERATE if (n > 3 and k/n > 0.4) else DEFECT
    
    # Adaptive phase
    prev_coop_rate = get_coop_rate(history, round - 1)
    avg_coop_rate = get_average_coop_rate(history)
    my_coop_ratio = get_my_coop_ratio(history)
    
    if prev_coop_rate >= 0.6:
        if my_coop_ratio > avg_coop_rate:
            return DEFECT
        prob = min(0.7, prev_coop_rate - 0.1)
        return COOPERATE if random() < prob else DEFECT
        
    elif prev_coop_rate >= 0.3:
        prob = prev_coop_rate * 0.8
        return COOPERATE if random() < prob else DEFECT
        
    else:
        return DEFECT
```

---

## Robustness Features

- **Against all-cooperators**: Extracts maximum surplus through consistent under-cooperation
- **Against all-defectors**: Matches defection, losing nothing relative to baseline
- **Against tit-for-tat variants**: Probabilistic cooperation prevents predictable punishment
- **Against random strategies**: Exploits any above-baseline cooperation
- **Across parameter ranges**: Thresholds adapt to k/n ratio
'''

description_EXPLOITATIVE_124 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but exploiting cooperators yields even higher returns. We want to:

1. Identify and exploit "suckers" (persistent cooperators)
2. Avoid being exploited ourselves
3. Defect heavily in endgame when reputation no longer matters

---

## Decision Rules

### Round Classification

Divide the game into three phases:
- **Early Phase**: Rounds 1 to ⌈r/4⌉
- **Middle Phase**: Rounds ⌈r/4⌉+1 to r-2
- **Endgame**: Final 2 rounds (r-1 and r)

### Key Metrics (tracked each round)

```
cooperation_rate = (total cooperations by others) / ((current_round) × (n-1))
last_round_cooperators = count of players who played C in previous round
my_cooperation_count = how many times I've cooperated
```

---

## Phase-Specific Rules

### Phase 1: Early Phase (Probing)

**Round 1**: **DEFECT**
- Rationale: Never cooperate blind. Observe who the cooperators are without paying the cost.

**Rounds 2 to ⌈r/4⌉**: 
- If `last_round_cooperators >= n/2`: **COOPERATE** (with probability 0.6) / **DEFECT** (0.4)
- If `last_round_cooperators < n/2`: **DEFECT**

*Purpose*: Build minimal reputation while identifying exploitable cooperators. The randomization prevents easy prediction.

### Phase 2: Middle Phase (Exploitation)

Calculate a **cooperation threshold** based on observed behavior:

```
exploit_threshold = max(2, ⌈n × 0.4⌉)  # Need at least this many cooperators to make cooperation "worth" faking
```

**Decision Rule**:
```
IF last_round_cooperators >= exploit_threshold:
    IF cooperation_rate > 0.5:
        # Population is cooperative - defect to exploit them
        DEFECT with probability 0.7
        COOPERATE with probability 0.3 (to maintain some goodwill)
    ELSE:
        # Cooperation is fragile - contribute occasionally to sustain it
        COOPERATE with probability 0.4
        DEFECT with probability 0.6
ELSE:
    # Not enough cooperators to exploit - pure defection
    DEFECT
```

**Reputation Management Adjustment**:
```
IF my_cooperation_count / current_round < 0.15:
    # I look too predatory - throw in a cooperation
    Increase cooperation probability by 0.2 for this round
```

### Phase 3: Endgame (Pure Exploitation)

**Round r-1**: **DEFECT**
**Round r (final)**: **DEFECT**

*Rationale*: No future rounds means no reputation value. Pure defection is dominant.

---

## Adaptive Mechanisms

### Detecting Strategy Types

Track each opponent's individual cooperation history:

```
opponent_coop_rate[j] = cooperations by player j / rounds played
```

**Opponent Classification**:
- `sucker`: opponent_coop_rate[j] > 0.7 (exploit heavily)
- `reciprocator`: 0.3 ≤ opponent_coop_rate[j] ≤ 0.7 (be cautious)
- `predator`: opponent_coop_rate[j] < 0.3 (don't bother cooperating)

### Population-Level Adjustment

```
sucker_count = count of opponents with coop_rate > 0.7
predator_count = count of opponents with coop_rate < 0.3

IF sucker_count >= n/3:
    # Goldmine - defect more aggressively
    Shift all cooperation probabilities down by 0.15
    
IF predator_count >= n/2:
    # Hostile environment - pure defection
    ALWAYS DEFECT regardless of phase
```

---

## Complete Pseudocode

```
function decide(round, history, n, k, r):
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # Round 1 - probe
    if round == 1:
        return DEFECT
    
    # Calculate metrics
    last_coop = count_cooperators_last_round(history)
    overall_coop_rate = total_opponent_cooperations(history) / ((round-1) * (n-1))
    my_coop_rate = my_cooperations(history) / (round - 1)
    sucker_count = count_opponents_with_rate_above(history, 0.7)
    predator_count = count_opponents_with_rate_below(history, 0.3)
    
    # Hostile environment check
    if predator_count >= n/2:
        return DEFECT
    
    # Set base cooperation probability
    if round <= ceil(r/4):  # Early phase
        if last_coop >= n/2:
            coop_prob = 0.6
        else:
            coop_prob = 0.0
    else:  # Middle phase
        exploit_threshold = max(2, ceil(n * 0.4))
        if last_coop >= exploit_threshold:
            if overall_coop_rate > 0.5:
                coop_prob = 0.3  # Exploit the cooperators
            else:
                coop_prob = 0.4  # Sustain fragile cooperation
        else:
            coop_prob = 0.0
    
    # Adjustments
    if sucker_count >= n/3:
        coop_prob = max(0, coop_prob - 0.15)
    
    if my_coop_rate < 0.15 and round > 3:
        coop_prob = min(1, coop_prob + 0.2)
    
    # Endgame approach - ramp down cooperation
    rounds_left = r - round
    if rounds_left <= 4:
        coop_prob = coop_prob * (rounds_left / 5)
    
    return COOPERATE with probability coop_prob, else DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first**: Always defects round 1 to avoid being a sucker
2. **Free-rides on cooperators**: When others cooperate, we defect more often to capture the public good without contributing
3. **Endgame betrayal**: Guaranteed defection in final rounds regardless of history
4. **Sucker detection**: Specifically identifies and exploits unconditional cooperators
5. **Minimal reputation investment**: Only cooperates enough to keep cooperative opponents from fully abandoning cooperation
6. **Adaptive hostility**: Becomes purely defecting against predominantly defecting populations (no point cooperating with other predators)
'''

description_EXPLOITATIVE_124 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant strategy in a single round—but cooperative opponents can be milked for profit across multiple rounds before they wise up.

## Decision Rules

### Round 1: Always Defect
- **Rationale**: No information exists yet. Defection is the dominant single-round strategy and provides a baseline to observe others' behavior without personal cost.

### Middle Rounds (2 to r-1): Conditional Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / n
```

**Decision Logic:**

1. **If coop_rate ≥ threshold_high (0.6):** **DEFECT**
   - Many players are cooperating. Free-ride aggressively—you get (k/n) × contributions without paying in.

2. **If threshold_low (0.3) ≤ coop_rate < threshold_high:** **COOPERATE**
   - Cooperation is moderate. Contributing helps sustain the pool of cooperators who might otherwise abandon cooperation. This is an *investment* in future exploitation opportunities.

3. **If coop_rate < threshold_low:** **DEFECT**
   - Too few cooperators to sustain. Cut losses and defect—there's nothing worth investing in.

### Last Round: Always Defect
- **Rationale**: No future rounds exist to punish defection. Pure dominance logic applies.

### Refinement: Trend Detection

Track cooperation trends over the last 3 rounds (when available):

```
trend = coop_rate(t-1) - coop_rate(t-3)  [averaged over 3 rounds if possible]
```

- **If trend > 0.1 (rising cooperation):** Lower threshold_high to 0.5
  - More aggressively exploit the growing cooperative environment
  
- **If trend < -0.1 (falling cooperation):** Raise threshold_low to 0.4
  - Abandon ship earlier when cooperation is collapsing

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Edge cases
    if round == 1:
        return DEFECT
    if round == r:
        return DEFECT
    
    # Calculate last round cooperation rate
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate = last_round_coops / n
    
    # Dynamic thresholds based on trend
    threshold_high = 0.6
    threshold_low = 0.3
    
    if round >= 4:
        trend = calculate_trend(history, round)
        if trend > 0.1:
            threshold_high = 0.5
        if trend < -0.1:
            threshold_low = 0.4
    
    # Core decision
    if coop_rate >= threshold_high:
        return DEFECT      # Exploit the cooperators
    elif coop_rate >= threshold_low:
        return COOPERATE   # Sustain the herd
    else:
        return DEFECT      # Nothing to exploit

function calculate_trend(history, round):
    recent = average_coop_rate(history, round-3, round-1)
    older = average_coop_rate(history, round-6, round-4) if round >= 7 else coop_rate(round-1)
    return recent - older
```

## Why This Strategy is Exploitative

1. **Asymmetric extraction**: Defects when cooperation is high (maximum free-riding payoff) while only cooperating when necessary to prevent cooperation collapse.

2. **Last-round betrayal**: Guaranteed defection when punishment is impossible.

3. **First-round safety**: Never takes the sucker's payoff in round 1.

4. **Adaptive thresholds**: Adjusts behavior to squeeze more value from rising cooperation environments and exit faster from collapsing ones.

5. **Sustaining the prey**: Strategic cooperation in middle ranges keeps enough players cooperating to be exploited later—like a farmer tending livestock.

## Edge Case Handling

| Scenario | Action | Reason |
|----------|--------|--------|
| Round 1 | DEFECT | No info, dominant strategy |
| Round r (last) | DEFECT | No future punishment |
| All cooperated last round | DEFECT | Maximum exploitation |
| All defected last round | DEFECT | Nothing to gain from cooperation |
| n = 2 | Standard rules apply | Thresholds still work |
| k very close to n | Slightly more cooperative | Returns approach fairness |
'''

description_EXPLOITATIVE_125 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: cooperators create value that defectors can free-ride on. The goal is to **extract maximum value from cooperative opponents while minimizing losses against other defectors**. We cooperate only when it's instrumentally useful to maintain a "cooperation ecosystem" worth exploiting.

---

## Decision Rules

### Round 1: Defect
- **Rationale**: No information exists about opponents. Defection is the dominant single-round strategy (guarantees payoff ≥ 1, while cooperation risks getting 0 + k/n if alone). This also serves as a "test" - cooperative opponents will reveal themselves.

### Last Round (Round r): Always Defect
- **Rationale**: No future rounds exist to punish defection. This is the Nash equilibrium play. Any cooperation here is pure charity.

### Second-to-Last Round (Round r-1): Always Defect
- **Rationale**: Sophisticated opponents know round r will be defection, so they defect in r-1 via backward induction. Exploit any naive cooperators still holding out.

### Middle Rounds (Rounds 2 through r-2): Conditional Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

**Decision Logic:**

```
IF coop_rate >= exploitation_threshold THEN:
    Defect (free-ride on cooperative environment)
    
ELSE IF coop_rate > collapse_threshold AND coop_rate < exploitation_threshold THEN:
    Cooperate with probability = cooperation_probability
    (Probabilistic cooperation to "farm" cooperators back up)
    
ELSE (coop_rate <= collapse_threshold):
    Defect (environment is already defection-dominant, nothing to save)
```

**Threshold Parameters (calibrated to game parameters):**

```
exploitation_threshold = 0.5  # If majority cooperates, defect and exploit
collapse_threshold = 1/n      # If ≤1 cooperator, environment is dead
cooperation_probability = min(0.3, (k-1)/(n-1))  # Low but non-zero
```

---

## Adaptive Mechanism: Tracking Exploitability

Maintain a **running estimate of environment exploitability**:

```
exploitability_score = weighted average of recent cooperation rates
  (more recent rounds weighted higher, decay factor = 0.7)
```

**Adjustment Rules:**

1. **If exploitability_score is rising**: Continue current strategy (environment is recoverable)

2. **If exploitability_score is falling for 3+ consecutive rounds**: 
   - Slightly increase cooperation_probability (try to prevent total collapse)
   - But cap at 0.4 (never become a sucker)

3. **If exploitability_score stable and high (>0.4)**: Pure defection mode

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| n = 2 (minimum players) | Defect always except possibly mid-game probing | Iterated Prisoner's Dilemma dynamics; one defection collapses cooperation |
| k very close to n | Slightly more willing to cooperate early | Higher returns justify occasional cooperation investment |
| k very close to 1 | Pure defection | Public good barely multiplies; not worth contributing |
| r ≤ 3 (very short game) | Defect every round | Not enough rounds to establish exploitable cooperation |
| Everyone defected round 1 | Defect until seeing cooperation | No point investing in dead environment |
| Everyone cooperated round 1 | Defect aggressively | Maximum exploitation opportunity |

---

## Pseudocode Summary

```
function decide(round, history, n, k, r):
    
    # Hard rules for edge rounds
    if round == 1: return DEFECT
    if round >= r - 1: return DEFECT
    if r <= 3: return DEFECT
    
    # Calculate environment state
    prev_cooperators = count_cooperators(history[round-1])
    coop_rate = prev_cooperators / n
    
    # Set thresholds
    exploitation_threshold = 0.5
    collapse_threshold = 1 / n
    base_coop_prob = min(0.3, (k - 1) / (n - 1))
    
    # Adaptive adjustment based on trend
    trend = calculate_trend(history, window=3)
    if trend < -0.1 for 3+ rounds:
        coop_prob = min(base_coop_prob * 1.5, 0.4)
    else:
        coop_prob = base_coop_prob
    
    # Main decision
    if coop_rate >= exploitation_threshold:
        return DEFECT  # Exploit the cooperators
    elif coop_rate > collapse_threshold:
        return COOPERATE with probability coop_prob, else DEFECT
    else:
        return DEFECT  # Environment collapsed, nothing to exploit
```

---

## Why This Strategy is Exploitative

1. **Free-rides on cooperators**: When cooperation is high, we defect and take the public good without contributing

2. **Never gets suckered in endgame**: Guaranteed defection in final rounds prevents exploitation by others

3. **Minimal investment**: Cooperation probability is capped low; we're not altruists

4. **Adaptive farming**: Just enough occasional cooperation to prevent total collapse of the cooperation ecosystem we're exploiting

5. **Robust to opponent types**: Against all-defectors, we lose nothing extra. Against cooperators, we extract maximum surplus.
'''

description_EXPLOITATIVE_125 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperative opponents while minimizing losses against defectors**. The key insight is that in a public goods game with k < n, defection is always the individually rational choice in a single round—but exploiting cooperators yields even higher returns than mutual defection.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit cooperative players.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to ⌈r/5⌉)

**Purpose:** Gather information about opponent tendencies with minimal cost.

**Rule:** Defect in all probing rounds.

**Rationale:** 
- If others cooperate, I get the maximum payoff (1 + k/n × cooperators)
- I learn who the "suckers" are without risking my own endowment
- Early defection establishes no expectation of cooperation from me

### Phase 2: Exploitation Phase (Rounds ⌈r/5⌉+1 to r-1)

**Purpose:** Adaptively exploit based on observed behavior.

**Decision Rule:**

```
Calculate: cooperation_rate = (total C plays by all opponents) / (total plays by all opponents)

IF cooperation_rate > (n - 1) / (k × (n - 1)):
    # Enough cooperators exist that defecting is profitable
    DEFECT
    
ELSE IF cooperation_rate > 0.5 AND declining trend detected:
    # Cooperators are wising up - throw occasional C to "reset" them
    COOPERATE with probability = 0.2
    DEFECT with probability = 0.8
    
ELSE IF cooperation_rate < 0.2:
    # Environment is hostile, pure defection optimal
    DEFECT
    
ELSE:
    # Moderate cooperation - use conditional strategy
    IF (number of cooperators in previous round) ≥ n/2:
        DEFECT  # Free ride on the cooperators
    ELSE:
        DEFECT  # No point cooperating in uncooperative environment
```

**Opponent Classification (updated each round):**
- **Sucker:** Cooperated >70% of time → Always defect against these groups
- **Retaliator:** Mirrors or responds to aggregate behavior → Occasional cooperation to keep them contributing
- **Predator:** Cooperated <20% of time → Ignore, always defect

**Adaptive Cooperation Injection:**

When cooperation rate is declining but still above 0.3:
- Cooperate once every ⌈n/2⌉ rounds to "bait" conditional cooperators back
- This is an investment to restore exploitable conditions

### Phase 3: Endgame (Final Round r)

**Rule:** Always DEFECT.

**Rationale:** No future rounds exist for punishment. This is the dominant strategy regardless of history.

---

## Pseudocode Implementation

```
function decide(round, history, n, k, r):
    
    if round == 1:
        return DEFECT
    
    if round == r:
        return DEFECT  # Endgame defection
    
    # Calculate opponent statistics
    total_opponent_actions = (round - 1) * (n - 1)
    total_opponent_cooperations = sum(cooperations in history by others)
    coop_rate = total_opponent_cooperations / total_opponent_actions
    
    # Probing phase
    if round <= ceil(r / 5):
        return DEFECT
    
    # Exploitation phase
    last_round_cooperators = count(players who played C in round - 1)
    
    # Calculate if cooperation rate makes defection profitable
    # Defecting gives: 1 + (k/n) * others_who_cooperate
    # Cooperating gives: (k/n) * (others_who_cooperate + 1)
    # Defect better when: 1 > k/n, which is always true since k < n
    
    # Check for declining cooperation trend
    if round > 3:
        recent_coop = cooperation_rate(last 3 rounds)
        earlier_coop = cooperation_rate(rounds before last 3)
        declining = recent_coop < earlier_coop - 0.1
    
    # Strategic cooperation injection to maintain exploitable population
    if coop_rate > 0.3 AND coop_rate < 0.6 AND declining:
        if random() < 0.15:  # Occasional cooperation bait
            return COOPERATE
    
    # Default: Defect (always individually rational)
    return DEFECT
```

---

## Edge Cases

| Situation | Action | Reasoning |
|-----------|--------|-----------|
| Round 1 | DEFECT | No information; defection is risk-free probe |
| Round r (final) | DEFECT | No future punishment possible |
| All opponents always defect | DEFECT | No exploitation opportunity; minimize losses |
| All opponents always cooperate | DEFECT | Maximum exploitation opportunity |
| n = 2 (two players) | DEFECT always | Simplified prisoner's dilemma; defection dominant |
| k very close to n | Still DEFECT | Even with high k, free-riding still optimal |
| r = 2 (two rounds) | DEFECT both | Too short for reputation building to matter |

---

## Why This Strategy is Exploitative

1. **Never initiates cooperation** - Avoids being the sucker
2. **Free-rides maximally** - Takes advantage of any cooperation without reciprocating
3. **Strategic minimal investment** - Only cooperates to "farm" conditional cooperators when profitable
4. **Endgame awareness** - Guaranteed defection when punishment is impossible
5. **Robust to hostile environments** - Defaults to defection, which is always safe

This strategy treats other players as resources to be harvested, not partners to coordinate with.
'''

description_EXPLOITATIVE_126 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy exploits the fundamental asymmetry in public goods games: defectors free-ride on cooperators. The goal is to **maximize extraction from cooperative opponents while minimizing losses against defectors**. I will cooperate only when it's instrumentally useful for inducing future cooperation from others that I can then exploit.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit behavioral patterns.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to min(3, r/4))

**Purpose:** Gather information about opponent tendencies with minimal cost.

- **Round 1:** DEFECT
  - Rationale: Defecting in round 1 is dominant for information gathering. If others cooperate, I profit maximally. If others defect, I lose nothing. This also avoids being marked as an easy target.

- **Rounds 2-3:** Conditional on Round 1 results
  - If cooperation rate in previous round > 50%: DEFECT (exploit the cooperators)
  - If cooperation rate in previous round ≤ 50%: COOPERATE once (test if conditional cooperators exist)
  - Then immediately DEFECT next round to see if cooperation persists

### Phase 2: Exploitation Phase (Middle rounds, up to round r-2)

**Purpose:** Maximize extraction based on learned opponent behavior.

**Classify the environment based on observed cooperation rate (CR):**

```
CR = (total cooperations by others) / (total possible cooperations by others)
```

**Decision Rule:**

```
IF CR > 0.6:
    # High-cooperation environment - pure exploitation
    DEFECT (free-ride on consistent cooperators)
    
ELIF CR between 0.3 and 0.6:
    # Mixed environment - strategic intermittent cooperation
    IF my recent defection caused CR to drop significantly (>20% decline):
        COOPERATE (rebuild cooperation to exploit later)
    ELSE:
        DEFECT
        
ELIF CR < 0.3:
    # Low-cooperation environment - minimal losses
    DEFECT (no point cooperating; would just be exploited)
```

**Exploitation Refinement - Detecting Conditional Cooperators:**

Track if cooperation rate responds to MY actions specifically:
- If others seem to cooperate MORE after I cooperate: These are conditional cooperators (like TFT players)
- Strategy: Cooperate just enough to maintain their cooperation, then defect periodically

```
optimal_defection_frequency = 1 / (r - current_round)
# Defect more frequently as end approaches
```

### Phase 3: Endgame (Final 2 rounds)

**Purpose:** Extract maximum value with no future consequences.

- **Round r-1 (second to last):** DEFECT
  - No credible punishment possible that would outweigh gains
  
- **Round r (last):** DEFECT
  - Dominant strategy; no future interaction exists

---

## Adaptive Opponent Modeling

**Track per-round statistics:**
1. Overall cooperation rate
2. Cooperation rate trend (increasing/decreasing/stable)
3. Response to my cooperation (do others reciprocate?)
4. Response to my defection (do others punish?)

**Identify exploitable patterns:**

```
IF opponents appear to play "Always Cooperate":
    ALWAYS DEFECT (maximum exploitation)
    
IF opponents appear to play "Tit-for-Tat" or conditional strategies:
    Cooperate early, build trust, then defect in final ~30% of rounds
    
IF opponents appear to play "Always Defect":
    ALWAYS DEFECT (mutual defection is equilibrium)
    
IF opponents appear to play "Grim Trigger":
    Cooperate until round (r - punishment_horizon), then defect
    # punishment_horizon ≈ 2-3 rounds
```

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    my_history = history.my_actions
    others_cooperation_rate = calculate_CR(history)
    
    # Endgame - always defect
    if round >= r - 1:
        return DEFECT
    
    # Probing phase
    if round == 1:
        return DEFECT
    if round <= min(3, r // 4):
        if others_cooperation_rate > 0.5:
            return DEFECT
        else:
            return COOPERATE if my_history[-1] == DEFECT else DEFECT
    
    # Exploitation phase
    if others_cooperation_rate > 0.6:
        return DEFECT  # Free-ride on cooperators
    
    if others_cooperation_rate < 0.3:
        return DEFECT  # No cooperation to exploit
    
    # Mixed environment - strategic cooperation
    if detected_cooperation_drop_after_my_defection(history):
        # Conditional cooperators exist - maintain some cooperation
        if random() < 0.3 + (r - round) / r:  # Cooperate less as game ends
            return COOPERATE
    
    return DEFECT
```

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | DEFECT both rounds | No time to build exploitable trust |
| n = 2 (minimum players) | More aggressive defection | Only one opponent to model |
| k close to n | Slightly more cooperation early | Higher returns from mutual cooperation worth exploiting |
| k close to 1 | More defection | Low public good multiplier makes cooperation less valuable |
| All opponents defecting | Always defect | No cooperation to exploit |
| All opponents cooperating | Always defect | Maximum free-riding opportunity |

---

## Why This Strategy is Exploitative

1. **Never cooperates altruistically** - Every cooperation is an investment to induce exploitable future cooperation
2. **Endgame defection** - Guaranteed defection when punishment is impossible
3. **Asymmetric extraction** - Profits from cooperators without reciprocating fairly
4. **Pattern recognition** - Identifies and exploits predictable opponents
5. **Minimal vulnerability** - Opens with defection to avoid being marked as exploitable
'''

description_EXPLOITATIVE_126 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection always yields higher individual payoff than cooperation *given the same actions by others*. Therefore, the exploitative approach is to defect by default while strategically cooperating only when it induces enough future cooperation from others to be profitable.

## Strategy Overview

The strategy operates in three phases based on game progression, with continuous opponent modeling to identify and exploit behavioral patterns.

---

## Decision Rules

### Phase 1: Probing Phase (Rounds 1 to min(3, r/4))

**Purpose:** Gather information about opponent tendencies with minimal cost.

**Round 1:** **DEFECT**
- Rationale: No information exists. Defection guarantees payoff ≥ 1 regardless of others' actions. Starting with cooperation risks being exploited with no compensating benefit.

**Rounds 2-3 (if applicable):**
- **COOPERATE once** if and only if the cooperation rate in round 1 was ≥ 50%
- Otherwise **DEFECT**
- This tests whether opponents are responsive/reciprocal without excessive investment

### Phase 2: Exploitation Phase (Middle rounds, until round r-2)

**Classify each opponent based on observed history:**

```
For each opponent j, calculate:
  - coop_rate[j] = (times j cooperated) / (rounds observed)
  - responsiveness[j] = correlation between group cooperation and j's next move
```

**Opponent Types:**
1. **Unconditional Cooperators** (coop_rate > 0.8): Exploit ruthlessly - they'll cooperate regardless
2. **Unconditional Defectors** (coop_rate < 0.2): Ignore - no value to extract
3. **Conditional Cooperators** (0.2 ≤ coop_rate ≤ 0.8, positive responsiveness): Potential value

**Decision Rule for Phase 2:**

```
Let:
  num_unconditional_coops = count of opponents with coop_rate > 0.8
  num_conditional = count of opponents with 0.2 ≤ coop_rate ≤ 0.8
  recent_coop_rate = group cooperation rate in last 2 rounds
  
IF num_unconditional_coops ≥ (n-1)/2:
    DEFECT  # Free-ride on reliable cooperators
    
ELSE IF num_conditional ≥ (n-1)/2 AND recent_coop_rate ≥ 0.5:
    # Conditional cooperation to maintain the "herd"
    IF (rounds_remaining > r/3) AND (my_coop_rate_last_3_rounds < 0.4):
        COOPERATE  # Maintain reputation to keep conditionals cooperating
    ELSE:
        DEFECT  # Extract value
        
ELSE:
    DEFECT  # Not enough cooperative mass to justify contribution
```

**Exploitation Trigger:** If cooperation has been high (≥ 60%) for 3+ consecutive rounds, **DEFECT** for the next 2 rounds to maximize extraction, then reassess.

### Phase 3: Endgame (Final 2 rounds)

**Round r-1 (second to last):** 
- **DEFECT** unless cooperation rate has been > 70% AND there are clear conditional cooperators who might punish in the final round
- In most cases: **DEFECT**

**Round r (final round):**
- **ALWAYS DEFECT**
- Rationale: No future consequences, pure dominant strategy logic applies

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | DEFECT both rounds | No time to build/exploit reciprocity |
| r = 3 | DEFECT all rounds | Insufficient rounds for cooperation investment to pay off |
| n = 2 (minimum players) | More aggressive defection; cooperate only if opponent showed 100% cooperation | Fewer cooperators to free-ride on |
| All opponents defected round 1 | DEFECT until pattern changes | No cooperative surplus to exploit |
| All opponents cooperated round 1 | DEFECT round 2-3, reassess | Test if they're unconditional (exploitable) or conditional |
| k very close to n | Slightly more willing to cooperate | Higher marginal return to cooperation |
| k very close to 1 | More aggressive defection | Low returns to public good |

---

## Pseudocode Summary

```python
def adaptive_predator(round, history, n, k, r):
    if round == r:  # Final round
        return DEFECT
    
    if round == 1:  # First round
        return DEFECT
    
    # Calculate metrics
    opponent_profiles = classify_opponents(history)
    recent_coop_rate = get_recent_coop_rate(history, window=2)
    rounds_remaining = r - round
    
    # Endgame
    if rounds_remaining <= 1:
        return DEFECT
    
    # Probing phase
    if round <= min(3, r//4):
        if get_coop_rate(history, round-1) >= 0.5 and not cooperated_in_probe:
            return COOPERATE  # One probe cooperation
        return DEFECT
    
    # Exploitation phase
    num_suckers = count_unconditional_cooperators(opponent_profiles)
    num_conditional = count_conditional(opponent_profiles)
    
    if num_suckers >= (n-1)/2:
        return DEFECT  # Free ride
    
    if num_conditional >= (n-1)/2 and recent_coop_rate >= 0.5:
        if rounds_remaining > r/3 and my_recent_coop_rate(history, 3) < 0.4:
            return COOPERATE  # Maintain herd
    
    # Check for extraction opportunity
    if consecutive_high_coop_rounds(history) >= 3:
        return DEFECT  # Extract
    
    return DEFECT  # Default
```

---

## Why This Strategy is Exploitative

1. **Never cooperates in final round** - Pure exploitation of any remaining cooperators
2. **Identifies and milks "suckers"** - Unconditional cooperators are exploited completely
3. **Maintains cooperative environments only to harvest them** - Strategic cooperation is an investment, not altruism
4. **Front-loads defection, back-loads extraction** - Minimizes risk while maximizing information
5. **Defection is the default** - Cooperation requires positive justification based on expected exploitation value
'''

description_EXPLOITATIVE_127 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

The fundamental insight is that in a public goods game with k < n, defection strictly dominates cooperation in any single round. However, in a repeated setting, I can exploit cooperators by:
1. **Detecting and leeching off cooperative populations** - free-riding while others contribute
2. **Punishing defectors minimally** - only cooperating when it's likely to be reciprocated
3. **End-game exploitation** - guaranteed defection when future punishment is impossible

## Strategy Specification

### Key Variables Tracked
- `cooperation_rate[t]` = fraction of other players who cooperated in round t
- `avg_cooperation` = running average cooperation rate across all past rounds
- `rounds_remaining` = r - current_round

### Decision Rules

#### Round 1: Defect
**Rationale:** No information exists. Defection is risk-free and provides a baseline to observe others. If cooperators exist, I benefit without cost. If all defect, I lose nothing.

#### Last Round (round r): Defect
**Rationale:** No future punishment is possible. Defection strictly dominates.

#### Penultimate Round (round r-1): Defect
**Rationale:** Sophisticated opponents will defect in round r regardless, so there's no cooperative equilibrium to protect. Begin end-game exploitation early.

#### Middle Rounds (rounds 2 through r-2):

```
Calculate: exploitation_threshold = k / n  (the share I get per cooperator)

IF cooperation_rate[t-1] >= 0.5:
    # Rich cooperative environment - EXPLOIT IT
    IF avg_cooperation >= 0.6:
        # Stable cooperative population - pure exploitation
        DEFECT
    ELSE:
        # Fragile cooperation - occasional token cooperation to sustain it
        IF random() < 0.2:  # Cooperate 20% of the time
            COOPERATE
        ELSE:
            DEFECT

ELSE IF cooperation_rate[t-1] >= 0.25:
    # Mixed environment - conditional cooperation to probe
    IF my_last_action == DEFECT AND cooperation_rate[t-1] > cooperation_rate[t-2]:
        # Cooperation increased despite my defection - keep exploiting
        DEFECT
    ELSE IF my_last_action == COOPERATE AND cooperation_rate[t-1] dropped significantly:
        # My cooperation didn't help - stop wasting resources
        DEFECT
    ELSE:
        # Uncertain - match the prevailing rate minus a discount
        IF random() < (cooperation_rate[t-1] - 0.15):
            COOPERATE
        ELSE:
            DEFECT

ELSE:  # cooperation_rate[t-1] < 0.25
    # Hostile environment - don't waste resources
    DEFECT
```

### Edge Cases

1. **n = 2 (two players):** This becomes essentially a repeated Prisoner's Dilemma. Use stricter exploitation:
   - Defect rounds 1, r-1, r
   - Middle rounds: Defect unless opponent cooperated in BOTH of the last two rounds, then cooperate with 30% probability

2. **Very short games (r ≤ 4):** Defect always. Not enough rounds to establish or exploit cooperation patterns.

3. **Large n (n ≥ 10):** Individual actions have minimal impact. Defect more aggressively (reduce the 20% token cooperation to 10%).

4. **k very close to n:** Cooperation becomes more attractive. Increase cooperation probability by `(k/n - 0.5) * 0.3` in mixed environments.

### Pseudocode Summary

```
function decide(round, history, n, k, r):
    if round == 1 or round >= r-1:
        return DEFECT
    
    if r <= 4:
        return DEFECT
    
    coop_rate_last = count_cooperators(history, round-1) / (n-1)
    avg_coop = average_cooperation_rate(history)
    
    if coop_rate_last >= 0.5:
        if avg_coop >= 0.6:
            return DEFECT
        else:
            return COOPERATE with probability 0.2
    
    else if coop_rate_last >= 0.25:
        return COOPERATE with probability max(0, coop_rate_last - 0.15)
    
    else:
        return DEFECT
```

## Why This Is Exploitative

1. **Asymmetric behavior:** I cooperate far less than I benefit from others' cooperation
2. **Free-riding optimization:** Maximum defection in cooperative environments
3. **Token cooperation as manipulation:** Just enough to prevent total collapse of cooperation I'm exploiting
4. **Information extraction:** Round 1 defection reveals opponent types at zero cost
5. **End-game ruthlessness:** No pretense of cooperation when punishment is impossible
'''

description_EXPLOITATIVE_128 = '''
# Exploitative Strategy: "Adaptive Parasite"

## Core Philosophy

This strategy aims to **maximize personal payoff by free-riding on cooperators while avoiding retaliation costs**. The key insight is that in a public goods game with k < n, defection is always individually rational in a single round, but sustained cooperation by others is valuable to exploit. The strategy identifies and exploits cooperative opponents while minimizing losses against defectors.

## Decision Rules

### Round 1: Defect
- **Rationale**: Gather information about opponent behavior without paying any cooperation cost. If others cooperate, I gain from their contributions while keeping my endowment. If others defect, I lose nothing.

### Rounds 2 through (r-1): Conditional Exploitation

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in last round) / (n - 1)
```

**Decision Logic:**

1. **If coop_rate ≥ 0.6 (majority cooperating):**
   - **Defect** — This is the sweet spot for exploitation. Others are providing the public good; I free-ride.

2. **If 0.3 ≤ coop_rate < 0.6 (mixed environment):**
   - Calculate my **historical defection rate** over all previous rounds
   - If my defection rate > 0.7: **Cooperate once** (to avoid being identified as a pure defector and potentially triggering retaliation cascades)
   - Otherwise: **Defect**

3. **If coop_rate < 0.3 (mostly defectors):**
   - **Defect** — No point cooperating when few others contribute; the multiplied return is too low.

### Last Round (Round r): Always Defect
- **Rationale**: No future rounds means no retaliation possible. Pure Nash equilibrium logic applies.

### Adaptive Adjustment: Trend Detection

Track the **cooperation trend** over the last 3 rounds (when available):
```
trend = (coop_rate at t-1) - (coop_rate at t-3)
```

- **If trend < -0.2 (cooperation collapsing):** Defect regardless of current rate
- **If trend > 0.2 (cooperation rising):** Continue defecting to maximize exploitation of the upswing

## Pseudocode

```
function decide(round, history, n, k, r):
    
    # Last round: always defect
    if round == r:
        return DEFECT
    
    # First round: always defect
    if round == 1:
        return DEFECT
    
    # Calculate cooperation rate from last round
    last_round_coops = count_cooperators(history, round - 1)
    coop_rate = last_round_coops / (n - 1)
    
    # Calculate trend if we have enough history
    if round >= 4:
        coop_rate_3_ago = count_cooperators(history, round - 3) / (n - 1)
        trend = coop_rate - coop_rate_3_ago
        
        if trend < -0.2:
            return DEFECT
    
    # Main decision logic
    if coop_rate >= 0.6:
        return DEFECT  # Exploit cooperators
    
    elif coop_rate >= 0.3:
        my_defection_rate = count_my_defections(history) / (round - 1)
        if my_defection_rate > 0.7:
            return COOPERATE  # Occasional cooperation to maintain ecosystem
        else:
            return DEFECT
    
    else:  # coop_rate < 0.3
        return DEFECT  # No point contributing to a defecting group

```

## Edge Cases

| Scenario | Action | Reasoning |
|----------|--------|-----------|
| Round 1 | Defect | Information gathering at zero cost |
| Round r (final) | Defect | No future retaliation possible |
| n = 2 | Follow standard logic | Becomes essentially iterated prisoner's dilemma |
| All opponents defected last round | Defect | No value in unilateral cooperation |
| All opponents cooperated last round | Defect | Maximum exploitation opportunity |
| r = 2 (only two rounds) | Defect both rounds | Too short for reputation building to matter |

## Why This Strategy is Exploitative

1. **Never initiates cooperation** — Only cooperates reactively to maintain exploitable conditions
2. **Maximizes free-riding** — Defects precisely when others cooperate most
3. **Abandons sinking ships** — Quickly stops any cooperation when the group defects
4. **Endgame exploitation** — Guaranteed defection in final round
5. **Minimal cooperation investment** — Only cooperates ~1 in 4 rounds at most, and only to prevent total cooperation collapse
'''

description_EXPLOITATIVE_127 = '''
# Exploitative Strategy for N-Player Public Goods Game

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection always yields a higher individual payoff than cooperation *given the same behavior from others*. Therefore, I should cooperate only when I can induce others to cooperate more than they otherwise would, creating surplus I can later exploit.

## Strategy: "Generous Probe, Swift Punishment, Endgame Defection" (GPSED)

### Decision Rules

#### Round 1: Cooperative Probe
**Action: COOPERATE**

Rationale: This signals willingness to cooperate, encouraging reciprocators to reveal themselves. The information gained about opponent types is worth the potential loss. It also builds "credit" with conditional cooperators.

#### Rounds 2 through (r-2): Adaptive Exploitation Phase

Calculate the **cooperation rate** from the previous round:
```
coop_rate = (number of cooperators in previous round) / n
```

Calculate my **cumulative cooperation rate**:
```
my_coop_rate = (my total cooperations so far) / (current round - 1)
```

**Decision Logic:**

```
IF coop_rate >= (n-1)/n:
    # Almost everyone cooperated - this is exploitable
    # Defect to free-ride on the cooperators
    ACTION = DEFECT
    
ELIF coop_rate >= 0.5:
    # Moderate cooperation exists
    # Match slightly below the group rate to exploit while maintaining cooperation
    IF my_coop_rate > coop_rate + 0.1:
        ACTION = DEFECT  # I've been too generous, take back
    ELSE:
        ACTION = COOPERATE  # Maintain the cooperative environment
        
ELIF coop_rate > 0:
    # Low cooperation - some suckers exist
    # Defect and let them subsidize me
    ACTION = DEFECT
    
ELSE:
    # Everyone defected
    # Occasionally probe to test if cooperation can restart
    IF (current_round mod 3) == 0:
        ACTION = COOPERATE  # Probe every 3rd round
    ELSE:
        ACTION = DEFECT
```

#### Round (r-1): Penultimate Round
**Action: DEFECT**

Rationale: This is the setup for endgame exploitation. Any rational player should defect in the final round, so I defect one round early to get ahead of the rush.

#### Round r: Final Round
**Action: DEFECT**

Rationale: No future rounds exist to punish defection. This is the dominant strategy regardless of history.

### Edge Cases

1. **r = 2 (minimum rounds):** Defect both rounds. With only 2 rounds, there's insufficient time to build cooperative surplus worth exploiting.

2. **r = 3:** Cooperate round 1, defect rounds 2-3. Minimal probe, then exploit.

3. **n = 2 (minimum players):** Standard strategy applies, but be more willing to cooperate in middle rounds since bilateral cooperation is easier to sustain.

4. **k very close to n:** Cooperation becomes more attractive. Increase cooperation threshold:
   - If k/n > 0.8, cooperate when coop_rate >= 0.4 (lower threshold)

5. **k very close to 1:** Defection is almost always optimal. Only cooperate in round 1 as a probe.

### Summary Pseudocode

```
function decide(round, history, n, k, r):
    if round == 1:
        return COOPERATE
    
    if round >= r - 1:
        return DEFECT
    
    if r <= 3:
        return DEFECT
    
    coop_rate = count_cooperators(history, round-1) / n
    my_coop_rate = my_cooperations(history) / (round - 1)
    
    if coop_rate >= (n-1)/n:
        return DEFECT  # Exploit high cooperation
    elif coop_rate >= 0.5:
        if my_coop_rate > coop_rate + 0.1:
            return DEFECT
        else:
            return COOPERATE
    elif coop_rate > 0:
        return DEFECT  # Free-ride on partial cooperation
    else:
        if round mod 3 == 0:
            return COOPERATE  # Periodic probe
        else:
            return DEFECT
```

### Why This Strategy is Exploitative

1. **Exploits unconditional cooperators:** By defecting when cooperation is high, I maximize free-riding gains.
2. **Exploits conditional cooperators:** My initial cooperation and moderate matching keeps them cooperating while I systematically defect slightly more.
3. **Minimizes losses to defectors:** Quick detection of all-defect environments prevents wasted cooperation.
4. **Endgame exploitation:** Early defection in final rounds captures value before others switch.
'''

description_EXPLOITATIVE_128 = '''
# Exploitative Strategy: "Adaptive Predator"

## Core Philosophy

This strategy aims to **extract maximum value from cooperators while minimizing losses to defectors**. The key insight is that in a public goods game with k < n, defection is always the dominant single-round strategy, but sustained cooperation by others creates exploitable surplus. My goal is to detect and milk cooperative environments while quickly abandoning cooperation when facing defectors.

## Strategy Overview

I maintain a **cooperation probability threshold** based on observed group behavior, and I become increasingly exploitative as the game progresses toward the end. I treat other players as a collective "environment" that either rewards exploitation or punishes it.

---

## Decision Rules

### Key Variables Tracked
- `group_coop_rate`: Rolling average of cooperation rate among all other players
- `rounds_remaining`: r - current_round
- `exploitation_value`: (k/n) × expected_cooperators - opportunity cost of cooperating

### Round-by-Round Logic

**Round 1 (Cold Start):**
- **DEFECT**
- Rationale: No information exists, and defection is risk-free. If others cooperate, I profit maximally. If others defect, I lose nothing compared to cooperating.

**Rounds 2 through (r-2):**

```
Calculate group_coop_rate = (total C plays by others) / (total plays by others)

IF group_coop_rate >= threshold THEN:
    # Environment is cooperative - conditional cooperation to sustain it
    IF last_round_coop_rate >= 0.5 THEN:
        COOPERATE with probability = min(group_coop_rate - 0.1, 0.8)
        DEFECT otherwise
    ELSE:
        DEFECT (recent defection wave detected)
ELSE:
    DEFECT (not enough cooperators to justify contribution)

Where threshold = k / n  # Break-even point for cooperation value
```

**Round (r-1) - Penultimate Round:**
- **DEFECT**
- Rationale: Begin endgame defection. Others cannot effectively punish in the final round.

**Round r - Final Round:**
- **DEFECT**
- Rationale: No future consequences; pure dominant strategy.

---

## Detailed Decision Framework

### The Exploitation Calculus

For any round, I calculate whether the "cooperative environment" is worth sustaining:

1. **Exploitation surplus** = (k/n) × expected_other_cooperators
2. **Cooperation cost** = 1 (my foregone private payoff)
3. **Sustainability factor** = Will my defection cause a collapse?

**Key insight**: I cooperate *just enough* to keep cooperators cooperating, but defect whenever I can free-ride without triggering retaliation cascades.

### Adaptive Thresholds

```
base_threshold = k / n  # Mathematical break-even

# Adjust based on game progress
adjusted_threshold = base_threshold + (0.2 × current_round / r)

# As game progresses, require MORE cooperation from others to justify my cooperation
# This reflects diminishing value of maintaining future cooperation
```

### Detecting Exploitable Patterns

**Unconditional Cooperators**: If any subset of players has cooperated 100% of the time for 3+ rounds:
- **Always DEFECT** - these players will cooperate regardless of my action

**Tit-for-Tat-like Players**: If group cooperation tracks my cooperation closely:
- Maintain minimal cooperation (cooperate every 2-3 rounds) to keep them engaged

**Defector-Heavy Groups**: If group_coop_rate < 0.3:
- **Always DEFECT** - nothing to exploit

---

## Edge Cases

| Situation | Action | Rationale |
|-----------|--------|-----------|
| r = 2 (minimum rounds) | D, D | Too short for reputation to matter |
| n = 2 (minimum players) | Defect-heavy; cooperate only if opponent always cooperates | Closest to Prisoner's Dilemma dynamics |
| k very close to n | More willing to cooperate early (higher exploitation value) | Public good more valuable |
| k very close to 1 | Almost always defect | Public good barely worth it |
| All others defected last round | DEFECT | No cooperative surplus to protect |
| All others cooperated last round | DEFECT with 70% probability | Maximum exploitation opportunity |

---

## Pseudocode Summary

```python
def decide(round, history, n, k, r):
    if round == 1:
        return DEFECT
    
    if round >= r - 1:  # Last two rounds
        return DEFECT
    
    others_history = get_others_actions(history)
    group_coop_rate = sum(others_history) / len(others_history)
    last_round_coop_rate = count_cooperators_last_round(history) / (n - 1)
    
    threshold = (k / n) + (0.2 * round / r)
    
    if group_coop_rate < threshold:
        return DEFECT
    
    if last_round_coop_rate < 0.5:
        return DEFECT
    
    # Probabilistic cooperation - cooperate less than group rate to extract surplus
    coop_probability = min(group_coop_rate - 0.15, 0.75)
    return COOPERATE if random() < coop_probability else DEFECT
```

---

## Why This Strategy is Exploitative

1. **Never cooperates first** - lets others bear the risk
2. **Free-rides on cooperative environments** - cooperates less than the group average
3. **Aggressive endgame** - abandons cooperation when punishment becomes impossible
4. **Targets unconditional cooperators** - extracts maximum value from naive strategies
5. **Quick to defect** - any sign of environmental defection triggers protective defection
'''
